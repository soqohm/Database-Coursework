<?xml version="1.0"?>
<doc>
    <assembly>
        "TFlexAPI"
    </assembly>
    <members>
        <member name="M:TFlex.Model.Model2D.Area.get_ContourCount">
            <returns>Количества контуров штриховки</returns>
        </member>
        <member name="M:SeidelTriangulation.TriangulatePolygon(System.Int32,System.Int32*,System.Double(*)[N2],System.Int32(*)[N3])">
Собственно триангуляция. Каждый треугольник определяется индексами вершин в массиве координат.
В случае некорректных данных возвращается false
</member>
        <member name="M:SeidelTriangulation.CountNumberOfTriangles(System.Int32,System.Int32*)">
Функция возвращает количество треугольников, на которое будет разбит многоконтурный полигон.
Может использоваться для резервирования памяти под массив, передающийся в функцию триангуляции.
</member>
        <member name="M:ParamsToCoords.UpdateArrowNodeParams(TFPoint,TFArrowNode*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFArrowsList*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Из ArrowCommand
</member>
        <member name="P:TFlex.Dialogs.Icon.IsValid">
            <summary>Возвращает True для непустых иконок</summary>
        </member>
        <member name="M:TFlex.Dialogs.Icon.op_Inequality(TFlex.Dialogs.Icon,TFlex.Dialogs.Icon)">
            <summary>Сравнить две иконки</summary>
        </member>
        <member name="M:TFlex.Dialogs.Icon.op_Equality(TFlex.Dialogs.Icon,TFlex.Dialogs.Icon)">
            <summary>Сравнить две иконки</summary>
        </member>
        <member name="M:TFlex.Dialogs.Icon.#ctor(System.Drawing.Icon)">
            <param name="drawingIcon">Источник иконки</param>
        </member>
        <member name="M:TFlex.Dialogs.Icon.#ctor(System.String,System.String,System.Boolean)">
            <param name="id">Идентификатор иконки</param>
            <param name="path">Пути к файлу иконки</param>
            <param name="cache">Кэшировать</param>
        </member>
        <member name="M:TFlex.Dialogs.Icon.#ctor(System.String,System.String)">
            <param name="id">Идентификатор иконки</param>
            <param name="path">Пути к файлу иконки</param>
        </member>
        <member name="M:TFlex.Dialogs.Icon.#ctor(System.String)">
            <param name="id">Идентификатор иконки</param>
        </member>
        <member name="T:TFlex.Dialogs.Icon">
            <summary>Иконка</summary>
        </member>
        <member name="M:TFPDMNomenclatureProxy.GetUniqeParameters">
            <summary>
Получить идентификаторы уникальных параметров
</summary>
        </member>
        <member name="M:TFPDMNomenclatureProxy.SetDefaultPDMProfile(TFPDMHandle&lt;TFPDMParametersRelationsProfileProxy&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Установать правило передачи данных из приложений в PDM по-умолчанию
</summary>
        </member>
        <member name="M:TFPDMNomenclatureProxy.FindPDMProfile(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Получение правила передачи данных из приложений в PDM по имени
</summary>
        </member>
        <member name="M:TFPDMNomenclatureProxy.GetPDMProfiles">
            <summary>
Получение списка правил передачи данных из приложений в PDM
</summary>
        </member>
        <member name="M:TFPDMNomenclatureProxy.FindParameterInfo(_GUID!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Получение описания параметра.
</summary>
        </member>
        <member name="M:TFPDMNomenclatureProxy.SelectParameterDescription(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Выбор из диалога описание параметра номенклатуры c проверкой поддержки диалог PDM системой.
</summary>
        </member>
        <member name="M:TFPDMReferenceProxy.CreateControl">
            <summary>
Создать элемент управления справочника
</summary>
        </member>
        <member name="M:TFPDMReferenceProxy.GetParameterDescription(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Получение описания параметра по справочника
</summary>
        </member>
        <member name="M:TFPDMReferenceProxy.SelectParameterDescription(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Выбор из диалога описание параметра справочника.
</summary>
        </member>
        <member name="M:TFPDMReferenceProxy.SelectParameterInfo">
            <summary>
Выбор из диалога описание параметра справочника.
</summary>
        </member>
        <member name="M:TFPDMReferenceProxy.GetGuid">
            <summary>
Получить guid справочника
</summary>
        </member>
        <member name="M:TFPDMReferenceProxy.GetIcon">
            <summary>
Получить иконку справочника
</summary>
        </member>
        <member name="M:TFPDMReferenceProxy.GetName">
            <summary>
Получить имя справочника
</summary>
        </member>
        <member name="P:TFlex.Model.CustomBOMItem.TextValue">
            <summary>Текстовое значение элемента записи данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.CustomBOMItem.Variable">
            <summary>Переменная, задающая текст элемента записи данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.CustomBOMItem.Text">
            <summary>Текст элемента записи данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.CustomBOMItem.Title">
            <summary>Название элемента записи данных для спецификации</summary>
        </member>
        <member name="T:TFlex.Model.CustomBOMItem">
            <summary>Пользовательский элемент записи данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.StandardBOMItem.Type">
            <summary>Тип стандартного элемента записи данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.StandardBOMItem.Variable">
            <summary>Переменная, задающая текст элемента записи данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.StandardBOMItem.TextValue">
            <summary>Текстовое значение элемента записи данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.StandardBOMItem.Text">
            <summary>Текст элемента записи данных для спецификации</summary>
        </member>
        <member name="T:TFlex.Model.StandardBOMItem">
            <summary>Стандартный элемент записи данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.BOMRecord.IncludeToCurrentDocumentBOM">
            <summary>Включать запись в спецификацию текущего документа</summary>
        </member>
        <member name="P:TFlex.Model.BOMRecord.IncludeToAssemblyBOM">
            <summary>Включать запись в спецификацию сборочного документа</summary>
        </member>
        <member name="M:TFlex.Model.BOMRecord.DeleteCustomItem(System.Int32)">
            <summary>Удалить пользовательский элемент записи данных спецификации</summary>
        </member>
        <member name="M:TFlex.Model.BOMRecord.AddCustomItem">
            <summary>Добавить пользовательский элемент записи данных спецификации</summary>
        </member>
        <member name="M:TFlex.Model.BOMRecord.GetCustomItem(System.Int32)">
            <summary>Получить пользовательский элемент записи данных спецификации</summary>
            <param name="index">Номер записи данных</param>
        </member>
        <member name="P:TFlex.Model.BOMRecord.CustomItemCount">
            <summary>Количество пользовательских элементов записи данных спецификации</summary>
        </member>
        <member name="M:TFlex.Model.BOMRecord.GetStandardItem(TFlex.Model.StandardBOMItemType)">
            <summary>Получить стандартный элемент записи данных для спецификации</summary>
            <param name="item">Тип стандартного элемента записи данных для спецификации</param>
        </member>
        <member name="T:TFlex.Model.BOMRecord">
            <summary>Запись данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.BOMData.NeverIncludeToBOMs">
            <summary>Никогда не включать в спецификации</summary>
        </member>
        <member name="M:TFlex.Model.BOMData.GetRecord(System.Int32)">
            <summary>Получить запись данных для спецификации</summary>
            <param name="index">Номер записи данных</param>
        </member>
        <member name="P:TFlex.Model.BOMData.RecordCount">
            <summary>Количество записей данных о спецификации</summary>
        </member>
        <member name="T:TFlex.Model.BOMData">
            <summary>Контейнер данных для спецификации</summary>
        </member>
        <member name="T:TFlex.Model.StandardBOMItemType">
            <summary>Тип стандартного элемента записи данных для спецификации</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.CageCode">
            <summary>Коммерческий код</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Quantity">
            <summary>Количество</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Zone">
            <summary>Зона</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Format">
            <summary>Формат</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Comments">
            <summary>Комментарии</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Price">
            <summary>Цена</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Weight">
            <summary>Масса</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Material3">
            <summary>Материал (третья строка)</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Material2">
            <summary>Материал (вторая строка)</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Material">
            <summary>Материал (первая строка)</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Designation">
            <summary>Обозначение</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.Title">
            <summary>Наименование</summary>
        </member>
        <member name="F:TFlex.Model.StandardBOMItemType.SectionName">
            <summary>Раздел записи</summary>
        </member>
        <member name="T:TFlex.Model.ExportTo3mf">
            <summary>Класс экспорта в файл формата 3MF</summary>
        </member>
        <member name="P:TFlex.Model.ExportToJt.Version">
            <summary>Версия JT формата</summary>
        </member>
        <member name="T:TFlex.Model.ExportToJt">
            <summary>Класс экспорта в файл формата JT</summary>
        </member>
        <member name="T:TFlex.Model.ExportToJtVersion">
            <summary>Версии JT формата</summary>
        </member>
        <member name="F:TFlex.Model.ExportToJtVersion.JT95">
            <summary>Использовать 95 версию JT формата</summary>
        </member>
        <member name="F:TFlex.Model.ExportToJtVersion.JT81">
            <summary>Использовать 81 версию JT формата</summary>
        </member>
        <member name="T:TFlex.Model.ExportToPrc">
            <summary>Класс экспорта в файл формата PRC</summary>
        </member>
        <member name="T:TFlex.Model.ExportToAcis">
            <summary>Класс экспорта в файл формата ACIS</summary>
        </member>
        <member name="P:TFlex.Model.ExportToIges.ConvertAnaliticGeometryToNurbs">
            <summary>Преобразование аналитической геометрии в Nurbs</summary>
        </member>
        <member name="P:TFlex.Model.ExportToIges.SaveSolidBodiesAsFaceSet">
            <summary>Сохранять твёрдые тела, как набор граней</summary>
        </member>
        <member name="T:TFlex.Model.ExportToIges">
            <summary>Класс экспорта в файл формата IGES</summary>
        </member>
        <member name="P:TFlex.Model.ExportToStep.Protocol">
            <summary>Протокол экспорта в Step</summary>
        </member>
        <member name="T:TFlex.Model.ExportToStep">
            <summary>Класс экспорта в файл формата STEP</summary>
        </member>
        <member name="T:TFlex.Model.ExportToStepProtocol">
            <summary>Протокол, который будет использоваться для экспорта в Step</summary>
        </member>
        <member name="F:TFlex.Model.ExportToStepProtocol.AP242">
            <summary>Использовать AP242 протокол для экспорта в Step</summary>
        </member>
        <member name="F:TFlex.Model.ExportToStepProtocol.AP214">
            <summary>Использовать AP214 протокол для экспорта в Step</summary>
        </member>
        <member name="F:TFlex.Model.ExportToStepProtocol.AP203">
            <summary>Использовать AP203 протокол для экспорта в Step</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.SimplifyGeometry">
            <summary>Упрощать геометрию</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ExportContours">
            <summary>Экспортировать профили</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ExportCurves">
            <summary>Экспортировать кривые</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ExportWelds">
            <summary>Экспортировать сварные швы</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ExportAnotation">
            <summary>Экспортировать аннотации</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.Export3DPictures">
            <summary>Экспортировать 3D изображения</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ExportWireBodies">
            <summary>Экспортировать  проволочные тела(кривые)</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ExportSheetBodies">
            <summary>Экспортировать листовые тела</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ExportSolidBodies">
            <summary>Экспортировать твёрдые тела</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ShowDialog">
            <summary>Показывать диалог опций импорта</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.ColorSource">
            <summary>Источник для цвета</summary>
        </member>
        <member name="P:TFlex.Model.ExportTo3dCommon.Mode">
            <summary>Тип экспорта</summary>
        </member>
        <member name="M:TFlex.Model.ExportTo3dCommon.Export(System.String)">
            <summary>Функция экспорта в файл</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportTo3dCommon">
            <summary>Базовый класс для экспорта в некоторые универсальные 3D форматы(STEP, ACIS, JT, PRC, 3MF, IGES)</summary>
        </member>
        <member name="T:TFlex.Model.ExportTo3dColorSource">
            <summary>Источник для цвета</summary>
        </member>
        <member name="F:TFlex.Model.ExportTo3dColorSource.MaterialColor">
            <summary>Цвет брать из информации о материале детали</summary>
        </member>
        <member name="F:TFlex.Model.ExportTo3dColorSource.ToneColor">
            <summary>Цвет брать из информации о цвете детали</summary>
        </member>
        <member name="T:TFlex.Model.ExportTo3dMode">
            <summary>Тип экспорта</summary>
        </member>
        <member name="F:TFlex.Model.ExportTo3dMode.BodySet">
            <summary>Экспортрировать сборку как набор тел</summary>
        </member>
        <member name="F:TFlex.Model.ExportTo3dMode.Assembly">
            <summary>Экспортировать как сборку</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.PathToAssemblyFolder">
            <summary>Путь к папке, в которую будут сохраняться создаваемые фрагменты в режиме сборки(используются только для типа импорта - сборка)</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.SewTolerance">
            <summary>Точность сшивки в мм</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.Sewing">
            <summary>Сшивка</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.CreateAccurateEdges">
            <summary>Строить точные рёбра</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.Heal">
            <summary>Лечение геометрии</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.AddBodyRecordsInProductStructure">
            <summary>Добавить записи о телах в структуру изделия</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.UpdateProductStructure">
            <summary>Обновить структуру изделия</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.CheckImportGeomerty">
            <summary>Сделать проверку тел, после импорта</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.ImportOnlyFromActiveFilter">
            <summary>Импортировать тела только с активного слоя</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.ImportHideBodies">
            <summary>Импортировать скрытые тела</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.ImportAnotations">
            <summary>Импортировать аннотации</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.ImportMeshBodies">
            <summary>Импортировать сеточные тела в виде 3D изображений</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.ImportWireBodies">
            <summary>Импортировать проволочные тела(кривые)</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.ImportSheetBodies">
            <summary>Импортировать листовые тела</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.ImportSolidBodies">
            <summary>Импортировать твёрдые тела</summary>
        </member>
        <member name="P:TFlex.Model.ImportFrom3dCommon.ShowDialog">
            <summary>Показывать диалог опций импорта</summary>
        </member>
        <member name="F:TFlex.Model.ImportFrom3dCommon.Mode">
            <summary>Тип импорта</summary>
        </member>
        <member name="M:TFlex.Model.ImportFrom3dCommon.Import(System.String)">
            <summary>Функция импорта файла</summary>
            <param name="fileName">Имя входного файла</param>
            <returns>Результат импорта</returns>
        </member>
        <member name="T:TFlex.Model.ImportFrom3dCommon">
            <summary>Класс импорта из множества популярных форматов CAD-систем(step, acis, iges, SolidWorks, NX, SolidEdge, Creo,...)</summary>
        </member>
        <member name="T:TFlex.Model.ImportFrom3dMode">
            <summary>Тип импорта модели</summary>
        </member>
        <member name="F:TFlex.Model.ImportFrom3dMode.Operation">
            <summary>Импортировать как отдельную операцию</summary>
        </member>
        <member name="F:TFlex.Model.ImportFrom3dMode.BodySet">
            <summary>Импортировать сборку как набор тел</summary>
        </member>
        <member name="F:TFlex.Model.ImportFrom3dMode.Assembly">
            <summary>Импортировать как сборку</summary>
        </member>
        <member name="T:TFlex.Model.ImportFrom3dOption">
            <summary>Возможные варианты использования некоторых опций импорта</summary>
        </member>
        <member name="F:TFlex.Model.ImportFrom3dOption.No">
            <summary>Опция не будет использоваться никогда ни для каких форматов</summary>
        </member>
        <member name="F:TFlex.Model.ImportFrom3dOption.Yes">
            <summary>Опция будет использоваться всегда для любых форматов</summary>
        </member>
        <member name="F:TFlex.Model.ImportFrom3dOption.Auto">
            <summary>Решение о том будет ли использоваться опция будет принято автоматически исходя из формата импортируемого файла</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF.ExportLayers">
            <summary>Экспортируемые слои документа</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF.ConvertToRaster">
            <summary>Преобразовать в растровое изображение</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF.Export3DModel">
            <summary>Экспортировать 3D модель</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF.Layers">
            <summary>Экспортировать слои</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF.IsSelectPagesDialogEnabled">
            <summary>Показывать диалог выбора экспортируемых страниц</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF.OpenExportFile">
            <summary>Открывать файл после экспорта</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF.ExportPages">
            <summary>Экспортируемые страницы документа</summary>
        </member>
        <member name="M:TFlex.Model.ExportToPDF.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToPDF">
            <summary>Класс экспорта в файл формата PDF</summary>
        </member>
        <member name="P:TFlex.Model.ExportToBitmap3D.Height">
            <summary>Установить высоту изображения в пикселях</summary>
        </member>
        <member name="P:TFlex.Model.ExportToBitmap3D.Width">
            <summary>Установить ширину изображения в пикселях</summary>
        </member>
        <member name="M:TFlex.Model.ExportToBitmap3D.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="M:TFlex.Model.ExportToBitmap3D.#ctor(TFlex.Control)">
            <summary>Конструктор</summary>
            <param name="control">Контрол</param>
        </member>
        <member name="M:TFlex.Model.ExportToBitmap3D.#ctor(TFlex.Model.View)">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.ExportToBitmap3D">
            <summary>Класс экспорта 3D модели в растровое изображение</summary>
        </member>
        <member name="M:TFlex.Model.ExportToRhino.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToRhino">
            <summary>Класс экспорта в файл формата Rhino</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromKompas.CreateNewDocument">
            <summary>Создать новый документ</summary>
        </member>
        <member name="M:TFlex.Model.ImportFromKompas.Import(System.String,System.String)">
            <summary>Импорт документа формата Компас</summary>
            <param name="fileNameFrom">Импортируемый файл</param>
            <param name="fileNameTo">Результирующий файл</param>
        </member>
        <member name="T:TFlex.Model.ImportFromKompas">
            <summary>Класс, импортирующий документы формата Компас</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.ExplodeBlocks">
            <summary>Раскрывать блоки</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.ScaleViewLines">
            <summary>При импорте масштабируем линии на чертёжных видах страниц</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.ImportWidth">
            <summary>Импортируем толщину линий вместо веса</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.ImportBodiesAndSurfaces">
            <summary>Импортировать тела и поверхности</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.ImportMeshes3DToPictures3D">
            <summary>Импортировать 3D сетки в 3D изображения</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.ImportLines3DToPaths3D">
            <summary>Импортировать 3D линии в 3D пути</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.ImportPoints3DToNodes3D">
            <summary>Импортировать 3D точки в 3D узлы</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.ImportGeometryMode">
            <summary>Тип экспортируемой из ACAD геометрии</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromACAD.CreateNewDocument">
            <summary>Создать новый документ</summary>
        </member>
        <member name="M:TFlex.Model.ImportFromACAD.Import(System.String)">
            <summary>Функция импорта файла</summary>
            <param name="fileName">Имя входного файла</param>
            <returns>Результат импорта</returns>
        </member>
        <member name="T:TFlex.Model.ImportFromACAD">
            <summary>Класс, импортирующий документы формата AutoCAD</summary>
        </member>
        <member name="T:TFlex.Model.ImportACADGeometryMode">
            <summary>Тип экспортируемой из ACAD геометрии</summary>
        </member>
        <member name="F:TFlex.Model.ImportACADGeometryMode.Import3DOnly">
            <summary>Импортировать только 3D</summary>
        </member>
        <member name="F:TFlex.Model.ImportACADGeometryMode.Imporе3DAs2D">
            <summary>Импортировать 3D как 2D</summary>
        </member>
        <member name="F:TFlex.Model.ImportACADGeometryMode.Ignore">
            <summary>Игнорировать</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromParasolid.ImportFormat">
            <summary>Формат импортирования сборки</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromParasolid.UUID">
            <summary>Задание UUID</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromParasolid.Layer">
            <summary>Задание слоя</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.ImportFromParasolid.Import(System.String)">
            <summary>Функция импорта файла</summary>
            <param name="fileName">Имя входного файла</param>
            <returns>Результат импорта</returns>
        </member>
        <member name="T:TFlex.Model.ImportFromParasolid">
            <summary>Класс, импортирующий документы Parasolid</summary>
        </member>
        <member name="T:TFlex.Model.ImportParasolidFormat">
            <summary>Опции импорта</summary>
        </member>
        <member name="F:TFlex.Model.ImportParasolidFormat.BodySet">
            <summary>Импортировать сборку как набор тел</summary>
        </member>
        <member name="F:TFlex.Model.ImportParasolidFormat.Operation">
            <summary>Импортировать как отдельную операцию</summary>
        </member>
        <member name="F:TFlex.Model.ImportParasolidFormat.Assembly">
            <summary>Импортировать как сборку</summary>
        </member>
        <member name="M:TFlex.Model.ImportVariables.Import(System.String)">
            <summary>Функция импорта переменных</summary>
            <param name="fileName">Имя входного файла</param>
            <returns>Результат импорта</returns>
        </member>
        <member name="T:TFlex.Model.ImportVariables">
            <summary>Класс, импортирующий переменные документа</summary>
        </member>
        <member name="M:TFlex.Model.ExportVariables.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportVariables">
            <summary>Класс, экспортирующий переменные документа</summary>
        </member>
        <member name="P:TFlex.Model.ExportToInventor.ExportTFLEXData">
            <summary>Экспортировать данные, необходимые для вставки данного файла в T-FLEX CAD</summary>
        </member>
        <member name="M:TFlex.Model.ExportToInventor.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToInventor">
            <summary>Класс экспорта в файл форматa Open Inventor</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPOV.Height">
            <summary>Установить высоту изображения в пикселях</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPOV.Width">
            <summary>Установить ширину изображения в пикселях</summary>
        </member>
        <member name="M:TFlex.Model.ExportToPOV.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToPOV">
            <summary>Класс экспорта в файл форматa POV</summary>
        </member>
        <member name="M:TFlex.Model.ExportToOBJ.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToOBJ">
            <summary>Класс экспорта в файл форматa OBJ</summary>
        </member>
        <member name="M:TFlex.Model.ExportToU3D.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToU3D">
            <summary>Класс экспорта в файл форматa U3D</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF3D.Layers">
            <summary>Экспортировать слои. Слои экспортируются как узлы дерева модели</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF3D.TreeModel">
            <summary>Экспортировать дерево модели</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF3D.Attributes">
            <summary>Экспортировать атрибуты</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF3D.Edges">
            <summary>Экспортировать рёбра</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF3D.Texture">
            <summary>Экспортировать с текстурами. Опция экспорта с материалами должна быть включена</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF3D.Material">
            <summary>Экспортировать с материалами</summary>
        </member>
        <member name="P:TFlex.Model.ExportToPDF3D.OpenExportFile">
            <summary>Открывать файл после экспорта</summary>
        </member>
        <member name="M:TFlex.Model.ExportToPDF3D.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToPDF3D">
            <summary>Класс экспорта в файл форматa PDF3D</summary>
        </member>
        <member name="M:TFlex.Model.ExportToECT.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="M:TFlex.Model.ExportToPLY.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToPLY">
            <summary>Класс экспорта в файл форматa PLY</summary>
        </member>
        <member name="M:TFlex.Model.ExportToX3D.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToX3D">
            <summary>Класс экспорта в файл форматa X3D</summary>
        </member>
        <member name="M:TFlex.Model.ExportToVRML.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToVRML">
            <summary>Класс экспорта в файл форматa VRML</summary>
        </member>
        <member name="P:TFlex.Model.ExportToDXF3D.LayerModel">
            <summary>Цветовая модель для экспорта в STL</summary>
        </member>
        <member name="P:TFlex.Model.ExportToDXF3D.AngleTolerance">
            <summary>Допуск по углу</summary>
        </member>
        <member name="P:TFlex.Model.ExportToDXF3D.FaceTolerance">
            <summary>Точность грани</summary>
        </member>
        <member name="P:TFlex.Model.ExportToDXF3D.EdgeTolerance">
            <summary>Допуск по ребру</summary>
        </member>
        <member name="P:TFlex.Model.ExportToDXF3D.NormalTolerance">
            <summary>Максимальное уклонение нормали</summary>
        </member>
        <member name="P:TFlex.Model.ExportToDXF3D.MaxCellSize">
            <summary>Максимальный размер ячейки</summary>
        </member>
        <member name="P:TFlex.Model.ExportToDXF3D.LinearTolerance">
            <summary>Допуск</summary>
        </member>
        <member name="P:TFlex.Model.ExportToDXF3D.FileVersion">
            <summary>Версия выходного файла</summary>
        </member>
        <member name="M:TFlex.Model.ExportToDXF3D.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToDXF3D">
            <summary>Класс экспорта в файл форматa DXF 3D</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.ShowDialog">
            <summary>Показывать диалог опций экспорта</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.FileFormat">
            <summary>Формат файла</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.DeleteRedundant">
            <summary>Удалить избыточную геометрию</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.FileVersion">
            <summary>Версия выходного файла</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.ConverterName">
            <summary>Название конвертера</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.ModelName">
            <summary>Название модели</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.CompanyName">
            <summary>Название экспортирующей компании</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.UserName">
            <summary>Имя пользователя</summary>
        </member>
        <member name="P:TFlex.Model.ExportToParasolid.SystemName">
            <summary>Название экспортирующей системы</summary>
        </member>
        <member name="M:TFlex.Model.ExportToParasolid.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToParasolid">
            <summary>Класс экспорта в файлы форматов Parasolid</summary>
        </member>
        <member name="T:TFlex.Model.ParasolidFileFormat">
            <summary>Формат файла</summary>
        </member>
        <member name="F:TFlex.Model.ParasolidFileFormat.Binary">
            <summary>Бинарный</summary>
        </member>
        <member name="F:TFlex.Model.ParasolidFileFormat.Text">
            <summary>Текстовый</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.ColorModel">
            <summary>Цветовая модель для экспорта в STL</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.DivideByOperation">
            <summary>Писать отдельный файл для каждой операции</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.Binary">
            <summary>Использовать бинарный формат STL</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.AngleTolerance">
            <summary>Допуск по углу</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.FaceTolerance">
            <summary>Точность грани</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.EdgeTolerance">
            <summary>Допуск по ребру</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.NormalTolerance">
            <summary>Максимальное уклонение нормали</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.MaxCellSize">
            <summary>Максимальный размер ячейки</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTL.LinearTolerance">
            <summary>Допуск</summary>
        </member>
        <member name="M:TFlex.Model.ExportToSTL.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToSTL">
            <summary>Класс экспорта в файл формата STL</summary>
        </member>
        <member name="P:TFlex.Model.ExportToBMF.Page">
            <summary>Установить экспортируемую страницу</summary>
        </member>
        <member name="M:TFlex.Model.ExportToBMF.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToBMF">
            <summary>Класс экспорта в файл формата BMF</summary>
        </member>
        <member name="P:TFlex.Model.ExportToMetafileWMF.Page">
            <summary>Установить экспортируемую страницу</summary>
        </member>
        <member name="M:TFlex.Model.ExportToMetafileWMF.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToMetafileWMF">
            <summary>Класс экспорта в файл формата Windows Metafile (WMF)</summary>
        </member>
        <member name="P:TFlex.Model.ExportToMetafile.UseOneColor">
            <summary>Использовать один цвет</summary>
        </member>
        <member name="P:TFlex.Model.ExportToMetafile.Color">
            <summary>Установить цвет</summary>
        </member>
        <member name="P:TFlex.Model.ExportToMetafile.Page">
            <summary>Установить экспортируемую страницу</summary>
        </member>
        <member name="M:TFlex.Model.ExportToMetafile.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToMetafile">
            <summary>Класс экспорта в файл формата Windows Enhanced Metafile (EMF)</summary>
        </member>
        <member name="P:TFlex.Model.ExportToIGES.Units">
            <summary>Единицы измерения</summary>
        </member>
        <member name="P:TFlex.Model.ExportToIGES.UseCubicSplines">
            <summary>Использовать только кубические сплайны</summary>
        </member>
        <member name="P:TFlex.Model.ExportToIGES.ConvertToSplines">
            <summary>Преобразовывать в сплайны</summary>
        </member>
        <member name="M:TFlex.Model.ExportToIGES.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToIGES">
            <summary>Класс экспорта в файл формата IGES</summary>
        </member>
        <member name="P:TFlex.Model.ImportFromSTEP.ImportFormat">
            <summary>Формат импортирования сборки</summary>
        </member>
        <member name="M:TFlex.Model.ImportFromSTEP.Import(System.String)">
            <summary>Функция импорта документа</summary>
            <param name="fileName">Имя входного файла</param>
            <returns>Результат импорта</returns>
        </member>
        <member name="T:TFlex.Model.ImportFromSTEP">
            <summary>Класс импорта в файл формата STEP</summary>
        </member>
        <member name="T:TFlex.Model.ImportSTEPFormat">
            <summary>Опции импорта</summary>
        </member>
        <member name="F:TFlex.Model.ImportSTEPFormat.BodySet">
            <summary>Импортировать сборку как набор тел</summary>
        </member>
        <member name="F:TFlex.Model.ImportSTEPFormat.Operation">
            <summary>Импортировать как отдельную операцию</summary>
        </member>
        <member name="F:TFlex.Model.ImportSTEPFormat.Assembly">
            <summary>Импортировать как сборку</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.Units">
            <summary>Единицы измерения</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.QuickTranformationDisabled">
            <summary>Запретить "быстрые" преобразования</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.SplitAllPeriodic">
            <summary>Разделять все периодические грани</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.SplitPeriodic">
            <summary>Разделять периодические грани</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.AssemblyRepresentation">
            <summary>Тип сборочной модели</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.SimplifyModel">
            <summary>Упростить модель</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.ConvertToBS">
            <summary>Конвертировать в B-Сплайны</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.ConverterName">
            <summary>Название конвертера</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.ModelName">
            <summary>Название модели</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.CompanyName">
            <summary>Название экспортирующей компании</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.UserName">
            <summary>Имя пользователя</summary>
        </member>
        <member name="P:TFlex.Model.ExportToSTEP.SystemName">
            <summary>Название экспортирующей системы</summary>
        </member>
        <member name="M:TFlex.Model.ExportToSTEP.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToSTEP">
            <summary>Класс экспорта в файл формата STEP</summary>
        </member>
        <member name="P:TFlex.Model.ExportToBitmap.PageRectangle">
            <summary>Установить границы экспортируемого изображения страницы</summary>
        </member>
        <member name="P:TFlex.Model.ExportToBitmap.Page">
            <summary>Установить экспортируемую страницу</summary>
        </member>
        <member name="P:TFlex.Model.ExportToBitmap.Resolution">
            <summary>Установить разрешение</summary>
        </member>
        <member name="P:TFlex.Model.ExportToBitmap.Height">
            <summary>Установить высоту изображения в пикселях</summary>
        </member>
        <member name="P:TFlex.Model.ExportToBitmap.Width">
            <summary>Установить ширину изображения в пикселях</summary>
        </member>
        <member name="M:TFlex.Model.ExportToBitmap.Export(TFlex.Model.ImageExport)">
            <summary>Функция экспорта документа</summary>
            <param name="options">Опции экспорта</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="M:TFlex.Model.ExportToBitmap.Export(System.String,TFlex.Model.ImageExport,TFlex.Model.ImageExportFormat)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <param name="options">Опции экспорта</param>
            <param name="format">Формат экспорта</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="M:TFlex.Model.ExportToBitmap.Export(System.String,TFlex.Model.ImageExport)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <param name="options">Опции экспорта</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="M:TFlex.Model.ExportToBitmap.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToBitmap">
            <summary>Класс экспорта в файлы растровых форматов</summary>
        </member>
        <member name="M:TFlex.Model.ExportToDXB.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToDXB">
            <summary>Класс экспорта в формат DXB</summary>
        </member>
        <member name="M:TFlex.Model.ExportToDXF.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToDXF">
            <summary>Класс экспорта в формат DXF</summary>
        </member>
        <member name="M:TFlex.Model.ExportToDWG.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportToDWG">
            <summary>Класс экспорта в формат DWG</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.NotCreateBlocksForPages">
            <summary>Не создавать блоки для страниц</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.ExportPages">
            <summary>Экспортируемые страницы</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.Page">
            <summary>Установить экспортируемую страницу</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.ExportAllPages">
            <summary>Экспортировать все страницы</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.BiarcInterpolationAccuracyForSplines">
            <summary>Точность круговой интерполяции</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.BiarcInterpolationForSplines">
            <summary>Экспортировать сплайны с использованием круговой интерполяции</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.ConvertLineText">
            <summary>Конвертировать строчные тексты: false - в тексты, true - в линии</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.ConvertMultitext">
            <summary>Конвертировать мультитексты: 0 - выборочно, 1 - в мультитексты,
2 - в тексты и линии</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.ConvertAreas">
            <summary>Конвертировать штриховки: true - в штриховки, false - в линии</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.ConvertDimensions">
            <summary>Конвертировать размеры: 0 - в размеры, 1 - в размеры и тексты, 
2 - в линии и тексты</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.ConvertToLines">
            <summary>Конвертировать линии: true - в линии, false - в полилинии</summary>
        </member>
        <member name="P:TFlex.Model.ExportToACAD.AutocadExportFileVersion">
            <summary>Установка версии файла Autocad</summary>
        </member>
        <member name="T:TFlex.Model.ExportToACAD">
            <summary>Класс экспорта в форматы AutoCAD</summary>
        </member>
        <member name="T:TFlex.Model.AutocadExportFileVersionType">
            <summary>Доступные для экспорта версии Autocad</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efDEFAULT_LAST_VERSION">
            <summary>AutoCAD последней версии</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efACAD2013">
            <summary>AutoCAD 2013</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efACAD2010">
            <summary>AutoCAD 2010</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efACAD2007">
            <summary>AutoCAD 2007</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efACAD2004">
            <summary>AutoCAD 2004</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efACAD2000">
            <summary>AutoCAD 2000</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efACAD14">
            <summary>AutoCAD 14</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efACAD13">
            <summary>AutoCAD 13</summary>
        </member>
        <member name="F:TFlex.Model.AutocadExportFileVersionType.efACAD12">
            <summary>AutoCAD 12</summary>
        </member>
        <member name="M:TFlex.Model.ExportTo.Export(System.String)">
            <summary>Функция экспорта документа</summary>
            <param name="fileName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="T:TFlex.Model.ExportTo">
            <summary>Базовый класс для всех классов экспорта документа</summary>
        </member>
        <member name="T:TFlex.Model.ImageExportFormat">
            <summary>Форматы экспорта изображений</summary>
        </member>
        <member name="F:TFlex.Model.ImageExportFormat.Png">
            <summary>Изображение Png</summary>
        </member>
        <member name="F:TFlex.Model.ImageExportFormat.Tiff">
            <summary>Изображение Tiff</summary>
        </member>
        <member name="F:TFlex.Model.ImageExportFormat.Gif">
            <summary>Изображение Gif</summary>
        </member>
        <member name="F:TFlex.Model.ImageExportFormat.Jpeg">
            <summary>Изображение Jpeg</summary>
        </member>
        <member name="F:TFlex.Model.ImageExportFormat.Bmp">
            <summary>Битовое изображение BMP</summary>
        </member>
        <member name="T:TFlex.Model.ImageExport">
            <summary>Опции экспорта изображений</summary>
        </member>
        <member name="F:TFlex.Model.ImageExport.Default">
            <summary>Экспортировать все элементы, кроме элементов построения</summary>
        </member>
        <member name="F:TFlex.Model.ImageExport.Constructions">
            <summary>Экспортировать элементы построения</summary>
        </member>
        <member name="F:TFlex.Model.ImageExport.ScreenLayers">
            <summary>Экспортировать экранные слои</summary>
        </member>
        <member name="F:TFlex.Model.ImageExport.None">
            <summary>Не экспортировать вспомогательные объекты</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.Gallon">
            <summary> Галлон; галлон; gallon; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.CubicDecimeter">
            <summary> Кубический дециметр; дм³; dm³; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.CubicCentimeter">
            <summary> Кубический сантиметр; см³; cm³; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.CubicInch">
            <summary> Кубический дюйм; дюйм³; in³; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.CubicMeter">
            <summary> Кубический метр; м³; m³; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.Liter">
            <summary> Литр; л; L; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.CubicKilometer">
            <summary> Кубический километр; км³; km³; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.CubicMillimeter">
            <summary> Кубический миллиметр; мм³; mm³; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.CubicYard">
            <summary> Кубический ярд; ярд³; yd³; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.CubicFoot">
            <summary> Кубический фут; фут³; ft³; <para />Тип - Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Volume.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Volume">
            <summary>Тип единицы измерения (физическая величина) Объём</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Voltage.Megavolt">
            <summary> Мегавольт; МВ; MV; <para />Тип - Напряжение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Voltage.Kilovolt">
            <summary> Киловольт; кВ; kV; <para />Тип - Напряжение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Voltage.Volt">
            <summary> Вольт; В; V; <para />Тип - Напряжение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Voltage.Microvolt">
            <summary> Микровольт; мкВ; mkV; <para />Тип - Напряжение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Voltage.Millivolt">
            <summary> Милливольт; мВ; mV; <para />Тип - Напряжение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Voltage.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Voltage">
            <summary>Тип единицы измерения (физическая величина) Напряжение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Velocity.MillimeterPerSecond">
            <summary> Миллиметр в секунду; мм/с; mm/s; <para />Тип - Скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Velocity.InchesPerSecond">
            <summary> Дюйм в секунду; дюйм/с; In/s; <para />Тип - Скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Velocity.MilesPerHour">
            <summary> Миль в час; миль/ч; mph; <para />Тип - Скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Velocity.KilometerPerHour">
            <summary> Километр в час; км/ч; km/h; <para />Тип - Скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Velocity.FootPerSecond">
            <summary> Фут в секунду; фут/с; ft/s; <para />Тип - Скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Velocity.MeterPerSecond">
            <summary> Метр в секунду; м/с; m/s; <para />Тип - Скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Velocity.CentimeterPerSecond">
            <summary> Сантиметр в секунду; см/с; sm/s; <para />Тип - Скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Velocity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Velocity">
            <summary>Тип единицы измерения (физическая величина) Скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Toughness.JoulePerSquareMeter">
            <summary> Джоуль на квадратный метр; Дж/м²; J/m²; <para />Тип - Ударная вязкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Toughness.KilojoulePerSquareMeter">
            <summary> Килоджоуль на квадратный метр; кДж/м²; kJ/m²; <para />Тип - Ударная вязкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Toughness.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Toughness">
            <summary>Тип единицы измерения (физическая величина) Ударная вязкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.TorsionalStrength.NewtonPerMeter">
            <summary> Ньютон на метр; Н/м; N/m; <para />Тип - Прочность кручения</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.TorsionalStrength.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.TorsionalStrength">
            <summary>Тип единицы измерения (физическая величина) Прочность кручения</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Torque.PoundForceInch">
            <summary> Фунт-сила дюйм; фунт-сила·дюйм ; lbf·in; <para />Тип - Момент силы</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Torque.KilogramForceCentimeter">
            <summary> Килограмм-сила сантиметр; кгс·см; kgf·cm; <para />Тип - Момент силы</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Torque.NewtonMeter">
            <summary> Ньютон-метр; Н·м; N·m; <para />Тип - Момент силы</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Torque.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Torque">
            <summary>Тип единицы измерения (физическая величина) Момент силы</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Day">
            <summary> День; сут; d; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Week">
            <summary> Неделя; нед; week; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Minute">
            <summary> Минута; мин; min; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Day24">
            <summary> Сутки; сут; d; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Hour">
            <summary> Час; ч; h; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Microsecond">
            <summary> Микросекунда; мкс; µs; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Millisecond">
            <summary> Миллисекунда; мс; ms; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Decade">
            <summary> Декада; дек; decade; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Second">
            <summary> Секунда; с; s; <para />Тип - Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Time.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Time">
            <summary>Тип единицы измерения (физическая величина) Время</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalInsulance.SquareCentimeterCelciusDegreeSecondPerCalorie">
            <summary> Квадратный сантиметр градус Цельсия секунда на калорию; см²·°C·с/кал; cm²·°C·s/cal; <para />Тип - Поверхностное тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalInsulance.SquareInchFahrenheitDegreeSecondPerBTU">
            <summary> Квадратный дюйм градус Фаренгейта секунда на БТЕ; дюйм²·°F·с/БТЕ; in²·°F·s/BTU; <para />Тип - Поверхностное тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalInsulance.SquareMeterKelvinPerWatt">
            <summary> Квадратный метр Кельвин на Ватт; м²·K/Вт; m²·K/W; <para />Тип - Поверхностное тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalInsulance.SquareMeterCelciusDegreeSecondPerCalorie">
            <summary> Квадратный метр градус Цельсия секунда на калорию; м²·°C·с/кал; m²·°C·s/cal; <para />Тип - Поверхностное тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalInsulance.SquareFootFahrenheitDegreeSecondPerBTU">
            <summary> Квадратный фут градус Фаренгейта секунда на БТЕ; фут²·°F·с/БТЕ; ft²·°F·s/BTU; <para />Тип - Поверхностное тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalInsulance.SquareFootFahrenheitDegreeHourPerBTU">
            <summary> Квадратный фут градус Фаренгейта час на БТЕ; фут²·°F·ч/БТЕ; ft²·°F·hr/BTU; <para />Тип - Поверхностное тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalInsulance.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.ThermalInsulance">
            <summary>Тип единицы измерения (физическая величина) Поверхностное тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalExpansionCoefficient._1PerDegree">
            <summary> 1 / градус; 1/°C; °C; <para />Тип - Коэффициент теплового расширения</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalExpansionCoefficient.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.ThermalExpansionCoefficient">
            <summary>Тип единицы измерения (физическая величина) Коэффициент теплового расширения</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalConductivity.WattPerMeterDegree">
            <summary> Ватт на метр-градус; Вт/(м·К); W/(m·°С); <para />Тип - Теплопроводность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalConductivity.WattPerMillimeterDegree">
            <summary> Ватт на миллиметр-градус; Вт/(мм·К); W/(mm·°С); <para />Тип - Теплопроводность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ThermalConductivity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.ThermalConductivity">
            <summary>Тип единицы измерения (физическая величина) Теплопроводность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Temperature.Kelvin">
            <summary> Кельвин; К; K; <para />Тип - Температура</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Temperature.FahrenheitDegree">
            <summary> Градус Фаренгейта; °F; °F; <para />Тип - Температура</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Temperature.CelsiusDegree">
            <summary> Градус Цельсия; °C; °C; <para />Тип - Температура</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Temperature.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Temperature">
            <summary>Тип единицы измерения (физическая величина) Температура</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.SpecificHeatCapacity.JoulePerGramKelvin">
            <summary> Джоуль на грамм на Кельвин; Дж/(г·К); J/(g·K); <para />Тип - Удельная теплоемкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.SpecificHeatCapacity.JoulePerKilogramKelvin">
            <summary> Джоуль на килограмм на Кельвин; Дж/(кг·К); J/(kg·K); <para />Тип - Удельная теплоемкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.SpecificHeatCapacity.JoulePerPoundKelvin">
            <summary> Джоуль на фунт на Кельвин; Дж/(фунт·К); J/(lb·K); <para />Тип - Удельная теплоемкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.SpecificHeatCapacity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.SpecificHeatCapacity">
            <summary>Тип единицы измерения (физическая величина) Удельная теплоемкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Resistance.Megaohm">
            <summary> Мегаом; МОм; MΩ; <para />Тип - Сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Resistance.Ohm">
            <summary> Ом; Ом; Ohm; <para />Тип - Сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Resistance.Microohm">
            <summary> Микроом; мкОм; µΩ; <para />Тип - Сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Resistance.Milliohm">
            <summary> Миллиом; мОм; mΩ; <para />Тип - Сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Resistance.Kiloohm">
            <summary> Килоом; кОм; kOhm; <para />Тип - Сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Resistance.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Resistance">
            <summary>Тип единицы измерения (физическая величина) Сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.InchOfMercury">
            <summary> Дюйм ртутного столба; дюйм рт. ст.; inches Hg; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.Kilopascal">
            <summary> Килопаскаль; кПа; kPa; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.KilopoundPerSquareInch">
            <summary> Килофунт на квадратный дюйм; килофунт/дюйм²; ksi; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.Pascal">
            <summary> Паскаль; Па; Pa; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.KilonewtonPerSquareMeter">
            <summary> Килоньютон на квадратный метр; кН/м²; kN/m²; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.MillimeterOfMercury">
            <summary> Миллиметр ртутного столба; мм рт.ст.; mm Hg; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.Bar">
            <summary> Бар; бар; bar; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.InchOfWater">
            <summary> Дюйм водяного столба; дюйм в. ст.; inches H₂O; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.Atmosphere">
            <summary> Атмосфера; атм; atm; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.NewtonPerSquareCentimeter">
            <summary> Ньютон на квадратный сантиметр; Н/см²; N/cm²; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.KilonewtonPerSquareCentimeter">
            <summary> Килоньютон на квадратный сантиметр; кН/см²; kN/cm²; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.PoundPerSquareInch">
            <summary> Фунт на квадратный дюйм; фунт/дюйм²; psi; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.Megapascal">
            <summary> Мегапаскаль; МПа; MPa; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.NewtonPerSquareMeter">
            <summary> Ньютон на квадратный метр; Н/м²; N/m²; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.MillimeterOfWater">
            <summary> Миллиметр водяного столба	; мм в.ст.; mm H₂O; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.KilogramForcePerSquareCentimeter">
            <summary> Килограмм-сила на квадратный сантиметр; кгс/см²; kgf/cm²; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.PoundPerSquareFoot">
            <summary> Фунт на квадратный фут; фунт/фут²; psf; <para />Тип - Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Pressure.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Pressure">
            <summary>Тип единицы измерения (физическая величина) Давление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.Kilowatt">
            <summary> Киловатт; кВт; kW; <para />Тип - Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.CaloriePerSecond">
            <summary> Калория в секунду; кал/с; cal/s; <para />Тип - Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.BTUPerSecond">
            <summary> БТЕ в секунду; БТЕ/с; BTU/s; <para />Тип - Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.Watt">
            <summary> Ватт; Вт; W; <para />Тип - Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.Megawatt">
            <summary> Мегаватт; МВт; MW; <para />Тип - Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.Gigawatt">
            <summary> Гигаватт; ГВт; GW; <para />Тип - Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.Microwatt">
            <summary> Микроватт; мкВт; mkW; <para />Тип - Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.Milliwatt">
            <summary> Милливат; мВт; mW; <para />Тип - Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Power.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Power">
            <summary>Тип единицы измерения (физическая величина) Мощность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ObjectsQuantity.Piece">
            <summary> Штука; шт; pc; <para />Тип - Количество объектов</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ObjectsQuantity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.ObjectsQuantity">
            <summary>Тип единицы измерения (физическая величина) Количество объектов</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.MomentOfInertia.PoundSquareFoot">
            <summary> Фунт квадратный фут; фунт·фут²; lb·ft²; <para />Тип - Момент инерции</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.MomentOfInertia.GramSquareCentimeter">
            <summary> Грамм квадратный сантиметр; г·см²; g·cm²; <para />Тип - Момент инерции</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.MomentOfInertia.KilogramSquareMeter">
            <summary> Килограмм квадратный метр; кг·м²; kg·m²; <para />Тип - Момент инерции</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.MomentOfInertia.PoundSquareInch">
            <summary> Фунт квадратный дюйм; фунт·дюйм²; lb·in²; <para />Тип - Момент инерции</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.MomentOfInertia.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.MomentOfInertia">
            <summary>Тип единицы измерения (физическая величина) Момент инерции</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Mass.Gram">
            <summary> Грамм; г; g; <para />Тип - Масса</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Mass.Milligram">
            <summary> Миллиграмм; мг; mg; <para />Тип - Масса</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Mass.Pound">
            <summary> Фунт; фунт; lb; <para />Тип - Масса</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Mass.Kilogram">
            <summary> Килограмм; кг; kg; <para />Тип - Масса</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Mass.Ounce">
            <summary> Унция; унция; oz; <para />Тип - Масса</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Mass.Tonne">
            <summary> Тонна; т; t; <para />Тип - Масса</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Mass.Centner">
            <summary> Центнер; ц; q; <para />Тип - Масса</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Mass.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Mass">
            <summary>Тип единицы измерения (физическая величина) Масса</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LuminousIntensity.Candela">
            <summary> Кандела; кд; cd; <para />Тип - Сила света</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LuminousIntensity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.LuminousIntensity">
            <summary>Тип единицы измерения (физическая величина) Сила света</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.OuncePerFoot">
            <summary> Унция на фут; унция/фут; oz/ft; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.GramPerMeter">
            <summary> Грамм на метр; г/м; g/m; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.KilogramPerMeter">
            <summary> Килограмм на метр; кг/м; kg/m; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.Denier">
            <summary> Титр; титр; den; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.PoundPerYard">
            <summary> Фунт на ярд; фунт/ярд; lb/yd; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.OuncePerInch">
            <summary> Унция на дюйм; унция/дюйм; oz/in; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.Decitex">
            <summary> Децитекс; децитекс; dtex; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.GramPerKilometer">
            <summary> Грамм на километр; г/км; g/km; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.GramPerCentimeter">
            <summary> Грамм на сантиметр; г/см; g/cm; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.Tex">
            <summary> Текс; текс; tex; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.PoundPerFoot">
            <summary> Фунт на фут; фунт/фут; lb/ft; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.PoundPerInch">
            <summary> Фунт на дюйм; фунт/дюйм; lb/in; <para />Тип - Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.LinearDensity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.LinearDensity">
            <summary>Тип единицы измерения (физическая величина) Линейная плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Yard">
            <summary> Ярд; ярд; yd; <para />Тип - Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Meter">
            <summary> Метр; м; m; <para />Тип - Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Inch">
            <summary> Дюйм; дюйм; in; <para />Тип - Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Kilometer">
            <summary> Километр; км; km; <para />Тип - Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Millimeter">
            <summary> Миллиметр; мм; mm; <para />Тип - Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Foot">
            <summary> Фут; фут; ft; <para />Тип - Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Decimeter">
            <summary> Дециметр; дм; dm; <para />Тип - Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Centimeter">
            <summary> Сантиметр; см; cm; <para />Тип - Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Length.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Length">
            <summary>Тип единицы измерения (физическая величина) Длина</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.KinematicViscosity.SquareCentimeterPerSecond">
            <summary> Квадратный сантиметр в секунду; см²/c; cm²/s; <para />Тип - Кинематическая вязкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.KinematicViscosity.SquareMeterPerSecond">
            <summary> Квадратный метр в секунду; м²/с; m²/s; <para />Тип - Кинематическая вязкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.KinematicViscosity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.KinematicViscosity">
            <summary>Тип единицы измерения (физическая величина) Кинематическая вязкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Inductance.Microhenry">
            <summary> Микрогенри; мкГн; µH; <para />Тип - Индуктивность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Inductance.Millihenry">
            <summary> Миллигенри; мГн; mH; <para />Тип - Индуктивность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Inductance.Henri">
            <summary> Генри; Гн; H; <para />Тип - Индуктивность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Inductance.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Inductance">
            <summary>Тип единицы измерения (физическая величина) Индуктивность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatResistance.KelvinPerWatt">
            <summary> Градус Кельвина на Ватт; К/Вт; K/W; <para />Тип - Тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatResistance.FahrenheitDegreeSecondPerBTU">
            <summary> Градус Фаренгейта секунда на БТЕ; °F·с/БТЕ; °F·s/Btuth; <para />Тип - Тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatResistance.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.HeatResistance">
            <summary>Тип единицы измерения (физическая величина) Тепловое сопротивление</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatFluxDensity.WattPerSquareMeter">
            <summary> Ватт на квадратный метр; Вт/м²; W/m²; <para />Тип - Плотность теплового потока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatFluxDensity.WattPerSquareCentimeter">
            <summary> Ватт на квадратный сантиметр; Вт/см²; W/cm²; <para />Тип - Плотность теплового потока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatFluxDensity.BTUPerSecondPerSquareInch">
            <summary> БTE в секунду на квадратный дюйм; БТЕ/(дюйм²·с); BTU/(in²·s); <para />Тип - Плотность теплового потока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatFluxDensity.CaloriePerSecondPerSquareCentimeter">
            <summary> Калория в секунду на квадратный сантиметр; кал/(см²·с); cal/(cm²·s); <para />Тип - Плотность теплового потока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatFluxDensity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.HeatFluxDensity">
            <summary>Тип единицы измерения (физическая величина) Плотность теплового потока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatConvectionCoefficient.WattPerSquareCentimeterCelsiusDegree">
            <summary> Ватт на квадратный сантиметр на градус Цельсия; Вт/(см²·°С); W/(cm²·°C); <para />Тип - Коэффициент теплоотдачи</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatConvectionCoefficient.CaloriePerSecondPerSquareCentimeterPerCelciusDegree">
            <summary> Калория в секунду на квадратный сантиметр на градус Цельсия; кал/(с·см²·°C); cal/(s·cm²·°C); <para />Тип - Коэффициент теплоотдачи</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatConvectionCoefficient.WattPerSquareMeterCelsiusDegree">
            <summary> Ватт на квадратный метр на градус Цельсия; Вт/(м²·°С); W/(m²·°C); <para />Тип - Коэффициент теплоотдачи</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatConvectionCoefficient.BTUPerSecondPerSquareInchPerFahrenheitDegree">
            <summary> БTE в секунду на квадратный дюйм на градус Фаренгейта; БТЕ/(с·дюйм²·°F); BTU/(s·in²·°F); <para />Тип - Коэффициент теплоотдачи</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatConvectionCoefficient.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.HeatConvectionCoefficient">
            <summary>Тип единицы измерения (физическая величина) Коэффициент теплоотдачи</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatCapacity.JoulePerKelvin">
            <summary> Джоуль на Кельвин; Дж/К; J/K; <para />Тип - Теплоёмкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.HeatCapacity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.HeatCapacity">
            <summary>Тип единицы измерения (физическая величина) Теплоёмкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Hardness.KilogramForcePerSquareMillimeter">
            <summary> Килограмм-сила на квадратный миллиметр; кгс/мм²; kgf/mm²; <para />Тип - Твёрдость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Hardness.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Hardness">
            <summary>Тип единицы измерения (физическая величина) Твёрдость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Frequency.Megahertz">
            <summary> Мегагерц; МГц; MHz; <para />Тип - Частота</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Frequency.Hertz">
            <summary> Герц; Гц; Hz; <para />Тип - Частота</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Frequency.Kilohertz">
            <summary> Килогерц; кГц; kHz; <para />Тип - Частота</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Frequency.Gigahertz">
            <summary> Гигагерц; ГГц; GHz; <para />Тип - Частота</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Frequency.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Frequency">
            <summary>Тип единицы измерения (физическая величина) Частота</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Force.Kilonewton">
            <summary> Килоньютон; кН; kN; <para />Тип - Сила</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Force.Meganewton">
            <summary> Меганьютон; МН; MN; <para />Тип - Сила</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Force.Dyne">
            <summary> Дина; дин; dyn; <para />Тип - Сила</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Force.Newton">
            <summary> Ньютон; Н; N; <para />Тип - Сила</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Force.PoundForce">
            <summary> Фунт-сила; фунт-сила; lbf; <para />Тип - Сила</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Force.KilogramForce">
            <summary> Килограмм-сила; кГ; kgf; <para />Тип - Сила</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Force.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Force">
            <summary>Тип единицы измерения (физическая величина) Сила</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.FlowRate.LiterPerSecond">
            <summary> Литр в секунду; л/с; l/s; <para />Тип - Расход</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.FlowRate.CubicFootPerSecond">
            <summary> Кубический фут в секунду; фут³/с; ft³/s; <para />Тип - Расход</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.FlowRate.CubicMeterPerHour">
            <summary> Кубический метр в час; м³/ч; m³/h; <para />Тип - Расход</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.FlowRate.CubicMeterPerSecond">
            <summary> Кубический метр в секунду; м³/c; m³/s; <para />Тип - Расход</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.FlowRate.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.FlowRate">
            <summary>Тип единицы измерения (физическая величина) Расход</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Energy.Kilojoule">
            <summary> Килоджоуль; кДж; kJ; <para />Тип - Энергия</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Energy.Joule">
            <summary> Джоуль; Дж; J; <para />Тип - Энергия</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Energy.BritishThermalUnit">
            <summary> Британская термическая единица; бте; btu; <para />Тип - Энергия</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Energy.Calorie">
            <summary> Калория; кал; cal; <para />Тип - Энергия</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Energy.KilowattHour">
            <summary> Киловатт-час; кВт·ч; kW·h; <para />Тип - Энергия</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Energy.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Energy">
            <summary>Тип единицы измерения (физическая величина) Энергия</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ElectricalConductivity.Siemens">
            <summary> Сименс; См; S; <para />Тип - Электропроводность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.ElectricalConductivity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.ElectricalConductivity">
            <summary>Тип единицы измерения (физическая величина) Электропроводность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.DielectricRigidity.MegavoltsPerMeter">
            <summary> Мегавольт на метр; МВ/м; MV/m; <para />Тип - Прочность диэлектрическая</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.DielectricRigidity.VoltPerMeter">
            <summary> Вольт на метр; В/м; V/m; <para />Тип - Прочность диэлектрическая</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.DielectricRigidity.KilovoltPerMeter">
            <summary> Киловольт на метр; кВ/м; kV/m; <para />Тип - Прочность диэлектрическая</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.DielectricRigidity.KilovoltPerMillimeter">
            <summary> Киловольт на миллиметр; кВ/мм; kV/mm; <para />Тип - Прочность диэлектрическая</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.DielectricRigidity.KilovoltPerCentimeter">
            <summary> Киловольт на сантиметр; кВ/см; kV/cm; <para />Тип - Прочность диэлектрическая</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.DielectricRigidity.VoltPerMillimeter">
            <summary> Вольт на миллиметр; В/мм; V/mm; <para />Тип - Прочность диэлектрическая</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.DielectricRigidity.VoltPerCentimeter">
            <summary> Вольт на сантиметр; В/см; V/cm; <para />Тип - Прочность диэлектрическая</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.DielectricRigidity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.DielectricRigidity">
            <summary>Тип единицы измерения (физическая величина) Прочность диэлектрическая</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.PoundPerGallon">
            <summary> Фунт на галлон; фунт/галлон; lb/gallon; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.KilogramPerCubicMillimeter">
            <summary> Килограмм на кубический миллиметр; кг/мм³; kg/mm³; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.PoundPerCubicFoot">
            <summary> Фунт на кубический фут; фунт/фут³; lb/ft³; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.KilogramPerCubicMeter">
            <summary> Килограмм на кубический метр; кг/м³; kg/m³; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.KilogramPerCubicCentimeter">
            <summary> Килограмм на кубический сантиметр; кг/см³; kg/cm³; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.PoundPerCubicYard">
            <summary> Фунт на кубический ярд; фунт/ярд³; lb/yd³; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.KilogramPerLiter">
            <summary> Килограмм на литр; кг/л; kg/L; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.KilogramPerGallon">
            <summary> Килограмм на галлон; кг/галлон; kg/gallon; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.GramPerCubicCentimeter">
            <summary> Грамм на кубический сантиметр; г/см³; g/cm³; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.TonnePerCubicMeter">
            <summary> Тонна на кубический метр; т/м³; t/m³; <para />Тип - Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Density.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Density">
            <summary>Тип единицы измерения (физическая величина) Плотность</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentIntensity.Kiloampere">
            <summary> Килоампер; кА; kA; <para />Тип - Сила тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentIntensity.Ampere">
            <summary> Ампер; А; A; <para />Тип - Сила тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentIntensity.Megaampere">
            <summary> Мегаампер; МА; MA; <para />Тип - Сила тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentIntensity.Microampere">
            <summary> Микроампер; мкА; µA; <para />Тип - Сила тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentIntensity.Milliampere">
            <summary> Миллиампер; мА; mA; <para />Тип - Сила тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentIntensity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.CurrentIntensity">
            <summary>Тип единицы измерения (физическая величина) Сила тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentDensity.AmperesPerSquareMeter">
            <summary> Ампер на квадратный метр; А/м²; A/m²; <para />Тип - Плотность тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentDensity.AmperePerSquareMillimeter">
            <summary> Ампер на квадратный миллиметр; А/мм²; A/mm²; <para />Тип - Плотность тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentDensity.AmperesPerSquareCentimeter">
            <summary> Ампер на квадратный сантиметр; А/см²; A/cm²; <para />Тип - Плотность тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.CurrentDensity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.CurrentDensity">
            <summary>Тип единицы измерения (физическая величина) Плотность тока</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Currency.Copeck">
            <summary> Копейка; коп; cop; <para />Тип - Валюта</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Currency.Rouble">
            <summary> Рубль; руб; RU; <para />Тип - Валюта</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Currency.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Currency">
            <summary>Тип единицы измерения (физическая величина) Валюта</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Capacitance.Nanofarad">
            <summary> Нанофарад; нФ; nF; <para />Тип - Электроёмкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Capacitance.Microfarad">
            <summary> Микрофарад; мкФ; µF; <para />Тип - Электроёмкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Capacitance.Picofarad">
            <summary> Пикофарад; пФ; pF; <para />Тип - Электроёмкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Capacitance.Farad">
            <summary> Фарад; Ф; F; <para />Тип - Электроёмкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Capacitance.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Capacitance">
            <summary>Тип единицы измерения (физическая величина) Электроёмкость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.BreakingStrength.NewtonPerSquareMeter">
            <summary> Ньютон на квадратный метр; Н/м²; N/m²; <para />Тип - Прочность на разрыв</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.BreakingStrength.PoundForcePerSquareInch">
            <summary> Фунт-сила на квадратный дюйм; фунт-сила/дюйм²; lbf/in²; <para />Тип - Прочность на разрыв</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.BreakingStrength.NewtonPerSquareMillimeter">
            <summary> Ньютон на квадратный миллиметр; Н/мм²; N/mm²; <para />Тип - Прочность на разрыв</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.BreakingStrength.DynePerSquareCentimeter">
            <summary> Дина на квадратный сантиметр; дин/см²; dyn/cm²; <para />Тип - Прочность на разрыв</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.BreakingStrength.KilogramForcePerSquareCentimeter">
            <summary> КГС на квадратный сантиметр; кгс/см²; kgf/cm²; <para />Тип - Прочность на разрыв</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.BreakingStrength.KilogramForcePerSquareMillimeter">
            <summary> КГС на квадратный миллиметр; кгс/мм²; kgf/mm²; <para />Тип - Прочность на разрыв</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.BreakingStrength.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.BreakingStrength">
            <summary>Тип единицы измерения (физическая величина) Прочность на разрыв</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.SquareDecimeter">
            <summary> Квадратный дециметр; дм²; dm²; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.SquareYard">
            <summary> Квадратный ярд; ярд²; yd²; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.SquareFoot">
            <summary> Квадратный фут; фут²; ft²; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.SquareInch">
            <summary> Квадратный дюйм; дюйм²; in²; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.SquareMillimeter">
            <summary> Квадратный миллиметр; мм²; mm²; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.SquareKilometer">
            <summary> Квадратный километр; км²; km²; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.Hectare">
            <summary> Гектар; га; ha; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.SquareMeter">
            <summary> Квадратный метр; м²; m²; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.SquareCentimeter">
            <summary> Квадратный сантиметр; см²; cm²; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.Are">
            <summary> Ар; а; a; <para />Тип - Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Area.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Area">
            <summary>Тип единицы измерения (физическая величина) Площадь</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularVelocity.RadianPerSecond">
            <summary> Радиан в секунду; рад/с; rad/s; <para />Тип - Угловая скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularVelocity.DegreePerSecond">
            <summary> Градус в секунду; °/с; deg/s; <para />Тип - Угловая скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularVelocity.RevolutionsPerSecond">
            <summary> Оборот в секунду; об/с; r/s; <para />Тип - Угловая скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularVelocity.RevolutionsPerMinute">
            <summary> Оборот в минуту; об/мин; r/min; <para />Тип - Угловая скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularVelocity.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.AngularVelocity">
            <summary>Тип единицы измерения (физическая величина) Угловая скорость</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularAcceleration.DegreesPerSquareSecond">
            <summary> Градус на секунду в квадрате; °/с²; deg/s²; <para />Тип - Угловое ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularAcceleration.RadiansPerSquareSecond">
            <summary> Радиан на секунду в квадрате; рад/с²; rad/s²; <para />Тип - Угловое ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularAcceleration.RevolutionsPerSquareMinute">
            <summary> Оборотов на минуту в квадрате; об/мин²; r/min²; <para />Тип - Угловое ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularAcceleration.RevolutionsPerSquareSecond">
            <summary> Оборотов на секунду в квадрате; об/с²; r/s²; <para />Тип - Угловое ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AngularAcceleration.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.AngularAcceleration">
            <summary>Тип единицы измерения (физическая величина) Угловое ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Angle.Radian">
            <summary> Радиан; рад; rad; <para />Тип - Угол</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Angle.Degree">
            <summary> Градус; °; deg; <para />Тип - Угол</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Angle.Deg">
            <summary> Град; град; gon; <para />Тип - Угол</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Angle.Revolution">
            <summary> Оборот; оборот; revolution; <para />Тип - Угол</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Angle.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Angle">
            <summary>Тип единицы измерения (физическая величина) Угол</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AmountOfSubstance.Millimole">
            <summary> Миллимоль; ммоль; mmol; <para />Тип - Количество вещества</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AmountOfSubstance.Micromole">
            <summary> Микромоль; мкмоль; mkmol; <para />Тип - Количество вещества</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AmountOfSubstance.Kilomole">
            <summary> Киломоль; кмоль; kmol; <para />Тип - Количество вещества</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AmountOfSubstance.Mole">
            <summary> Моль; моль; mol; <para />Тип - Количество вещества</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AmountOfSubstance.Megamole">
            <summary> Мегамоль; Ммол; Mmol; <para />Тип - Количество вещества</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AmountOfSubstance.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.AmountOfSubstance">
            <summary>Тип единицы измерения (физическая величина) Количество вещества</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnFace.KilogramForcePerCentimeterPerSquareCentimeter">
            <summary> Килограмм-сила на сантиметр на квадратный сантиметр; (кГ/см)/см²; (kgf/cm)/cm²; <para />Тип - Дополнительная жёсткость на грань</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnFace.PoundForcePerInchPerSquareInch">
            <summary> Фунт-сила на дюйм на квадратный дюйм; (фунт-сила/дюйм)/дюйм²; (lbf/in)/in²; <para />Тип - Дополнительная жёсткость на грань</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnFace.NewtonPerMeterPerSquareMeter">
            <summary> Ньютон на метр на квадратный метр; (Н/м)/м²; (N/m)m²; <para />Тип - Дополнительная жёсткость на грань</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnFace.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnFace">
            <summary>Тип единицы измерения (физическая величина) Дополнительная жёсткость на грань</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnEdge.PoundForcePerInchPerInch">
            <summary> Фунт-сила на дюйм на дюйм; (фунт-сила/дюйм)/дюйм; (lbf/in)/in; <para />Тип - Дополнительная жёсткость на ребро</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnEdge.NewtonPerMeterPerMeter">
            <summary> Ньютон на метр на метр; (Н/м)/м; (N/m)/m; <para />Тип - Дополнительная жёсткость на ребро</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnEdge.KilogramForcePerCentimeterPerCentimeter">
            <summary> Килограмм-сила на сантиметр на сантиметр; (кГ/см)/см; (kgf/cm)/cm; <para />Тип - Дополнительная жёсткость на ребро</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnEdge.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.AdditionalStiffnessOnEdge">
            <summary>Тип единицы измерения (физическая величина) Дополнительная жёсткость на ребро</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Acceleration.InchPerSquareSecond">
            <summary> Дюйм на секунду в квадрате; дюйм/c²; In/s²; <para />Тип - Ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Acceleration.MillimeterPerSquareSecond">
            <summary> Миллиметр в секунду в квадрате; мм/с²; mm/s²; <para />Тип - Ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Acceleration.CentimeterPerSquareSecond">
            <summary> Сантиметр на секунду в квадрате; см/с²; sm/s²; <para />Тип - Ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Acceleration.MeterPerSquareSecond">
            <summary> Метр на секунду в квадрате; м/с²; m/s²; <para />Тип - Ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Acceleration.FootPerSquareSecond">
            <summary> Фут в секунду в квадрате; фут/c²; ft/s²; <para />Тип - Ускорение</summary>
        </member>
        <member name="P:TFlex.Model.Units.StandardUnits.Acceleration.Type">
            <summary>Тип единицы измерения (физическая величина)</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits.Acceleration">
            <summary>Тип единицы измерения (физическая величина) Ускорение</summary>
        </member>
        <member name="T:TFlex.Model.Units.StandardUnits">
            <summary>Standard Units</summary>
        </member>
        <member name="M:image3D.GetOwner">
Метод возвращает проекцию или 2D фрагмент в качестве владельца
</member>
        <member name="M:CIDManager.IsIDEnrichment(TFObjectID)">
идектификатор объекта для обогащения
</member>
        <member name="M:CIDManager.CreateIDEnrichment(System.UInt32)">
создание идентификаторов для объектов обогащения
</member>
        <member name="M:CIDContainer.MergeIndexEnrichment(CIDContainer!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
объединить индексы для объектов обогащения, возращает true, если объединение произошло
</member>
        <member name="P:TFlex.Model.Model2D.Harness2D.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Harness2D.GetNodes">
            <summary>Получить информацию об узлах</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Harness2D.OwnerHarness3D">
            <summary>Кабельное изделие, по которому создан Harness2D</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Harness2D">
            <summary>Класс для 2D жгутов (сборочный чертёж кабельного изделия)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.StaticTextControl.Caption">
            <summary>Заголовок</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.StaticTextControl.ControlType">
            <summary>Тип элемента управления</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.StaticTextControl">
            <summary>Статический элемент управления</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.InsertVariableDialog">
            <summary>Класс "Диалог вставки переменной"</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.InsertSymbolDialog">
            <summary>Класс "Диалог вставки символа"</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FolderBrowserDialog">
            <summary>Класс "Диалог открытия каталога"</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FileBrowserDialog">
            <summary>Класс "Диалог открытия файлов"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EditControl.ControlType">
            <summary>Тип элемента управления</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.EditControl">
            <summary>Класс элемента управления "Строка редактирования"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.VariableControl.Variable">
            <summary>Переменная элемента управления</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.VariableControl">
            <summary>Класс элемента управления, связанного с переменной</summary>
            <example>
                <code name="Создание элемента управления VariableControl">
using System;
using System.Windows.Forms;

using TFlex;
using TFlex.Model;
using TFlex.Model.Model2D;
using TFlex.Model.Model3D;
using TFlex.Command;

namespace NewMacroNamespace
{
   public class GrooveCommand : CustomCommand
   {
       public GrooveCommand(TFlex.Command.CommandState cmd)
           : base(cmd)
       {

       }

       TFlex.Model.Document _document;
       TFlex.Model.Model2D.Fragment fragment;

       public override void OnInitialize(InitializeEventArgs e)
       {
           _document = TFlex.Application.ActiveDocument;
           _document.BeginChanges("");

           base.OnInitialize(e);

           UpdateAutomenu();
       }

       public override void OnExit(ExitEventArgs e)
       {
           _document.EndChanges();
       }

       public void InsertGroove(TFlex.Command.CommandState cmd)
       {
           try
           {
               CustomCommand d = new GrooveCommand(cmd);
               d.Run(null);
           }
           catch (Exception e)
           {
               MessageBox.Show(e.StackTrace);
           }
       }

       public InputState State { get; set; }

       public enum InputState
       {
           None,//Ничего не выбрано
           Fragment,//вставка фрагмента
           FragVars,//вызов окна свойств
       };

       public override void OnKeyPressed(TFlex.Command.KeyEventArgs e)
       {
           _document = e.Document;
           switch (e.Code)
           {
               case KeyCode.keyEND:
                   {
                       State = InputState.Fragment;

                       string pathFragment = "&lt;Винты невыпадающие&gt;Винт ГОСТ 10336-80.grb";

                       fragment = new Fragment(_document, pathFragment);
                       FixingVector fv = new FixingVector(_document); //вектор привязки
                       //fv.Name = "FixingVector";

                       FreeNode fn1 = new FreeNode(_document, 10, 160);
                       FreeNode fn2 = new FreeNode(_document, 100, 160);

                       fv.StartNode = fn1;
                       fv.EndNode = fn2;
                       fv.Color = 200;
                       //установить привязку фрагмента по вектору привязки с указанным именем
                       fragment.SetFixingVectorName("FixingVector");

                       _document.ApplyChanges();
                       UpdateAutomenu();
                   }
                   break;

               case (KeyCode.keyF):
                   {
                       State = InputState.FragVars;
                       CreatePropertiesWindow();
                       UpdateAutomenu();
                   }
                   break;

               case KeyCode.keyESCAPE:
                   {
                       State = InputState.None;
                       GoToNextState(null);
                       OnExit(null);
                   }
                   break;
           }
       }

       private PropertiesWindowForm _propertiesControlForm;

       protected void UpdateAutomenu()
       {
           TFlex.Command.Button[] buttonsAutonenu = new TFlex.Command.Button[3];
           buttonsAutonenu[0] = new DefaultButton(DefaultButton.Kind.OK, KeyCode.keyEND,
               State == InputState.Fragment ? TFlex.Command.Button.Style.Checked : TFlex.Command.Button.Style.Default);
           
           buttonsAutonenu[1] = new CustomButton(2, KeyCode.keyF, "", State == InputState.FragVars ? TFlex.Command.Button.Style.Checked : TFlex.Command.Button.Style.Default);          
           buttonsAutonenu[2] = new DefaultButton(State == InputState.None ? DefaultButton.Kind.Exit : DefaultButton.Kind.Cancel);

           Automenu = new Automenu(buttonsAutonenu);
       }

       protected void CreatePropertiesWindow()
       {
           //Инициализируем диалог свойств
           //В нём 2 закладки
           PropertiesWindow propertiesWindow = new PropertiesWindow();
           propertiesWindow.Caption = "Свойства фрагмента";
           VariablesControl control1 = new VariablesControl();//this, _document);
           control1.Visible = true;
           control1.Fragment = fragment;
           control1.Anchor = AnchorStyles.Top | AnchorStyles.Right | AnchorStyles.Left;

           PropertiesWindowForm form1 = new PropertiesWindowForm(control1);
           form1.Caption = "Основные свойства";
           form1.AutoSize = true;
           this._propertiesControlForm = form1;
           propertiesWindow.AppendForm(form1);

           //Тип заголовка в окне свойств
           propertiesWindow.PropertiesHeaderType = PropertiesWindow.HeaderType.OkPreviewCancel;

           propertiesWindow.EnableHeaderButton(PropertiesWindowHeaderButton.OK, false);
           propertiesWindow.EnableHeaderButton(PropertiesWindowHeaderButton.Preview, false);

           this.PropertiesWindow = propertiesWindow;
       }
   };

   public class NewMacroClass
   {
       public static void NewMacro()
       {
           TFlex.Command.CommandState cmd = new TFlex.Command.CommandState();

           GrooveCommand c = new GrooveCommand(cmd);//.InsertGroove(null);
           c.InsertGroove(cmd);
       }
   }

}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Control.Rectangle">
            <summary>Прямоугольник элемента управления</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Control.ControlType">
            <summary>Тип элемента управления</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Control.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Control">
            <summary>Класс элемента управления</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ControlType">
            <summary>Типы элементов управления</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ControlType.StaticText">
            <summary>Статический текст</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ControlType.Edit">
            <summary>Строка редактирования</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ControlType.Unknown">
            <summary>Неизвестный тип</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.BreakSet">
            <summary>Набор разрывов чертёжного вида</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.GetEnumerator">
            <summary>Получить перечиcлитель</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.Enumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.Enumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.SpecialElements.Enumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.Remove(TFlex.Model.ObjectId)">
            <summary>Удалить особый элемент оформления</summary>
            <param name="objectId">Идентификатор объкта</param>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.Remove(TFlex.Model.Model2D.DrawingView.SpecialElement)">
            <summary>Удалить особый элемент оформления</summary>
            <param name="specialElement">Особый элемент</param>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.RemoveAll">
            <summary>Удалить все особые элементы оформления</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.AddModelObject(TFlex.Model.Model2D.Object2D,TFlex.Model.Model2D.DrawingView.SpecialElement.DrawMode)">
            <summary>Добавить особый элемент оформления</summary>
            <param name="object2D">Объект в 2D</param>
            <param name="mode">Режим рисования элемента</param>
            <returns>Особый элемент</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.AddModelObject(TFlex.Model.Model2D.Object2D)">
            <summary>Добавить особый элемент оформления</summary>
            <param name="object2D">Объект в 2D</param>
            <returns>Особый элемент</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SpecialElements.FromModelObject(TFlex.Model.Model2D.Object2D)">
            <summary>Получить элемент оформления по модельному объекту</summary>
            <param name="object2D">Объект в 2D</param>
            <returns>Особый элемент</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.SpecialElements.Count">
            <summary>Количество особых элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.SpecialElements">
            <summary>Коллекция особых элементов оформления, входящих в вид</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.SpecialElement.Mode">
            <summary>Режим рисования элемента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.SpecialElement.ModelObject">
            <summary>Особый элемент оформления</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.SpecialElement.DrawMode.Hide">
            <summary>Элемент должен быть скрыт</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.SpecialElement.DrawMode.DontTrim">
            <summary>Элемент должен быть изображён без обрезки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.SpecialElement.DrawMode.Trim">
            <summary>Элемент должен быть изображён с обрезкой</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.SpecialElement.DrawMode">
            <summary>Режим рисования элемента</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.SpecialElement">
            <summary>Особый элемент оформления, входящий в вид</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.SpecialElements">
            <summary>Получить коллекцию элементов, управляющих отображением 2D объектов в области разрыва на чертёжном виде</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineWaveHeight">
            <summary>Высота волны волнистой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineWaveLength">
            <summary>Длина периода волнистой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineWaveNumber">
            <summary>Количество периодов волнистой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineWaveType">
            <summary>Способ задания волнистой линии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.Breaks.LineWaveTypes.ByWaveLength">
            <summary>Длиной периода волны</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.Breaks.LineWaveTypes.ByWaveNumber">
            <summary>Количеством волн</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.Breaks.LineWaveTypes">
            <summary>Способ задания волнистой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineColor">
            <summary>Цвет линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.UseLineColor">
            <summary>Использовать особый цвет линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineScale">
            <summary>Масштаб штрихов линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineWidth">
            <summary>Толщина линий разрыва</summary>
            <example>
                <code name="Установка толщины линии">
public static void SetLineWidth(ModelObject ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка толщины линии");//Открытие блока изменений документа

   ob.LineWidth = 3;	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineType">
            <summary>Тип линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.BrokenBoundOutline2">
            <summary>Вторая линия изображения, задающая границу для линий разрывов (допускается значение null)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.BrokenBoundOutline1">
            <summary>Первая линия изображения, задающая границу для линий разрывов (допускается значение null)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.BrokenBoundConstruction2">
            <summary>Вторая линия построения, задающая границу для линий разрывов (допускается значение null)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.BrokenBoundConstruction1">
            <summary>Первая линия построения, задающая границу для линий разрывов (допускается значение null)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.Alignment">
            <summary>Способ задания позиций разрывов чертёжного вида, в соответствии с направлением разрывов</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.Metric">
            <summary>Способ задания позиций разрывов чертёжного вида</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.KeepParts">
            <summary>Сохранять части изображения в исходном положении</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.LineExtension">
            <summary>Размер выступания линий разрыва в единицах страницы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.UseLineExtension">
            <summary>Показывать линии разрыва с выступами</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.Gap">
            <summary>Размер разрыва в единицах страницы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.AngleLine">
            <summary>Прямая, задающая направление разрывов (допускается значение null)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.Angle">
            <summary>Угол направления разрывов</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.OriginNode">
            <summary>Базовый узел разрывов (допускается значение null)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.Origin">
            <summary>Базовая точка разрывов</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.Breaks.RemoveAt(System.Int32)">
            <summary>Добавить разрыв</summary>
            <param name="index">Index</param>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.Breaks.RemoveAll">
            <summary>Удалить все разрывы</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.Breaks.AddBreak">
            <summary>Добавить разрыв</summary>
            <returns>Разрыв</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.Breaks.GetEnumerator">
            <summary>Получить перечиcлитель</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.Breaks.Enumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.Breaks.Enumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.Enumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.Breaks.GetAt(System.Int32)">
            <summary>Получить разрыв по индексу</summary>
            <param name="index">Индекс разрыва</param>
            <returns>Рызрыв</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Breaks.Count">
            <summary>Количество разрывов</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.Breaks">
            <summary>Набор разрывов чертёжного вида</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Break.EndNode">
            <summary>Узел, задающий конечную позицию (допускается значение null)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Break.BeginNode">
            <summary>Узел, задающий начальную позицию (допускается значение null)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Break.End">
            <summary>Конечная позиция</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Break.Begin">
            <summary>Начальная позиция</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.Break">
            <summary>Разрыв чертёжного вида</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.BreakPositionsAlignment.Origin">
            <summary>Базовая точка разрывов вида</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.BreakPositionsAlignment.End">
            <summary>Конечная сторона изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.BreakPositionsAlignment.Center">
            <summary>Середина изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.BreakPositionsAlignment.Begin">
            <summary>Начальная сторона изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.BreakPositionsAlignment">
            <summary>Способ задания позиций разрывов чертёжного вида, в соответствии с направлением разрывов</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.BreakPositionsMetric.ModelUnits">
            <summary>В единицах модели</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.BreakPositionsMetric.Percentage">
            <summary>В процентах от размера изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.BreakPositionsMetric">
            <summary>Способ задания позиций разрывов чертёжного вида</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Clipping">
            <summary>Выполнять отсечение изображения по текущему прямоугольнику отсечения (свойство ClippingRectangle)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.ClippingRectangle">
            <summary>Прямоугольная область отсечения в системе координат отображаемой страницы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.IsActive">
            <summary>Вид является активным</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Transformation">
            <summary>Преобразование, применяемое при выводе отображаемой страницы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.ViewSymbol">
            <summary>Объект обозначения вида</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.LeaderNote">
            <summary>Объект надписи обозначения (только для выносного вида)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.ShowConstructions">
            <summary>Показывать линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Visible">
            <summary>Изображение вида показывать</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.OriginY">
            <summary>Координата Y базовой точки на отображаемой странице</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.OriginX">
            <summary>Координата X базовой точки на отображаемой странице</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Y2">
            <summary>Координата Y второй точки привязки. Используется только в режиме привязки по вектору</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.X2">
            <summary>Координата X второй точки привязки. Используется только в режиме привязки по вектору</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Y1">
            <summary>Координата Y первой точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.X1">
            <summary>Координата X первой точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Node2">
            <summary>Второй узел привязки. Используется только в режиме привязки по вектору</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Node1">
            <summary>Первый узел привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Vector">
            <summary>Вектор привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SetVector(TFlex.Model.Model2D.FixingVector,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Установка привязки по вектору и узлам</summary>
            <param name="vector">Вектор привязки на отображамой странице</param>
            <param name="node1">Первый узел на отображающей странице</param>
            <param name="node2">Второй узел на отображающей странице</param>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SetVector(TFlex.Model.Model2D.FixingVector,TFlex.Drawing.Point,TFlex.Drawing.Point)">
            <summary>Установка привязки по вектору и точкам</summary>
            <param name="vector">Вектор привязки на отображаемой странице</param>
            <param name="point1">Первая точка на отображающей странице</param>
            <param name="point2">Вторая точка на отображающей странице</param>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SetPosition(TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Установка привязки по узлу и углу</summary>
            <param name="node">Узел привязки</param>
            <param name="angle">Угол поворота</param>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.SetPosition(System.Double,System.Double,TFlex.Model.Parameter)">
            <summary>Установка привязки по точке и углу</summary>
            <param name="x">Координата X</param>
            <param name="y">Координата Y</param>
            <param name="angle">Угол поворота</param>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Angle">
            <summary>Угол поворота изображения. При установке значения привязка по вектору отменяется</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Scale">
            <summary>Масштаб изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.ViewFixingMode">
            <summary>Режим привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.ShowPage">
            <summary>Отображаемая на виде страница</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.HideBreaksLines">
            <summary>Скрывать линии разрывов</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.DrawingView.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Создание чертёжного вида с изображением заданной страницы</summary>
            <param name="doc">Документ объекта</param>
            <param name="pageToShow">Отображаемая страница</param>
        </member>
        <member name="M:TFlex.Model.Model2D.DrawingView.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="doc">Документ объекта</param>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.FixingMode.Vector">
            <summary>Привязка по вектору</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.FixingMode.NodeAndAngle">
            <summary>Привязка по узлу и углу поворота</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DrawingView.FixingMode.PointAndAngle">
            <summary>Привязка по точке и углу поворота</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView.FixingMode">
            <summary>Способ привязки чертёжного вида</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DrawingView">
            <summary>Класс чертёжного вида</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SimpleViewSymbol.BottomLineOffset">
            <summary>Смещение нижней строки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SimpleViewSymbol.TopLineOffset">
            <summary>Смещение верхней строки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SimpleViewSymbol.OutlineLineWidth">
            <summary>Толщина линий</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SimpleViewSymbol.ShowLine">
            <summary>Показывать линию подчёркивания</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SimpleViewSymbol.BottomNote">
            <summary>Строка текста под линией</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SimpleViewSymbol.TopNote">
            <summary>Строка текста над линией</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SimpleViewSymbol.Node">
            <summary>Узел привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SimpleViewSymbol.SetNode(TFlex.Model.Model2D.Node)">
            <summary>Установка привязки к узлу</summary>
            <param name="node">Узел привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.SimpleViewSymbol.Point">
            <summary>Координаты точки привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SimpleViewSymbol.SetAbsolutePosition(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка привязки в абсолютных коордиеннатах</summary>
            <param name="x">Координата x точки привязки</param>
            <param name="y">Координата y точки привязки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.SimpleViewSymbol.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.SimpleViewSymbol">
            <summary>Класс обозначения вида</summary>
            <example>
                <code name="Вид">
public static void SimpleViewSymbol()//обозначение вида
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   SimpleViewSymbol sv = new SimpleViewSymbol(document);
   FreeNode fn1 = new FreeNode(document, 10, 10);//создание узла
   sv.SetNode(fn1); //привязка вида к узлу
   sv.TopNote = "Вид1";//cтрока текста над линией
   sv.Color = 3;//цвет

   document.EndChanges();//Закрытие блока изменений документа	
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.NoteOffset2">
            <summary>Смещение надписи вдоль полки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.NoteOffset1">
            <summary>Смещение надписи перпендикулярно полке</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.ArrowLineWidth">
            <summary>Толщина линий стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.ArrowSize">
            <summary>Размер стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.ArrowLength">
            <summary>Длина стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.ArrowType">
            <summary>Тип стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.AttachmentType">
            <summary>Тип привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.NotePosition">
            <summary>Положение надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.Note">
            <summary>Надпись</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.Node2">
            <summary>Второй узел привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.Node1">
            <summary>Первый узел привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ArrowViewSymbol.SetNodeAndAngle(TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Установка привязки по узлу и углу</summary>
            <param name="node">Узел вершины стрелки</param>
            <param name="angle">Угол наклона стрелки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ArrowViewSymbol.SetNodes(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Установка привязки к узлам</summary>
            <param name="node1">Первый узел (позиция стрелки)</param>
            <param name="node2">Второй узел (определяет направление стрелки)</param>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.Angle">
            <summary>Угол наклона стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ArrowViewSymbol.Point">
            <summary>Координаты точки привязки стрелки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ArrowViewSymbol.SetAbsolutePosition(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка привязки стрелки по абсолютным координатам</summary>
            <param name="x">Координата x вершины стрелки</param>
            <param name="y">Координата y вершины стрелки</param>
            <param name="angle">Угол наклона линии стрелки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ArrowViewSymbol.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ArrowViewSymbol">
            <summary>Класс обозначения вида по стрелке</summary>
            <example>
                <code name="Вид по стрелке">
public static void ArrowViewSymbol()//обозначение вида по стрелке
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа	
   document.BeginChanges("");//Открытие блока изменений документа

   ArrowViewSymbol avs = new ArrowViewSymbol(document);
   FreeNode fn1 = new FreeNode(document, 10, 30);//создание узла
   FreeNode fn2 = new FreeNode(document, 50, 30);
   avs.SetNodes(fn1, fn2);//привязка к узлам
   avs.Note = "Вид по стрелке";//надпись
   avs.Color = 9;//цвет
   avs.ArrowLength = 50;//длина стрелки

   document.EndChanges();//Закрытие блока изменений документа	
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.ShowDashedLine">
            <summary>Отображать штриховую линию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.Standard">
            <summary>Стандарт обозначения сечения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.DashLengthInBreak">
            <summary>Длина штриха в изломе сечения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.NoteOffsetY">
            <summary>Смещение надписи по оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.NoteOffsetX">
            <summary>Смещение надписи по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.ArrowLineWidth">
            <summary>Толщина линий стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.ArrowType">
            <summary>Тип стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.ArrowSize">
            <summary>Размер стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.ArrowSpace">
            <summary>Отступ по краям штрихов</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.ArrowLength">
            <summary>Длина стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.DashThicknessFactor">
            <summary>Толщина штриха по отношению к основной линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.DashLength">
            <summary>Длина штриха</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.AdjustEndDash">
            <summary>Разрешить настраивать расстояние конечного штриха от контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.AdjustBeginDash">
            <summary>Разрешить настраивать расстояние начального штриха от контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.AdjustDashes">
            <summary>Настраивать расстояние штрихов от контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.ViewDirection">
            <summary>Направление взгляда: true - прямое, false - обратное</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.EndDashDist">
            <summary>Расстояние конечного штриха от контура изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.BeginDashDist">
            <summary>Расстояние начального штриха от контура изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.EndArrowNote">
            <summary>Строка текста над конечной стрелкой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.BeginArrowNote">
            <summary>Строка текста над начальной стрелкой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.Note">
            <summary>Текст надписи</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SectionViewSymbol.SetPoint(System.UInt32,TFlex.Drawing.Point)">
            <summary>Установка абсолютных координат точки</summary>
            <param name="i">Номер точки</param>
            <param name="point">Координаты точки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.Points">
            <summary>Абсолютные координаты точек привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SectionViewSymbol.SetNode(System.UInt32,TFlex.Model.Model2D.Node)">
            <summary>Установка привязки точки к узлу</summary>
            <param name="i">Номер точки</param>
            <param name="node">Узел привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.SectionViewSymbol.Nodes">
            <summary>Узлы привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SectionViewSymbol.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.SectionViewSymbol">
            <summary>Класс обозначения сечения</summary>
            <example>
                <code name="Сечение">
public static void SectionViewSymbol()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("обозначение сечения");//Открытие блока изменений документа

   SectionViewSymbol svs = new SectionViewSymbol(document);
   FreeNode fn1 = new FreeNode(document, 10, 60);//создание узла
   FreeNode fn2 = new FreeNode(document, 50, 60);
   svs.Nodes = new Node[] {fn1, fn2};
   svs.Note = "обозначение сечения";//надпись
   svs.Color = 12;//цвет
   svs.ArrowLength = 50;//длина стрелки

   document.EndChanges();	//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.SectionViewStandard">
            <summary>Стандарт изображения сечения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SectionViewStandard.ISO">
            <summary>ЕСКД</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SectionViewStandard.ANSI">
            <summary>ANSI</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SectionViewStandard.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ArrowViewSymbolAttachmentType">
            <summary>Тип привязки стрелки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ArrowViewSymbolAttachmentType.PointAndAngle">
            <summary>По точке и углу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ArrowViewSymbolAttachmentType.NodeAndAngle">
            <summary>По узлу и углу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ArrowViewSymbolAttachmentType.TwoNodes">
            <summary>По двум узлам</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ArrowViewSymbolNotePosition">
            <summary>Положение надписи относительно стрелки обозначения вида</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ArrowViewSymbolNotePosition.Right">
            <summary>Справа от стрелки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ArrowViewSymbolNotePosition.Left">
            <summary>Слева от стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ViewSymbol.FontStyle">
            <summary>Стиль шрифта текста для получения или установки его параметров</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ViewSymbol.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ViewSymbol.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ViewSymbol.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ViewSymbol.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ViewSymbol.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ViewSymbol.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ViewSymbol">
            <summary>Базовый класс обозначения вида, разреза или сечения</summary>
        </member>
        <member name="M:TFlex.FilePreview.ZoomAll">
            <summary>Приблизить изображение</summary>
        </member>
        <member name="P:TFlex.FilePreview.AutoPreview">
            <summary>Просматривать сразу при выборе файла</summary>
        </member>
        <member name="P:TFlex.FilePreview.FilePath">
            <summary>Путь к файлу</summary>
        </member>
        <member name="M:TFlex.FilePreview.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.FilePreview.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.FilePreview">
            <summary>Элемент управления для просмотра 2D документов</summary>
        </member>
        <member name="P:TFlex.Model.DOCsReferenceDatabase.Description">
            <summary>Описание справочника</summary>
        </member>
        <member name="P:TFlex.Model.DOCsReferenceDatabase.Title">
            <summary>Название справочника</summary>
        </member>
        <member name="P:TFlex.Model.DOCsReferenceDatabase.UpdateMode">
            <summary>Режим обновления</summary>
        </member>
        <member name="P:TFlex.Model.DOCsReferenceDatabase.SubType">
            <summary>Подтип базы данных</summary>
        </member>
        <member name="M:TFlex.Model.DOCsReferenceDatabase.#ctor(TFlex.Model.Document,System.String,System.String)">
            <summary>Конструктор для создания базы данных по ссылке(справочник T-FLEX DOCs)</summary>
            <param name="document">Документ базы данных</param>
            <param name="title">Название справочника</param>
            <param name="description">Описание справочника</param>
        </member>
        <member name="T:TFlex.Model.DOCsReferenceDatabase">
            <summary>Класс для создания базы данных по ссылке(справочник T-FLEX DOCs)</summary>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetColumnOrder">
            <summary>Получить упорядоченные индексы столбцов</summary>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.SetRealValueFormat(System.Int32,System.Int32,System.Int32)">
            <summary>Установить формат вещественного значения</summary>
            <param name="column">Номер столбца</param>
            <param name="total">Общая длина</param>
            <param name="decimal">После запятой</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.InsertTextColumn(System.Int32,System.String,System.Int32)">
            <summary>Вставить текстовый столбец с указанием длины текста</summary>
            <param name="index">Номер столбца</param>
            <param name="name">Название столбца</param>
            <param name="length">Количество символов</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.InsertColumn(System.Int32,TFlex.Model.DatabaseColumnType,System.String)">
            <summary>Вставить столбец</summary>
            <param name="index">Номер столбца</param>
            <param name="type">Тип столбца базы данных</param>
            <param name="name">Название столбца</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetIntValue(System.Int32,System.Int32)">
            <summary>Получить целое значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.SetIntValue(System.Int32,System.Int32,System.Int32)">
            <summary>Установить целое значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
            <param name="value">Целое значение</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetTextValue(System.Int32,System.Int32)">
            <summary>Получить текстовое значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.SetTextValue(System.Int32,System.Int32,System.String)">
            <summary>Установить текстовое значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
            <param name="value">Текстовое значение</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetRealValue(System.Int32,System.Int32)">
            <summary>Получить вещественное значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.SetRealValue(System.Int32,System.Int32,System.Double)">
            <summary>Установить вещественное значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
            <param name="value">Вещественное значение</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.DeleteContents">
            <summary>Удалить все строки</summary>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.InsertRow(System.Int32)">
            <summary>Вставить строку</summary>
            <param name="index">Номер строки</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.DeleteRow(System.Int32)">
            <summary>Удалить строку</summary>
            <param name="index">Номер строки</param>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.AppendRow">
            <summary>Добавить строку</summary>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetColumnComment(System.Int32)">
            <summary>Получить комментарий столбца</summary>
            <param name="index">Номер столбца</param>
            <returns>Комментарий столбца</returns>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetColumnName(System.Int32)">
            <summary>Получить имя столбца</summary>
            <param name="index">Номер столбца</param>
            <returns>Имя столбца</returns>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetColumnType(System.Int32)">
            <summary>Получить тип столбца</summary>
            <param name="index">Номер столбца</param>
            <returns>Тип столбца</returns>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetRecordCount">
            <summary>Получить количество строк</summary>
            <returns>Количество строк</returns>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.GetColumnCount">
            <summary>Получить количество столбцов</summary>
            <returns>Количество столбцов</returns>
        </member>
        <member name="P:TFlex.Model.InternalDatabase.SubType">
            <summary>Подтип базы данных</summary>
        </member>
        <member name="M:TFlex.Model.InternalDatabase.#ctor(TFlex.Model.Document,System.String)">
            <summary>Конструктор</summary>
            <param name="document">Документ базы данных</param>
            <param name="name">Имя базы данных</param>
        </member>
        <member name="T:TFlex.Model.InternalDatabase">
            <summary>Внутренняя база данных</summary>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.ConvertToInternal(TFlex.Model.ReferenceDatabase)">
            <summary>Конвертировать базу данных во внутреннюю базу данных</summary>
            <param name="sourceDatabase">База данных по ссылке</param>
            <returns>Внутренняя база данных</returns>
            <remarks>При конвертации исходный объект разрушается</remarks>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.GetIntValue(System.Int32,System.Int32)">
            <summary>Получить целое значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.GetTextValue(System.Int32,System.Int32)">
            <summary>Получить текстовое значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.GetRealValue(System.Int32,System.Int32)">
            <summary>Получить вещественное значение в таблице</summary>
            <param name="column">Номер столбца</param>
            <param name="row">Номер строки</param>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.GetColumnComment(System.Int32)">
            <summary>Получить комментарий столбца</summary>
            <param name="index">Номер столбца</param>
            <returns>Комментарий столбца</returns>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.GetColumnName(System.Int32)">
            <summary>Получить имя столбца</summary>
            <param name="index">Номер столбца</param>
            <returns>Имя столбца</returns>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.GetRecordCount">
            <summary>Получить количество строк</summary>
            <returns>Количество строк</returns>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.GetColumnCount">
            <summary>Получить количество столбцов</summary>
            <returns>Количество столбцов</returns>
        </member>
        <member name="P:TFlex.Model.ReferenceDatabase.Delimiter">
            <summary>Тип разделителя</summary>
        </member>
        <member name="P:TFlex.Model.ReferenceDatabase.UseDosEncoding">
            <summary>Кодировка DOS</summary>
        </member>
        <member name="P:TFlex.Model.ReferenceDatabase.UpdateMode">
            <summary>Режим обновления</summary>
        </member>
        <member name="P:TFlex.Model.ReferenceDatabase.TableName">
            <summary>Имя таблицы базы данных по ссылке</summary>
        </member>
        <member name="P:TFlex.Model.ReferenceDatabase.FileLink">
            <summary>Путь к файлу базы данных по ссылке</summary>
        </member>
        <member name="P:TFlex.Model.ReferenceDatabase.SubType">
            <summary>Подтип базы данных</summary>
        </member>
        <member name="M:TFlex.Model.ReferenceDatabase.#ctor(TFlex.Model.Document,TFlex.Model.FileLink,System.String)">
            <summary>Конструктор для создания базы данных по ссылке(файл)</summary>
            <param name="document">Документ базы данных</param>
            <param name="fileLink">Ссылка на файл базы данных</param>
            <param name="tableName">Имя таблицы</param>
        </member>
        <member name="T:TFlex.Model.ReferenceDatabase">
            <summary>Класс для создания базы данных по ссылке(файл)</summary>
        </member>
        <member name="P:TFlex.Model.Database.Name">
            <summary>Имя базы данных</summary>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Database.SubType">
            <summary>Тип базы данных</summary>
        </member>
        <member name="P:TFlex.Model.Database.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="T:TFlex.Model.Database">
            <summary>Класс базы данных</summary>
        </member>
        <member name="T:TFlex.Model.DatabaseColumnType">
            <summary>Тип столбца базы данных</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseColumnType.DBUnknown">
            <summary>Неизвестный тип</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseColumnType.DBText">
            <summary>Строковый</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseColumnType.DBReal">
            <summary>Вещественный</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseColumnType.DBInt">
            <summary>Целый</summary>
        </member>
        <member name="T:TFlex.Model.DelimiterType">
            <summary>Тип разделителя</summary>
        </member>
        <member name="F:Semicolon">
            <summary>Точка с запятой</summary>
        </member>
        <member name="F:Tab">
            <summary>Табуляция</summary>
        </member>
        <member name="F:Auto">
            <summary>Авто</summary>
        </member>
        <member name="T:TFlex.Model.DatabaseUpdateMode">
            <summary>Режим обновления</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseUpdateMode.Manually">
            <summary>Вручную</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseUpdateMode.FullRegenerate">
            <summary>Полный пересчёт</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseUpdateMode.Auto">
            <summary>Автоматически</summary>
        </member>
        <member name="T:TFlex.Model.DatabaseType">
            <summary>Тип базы данных</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseType.DOCsReference">
            <summary>База данных по ссылке на справочник T-FLEX DOCs</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseType.Internal">
            <summary>Внутренняя база данных</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseType.Reference">
            <summary>База данных по ссылке на файл</summary>
        </member>
        <member name="F:TFlex.Model.DatabaseType.Undefined">
            <summary>Неопределённый тип</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.ValueControl">
            <summary>Ссылка на контрол</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.DefaultValue">
            <summary>Значение из статуса</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.DefaultText">
            <summary>Текст для значения из статуса</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.Increment">
            <summary>Приращение</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.MaxValue">
            <summary>Максимальное значение</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.MinValue">
            <summary>Минимальное значение</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.RealValue">
            <summary>Действительное значение переменной</summary>
        </member>
        <member name="P:TFlex.VariableUpDown.VariableCreationEnabled">
            <summary>Создание переменной с указанным именем разрешено</summary>
        </member>
        <member name="M:TFlex.VariableUpDown.ApplyValue">
            <summary>Принять значение</summary>
        </member>
        <member name="M:TFlex.VariableUpDown.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.VariableUpDown">
            <summary>Элемент управления NumericUpDown, позволяющий создавать переменную модели с указанным именем</summary>
            <remarks>Если в поле введен текст при потере фокуса элемента управления отображается диалог, в котором предлагается создать переменную с указанным именем</remarks>
        </member>
        <member name="P:TFlex.VariableTextBox.Value">
            <summary>Значение переменной</summary>
        </member>
        <member name="P:TFlex.VariableTextBox.RealValue">
            <summary>Действительное значение переменной</summary>
        </member>
        <member name="P:TFlex.VariableTextBox.VariableCreationEnabled">
            <summary>Создание переменной с указанным именем разрешено</summary>
        </member>
        <member name="M:TFlex.VariableTextBox.ApplyValue">
            <summary>Принять значение</summary>
        </member>
        <member name="M:TFlex.VariableTextBox.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.VariableTextBox">
            <summary>Элемент управления TextBox, позволяющий создавать переменную модели с указанным именем</summary>
            <remarks>Если в поле введен текст при потере фокуса элемента управления отображается диалог, в котором предлагается создать переменную с указанным именем</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.SmoothGraphLaw.UseEndTangent">
            <summary>Использование значения касательной в конце</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SmoothGraphLaw.UseBeginTangent">
            <summary>Использование значения касательной в начале</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SmoothGraphLaw.SetTangents(System.Double,System.Double)">
            <summary>Установка значений производных в начале и в конце</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SmoothGraphLaw.GetTangents(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получение значений производных в начале и в конце</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SmoothGraphLaw.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ объекта</param>
        </member>
        <member name="T:TFlex.Model.Model2D.SmoothGraphLaw">
            <summary>Зависимость F(x), заданная набором точек со сглаживанием</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.TableGraphLaw.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ объекта</param>
        </member>
        <member name="T:TFlex.Model.Model2D.TableGraphLaw">
            <summary>Зависимость F(x), заданная набором точек</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.Load(System.String,TFlex.Model.Document)">
            <summary>Создание графика из файла *.tflaw</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.Save(System.String)">
            <summary>Сохранение в отдельный файл *.tflaw</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.IsSmooth">
            <summary>График является сглаженным</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.Color">
            <summary>Цвет (для отображения в диалоге)</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.ArgumentToValueVisualRatio">
            <summary>Визуальное соотношение единиц аргумента и функции (для отображения в диалоге)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.UseWorkingArea">
            <summary>Использование области допустимых значений</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.WorkingArea">
            <summary>Область допустимых значений</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.UseLogarArgScale">
            <summary>Использование логарифмической шкалы аргумента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.ViewOnly">
            <summary>Редактирование в диалоге запрещено</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.NodesBounds">
            <summary>Ограничивающий прямоугольник узлов</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.GetValue(System.Double)">
            <summary>Получение значения по аргументу</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.RemoveAllNodes">
            <summary>Удаление всех узлов</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.RemoveNode(System.UInt32)">
            <summary>Удаление узла</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.InsertNode(TFlex.Drawing.Point)">
            <summary>Вставка узла в соответствии со значением аргумента</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.SetNode(System.UInt32,TFlex.Drawing.Point)">
            <summary>Установка узла по номеру</summary>
            <remarks>Узел изменяется только в том случае, если заданное значение
аргумента соответствует порядку значений аргументов остальных узлов (по возрастанию)</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.GetNode(System.UInt32)">
            <summary>Получение узла по номеру</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.Nodes">
            <summary>Точки графика</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.NodeCount">
            <summary>Количество точек графика</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.GraphLaw.GetRepeatCount(System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Количество повторений графика в положительном и отрицательном направлениях</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.ArgumentTolerance">
            <summary>Наименьшее допустимое расстояние между соседними узлами по значению аргумента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.ValueName">
            <summary>Название функции (F) в форме: [имя], [буквы_обозначения], [единицы]</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.ArgumentName">
            <summary>Название аргумента (x) в форме: [имя], [буквы_обозначения], [единицы]</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.SpecialName">
            <summary>Специальное имя</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.GraphLaw.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.GraphLaw">
            <summary>Зависимость F(x), заданная графиком</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsBase.Datum">
            <summary>Значение базы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsBase.SubType">
            <summary>Значение подтипа объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FormlimitsBase.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FormlimitsBase">
            <summary>Класс обозначения базы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.Datum3">
            <summary>База 3</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.Datum2">
            <summary>База 2</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.Datum1">
            <summary>База 1</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceType">
            <summary>Тип допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.ShowLeader">
            <summary>Показывать выносную линию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.CompoundTolerance">
            <summary>Составной допуск</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.IsTurned">
            <summary>Повернуть обозначение</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.ShowDimValue">
            <summary>Показывать номинальное значение размера допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.TextAfter">
            <summary>Строка после значения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.SettingMethod">
            <summary>Тип простановки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.DimValue">
            <summary>Значение размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.Expression">
            <summary>Тип выражения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.PrecisionClass">
            <summary>Класс точности (3-16)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.Value">
            <summary>Значение допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsSymbol.SubType">
            <summary>Значение подтипа объекта </summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FormlimitsSymbol.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ объекта</param>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.CompoundToleranceType.Second">
            <summary>Второй</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.CompoundToleranceType.First">
            <summary>Первый</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.CompoundToleranceType.None">
            <summary>Нет</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FormlimitsSymbol.CompoundToleranceType">
            <summary>Типы составного допуска</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.SettingMethodType.Auto">
            <summary>Авто</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.SettingMethodType.Manual">
            <summary>Вручную</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FormlimitsSymbol.SettingMethodType">
            <summary>Способы задания</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ExpressionType.Tdiv2">
            <summary>T/2</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ExpressionType.T">
            <summary>T</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ExpressionType.SphereD">
            <summary>Сфера D</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ExpressionType.SphereR">
            <summary>Сфера R</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ExpressionType.D">
            <summary>D</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ExpressionType.R">
            <summary>R</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ExpressionType.None">
            <summary>не указано</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FormlimitsSymbol.ExpressionType">
            <summary>Типы выражения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.AngularityAndFlatness">
            <summary>Наклон и плоскостность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.PerpendicularityAndFlatness">
            <summary>Перпендикулярность и плоскостность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.ParallelismAndFlatness">
            <summary>Параллельность и плоскостность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.SurfaceForm">
            <summary>Форма поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.ProfileForm">
            <summary>Форма профиля</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.TotalAxialRunOut">
            <summary>Полное торцевое биение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.TotalRadialRunOut">
            <summary>Полное радиальное биение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.DirectionBeating">
            <summary>Биение в заданном направлении</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.AxialRunOut">
            <summary>Торцевое биение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.RadialRunOut">
            <summary>Радиальное биение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.AxisCrossing">
            <summary>Пересечение осей</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Positional">
            <summary>Позиционный</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Symmetry">
            <summary>Симметричность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Coaxiality">
            <summary>Соосность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Angularity">
            <summary>Наклон</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Perpendecularity">
            <summary>Перпендикулярность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Parallelism">
            <summary>Параллельность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.SectionProfile">
            <summary>Профиль продольного сечения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Cylindricity">
            <summary>Цилиндричность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Circularity">
            <summary>Круглость</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Flatness">
            <summary>Плоскостность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes.Straightness">
            <summary>Прямолинейность</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FormlimitsSymbol.ToleranceTypes">
            <summary>Типы допуска</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FormlimitsSymbol">
            <summary>Класс обозначения допуска</summary>
            <example>
                <code name="Допуск">
public static void FormlimitsSymbol()
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Допуск");//Открытие блока изменений документа

   FormlimitsSymbol formlimitsSymbol = new FormlimitsSymbol(document);
   FreeNode fn1 = new FreeNode(document, 300, 640); //создание узла		 	
   FreeNode fn2 = new FreeNode(document, 350, 670);		 	

   ConstructionOutline constructionOutline = new ConstructionOutline(document, fn1, fn2);
   formlimitsSymbol.SetOutline(constructionOutline, true, 0);
   formlimitsSymbol.ToleranceType = FormlimitsSymbol.ToleranceTypes.Circularity;//Тип допуска - Круглость
   formlimitsSymbol.Datum1 = "А";//База 1
   formlimitsSymbol.Datum2 = "Б";//База 2

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.AltFitView">
            <summary>Вид простановки дополнительной посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.AltFit">
            <summary>Проставлять дополнительную посадку</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.FitView">
            <summary>Вид простановки посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Fit">
            <summary>Проставлять посадку</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Placement">
            <summary>Номер точки привязки на таблице (от 0 до 7)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Dimension">
            <summary>Размер, к которому привязан данный объект</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Formlimits.SetDimension(TFlex.Model.Model2D.Dimension)">
            <summary>Установка привязки к размеру</summary>
            <param name="dim">Размер привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Leader">
            <summary>Линия-выноска, которая связана с данным объектом</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Formlimits.SetLeader(TFlex.Model.Model2D.FormlimitsLeader)">
            <summary>Установить привязку к линии-выноске</summary>
            <param name="leader">Линия-выноска</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.FormlimitsObj">
            <summary>Другой объект обозначения допуска, к которому привязан данный объект</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Formlimits.SetFormlimitsObj(TFlex.Model.Model2D.Formlimits)">
            <summary>Установка привязки к другому обозначению допуска</summary>
            <param name="obj">Обозначение допуска привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Point">
            <summary>Абсолютные координаты точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Y">
            <summary>Координата Y точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.X">
            <summary>Координата X точки привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Formlimits.SetPoint(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка абсолютных координат точки привязки</summary>
            <param name="x">Координата X</param>
            <param name="y">Координата Y</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Node">
            <summary>Узел привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Formlimits.SetNode(TFlex.Model.Model2D.Node)">
            <summary>Установка привязки к узлу</summary>
            <param name="node">Узел привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Outline">
            <summary>Линия изображения, к которой привязана стрелка</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Formlimits.SetOutline(TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к отрезку</summary>
            <param name="line">Отрезок привязки</param>
            <param name="isOnEnd">Значение true указывает, что привязка выполняется к концу отрезка, false - к началу</param>
            <param name="offset">Смещение точки привязки по отрезку относительно выбранного конца отрезка</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Construction">
            <summary>Линия построения, к которой привязана стрелка</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Formlimits.SetConstruction(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к прямой</summary>
            <param name="line">Прямая</param>
            <param name="node">Узел на прямой</param>
            <param name="offset">Смещение точки привязки по прямой относительно узла</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.LineWidth">
            <summary>Толщина линий объекта</summary>
            <example>
                <code name="Установка толщины линии">
public static void SetLineWidth(ModelObject ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка толщины линии");//Открытие блока изменений документа

   ob.LineWidth = 3;	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.FontStyle">
            <summary>Стиль шрифта текста для получения или установки его параметров</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.Page">
            <summary>Cтраница, на которой размещается объект</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.AutoNamingDatum">
            <summary>Автоматическое именование базы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.SubType">
            <summary>Значение подтипа объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Formlimits.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Formlimits.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ объекта</param>
        </member>
        <member name="F:TFlex.Model.Model2D.Formlimits.FitViewType.Diagonal">
            <summary>Диагональная дробь</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Formlimits.FitViewType.Horizontal">
            <summary>Горизонтальная дробь</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Formlimits.FitViewType">
            <summary>Типы расположения посадки</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Formlimits">
            <summary>Базовый класс допусков формы, расположения и обозначения базы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.StartOffsetIsHoriz">
            <summary>Направление первого смещения: true - по горизонтали, false - по вертикали</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Offsets">
            <summary>Набор смещений, определяющих положение углов линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Position">
            <summary>Номер точки привязки на таблице допуска (от 0 до 7)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.FormlimitsObj">
            <summary>Обозначение допуска, к которому привязан объект</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FormlimitsLeader.SetFormlimitsObj(TFlex.Model.Model2D.Formlimits,System.Int32)">
            <summary>Установка привязки к обозначению допуска</summary>
            <param name="obj">Обозначение допуска привязки</param>
            <param name="position">Номер точки привязки к таблице допуска (от 0 до 7)</param>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Point">
            <summary>Абсолютные координаты точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Y">
            <summary>Координата Y точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.X">
            <summary>Координата X точки привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FormlimitsLeader.SetPoint(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка абсолютных координат точки привязки</summary>
            <param name="x">Координата x</param>
            <param name="y">Координата y</param>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Dimension">
            <summary>Размер, к которому привязана стрелка</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FormlimitsLeader.SetDimension(TFlex.Model.Model2D.Dimension,System.Boolean)">
            <summary>Установка привязки к размеру</summary>
            <param name="dim">Размер привязки</param>
            <param name="isOnEnd">Значение true указывает, что привязка выполняется к концу размера, false - к началу</param>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Outline">
            <summary>Линия изображения, к которой привязана стрелка</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FormlimitsLeader.SetOutline(TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к отрезку</summary>
            <param name="line">Отрезок привязки</param>
            <param name="isOnEnd">Значение true указывает, что привязка выполняется к концу отрезка, false - к началу</param>
            <param name="offset">Смещение точки привязки по отрезку относительно выбранного конца отрезка</param>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Construction">
            <summary>Линия построения, к которой привязана стрелка</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FormlimitsLeader.SetConstruction(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к прямой</summary>
            <param name="line">Прямая</param>
            <param name="node">Узел на прямой</param>
            <param name="offset">Смещение точки привязки по прямой относительно узла</param>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.FontStyle">
            <summary>Стиль шрифта текста для получения или установки его параметров</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.LineWidth">
            <summary>Толщина линий</summary>
            <example>
                <code name="Установка толщины линии">
public static void SetLineWidth(ModelObject ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка толщины линии");//Открытие блока изменений документа

   ob.LineWidth = 3;	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.ArrowSize">
            <summary>Размер стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.ArrowType">
            <summary>Тип стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FormlimitsLeader.Page">
            <summary>Cтраница, на которой размещается объект</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.FormlimitsLeader.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.FormlimitsLeader">
            <summary>Класс линии-выноски обозначения допуска формы</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FormlimitsType">
            <summary>Подтипы объектов</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsType.FormlimitsBase">
            <summary>Обозначение базы (класс FormlimitsBase)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsType.FormlimitsSymbol">
            <summary>Допуск формы или расположения (класс FormlimitsSymbol)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FormlimitsType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:TFlex.Model.ModelConfigurations.RenameConfiguration(System.String,System.String)">
            <summary>Переименовать конфигурацию</summary>
            <param name="OldName">Старое имя</param>
            <param name="NewName">Новое имя</param>
        </member>
        <member name="M:TFlex.Model.ModelConfigurations.GetConfigurationName(System.Int32)">
            <summary>Получение имени конфигурации с номером Index</summary>
            <param name="Index">Индекс конфигурации</param>
        </member>
        <member name="M:TFlex.Model.ModelConfigurations.LoadConfigurationVariables(System.String)">
            <summary>Загрузка переменных в текущую модель из конфигурации с именем Name</summary>
            <param name="Name">Имя конфигурации</param>
        </member>
        <member name="M:TFlex.Model.ModelConfigurations.LoadConfigurationSolids(System.String)">
            <summary>Загрузка тел в текущую модель из конфигурации с именем Name</summary>
            <param name="Name">Имя конфигурации</param>
        </member>
        <member name="M:TFlex.Model.ModelConfigurations.DeleteConfiguration(System.String)">
            <summary>Удаление конфигурации с именем Name</summary>
            <param name="Name">Имя конфигурации</param>
        </member>
        <member name="M:TFlex.Model.ModelConfigurations.CreateConfiguration(System.String)">
            <summary>Создание конфигурации с именем Name с текущим набором значений переменных</summary>
            <param name="Name">Имя конфигурации</param>
        </member>
        <member name="M:TFlex.Model.ModelConfigurations.GetConfigurationWithCurrentValues">
            <summary>Проверка существования конфигурации с текущим набором значений переменных.</summary>
        </member>
        <member name="M:TFlex.Model.ModelConfigurations.GetConfiguration(System.Int32)">
            <summary>Получить конфигурацию модели с заданным номером</summary>
            <param name="index">Номер конфигурации</param>
        </member>
        <member name="P:TFlex.Model.ModelConfigurations.ConfigurationCount">
            <summary>Количество конфигураций модели</summary>
        </member>
        <member name="T:TFlex.Model.ModelConfigurations">
            <summary>Контейнер конфигураций модели</summary>
        </member>
        <member name="P:TFlex.Model.ModelConfiguration.Name">
            <summary>Имя конфигурации</summary>
        </member>
        <member name="T:TFlex.Model.ModelConfiguration">
            <summary>Конфигурация модели</summary>
        </member>
        <member name="P:TFlex.VariablesControl.ProductVersion">
            <summary>Версия визульного элемента управления</summary>
        </member>
        <member name="P:TFlex.VariablesControl.ProductName">
            <summary>Название визуального элемента управления</summary>
        </member>
        <member name="P:TFlex.VariablesControl.Fragment">
            <summary>Фрагмент, для которого выполняется редактирование внешних переменных</summary>
        </member>
        <member name="M:TFlex.VariablesControl.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.VariablesControl">
            <summary>Класс визуального элемента управления, позволяющего редактировать внешние переменные фрагмента в окне приложения</summary>
        </member>
        <member name="M:NURBSBuilder.GenerateSplineGeometryOld(RGPlatform.Geometry.Context*,TFDocument!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,SplineImageData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.unique_ptr&lt;NURBSCurve,std.default_delete&lt;NURBSCurve&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary> Общий метод создания геометрии сплайна (до 31 версии)</summary>
            <param name="iContext"> Контекст </param>
            <param name="iVersion"> Версия объекта </param>
            <param name="iDoc"> Документ </param>
            <param name="iToModelSpaceScale"> Масштаб отображение из модельного пространства в RGP </param>
            <param name="iData"> Постановка задачи </param>
            <param name="oResult"> Результат </param>
            <param name="iScaleInterval"> Масштабировать интервал </param>
        </member>
        <member name="M:NURBSBuilder.GenerateSplineGeometry31(RGPlatform.Geometry.Context*,System.Int32,TFDocument!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,SplineImageData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Общий метод создания геометрии сплайна начиная с 31 версии(</summary>
            <param name="iContext"> Контекст </param>
            <param name="iVersion"> Версия объекта </param>
            <param name="iDoc"> Документ </param>
            <param name="iToModelSpaceScale"> Масштаб отображение из модельного пространства в RGP </param>
            <param name="iData"> Постановка задачи </param>
            <param name="oResult"> Результат </param>
        </member>
        <member name="M:NURBSBuilder.GenerateSplineGeometryCommon(RGPlatform.Geometry.Context*,System.Int32,TFDocument!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double,SplineImageData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Общий метод создания геометрии сплайна</summary>
            <param name="iContext"> Контекст </param>
            <param name="iVersion"> Версия объекта </param>
            <param name="iDoc"> Документ </param>
            <param name="iToModelSpaceScale"> Масштаб отображение из модельного пространства в RGP </param>
            <param name="iData"> Постановка задачи </param>
            <param name="oResult"> Результат </param>
        </member>
        <member name="M:SplineImageData.PreprocessData(TFDocument!System.Runtime.CompilerServices.IsConst*)">
            <summary> Обработать даныне перед построением сплайна </summary>
            <summary> 1. Метод анализирует повторяющиеся точки. На данном уровне проверки, точка может быть помечена как InvalidPoint в случае повторения. </summary>
        </member>
        <member name="M:SplineImageData.DetachNode(CTFObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,TFDocument!System.Runtime.CompilerServices.IsConst*)">
            <summary> Отвязаться от узла (обновляет координаты из узла) </summary>
            <param name="srcDoc"> Документ </param>
            <param name="setNodeCoords"> false, если не требуется обновление координат </param>
            <returns> true - если удалось получить узел, обновить координаты и отвязаться от него </returns>
        </member>
        <member name="M:SplineImageData.GetUpperConstrainedDerivativeOrder">
            <summary> Получить макс. указанную степень производной в точке сплайна </summary>
        </member>
        <member name="M:SplineImageData.HasTolerantPoints">
            <summary> Признак наличия толерантных точек</summary>
        </member>
        <member name="M:SplineImageData.GetCounter">
            <summary> Получить значение счетчика уникальных точек</summary>
        </member>
        <member name="M:SplineImageData.TrimOnInterval(RGPlatform.Geometry.Context*,TrimSplineData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TrimSplineResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить сплайн путем вырезания сплайна на интервала</summary>
        </member>
        <member name="M:SplineImageData.GetErrorMessage(RGK.Common.Result)">
            <summary> Получить строку для ошибки</summary>
        </member>
        <member name="M:SplineImageData.ConvertToExtension(RGPlatform.Geometry.Context*,std.optional&lt;System.Int32&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конвертировать вырезаемый интервал в отрицательно расширение</summary>
        </member>
        <member name="M:SplineImageData.GetExtendData(System.UInt64)">
            <summary> Получить расширение в конце кривой</summary>
        </member>
        <member name="M:SplineImageData.GetHighExtension">
            <summary> Получить расширение в конце кривой</summary>
        </member>
        <member name="M:SplineImageData.GetLowExtension">
            <summary> Получить расширение в начале кривой</summary>
        </member>
        <member name="M:SplineImageData.SetHighExtension(ExtendData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Установить расширение в конце кривой</summary>
        </member>
        <member name="M:SplineImageData.SetLowExtension(ExtendData*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Установить расширение в начале кривой</summary>
        </member>
        <member name="M:SplineImageData.GetCroppedCurve(RGPlatform.Geometry.Context*)">
            <summary> Получить требуемую кривую с учетом: "-" расщирения, "+" расширения, интервала </summary>
        </member>
        <member name="M:SplineImageData.IsPositiveExtended(RGPlatform.Geometry.Context*)">
            <summary> Кривая расширена c одного или с двух концов</summary>
        </member>
        <member name="M:SplineImageData.IsExtended(RGPlatform.Geometry.Context*)">
            <summary> Кривая расширена или укорочена. Результирующая кривая получается путем расширения или укорачивания исходной кривой.</summary>
            <summary> Расширенная кривая не может быть обрезана. т.к. в результате обрезки такой кривой корректируются параметры расширения</summary>
        </member>
        <member name="M:SplineImageData.IsCropped(RGPlatform.Geometry.Context*)">
            <summary> Кривая укорочена или расширенна, результирующая кривая вырезается или получается расширением из исходной кривой </summary>
            <summary> Интервал обрезанной кривой не равен интервалу исходной кривой. Вырезание может задаваться "-" расширением или интервалом который храниться, расширение всегда задается "+" расширением </summary>
        </member>
        <member name="M:SplineImageData.Parameterise(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
            <summary> Определить параметр точки, лежащей на кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPointInPageCs"> Точка на кривой с учётом масштаба страницы </param>
            <param name="ioParam"> Найденный параметр на кривой (на входе может содержать начальное приближение) </param>
            <param name="iUseGuess"> Использовать ли начальное приближение </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:SplineImageData.GetEndPoint(RGPlatform.Geometry.Context*,System.Double)">
            <summary> Получить точку конца кривой с учетом обрезки </summary>
        </member>
        <member name="M:SplineImageData.GetStartPoint(RGPlatform.Geometry.Context*,System.Double)">
            <summary> Получить точку начала кривой, с учетом обрезки </summary>
        </member>
        <member name="M:SplineImageData.BuildMiddlePoints(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Построить список промежуточных точек </summary>
        </member>
        <member name="M:SplineImageData.SetCurve(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Установить кривую </summary>
        </member>
        <member name="M:SplineImageData.GetCurve">
            <summary> Получить кривую </summary>
        </member>
        <member name="M:SplineImageData.Init(System.Int32,System.Int32,std.vector&lt;TFModelPoint,std.allocator&lt;TFModelPoint&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
            <summary>  Инициализация по устаревшим данным </summary>
            <param name="iSpline"> Сплайн </param>
        </member>
        <member name="M:SplineImageData.Init(std.shared_ptr&lt;RGPlatform.Geometry.Polyline2D&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>  Инициализация по полилинии </summary>
            <param name="iPolyLine"> Полилилиния </param>
        </member>
        <member name="M:SplineImageData.Init(std.shared_ptr&lt;RGPlatform.Geometry.BaseSpline2D&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>  Инициализация по сплайну </summary>
            <param name="iSpline"> Сплайн </param>
        </member>
        <member name="M:SplineImageData.Init(LegacySplineImageData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>  Инициализация по представлению доставшемуся в наследство </summary>
            <param name="iSpline"> Сплайн </param>
        </member>
        <member name="M:SplineImageData.Create(SPLINE_IMAGE*,System.Double,std.shared_ptr&lt;RGPlatform.Geometry.Spline2D&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;SplineImageData&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>  Создать по сплайну </summary>
            <param name="iSpline"> Сплайн </param>
        </member>
        <member name="M:SplineImageData.FillDerivativeData(RGPlatform.Geometry.Context*,TFDocument!System.Runtime.CompilerServices.IsConst*,System.Double)">
            <summary> Получить данные о диф. геометрии кривой в кэше </summary>
            <param name="iContext"> Контекст </param>
            <param name="iDoc"> Документ </param>
            <param name="iToModelSpaceScale"> Масштаб </param>
        </member>
        <member name="M:SplineImageData.BuildSpline(RGPlatform.Geometry.Context*,System.Int32,TFDocument!System.Runtime.CompilerServices.IsConst*,System.Int32,System.Double)">
            <summary>  Создать сплайн и запомнить в кэше </summary>
            <param name="iContext"> Контекст </param>
            <param name="iVersion"> Версия объекта </param>
            <param name="iDoc"> Документ </param>
            <param name="iToModelSpaceScale"> Масштаб </param>
        </member>
        <member name="M:SplineImageData.Copy">
            <summary>  Создать копию</summary>
        </member>
        <member name="M:SplineImageData.IsEndTangentConstrained">
            <summary> Первая производная ограничена в последней точке </summary>
            <returns> True или False</returns>
        </member>
        <member name="M:SplineImageData.IsStartTangentConstrained">
            <summary> Первая производная ограничена в первой точке </summary>
            <returns> True или False</returns>
        </member>
        <member name="M:SplineImageData.GetEndDerivative(TFModelDirection*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить направление первой производной в последней точке </summary>
            <param name="ioDirection"> Направление первой производной</param>
        </member>
        <member name="M:SplineImageData.GetStartDerivative(TFModelDirection*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить направление первой производной в первой точке </summary>
            <param name="ioDirection"> Направление первой производной</param>
        </member>
        <member name="M:SplineImageData.SetCloseContiniouslyRequired(System.Boolean)">
            <summary> Установить флаг дополнительных модификаций контрольного полигона для замкнутой кривой </summary>
            <param name="iValue"> Флаг </param>
        </member>
        <member name="M:SplineImageData.CloseContiniouslyRequired">
            <summary> Флаг, если TRUE тогда необходимы дополнительные модификации контрольного полигона для замкнутой кривой </summary>
            <returns> True или False</returns>
        </member>
        <member name="M:SplineImageData.SetKnotMethod(&lt;unknown type&gt;)">
            <summary>Устновить метод генерации узлов, для режима полилинии метод фикисрован - по длине </summary>
        </member>
        <member name="M:SplineImageData.GetKnotMethod">
            <summary>Метод построения узлов и параметров точек для интерполяции </summary>
            <returns>Метод</returns>
        </member>
        <member name="M:SplineImageData.GetKnots">
            <summary> Получить список узлов сплайна, может быть не задан.</summary>
        </member>
        <member name="M:SplineImageData.GetKnots(std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить список узлов сплайна, может быть не задан.</summary>
            <param name="oKnots"> Узлы </param>
        </member>
        <member name="M:SplineImageData.GetRawBackFirstDerivatives(TFDocument!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double!System.Runtime.CompilerServices.IsConst,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить обратные производные в масштабе RGP</summary>
        </member>
        <member name="M:SplineImageData.GetRawDerivatives(TFDocument!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить производные в масштабе RGP</summary>
        </member>
        <member name="M:SplineImageData.GetWeights(std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить веса точек</summary>
        </member>
        <member name="M:SplineImageData.GetTFPoints(TFDocument!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,TFPoints*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить точки в масштабе модели</summary>
        </member>
        <member name="M:SplineImageData.GetRawPoints(TFDocument!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить точки в масштабе RGP</summary>
            <summary> Метод предназначен для получения точек, которые будут передаваться в RGP для построения сплайна</summary>
            <summary> Точки порпускаются методом SplineImagePoint::Skip()</summary>
        </member>
        <member name="M:SplineImageData.GetRawPoint(System.UInt64,TFDocument!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double)">
            <summary> Получить точку в масштабе RGP</summary>
        </member>
        <member name="M:SplineImageData.GetSuppressedPointsCount">
            <summary> Получить количество подавленных точке</summary>
            <param name="oIndices"> Индексы </param>
        </member>
        <member name="M:SplineImageData.GetTolerantPointsCount(System.Boolean)">
            <summary> Получить количество толерантных точке</summary>
            <param name="iAllowSuppressed"> Учитывать подавленные точки (считать или не считать одновременно толерантные и подавденные точки) </param>
            <param name="oIndices"> Количество </param>
        </member>
        <member name="M:SplineImageData.GetSuppressedPointIndeces">
            <summary> Получить индексы подавленных точке</summary>
            <param name="oIndices"> Индексы </param>
        </member>
        <member name="M:SplineImageData.GetTolerantPointIndeces(System.Boolean)">
            <summary> Получить индексы толерантных точке</summary>
            <param name="iAllowSuppressed"> Учитывать подавленные точки </param>
            <param name="oIndices"> Индексы </param>
        </member>
        <member name="M:SplineImageData.SetPoints(std.vector&lt;TFModelPoint,std.allocator&lt;TFModelPoint&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;RealParameter,std.allocator&lt;RealParameter&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить точки на основе координат и весов</summary>
            <param name="iPoints"> Точки </param>
            <param name="iWeights"> Веса </param>
        </member>
        <member name="M:SplineImageData.SetPoints(std.vector&lt;TFModelPoint,std.allocator&lt;TFModelPoint&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить точки на основе координат и весов</summary>
            <param name="iPoints"> Точки </param>
            <param name="iWeights"> Веса </param>
        </member>
        <member name="M:SplineImageData.IsKnotsFixed">
            <summary> Узлы сплайна фиксированы</summary>
        </member>
        <member name="M:SplineImageData.SetKnotsFixed(System.Boolean)">
            <summary> Установить признак фиксации узлов</summary>
            <param name="iFixed"> Флаг </param>
        </member>
        <member name="M:SplineImageData.IsRepairIntermediateVersion">
            <summary> Исправление интервалов обрезки промежуточных версий </summary>
        </member>
        <member name="M:SplineImageData.SetRepairIntermediateVersion(System.Boolean)">
            <summary> Исправление интервалов обрезки промежуточных версий </summary>
        </member>
        <member name="M:SplineImageData.IsCreateExtendRequired">
            <summary> Требуетя создать данные для укорачивания кривой на основе интервала обрезки </summary>
        </member>
        <member name="M:SplineImageData.SetCreateExtendRequired(System.Boolean)">
            <summary> Требуетя создать данные для укорачивания кривой на основе интервала обрезки </summary>
        </member>
        <member name="M:SplineImageData.SetForceSourceInterval(RGK.Geometry.Interval)">
            <summary> Установить интервал исходной кривой</summary>
            <param name="iInterval"> Интервал </param>
        </member>
        <member name="M:SplineImageData.GetCroppedInterval">
            <summary> Получить вырезаемый интервал</summary>
        </member>
        <member name="M:SplineImageData.SetCroppedInterval(RGK.Geometry.Interval)">
            <summary> Установить вырезаемый интервал</summary>
            <param name="iInterval"> Вырезаемый интервал </param>
        </member>
        <member name="M:SplineImageData.SetCroppedInterval(System.Double,System.Double)">
            <summary> Установить вырезаемый интервал</summary>
            <param name="iStart"> Параметр начала вырезаемого сегмента </param>
            <param name="iStart"> Параметр конца вырезаемого сегмента </param>
        </member>
        <member name="M:SplineImageData.GetCroppedEnd">
            <summary> Получить конечный параметр сплайна</summary>
            <summary> Метод вычисляет(!!!) конечный параметр на результрующей кривой. С учетом расширения и укорачивания</summary>
        </member>
        <member name="M:SplineImageData.GetCroppedStart">
            <summary> Получить начальный параметр сплайна</summary>
            <summary> Метод вычисляет(!!!) начальный параметр на результрующей кривой. С учетом расширения и укорачивания</summary>
        </member>
        <member name="M:SplineImageData.SetCroppedEnd(System.Double)">
            <summary> Установить конечный параметр обрезки сплайна на интервале</summary>
            <summary> Метод кооректирует параметры укорачивания или создает его. Если сплайн использует интервал, тогда правит границы интервала</summary>
            <param name="iStart"> Параметр конца вырезаемого сегмента </param>
        </member>
        <member name="M:SplineImageData.SetCroppedStart(System.Double)">
            <summary> Установить начальный параметр обрезки сплайна на интервале</summary>
            <summary> Метод кооректирует параметры укорачивания или создает его. Если сплайн использует интервал, тогда правит границы интервала</summary>
            <param name="iStart"> Параметр начала вырезаемого сегмента </param>
        </member>
        <member name="M:SplineImageData.SetKnots(std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить список узлов для сплайна</summary>
            <param name="iKnots"> Список узлов </param>
        </member>
        <member name="M:SplineImageData.SetParametes(std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить параметры интерполяции для точек</summary>
            <param name="iParameters"> Список параметров </param>
        </member>
        <member name="M:SplineImageData.GetParameters">
            <summary>Получить параметры интерполяции для точек</summary>
        </member>
        <member name="M:SplineImageData.SetTolerance(RealParameter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить точность аппроксимации толерантных точек</summary>
            <param name="iTolerance"> Точность </param>
        </member>
        <member name="M:SplineImageData.ResetPointsData">
            <summary>Удалить всю информацию о сплайне, за исключением, типа построения (_periodic, _interpolation)</summary>
        </member>
        <member name="M:SplineImageData.SetTolerant(System.UInt64,System.Boolean)">
            <summary>Установить признак толерантной точки по индексу</summary>
            <param name="id"> Индекс точки </param>
            <param name="iValue"> Значение толерантности </param>
        </member>
        <member name="M:SplineImageData.SetDegree(System.Int32)">
            <summary> Установить степень сплайна (может игнорироваться)</summary>
        </member>
        <member name="M:SplineImageData.EvaluateBaseDegree(System.Boolean,System.UInt64)">
            <summary> Основное правило вычисления степени</summary>
        </member>
        <member name="M:SplineImageData.EvaluateDegree(System.Boolean,System.Boolean,System.Boolean,System.UInt64,System.UInt64,&lt;unknown type&gt;)">
            <summary> Получить cтепень сплайна с учетом ограничения, метод реализует общее правило вычисления степени</summary>
        </member>
        <member name="T:SplineImageData.EvaluateDegreeData">
            <summary> Постановка задачи для авто вычисления степени</summary>
        </member>
        <member name="M:SplineImageData.GetRawDegree">
            <summary> Получить значение поля для cтепени</summary>
        </member>
        <member name="M:SplineImageData.GetDegree">
            <summary> Получить cтепень сплайна с учетом ограничения</summary>
        </member>
        <member name="M:SplineImageData.PointsCount">
            <summary> Получить количество точек сплайна</summary>
        </member>
        <member name="M:SplineImageData.IsUnderEdit">
            <summary> Признак редактирования сплайна</summary>
            <param name="iValue">Флаг </param>
        </member>
        <member name="M:SplineImageData.SetUnderEdit(System.Boolean)">
            <summary> Установить признак редактирования сплайна</summary>
            <param name="iValue">Флаг </param>
        </member>
        <member name="M:SplineImageData.SetInterpolation(System.Boolean)">
            <summary> Установить признак интерполяционого сплайна</summary>
            <param name="iValue">Флаг </param>
        </member>
        <member name="M:SplineImageData.IsApproximation">
            <summary> Признак аппроксимации</summary>
        </member>
        <member name="M:SplineImageData.IsControlPolygon">
            <summary> Признак построения сплайна по контрольному полигону</summary>
        </member>
        <member name="M:SplineImageData.IsInterpolation">
            <summary> Признак интерполяционого сплайна</summary>
        </member>
        <member name="M:SplineImageData.IsClosed(RGPlatform.Geometry.Context*,TFDocument*,System.Double)">
            <summary> Проверка того, что начальная и конечная точка совпадают </summary>
        </member>
        <member name="M:SplineImageData.IsDegreeConstrained">
            <summary> Признак ограничения степени пользователем, это значит что пользователь задал собственное значение степени</summary>
        </member>
        <member name="M:SplineImageData.GetPointIndexByUID(System.UInt32)">
            <summary> Получить модельную точку сплайна по идентификатору</summary>
        </member>
        <member name="M:SplineImageData.GetModelPoint(System.UInt64)">
            <summary> Получить модельную точку сплайна по индексу</summary>
        </member>
        <member name="M:SplineImageData.SetModelPoint(System.UInt64,TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Установить модельную точку сплайна по индексу</summary>
        </member>
        <member name="T:SplineImageData.KnotMethod">
Метод построения набора узлов/параметров
</member>
        <member name="F:TrimSplineResult._newUIDs">
            <summary> Новые идентификаторы </summary>
        </member>
        <member name="F:TrimSplineResult._removedUIDs">
            <summary> Удаленные идентификаторы </summary>
        </member>
        <member name="F:TrimSplineResult._remainedUIDs">
            <summary> Оставшиеся идентификаторы </summary>
        </member>
        <member name="F:TrimSplineResult._newIndex">
            <summary> Индексы точек, в которые записаны точки которых ранее не было в сплайне</summary>
        </member>
        <member name="F:TrimSplineResult._oldRemovedIndex">
            <summary> Множество удаленных индексов</summary>
        </member>
        <member name="F:TrimSplineResult._oldToNewIndex">
            <summary> Отображение старых индексов в новые</summary>
        </member>
        <member name="F:TrimSplineResult._interval">
            <summary> Интервал новой кривой</summary>
        </member>
        <member name="T:TrimSplineResult">
            <summary> Результат вырезания сплайна</summary>
        </member>
        <member name="F:TrimSplineData._toModelSpaceScale">
            <summary> Масштаб модели</summary>
        </member>
        <member name="F:TrimSplineData._pageScale">
            <summary> Масштаб страницы</summary>
        </member>
        <member name="F:TrimSplineData._nPage">
            <summary> Номер страницы </summary>
        </member>
        <member name="F:TrimSplineData._doc">
            <summary> Документ</summary>
        </member>
        <member name="F:TrimSplineData._tolerance">
            <summary> Точность</summary>
        </member>
        <member name="F:TrimSplineData._interval">
            <summary> Вырезаемый интервал</summary>
        </member>
        <member name="T:TrimSplineData">
            <summary> Постановка задачи для вырезания сплайна</summary>
        </member>
        <member name="M:SplineImagePoint.DetachNode(CTFObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,TFDocument!System.Runtime.CompilerServices.IsConst*)">
            <summary> Отвязаться от узла (обновляет координаты из узла) </summary>
            <param name="srcDoc"> Документ </param>
            <param name="setNodeCoords"> false, если не требуется обновление координат </param>
            <returns> true - если удалось получить узел, обновить координаты и отвязаться от него </returns>
        </member>
        <member name="M:SplineImagePoint.GetUpperConstrainedDerivativeOrder">
            <summary> Получить макс. указанную степень производной в точке сплайна </summary>
        </member>
        <member name="M:SplineImagePoint.SetSecondDerivative(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary> Установить вторую производную в точке, поднимает только флаг ограничения кривизны</summary>
            <param name="iSecondDerivative"> Документ </param>
        </member>
        <member name="M:SplineImagePoint.SetForwardDirection(TFModelDirection!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary> Установить первую производную в точке, поднимает только флаг ограничения первой производной</summary>
            <param name="iSecondDerivative"> Документ </param>
        </member>
        <member name="M:SplineImagePoint.IsTolerant">
            <summary> Признак толерантной точки</summary>
        </member>
        <member name="M:SplineImagePoint.GetImageUID">
            <summary> Получить уникальный идентификатор точки</summary>
        </member>
        <member name="M:SplineImagePoint.GetUID">
            <summary> Получить уникальный идентификатор точки</summary>
        </member>
        <member name="M:SplineImagePoint.GetSecondDerivative">
            <summary> Получить вторую производную в точке</summary>
        </member>
        <member name="M:SplineImagePoint.DerivativeDataExist">
            <summary> Блок производных инициализирован</summary>
        </member>
        <member name="M:SplineImagePoint.GetFirstDerivativeUsed">
            <summary> Признак использования производных в точке</summary>
        </member>
        <member name="M:SplineImagePoint.GetAnyDerivativeUsed">
            <summary> Признак использования производных в точке</summary>
        </member>
        <member name="M:SplineImagePoint.InitDerivativeData">
            <summary>Инициализировать блок производных (если они не инициализирован)</summary>
        </member>
        <member name="M:SplineImagePoint.IsDerivativesConstraint">
            <summary>Есть огранчиения производных</summary>
        </member>
        <member name="M:SplineImagePoint.IsThirdDerivativeConstraint">
            <summary>Третья производная ограничена</summary>
        </member>
        <member name="M:SplineImagePoint.IsCurvatureConstraint">
            <summary>Кривизна ограничена</summary>
        </member>
        <member name="M:SplineImagePoint.IsFirstDerivativeConstraint">
            <summary>Первая производная ограничена</summary>
        </member>
        <member name="M:SplineImagePoint.Skip">
            <summary> Точка подавлена, Не допустимое состояние в результате интерактивного ввода, +не допустимое состояние после препроцессинга </summary>
        </member>
        <member name="M:SplineImagePoint.IsSuppressed">
            <summary> Признак подавления точки </summary>
        </member>
        <member name="M:SplineImagePoint.GetPoint(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить точку в системе координат страницы </summary>
            <param name="iDoc"> Документ </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в системе координат страницы </returns>
        </member>
        <member name="F:Torsion">
Кручение
</member>
        <member name="F:Tolerance">
Точка интерполяции
</member>
        <member name="F:Curvature">
Ограничена кривизна
</member>
        <member name="F:FirstDerivativeBackAngle">
Ограничен вектор угла производной в обратном направлении
</member>
        <member name="F:FirstDerivativeBackMagnitude">
Ограничена длинна производной в обратном направлении
</member>
        <member name="F:FirstDerivative">
ограничена первая производная в направлении движениия сплайна
</member>
        <member name="F:CoordinateY">
Ограничение по координате Y,
</member>
        <member name="F:CoordinateX">
Ограничение по координате X
</member>
        <member name="T:SplineImagePoint.PointConstrains">
Ограничения интерполяции в точке сплайна
</member>
        <member name="T:SplineImagePoint.PointState">
Состояние создания точки
</member>
        <member name="M:ExtendData.IsPositive(RGPlatform.Geometry.Context*)">
            <summary> Признак наличия положительного расширения _values &gt; eps </summary>
        </member>
        <member name="M:ExtendData.CheckExtend(RGPlatform.Geometry.Context*)">
            <summary> Признак наличия укорачивания или расширения |_values| &gt; eps </summary>
        </member>
        <member name="F:AbsoluteParameter">
По параметру
</member>
        <member name="F:ArcLengthDistance">
По длине
</member>
        <member name="F:NotRequested">
Параметр не требуется, так как расширение на конце кривой не выполняется
</member>
        <member name="T:ExtendData.ValueType">
Способ интерпретации параметра расширения
</member>
        <member name="F:Arc">
По дуге окружности
</member>
        <member name="F:Natural">
Натуральный
</member>
        <member name="F:Reflective">
Отражением
</member>
        <member name="F:Soft">
Непрерывный по кривизне
</member>
        <member name="T:ExtendData.Shape">
Способ расширения
</member>
        <member name="T:ExtendData">
Параметры расширения сплайн-кривой на концах
</member>
        <member name="F:RGPlatform.Geometry.Spline2D._rgkNURBS">
RGK-NURBS 3D-кривая
</member>
        <member name="M:RGPlatform.Geometry.Spline2D.CallRGKFunction( RGK.Geometry.NURBSCurve::*(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced),RGPlatform.Geometry.Context*,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Методы без аргументов
</member>
        <member name="T:RGPlatform.Geometry.Spline2D.CallRGKFunction0Type">
Шаблоны, описывающие код, делегирующий вызовы методов класса Spline2D одноимённым методам класса RGK::Geometry::NURBSCurve
</member>
        <member name="M:RGPlatform.Geometry.Spline2D._ConvertRGKParamToRGP(RGPlatform.Geometry.Context*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конвертировать RGK-параметр на соответствующей RGK-кривой (см. ConvertToRGK) в RGP-параметр.
- iContext - контекст геометрии
- iRGKParam - RGK-параметр
- iRGPParam - RGP-параметр
</member>
        <member name="M:RGPlatform.Geometry.Spline2D.FindSelfIntersections(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Curve2DSelfIntersectionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Curve2DIntersectionReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Найти самопересечения кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iData"> Данные для пересечения </param>
            <param name="oReport"> Результат поиска самопересечений </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.GetCharPointsCount(RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.CharPointType)">
            <summary> Получить количество характеристических точек указанного типа </summary>
            <param name="iType"> Тип характеристической точки </param>
            <returns> Количество характеристических точек </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.GetCharPointsCount">
            <summary> Получить количество характеристических точек </summary>
            <returns> Количество характеристических точек </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.GetCharPoint(System.UInt64)">
            <summary> Получить характеристическую точку </summary>
            <param name="iIndex"> Индекс характеристической точки </param>
            <returns> Характеристическая точка </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.DetectG1DiscontinuityPoint(System.Double,System.Double)">
            <summary> Определение наличия точки разрыва непрерывности по G1 </summary>
            <param name="iParam"> Параметр точки на кривой, для которой проводится анализ </param>
            <param name="iTolerance"> Точность вычислений </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.#ctor">
            <summary> Конструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.CharPoint.GetCharPointType">
            <summary> Получить тип характеристической точки </summary>
            <returns> Тип характеристической точки </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.CharPoint.GetPoint">
            <summary> Получить точку на кривой </summary>
            <returns> Точка на кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.CharPoint.GetParameter">
            <summary> Получить параметр на кривой </summary>
            <returns> Параметр на кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.CharPoint.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CharPointsReport.CharPoint.#ctor(System.Double,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.CharPointType)">
            <summary> Конструктор </summary>
            <param name="iParameter"> Параметр на кривой </param>
            <param name="iPoint"> Точка на кривой </param>
            <param name="iType"> Тип характеристической точки </param>
        </member>
        <member name="D:RGPlatform.Geometry.Spline2D.CharPointsReport.CharPoint.CharPointType">
Тип характеристической точки
</member>
        <member name="T:RGPlatform.Geometry.Spline2D.CharPointsReport.CharPoint">
            <summary> Структура для хранения параметров характеристической точки </summary>
        </member>
        <member name="T:RGPlatform.Geometry.Spline2D.CharPointsReport">
            <summary> Отчёт по результатам поиска характеристических точек на двумерной сплайн-кривой </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.FindArea(RGPlatform.Geometry.Context*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить площадь которую огрничивает кривая </summary>
            <param name="iTolerance"> Точность вычисления </param>
            <param name="oArea"> Площадь </param>
            <param name="oHasArea"> Признак наличия площади </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.Evaluate(RGPlatform.Geometry.Context*,System.Double,System.UInt32,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить координаты точки и все производные по параметру кривой. Пакетный расчёт производных. </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iU"> Параметр на кривой, в котором вычисляются производные </param>
            <param name="iMaxDerivOrder"> Максимальный порядок рассчитываемых производных </param>
            <param name="oDerivatives"> Значения вычисленных производных </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.Evaluate(RGPlatform.Geometry.Context*,System.Double,System.UInt32,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить значение производной (заданного порядка) кривой по заданному параметру </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iU"> Параметр на кривой, в котором вычисляется производная </param>
            <param name="iDerivOrder"> Порядок производной (&gt;=0) </param>
            <param name="oDerivative"> Значение вычисленной производной </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.FindNearestPoint(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить параметр точки на кривой, ближайшей к передаваемой точке </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, для которой ищется ближайшая точка на кривой </param>
            <param name="iTolerance"> Точность, с которой ищется ближайшая точка </param>
            <param name="oParam"> Найденный параметр ближайшей точки на кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.Parameterise(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
            <summary> Определить параметр точки, лежащей на кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка на кривой </param>
            <param name="ioParam"> Найденный параметр на кривой (на входе может содержать начальное приближение) </param>
            <param name="iUseGuess"> Использовать ли начальное приближение </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.ConvertToPolyline(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,RGPlatform.Geometry.Polyline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Адаптивный алгоритм получения полилинии.</summary>
            <remarks> Точки добавляются к уже имеющимся в ioPolyline. </remarks>
            <param name="iRGKContext"> Контекст RGK </param>
            <param name="iInterval"> Интервал, на котором выполняется расчёт полилинии </param>
            <param name="iScale"> Условный масштаб преобразования в единицы измерения устройства</param>
            <param name="ioPolyline"> Результирующая полилиния</param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.ConvertToPolyline(RGK.Common.Context*,System.Double,RGPlatform.Geometry.Polyline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Адаптивный алгоритм получения полилинии</summary>
            <remarks> Точки добавляются к уже имеющимся в ioPolyline. </remarks>
            <param name="iRGKContext"> Контекст RGK </param>
            <param name="iScale"> Условный масштаб преобразования в единицы измерения устройства</param>
            <param name="oPolyline"> Результирующая полилиния</param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.OutputPoints(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Curve2DGeometry.FacetParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Адаптивный алгоритм расчёта точек на кривой с учётом параметров точности </summary>
            <remarks> Точки добавляются к уже имеющимся в ioPoints, ioParams. </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iInterval"> Интервал, на котором выполняется расчёт точек </param>
            <param name="iOptions"> Параметры разбиения </param>
            <param name="oPoints"> Массив насчитанных точек </param>
            <param name="oParams"> Массив параметров, в которых насчитаны точки </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.ClampCurve(RGPlatform.Geometry.Context*,System.Boolean,System.Boolean,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Преобразование несжатой (unclamped) кривой в сжатую (clamped) </summary>
            <remarks> Для обработки обоих концов оба входных флага надо выставить в true. </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iFromLeft"> Обработка левой части кривой </param>
            <param name="iFromRight"> Обработка правой части кривой </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.UnclampCurve(RGPlatform.Geometry.Context*,System.Boolean,System.Boolean,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Преобразование сжатой (clamped) кривой в несжатую (unclamped) </summary>
            <remarks> Для обработки обоих концов оба входных флага надо выставить в true. </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iFromLeft"> Обработка левой части кривой </param>
            <param name="iFromRight"> Обработка правой части кривой </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.MakeBezier(RGPlatform.Geometry.Context*,System.Boolean,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конвертация двумерной сплайн-кривой в кривую Безье </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iType"> true - RGP  тип, false - Parasolid </param>
            <param name="oControlPolygon"> Контрольный полигон безье кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.MakeBezier(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конвертация двумерной сплайн-кривой в кривую Безье </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.Reverse(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Изменение порядка обхода узлов </summary>
Метод создаёт новую двумерную сплайн-кривую с противоположным порядком обхода узлов
<param name="iContext"> Контекст геометрии </param><param name="oResultCurve"> Созданная двумерная сплайн-кривая </param><returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns></member>
        <member name="M:RGPlatform.Geometry.Spline2D.ReduceDegree(RGPlatform.Geometry.Context*,System.Double!System.Runtime.CompilerServices.IsConst,System.Int32,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Понижение степени сплайна </summary>
Создать новую двумерную сплайн-кривую, понизив степень существующей двумерной сплайн-кривой
<param name="iContext"> Контекст геометрии </param><param name="iTolerance"> Передаваемая точность </param><param name="iTimes"> Порядок понижения степени </param><param name="oResultCurve"> Созданная двумерная сплайн-кривая </param><returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns></member>
        <member name="M:RGPlatform.Geometry.Spline2D.ElevateDegree(RGPlatform.Geometry.Context*,System.Int32,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Повышение степени сплайна </summary>
Создать новую двумерную сплайн-кривую, повысив степень существующей двумерной сплайн-кривой
<param name="iContext"> Контекст геометрии </param><param name="iTimes">Порядок повышения степени</param><param name="oResultCurve"> Созданная двумерная сплайн-кривая </param><returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns></member>
        <member name="M:RGPlatform.Geometry.Spline2D.RemoveKnots(RGPlatform.Geometry.Context*,System.Double,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать новую двумерную сплайн-кривую, удалив все возможные узлы </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iTolerance"> Погрешность, оценивается как iTolerance=dw_min/(1+|P|_max) </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.ShiftKnots(RGPlatform.Geometry.Context*,System.Double,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать новую двумерную сплайн-кривую, добавив к значениям узлов одно и то же число </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.NormalizeKnots(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать новую двумерную сплайн-кривую, перепараметризовав существующую с границами [0, 1] </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.Reparametrization(RGPlatform.Geometry.Context*,System.Double,System.Double,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать новую двумерную сплайн-кривую, перепараметризовав существующую </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iMin"> Новое значение нижней границы параметра </param>
            <param name="iMax"> Новое значение верхней границы параметра </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.InsertMultipleKnots(RGPlatform.Geometry.Context*,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Вставка набора уникальных узлов с заданными кратностями </summary>
            <param name="iContext"> Контекст вычисления </param>
            <param name="iInsertingKnots"> Набор узлов для вставки </param>
            <param name="iMultiplicities"> Кратности вставляемых узлов </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.RefineKnots(RGPlatform.Geometry.Context*,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать новую двумерную сплайн-кривую, заменяя вектор узловых значений новыми </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iKnots"> Новый вектор узловых значений (должен содержать существующий вектор узлов) </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.ModifyWeight(RGPlatform.Geometry.Context*,System.Int32,System.Double,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать новую двумерную сплайн-кривую, изменив вес одной управляющей точки </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iIndex"> Индекс управляющей точки</param>
            <param name="iWeight"> Новое значение веса </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.ModifyControlPoint(RGPlatform.Geometry.Context*,System.Int32,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать новую двумерную сплайн-кривую, изменив значение одной управляющей точки </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iIndex"> Индекс управляющей точки </param>
            <param name="iPoint"> Новое значение управляющей точки </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.IsRightClamped(RGPlatform.Geometry.Context*)">
            <summary> Проверить, является ли кривая зажатой (clamped) справа </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> true - является, false - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.IsLeftClamped(RGPlatform.Geometry.Context*)">
            <summary> Проверить, является ли кривая зажатой (clamped) слева </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> true - является, false - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetWeights">
            <summary> Получить массив весов </summary>
            <returns> Массив весов </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetControlPoints(std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить массив управляющих точек </summary>
            <param name="oControlPoints"> Массив управляющих точек </param>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetKnots">
            <summary> Получить массив узлов </summary>
            <returns> Массив узлов </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetKnot(System.Int32)">
            <summary> Получить узел с указанным индексом </summary>
            <param name="iIndex"> Индекс узла </param>
            <returns> Узел с указанным индексом </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetNumberOfKnots">
            <summary> Получить количество узловых значений </summary>
            <returns> Количество узловых значений </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetDegree">
            <summary> Получить степень сплайн-кривой </summary>
            <returns> Степень сплайн-кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetWeight(System.Int32)">
            <summary> Получить вес управляющей точки с указанным индексом </summary>
            <param name="iIndex"> Индекс точки </param>
            <returns> Вес точки с указанным индексом </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetControlPoint(System.Int32,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить управляющую точку с указанным индексом </summary>
            <param name="iIndex"> Индекс точки </param>
            <param name="oPoint"> Управляющая точка с указанным индексом </param>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetNumberOfPoints">
            <summary> Получить количество управляющих точек </summary>
            <returns> Количество управляющих точек </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.IsNonRational">
            <summary> Определить, является ли кривая нерациональной </summary>
            <returns>
                <para> - true - кривая нерациональная </para>
                <para> - false - кривая рациональная </para>
            </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.IsBezier">
            <summary> Определить, является ли кривая кривой Безье </summary>
            <returns>
                <para> - true - кривая является кривой Безье </para>
                <para> - false - кривая не является кривой Безье </para>
            </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.IsPeriodic">
            <summary> Определить, является ли кривая периодической </summary>
            <returns>
                <para> - true - кривая периодическая </para>
                <para> - false - кривая непериодическая </para>
            </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CreateBezier(RGPlatform.Geometry.Context*,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать кривую Безье </summary>
Метод создаёт кривую Безье с весами равными 1.0
<param name="iContext"> Контекст геометрии </param><param name="iPoints"> Массив управляющих точек кривой </param><param name="iDegree"> Степень кривой </param><param name="oResultCurve"> Созданная кривая Безье </param><returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns></member>
        <member name="M:RGPlatform.Geometry.Spline2D.CreateBezier(RGPlatform.Geometry.Context*,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать кривую Безье </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoints"> Массив управляющих точек кривой </param>
            <param name="iWeights"> Массив весов </param>
            <param name="iDegree"> Степень кривой </param>
            <param name="oResultCurve"> Созданная кривая Безье </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="F:CubicApproximation">
Искомые касательные - касательные к кубическим кривым, построенным по четырём первым и четырём последним точкам из набора
</member>
        <member name="F:QuadraticApproximation">
Искомые касательные - касательные к параболам, построенным по трём первым и трём последним точкам из набора
</member>
        <member name="F:LinearApproximation">
Искомые касательные - вектора, построенные по паре первых и паре последних точек из набора
</member>
        <member name="T:RGPlatform.Geometry.Spline2D.EndTangentCalculationMethod">
Способ вычисления касательных на концах сплайна при интерполяции набора точек
</member>
        <member name="F:Uniform">
Однородный

Однородный
</member>
        <member name="F:Centripetal">
Центростремительный

Центростремительный
</member>
        <member name="F:ChordLength">
По длине хорды

По длине хорды
</member>
        <member name="T:RGPlatform.Geometry.Spline2D.KnotGenerationMethod">
Метод построения набора узлов
</member>
        <member name="M:RGPlatform.Geometry.Spline2D.CreateByControlPolygon(RGPlatform.Geometry.Context*,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать двумерный сплайн по управляющему полигону с заданной параметризацией </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoints"> Массив управляющих точек кривой </param>
            <param name="iWeights"> Массив весов </param>
            <param name="iKnots"> Последовательность узлов </param>
            <param name="iDegree"> Степень кривой </param>
            <param name="iIsPeriodic"> Является ли кривая периодической </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CreateUniformByControlPolygon(RGPlatform.Geometry.Context*,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать двумерный сплайн с однородной параметризацией </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoints"> Массив управляющих точек кривой </param>
            <param name="iWeights"> Массив весов </param>
            <param name="iDegree"> Степень кривой </param>
            <param name="iIsPeriodic"> Является ли кривая периодической </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.Create(RGPlatform.Geometry.Context*,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать двумерный сплайн по параметрам кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoints"> Массив управляющих точек кривой </param>
            <param name="iWeights"> Массив весов </param>
            <param name="iKnots"> Последовательность узлов </param>
            <param name="iDegree"> Степень кривой </param>
            <param name="iIsPeriodic"> Является ли кривая периодической </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.ApproximateWithArcs(RGPlatform.Geometry.Context*,System.Double,std.vector&lt;std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,std.allocator&lt;std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary />
            <param name="iContext">Контекст геометрии</param>
            <param name="iTolerance">Максимальное отклонение от исходной кривой.</param>
            <param name="ioCurves">Массив дуг или отрезков, аппроксимирующий исходную кривую.</param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.Transform(RGPlatform.Geometry.Context*,RGPlatform.Geometry.AffineMap2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать трансформированную копию объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iTransformation"> Трансформация </param>
            <returns> Трансформированная копия объекта </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CreateCropped(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Построить кривую, совпадающую с данной на участке, ограниченном интервалом</summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iInterval"> Интервал </param>
            <param name="ioCurve"> Построенная кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CreateCropped(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Построить кривую, совпадающую с данной на участке, ограниченном двумя точками </summary>
            <remarks> Направление роста параметра определяется порядком точек </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint1"> Начальная точка сегмента кривой </param>
            <param name="iPoint2"> Конечная точка сегмента кривой </param>
            <param name="iTolerance"> Погрешность, с которой точки лежат на кривой </param>
            <param name="iInsideCurveBounds">
                <para> true - учитывается только кривая в своих границах, точки сегмента должны лежать внутри этих границ </para>
                <para> false - учитывается носитель кривой целиком, точки сегмента должны лежать на носителе </para>
            </param>
            <param name="ioCurve"> Построенная кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.CreateReversed(RGPlatform.Geometry.Context*,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Построить кривую, совпадающую с данной, но с противоположной параметризацией </summary>
            <remarks> Данная операция возможна не для всех типов кривых </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="ioCurve"> Построенная кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.ConvertToRGK(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Преобразовать кривую в набор RGK-кривых </summary>
По данной кривой строится набор пар {RGK-кривая, RGK-интервал}.
<param name="iContext"> Контекст геометрии </param><param name="iInterval"> Интервал RGP-кривой </param><param name="oResult"> Результат преобразования </param><returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns></member>
        <member name="M:RGPlatform.Geometry.Spline2D.Copy(RGPlatform.Geometry.Context*)">
            <summary> Создать копию объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> Копия объекта </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetEndParameter(RGPlatform.Geometry.Context*)">
            <summary> Вычислить конечный параметр кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> Конечный параметр кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetStartParameter(RGPlatform.Geometry.Context*)">
            <summary> Вычислить начальный параметр кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> Начальный параметр кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetEndPoint(RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить конечную точку кривой </summary>
            <param name="oPoint"> Конечная точка кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetStartPoint(RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить начальную точку кривой </summary>
            <param name="oPoint"> Начальная точка кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetRectangleWithClipping(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Rectangle2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить ограничивающий прямоугольник с заданной обрезкой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iClipInteval"> Интервал, задающий обрезку </param>
            <param name="oRect"> Вычисленный ограничивающий прямоугольник </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.EstimateRectangle(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Rectangle2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оценить ограничивающий прямоугольник </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oRect"> Вычисленная оценка ограничивающего прямоугольника </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetRectangle(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Rectangle2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение ограничивающего прямоугольника </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oRect"> Вычисленный ограничивающий прямоугольник </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetDistanceWithClipping(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение расстояния от точки до кривой с заданной обрезкой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="iClipInteval"> Интервал, задающий обрезку </param>
            <param name="oDistance"> Расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetDistance(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение расстояния от точки до объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="oDistance"> Расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.EstimateDistance(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оценка расстояния от точки до объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="oExact"> Флаг, определяющий является ли вычисленное приближённое расстояние точным </param>
            <param name="oDistance"> Приближённое расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.IsClosed">
            <summary> Проверить, является ли кривая замкнутой </summary>
            <returns> true - кривая является замкнутой, false - кривая не является замкнутой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.FindLength(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить длину кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iInterval"> Интервал, соответствующий участку кривой, длина которого ищется </param>
            <param name="iTolerance"> Точность вычисления длины кривой </param>
            <param name="oLength"> Вычисленная длина кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.FindLength(RGPlatform.Geometry.Context*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить длину кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iTolerance"> Точность вычисления длины кривой </param>
            <param name="oLength"> Вычисленная длина кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.AsSpline2D">
            <summary> Получить геометрию как двумерный сплайн </summary>
            <returns> Указатель на данный объект двумерного сплайна </returns>
            <summary> Получить геометрию как двумерный сплайн </summary>
            <returns> Указатель на данный объект двумерного сплайна </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.GetType">
            <summary> Получить тип геометрии </summary>
            <returns> Тип геометрии </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.IsValid">
            <summary> Проверить, что кривая не вырождена </summary>
            <returns>
                <para> - true - кривая была задана </para>
                <para> - false - кривая не задана </para>
            </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.#ctor(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Spline2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Копирующий конструктор </summary>
            <param name="iSpline"> Сплайн  </param>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.Initialize(RGPlatform.Geometry.Context*,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
            <summary> Инициализировать двумерный сплайн по параметрам кривой, предназначен для использования в списках инициализации наследников </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoints"> Массив управляющих точек кривой </param>
            <param name="iWeights"> Массив весов </param>
            <param name="iKnots"> Последовательность узлов </param>
            <param name="iDegree"> Степень кривой </param>
            <param name="iIsPeriodic"> Является ли кривая периодической </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.#ctor(RGPlatform.Geometry.Context*,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Boolean)">
            <summary> Создать двумерный сплайн по параметрам кривой, предназначен для использования в списках инициализации наследников </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoints"> Массив управляющих точек кривой </param>
            <param name="iWeights"> Массив весов </param>
            <param name="iKnots"> Последовательность узлов </param>
            <param name="iDegree"> Степень кривой </param>
            <param name="iIsPeriodic"> Является ли кривая периодической </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.#ctor(std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;)">
            <summary> Конструктор по RGK-сплайну </summary>
            <param name="iRGKNURBSCurve"> Сплайн кривая в формате RGK </param>
        </member>
        <member name="M:RGPlatform.Geometry.Spline2D.#ctor">
            <summary> Конструктор по умолчанию </summary>
        </member>
        <member name="T:RGPlatform.Geometry.Spline2D">
            <summary> Двумерный сплайн </summary>
Класс описывает объект двумерной сплайн-кривой.
</member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.EstimateRectangle(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Rectangle2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оценить ограничивающий прямоугольник </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oRect"> Вычисленная оценка ограничивающего прямоугольника </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.FindArea(RGPlatform.Geometry.Context*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить площадь которую огрничивает кривая </summary>
            <param name="iTolerance"> Точность вычисления </param>
            <param name="oArea"> Площадь </param>
            <param name="oHasArea"> Признак наличия площади </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.MakeBezier(RGPlatform.Geometry.Context*,System.Boolean,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конвертация двумерной сплайн-кривой в кривую Безье </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iType"> true - RGP  тип, false - Parasolid </param>
            <param name="oControlPolygon"> Контрольный полигон безье кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.MakeBezier(RGPlatform.Geometry.Context*,std.shared_ptr&lt;RGPlatform.Geometry.BaseSpline2D&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конвертация двумерной сплайн-кривой в кривую Безье </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oResultCurve"> Созданная двумерная сплайн-кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetWeights">
            <summary> Получить массив весов </summary>
            <returns> Массив весов </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetControlPoints(std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить массив управляющих точек </summary>
            <param name="oControlPoints"> Массив управляющих точек </param>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetKnots">
            <summary> Получить массив узлов </summary>
            <returns> Массив узлов </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetKnot(System.Int32)">
            <summary> Получить узел с указанным индексом </summary>
            <param name="iIndex"> Индекс узла </param>
            <returns> Узел с указанным индексом </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetNumberOfKnots">
            <summary> Получить количество узловых значений </summary>
            <returns> Количество узловых значений </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetDegree">
            <summary> Получить степень сплайн-кривой </summary>
            <returns> Степень сплайн-кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetWeight(System.Int32)">
            <summary> Получить вес управляющей точки с указанным индексом </summary>
            <param name="iIndex"> Индекс точки </param>
            <returns> Вес точки с указанным индексом </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetControlPoint(System.Int32,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить управляющую точку с указанным индексом </summary>
            <param name="iIndex"> Индекс точки </param>
            <param name="oPoint"> Управляющая точка с указанным индексом </param>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetNumberOfPoints">
            <summary> Получить количество управляющих точек </summary>
            <returns> Количество управляющих точек </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.IsNonRational">
            <summary> Определить, является ли кривая нерациональной </summary>
            <returns>
                <para> - true - кривая нерациональная </para>
                <para> - false - кривая рациональная </para>
            </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.IsBezier">
            <summary> Определить, является ли кривая кривой Безье </summary>
            <returns>
                <para> - true - кривая является кривой Безье </para>
                <para> - false - кривая не является кривой Безье </para>
            </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.AsBaseSpline2D">
            <summary> Получить геометрию как двумерный сплайн </summary>
            <returns> Указатель на данный объект двумерного сплайна </returns>
            <summary> Получить геометрию как двумерный сплайн </summary>
            <returns> Указатель на данный объект двумерного сплайна </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.GetType">
            <summary> Получить тип геометрии </summary>
            <returns> Тип геометрии </returns>
        </member>
        <member name="M:RGPlatform.Geometry.BaseSpline2D.#ctor">
            <summary> Конструктор по умолчанию </summary>
        </member>
        <member name="T:RGPlatform.Geometry.BaseSpline2D">
            <summary> Абстракстный двумерный сплайн </summary>
Класс описывает объект двумерной сплайн-кривой.
</member>
        <member name="M:RGK.Geometry.NURBSCurve._FindMinimalBoundingBox(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.LCS3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Получить наименьший (ориентированный) ограничивающий параллелепипед
для NURBS-кривой на интервале в заданной (или текущей) системе координат</summary>
            <param name="iContext">Указатель на контекст вычисления</param>
            <param name="iInterval">Интервал параметров, для которого выполняется расчёт ограничивающего параллелепипеда</param>
            <param name="oBox">Результирующий ограничивающий параллелепипед для кривой</param>
            <param name="oLCS">Система координат ограничивающего параллелепипеда</param>
            <param name="iEstimate">Выполнить быструю приблизительную оценку</param>
            <returns>
- Result::NotSupported данный тип интервала не поддерживается
- Result::Success в случае успешного выполнения
</returns>
        </member>
        <member name="M:RGK.Geometry.NURBSCurve._FindBoundingBox(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
            <summary>Получить ограничивающий параллелепипед для NURBS-кривой на интервале
в заданной (или текущей) системе координат</summary>
            <param name="iContext">Указатель на контекст вычисления</param>
            <param name="iInterval">Интервал параметров, для которого выполняется расчёт ограничивающего параллелепипеда</param>
            <param name="oBox">Результирующий ограничивающий параллелепипед для кривой</param>
            <param name="ipLCS">Система координат для поиска ограничивающего параллелепипеда</param>
            <param name="iEstimate">Выполнить быструю приблизительную оценку</param>
            <returns>
- Result::NotSupported данный тип интервала не поддерживается
- Result::Success в случае успешного выполнения
</returns>
        </member>
        <member name="M:RGK.Geometry.NURBSCurve._MakeNURBSCurve(RGK.Common.Context*,RGK.Geometry.MakeNURBSCurveData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.MakeNURBSCurveReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание NURBS-кривой, которая совпадает с кривой на интервале с заданной точностью
<param name="iContext">Контекст вычисления</param><param name="iData">Данные для интерполяции</param><param name="oReport">Результат построения</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve._FindNearestPoint(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить параметр точки на кривой, ближайшей к передаваемой точке
<param name="iContext">Контекст вычисления</param><param name="iPoint">Точка, для которой ищется ближайшая точка на кривой</param><param name="iTolerance">Точность, с которой ищется ближайшая точка</param><param name="oParam">Найденный параметр ближайшей точки на кривой</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve._Parameterise(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
Определить параметр точки, лежащей на кривой
<param name="iContext">Контекст вычисления</param><param name="iPoint">Точка на кривой</param><param name="ioParam">Найденный параметр на кривой (на входе может содержать начальное приближение)</param><param name="iUseGuess">Использовать ли начальное приближение</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotOnCurve точка не лежит на кривой
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.CheckBezier">
Проверка, является ли NURBS кривой Безье
</member>
        <member name="M:RGK.Geometry.NURBSCurve._FindNearestPoint(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить параметр точки на кривой, ближайшей к передаваемой точке
<param name="iContext">Контекст вычисления</param><param name="iPoint">Точка, для которой ищется ближайшая точка на кривой</param><param name="iInterval"> Интервал поиска </param><param name="iTolerance">Точность, с которой ищется ближайшая точка</param><param name="oParam">Найденный параметр ближайшей точки на кривой</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.DeleteBezierRepresentation">
Удалить Безье-представление
</member>
        <member name="M:RGK.Geometry.NURBSCurve.UpdateBezierRepresentation(RGK.Common.Context*,System.Boolean,std.shared_ptr&lt;RGK.Geometry.BezierCurveRepresentation&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Построение представления кривой в виде кусочного Безье
<param name="iContext">Контекст вычисления</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.IsCoincident(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.Geometry!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка совпадения геометрических объектов
<param name="iContext">Контекст создания линии</param><param name="iGeometry">Геометрический объект, с которым выполняется сравнение</param><param name="iData">Выполнять сравнение по данным. То есть объекты считаются одинаковыми в случае совпадения всех параметров объектов</param><param name="oCoincident">Результат сравнения</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.IsPlanar(RGK.Common.Context*,RGK.Geometry.Curve.IsPlanarData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Curve.IsPlanarReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Проверка, что кривая или её участок является плоской</summary>
            <param name="iData">Параметры проверки</param>
            <param name="oReport">Результаты проверки</param>
            <returns>
- Result::Success в случае успешного выполнения
</returns>
        </member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.GetCharPointsCount(RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.CharPointType)">
Получить количество характеристических точек по типу
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.GetCharPointsCount">
Получить количество характеристических точек
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.GetCharPoint(System.UInt64)">
Получить характеристическую точку
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.DetectG1DiscontinuityPoint(System.Double,System.Double)">
Определение наличия точки разрыва непрерывности по G1
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.Add(RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Добавить точку
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.Dispose">
Деструктор
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.#ctor">
Конструктор
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.GetCharPointType">
Получить тип характеристической точки
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.GetPoint">
Получить точку на кривой
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.GetParameter">
Получить параметр на кривой
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.Dispose">
Деструктор
</member>
        <member name="M:RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.#ctor(System.Double,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.CharPointType)">
Конструктор
</member>
        <member name="F:Singular">
Точка сингулярности
</member>
        <member name="F:C1Discont">
С1 разрыв
</member>
        <member name="F:LocalMinMax">
Локальный минимум/максимум
</member>
        <member name="F:InflectionPoint">
Точка перегиба
</member>
        <member name="F:Der1Discont">
Точка разрыва 1-ой производной
</member>
        <member name="T:RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint.CharPointType">
Тип характеристической точки
</member>
        <member name="T:RGK.Geometry.NURBSCurve.CharPointsReport.CharPoint">
Структура для хранения параметров характеристической точки
</member>
        <member name="T:RGK.Geometry.NURBSCurve.CharPointsReport">
Отчёт по результатам поиска характеристических точек на NURBS кривой
</member>
        <member name="M:RGK.Geometry.NURBSCurve.IsRightClamped(RGK.Common.Context*)">
Проверить, является ли кривая Clamped справа
<param name="iContext">Контекст вычисления</param><returns>
true, если кривая Clamped справа
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.IsLeftClamped(RGK.Common.Context*)">
Проверить, является ли кривая Clamped слева
<param name="iContext">Контекст вычисления</param><returns>
true, если кривая Clamped слева
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.ClampCurve(RGK.Common.Context*,System.Boolean,System.Boolean,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Преобразование несжатой (unclamped) в сжатую (clamped) кривую. Для обработки обоих концов оба входных флага надо выставить в true.
<param name="iContext">Контекст создания NURBS кривой</param><param name="iFromLeft">Обработка левой части кривой</param><param name="iFromRight">Обработка правой части кривой</param><param name="oCurve">Полученная сжатая кривая</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.UnclampCurve(RGK.Common.Context*,System.Boolean,System.Boolean,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Преобразование сжатой (clamped) кривой в несжатую (unclamped). Для обработки обоих концов оба входных флага надо выставить в true.
<param name="iContext">Контекст создания NURBS кривой</param><param name="iFromLeft">Обработка левой части кривой</param><param name="iFromRight">Обработка правой части кривой</param><param name="oCurve">Полученная несжатая кривая</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.MakeBezier(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конвертация NURBS-кривой в кривую Безье
<param name="iContext">Контекст создания NURBS кривой</param><param name="oCurve">Созданная кривая Безье</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Reverse(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод создаёт новую NURBS кривую с противоположным порядком обхода узлов
<summary>Изменение порядка обхода узлов</summary><param name="iContext">Контекст вычисления</param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.ReduceDegree(RGK.Common.Context*,System.Double!System.Runtime.CompilerServices.IsConst,System.Int32,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод, создающий новую NURBS-кривую, понизив степень существующей NURBS-кривой
<summary>Понижение степени сплайна</summary><param name="iContext">Контекст вычисления</param><param name="iTolerance">Передаваемая точность</param><param name="iTimes">Порядок понижения степени</param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.ElevateDegree(RGK.Common.Context*,System.Int32,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод, создающий новую NURBS-кривую, повысив степень существующей NURBS-кривой
<summary>Повышение степени сплайна</summary><param name="iContext">Контекст вычисления</param><param name="iTimes">Порядок повышения степени</param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.RemoveKnots(RGK.Common.Context*,System.Double,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод, создающий новую NURBS-кривую, удалив все возможные узлы
<param name="iContext">Контекст вычисления</param><param name="iTolerance">Погрешность, оценивается как iTolerance=dw_min/(1+|P|_max) </param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadParameter некорректно задан iTimes
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.ShiftKnots(RGK.Common.Context*,System.Double,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод, создающий новую NURBS-кривую, добавив к значениям узлов одно и то же число
<param name="iContext">Контекст вычисления</param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.NormalizeKnots(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание новой NURBS-кривой, перепараметризовав существующую с границами [0, 1]
<param name="iContext">Контекст вычисления</param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Reparametrization(RGK.Common.Context*,System.Double,System.Double,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание новой NURBS-кривой, перепараметризовав существующую
<param name="iContext">Контекст вычисления</param><param name="iMin">Новое значение нижней границы параметра</param><param name="iMax">Новое значение верхней границы параметра</param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParametr некорректно задана последовательность узлов
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.InsertMultipleKnots(RGK.Common.Context*,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Вставка набора уникальных узлов с заданными кратностями</summary>
            <param name="iContext">Контекст вычисления</param>
            <param name="iInsertingKnots">Набор узлов для вставки</param>
            <param name="iMultiplicities">Кратности вставляемых узлов</param>
            <param name="oCurve">Новая NURBS-кривая со вставленными узлами</param>
            <returns>
- Result::Success в случае успешного выполнения
- Result::InvalidInputParameter некорректно задана последовательность узлов и их кратностей
- Result::NullPointer недопустимая передача нулевого указателя
</returns>
        </member>
        <member name="M:RGK.Geometry.NURBSCurve.ModifyWeight(RGK.Common.Context*,System.Int32,System.Double,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание новой NURBS-кривой, изменив вес одной контрольной точки
<param name="iContext">Контекст вычисления</param><param name="index">Индекс контрольной точки</param><param name="iWeight">Новое значение веса</param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.ModifyControlPoint(RGK.Common.Context*,System.Int32,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание новой NURBS-кривой, изменив значение одной контрольной точки
<param name="iContext">Контекст вычисления</param><param name="index">Индекс контрольной точки</param><param name="iPoint">Новое значение контрольной точки</param><param name="oCurve">Созданная NURBS-кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetWeights">
Получить  вектор весов
<returns>Массив весов</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetControlPoints">
Получить  вектор контрольных точек
<returns>Массив контрольных точек</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetKnots">
Получить возвращает вектор узловых значений
<returns>Массив узловых значений</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetKnot(System.Int32)">
Получить  узловое значение под номером index
<param name="index">Индекс точки</param><returns>Узловое значение с указанным индексом</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetNumberOfKnots">
Получить  количество узловых значений
<returns>Количество узловых значений</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetDegree">
Получить  степень NURBS-кривой
<returns>Степень NURBS-кривой</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetWeight(System.Int32)">
Получить возвращает вес контрольной точки под номером index
<returns>Вес точки с указанным индексом</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetControlPoints4D">
Получить контрольные точки в 4D пространстве
<returns>Массив контрольных точек</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetControlPoint4D(System.Int32)">
Получить контрольную точку под номером index в 4D пространстве
<param name="index">Индекс точки</param><returns>Контрольная точка с указанным индексом</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetControlPoint(System.Int32)">
Получить контрольную точку под номером index
<param name="index">Индекс точки</param><returns>Контрольная точка с указанным индексом</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetNumberOfPoints">
Получить возвращает количество контрольных точек
</member>
        <member name="M:RGK.Geometry.NURBSCurve.IsNonRational">
Определить, является ли кривая нерациональной
<returns>
- true кривая нерациональная
- false кривая рациональная
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.IsBezier">
Определить, является ли кривая - кривой Безье
<returns>
- true кривая является кривой Безье
- false кривая не является кривой Безье
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.IsPeriodic">
Определить, является ли кривая периодической
<returns>
- true кривая периодическая
- false кривая непериодическая
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Transform(RGK.Common.Context*,RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,std.shared_ptr&lt;RGK.Geometry.Geometry!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание копии геометрии с применением аффинного преобразования
<param name="iContext">Контекст создания линии</param><param name="iMap">Аффинное преобразование</param><param name="iTolerance">Допустимая точность преобразований</param><param name="oCopy">Возвращается трансформированная геометрия</param><param name="oExact">Возвращается true-для точного преобразования</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.SplineEvaluate(RGK.Common.Context*,System.Double,System.UInt32,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить значение производной (iDerivOrder) кривой по параметрам</summary>
Вычисляется значение производной,
где массив iDerivIndices имеет длину равную iDerivOrder и содержит индексы
переменных, по которым дифференцируем (индекс встречается несколько раз,
если дифференцирование кратное).
u имеет индекс 0, далее каждая контрольная точка берет по три индекса.
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляется производная</param><param name="iDerivOrder">Порядок производной (&gt;=0)</param><param name="iDerivIndices">Индексы переменных, по которым дифференцируем </param><param name="oDerivative">Значение вычисленной производной</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.FindLength(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean,System.Int32)">
Получить длину кривой
<param name="iContext">Контекст вычисления</param><param name="iInterval">Параметрический интервал кривой, на котором считается длина</param><param name="iTolerance">Запрашиваемая точность вычисления длины</param><param name="oLength">Найденная длина</param><param name="iEstimate">Использовать быструю приблизительную оценку</param><param name="iNPoints">Количество точек для оценки</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.EvaluatePoints(RGK.Common.Context*,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить координаты точки и все производные по параметру кривой. Пакетный расчёт производных
<param name="iContext">Контекст вычисления</param><param name="iU">Параметры на кривой, в которых вычисляются производные</param><param name="iMaxDerivOrder">Максимальный порядок рассчитываемых производных</param><param name="oDerivatives">Значения вычисленных производных</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Evaluate(RGK.Common.Context*,System.Double,System.UInt32,RGK.Math.Vector3D*)">
Получить координаты точки и все производные по параметру кривой. Пакетный расчёт производных
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляются производные</param><param name="iMaxDerivOrder">Максимальный порядок рассчитываемых производных</param><param name="oDerivatives">Значения вычисленных производных</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Evaluate(RGK.Common.Context*,System.Double,System.UInt32,RGK.Math.Vector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить значение производной (iDerivOrder) кривой по параметру iU
<summary>В базовом классе метод реализован на основе сплайн-представления</summary><param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляется производная</param><param name="iDerivOrder">Порядок производной (&gt;=0)</param><param name="oDerivative">Значение вычисленной производной</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Evaluate4D(RGK.Common.Context*,System.Double,System.UInt32,std.vector&lt;RGK.Math.Vector4D,std.allocator&lt;RGK.Math.Vector4D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить координаты точки и все производные в 4D по параметру кривой. Пакетный расчёт производных
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляются производные</param><param name="iMaxDerivOrder">Максимальный порядок рассчитываемых производных</param><param name="oDerivatives">Значения вычисленных производных</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Evaluate4D(RGK.Common.Context*,System.Double,System.UInt32,RGK.Math.Vector4D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить значение производной в 4D (iDerivOrder) кривой по параметру iU
<summary>В базовом классе метод реализован на основе сплайн-представления</summary><param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляется производная</param><param name="iDerivOrder">Порядок производной (&gt;=0)</param><param name="oDerivative">Значение вычисленной производной</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetInterval(RGK.Geometry.Interval*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить параметры границы кривой
<param name="oInterval">Интервал</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported - для данного класса кривой функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Copy(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*)">
            <summary>Создание новой кривой с параметрами исходной на заданном интервале (копирование на интервале)</summary>
            <param name="iContext">Контекст создания NURBS поверхности</param>
            <param name="iInterval">Заданный интервал параметров (подмножество исходного интервала)</param>
            <param name="oCurve">Скопированная кривая</param>
            <param name="ipLCS">Система координат для копирования кривой</param>
            <returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
- Result::BadKnots некорректно заданная последовательность узлов
- Result::BadDegree некорректно задана степень NURBS
- Result::BadWeights некорректно заданы веса для контрольных точек
- Result::BadInterval некорректно задан интервал параметров
</returns>
        </member>
        <member name="M:RGK.Geometry.NURBSCurve.Copy(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.Geometry!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Создание новой кривой с параметрами исходной (копирование)</summary>
            <param name="iContext">Контекст создания NURBS кривой</param>
            <param name="oCurve">Скопированная кривая</param>
            <returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
- Result::BadKnots некорректно заданная последовательность узлов
- Result::BadDegree некорректно задана степень NURBS
- Result::BadWeights некорректно заданы веса для контрольных точек
</returns>
        </member>
        <member name="M:RGK.Geometry.NURBSCurve.Copy(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Создание новой кривой с параметрами исходной (копирование)</summary>
            <param name="iContext">Контекст создания NURBS кривой</param>
            <param name="oCurve">Скопированная кривая</param>
            <returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
- Result::BadKnots некорректно заданная последовательность узлов
- Result::BadDegree некорректно задана степень NURBS
- Result::BadWeights некорректно заданы веса для контрольных точек
</returns>
        </member>
        <member name="M:RGK.Geometry.NURBSCurve.CreateBezier(RGK.Common.Context*,std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание кривой Безье
<summary>Создаёт кривую Безье с весами равными 1.0</summary><param name="iContext">Контекст создания NURBS кривой</param><param name="iPoints">Массив опорных точек кривой</param><param name="iDegree">Степень кривой</param><param name="oCurve">Созданная кривая Безье</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
- Result::BadKnots некорректно заданная последовательность узлов
- Result::BadDegree некорректно задана степень NURBS
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.CreateBezier(RGK.Common.Context*,std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание кривой Безье
<param name="iContext">Контекст создания NURBS кривой</param><param name="iPoints">Массив опорных точек кривой</param><param name="iWeights">Массив весов</param><param name="iDegree">Степень кривой</param><param name="oCurve">Созданная кривая Безье</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
- Result::BadDegree некорректно задана степень NURBS
- Result::BadWeights некорректно заданы веса для контрольных точек
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Create(RGK.Common.Context*,std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание объекта NURBS кривой
<summary>Создаёт NURBS кривую с весами равными 1.0</summary><param name="iContext">Контекст создания NURBS кривой</param><param name="iPoints">Массив опорных точек кривой</param><param name="iDegree">Степень кривой</param><param name="iKnots">Последовательность узлов</param><param name="isPeriodic">Является ли кривая периодической</param><param name="oCurve">Созданная NURBS кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
- Result::BadKnots некорректно заданная последовательность узлов
- Result::BadDegree некорректно задана степень NURBS
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Create(RGK.Common.Context*,std.vector&lt;RGK.Math.Vector4D,std.allocator&lt;RGK.Math.Vector4D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание объекта NURBS кривой
<param name="iContext">Контекст создания NURBS кривой</param><param name="iPoints">Массив опорных точек кривой с весами</param><param name="iDegree">Степень кривой</param><param name="iKnots">Последовательность узлов</param><param name="isPeriodic">Является ли кривая периодической</param><param name="oCurve">Созданная NURBS кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
- Result::BadKnots некорректно заданная последовательность узлов
- Result::BadDegree некорректно задана степень NURBS
- Result::BadWeights некорректно заданы веса для контрольных точек
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.Create(RGK.Common.Context*,std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,std.shared_ptr&lt;RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание объекта NURBS кривой
<param name="iContext">Контекст создания NURBS кривой</param><param name="iPoints">Массив опорных точек кривой</param><param name="iWeights">Массив весов</param><param name="iDegree">Степень кривой</param><param name="iKnots">Последовательность узлов</param><param name="isPeriodic">Является ли кривая периодической</param><param name="oCurve">Созданная NURBS кривая</param><returns>
- Result::Success в случае успешного выполнения
- Result::NullPointer недопустимая передача нулевого указателя
- Result::BadKnots некорректно заданная последовательность узлов
- Result::BadDegree некорректно задана степень NURBS
- Result::BadWeights некорректно заданы веса для контрольных точек
</returns></member>
        <member name="M:RGK.Geometry.NURBSCurve.GetType">
Получить тип геометрии
<returns>Тип геометрии</returns></member>
        <member name="T:RGK.Geometry.NURBSCurve">
Класс NURBS-кривой
<seealso cref="!:Геометрия" /><seealso cref="!:Кривая" /></member>
        <member name="M:RGK.Math.Vector4D.GetNormByLength(System.Double)">
Получение нормированного вектора
<param name="iTolerance">Точность</param></member>
        <member name="M:RGK.Math.Vector4D.SetNormByLength(System.Double,System.Double)">
Нормирование по длине
<param name="iDistance">Длина</param><param name="iTolerance">Точность</param></member>
        <member name="M:RGK.Math.Vector4D.ToVector3D(System.Double)">
Преобразование в Vector3D
</member>
        <member name="M:RGK.Math.Vector4D.ToVector3D">
Преобразование в Vector3D
</member>
        <member name="M:RGK.Math.Vector4D.SetFromVector3D(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Метод для инициализации вектора
<param name="iPoint">Точка</param><param name="iWeight">Вес точки</param></member>
        <member name="M:RGK.Math.Vector4D.CopyXYZW(System.Double*)">
Получение массива значений координат
<param name="oResult">Адрес массива координат. Массив должен содержать 4 элемента</param></member>
        <member name="M:RGK.Math.Vector4D.GetW">
Получение координаты W
<returns>Значение координаты W</returns></member>
        <member name="M:RGK.Math.Vector4D.GetZ">
Получение координаты Z
<returns>Значение координаты Z</returns></member>
        <member name="M:RGK.Math.Vector4D.GetY">
Получение координаты Y
<returns>Значение координаты Y</returns></member>
        <member name="M:RGK.Math.Vector4D.GetX">
Получение координаты X
<returns>Значение координаты X</returns></member>
        <member name="M:RGK.Math.Vector4D.Magnitude2">
Получить длину вектора в квадрате
<returns>Значение длины вектора в квадрате</returns></member>
        <member name="M:RGK.Math.Vector4D.Magnitude">
Получить длину вектора
<returns>Значение длины вектора</returns></member>
        <member name="M:RGK.Math.Vector4D.SetXYZW(System.Double,System.Double,System.Double,System.Double)">
Задание значений координат вектора
<param name="x">Координата X</param><param name="y">Координата Y</param><param name="z">Координата Z</param><param name="w">Вес</param></member>
        <member name="M:RGK.Math.Vector4D.op_Subtraction(RGK.Math.Vector4D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Вычитание векторов
<param name="iToDecr">Вектор, который вычитается из данного</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector4D.op_Addition(RGK.Math.Vector4D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сумма векторов
<param name="iToAdd">Вектор, с которым складывается данный</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector4D.op_Division(System.Double)">
Масштабирование вектора. Деление значений координат на заданное число
<param name="iLambda">Значение делителя</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector4D.op_Multiply(System.Double)">
Масштабирование вектора. Умножение значений координат на заданное число
<param name="iLambda">Значение множителя</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector4D.op_Multiply(RGK.Math.Vector4D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Скалярное произведение векторов
<param name="iToMul">Второй множитель</param><returns>Значение скалярного произведение векторов</returns></member>
        <member name="M:RGK.Math.Vector4D.op_SubtractionAssignment(RGK.Math.Vector4D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Вычитание векторов
<param name="iToDecr">Вектор, который вычитается из данного</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector4D.op_AdditionAssignment(RGK.Math.Vector4D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сумма векторов
<param name="iToAdd">Вектор, с которым складывается данный</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector4D.op_DivisionAssignment(System.Double)">
Масштабирование вектора. Деление значений координат на заданное число
<param name="iLambda">Значение делителя</param><returns>Ссылка на объект</returns></member>
        <member name="M:RGK.Math.Vector4D.op_MultiplicationAssignment(System.Double)">
Масштабирование вектора. Умножение значений координат на заданное число
<param name="iLambda">Значение множителя</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector4D.op_UnaryNegation">
Противоположный вектор. Умножение значений координат вектора на -1
<returns>Объект, являющийся противоположным вектором</returns></member>
        <member name="M:RGK.Math.Vector4D.op_Subscript(System.Int32)">
Получение значения координаты вектора по индексу
<param name="idx">Индекс координаты 0 = X, 1 = Y, 2 = Z, 3 = W </param><returns>Значение координаты</returns>
Получение ссылки на значение координаты вектора по индексу
<param name="idx">Индекс координаты 0 = X, 1 = Y, 2 = Z, 3 = W</param><returns>Ссылка на координату</returns></member>
        <member name="M:RGK.Math.Vector4D.Flush">
Обнуление координат вектора
</member>
        <member name="M:RGK.Math.Vector4D.Vector">
Получение координат вектора в виде массива
<returns>Массив из 4 элементов, содержащий координаты X,Y,Z,W</returns></member>
        <member name="M:RGK.Math.Vector4D.IsEqual(RGK.Math.Vector4D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка двух векторов на равенство
<param name="iOther">Вектор, с которым сравнивается данный</param><returns>true если векторы равны, false если не равны</returns></member>
        <member name="M:RGK.Math.Vector4D.op_Assign(System.Double!System.Runtime.CompilerServices.IsConst*)">
Оператор присваивания по массиву значений
<param name="iVals">Массив значений координат вектора в порядке X, Y, Z, W. Массив должен содержать 4 элемента.</param></member>
        <member name="M:RGK.Math.Vector4D.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Конструктор по точке и весу.
<param name="iPoint">Точка</param><param name="iWeight">Вес точки</param></member>
        <member name="M:RGK.Math.Vector4D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*)">
Конструктор по массиву значений
<param name="iVals">Массив значений координат вектора в порядке X, Y, Z, W. Массив должен содержать 4 элемента.</param></member>
        <member name="M:RGK.Math.Vector4D.#ctor(System.Double,System.Double,System.Double,System.Double)">
Конструктор по координатам
<param name="x">Значение координаты X</param><param name="y">Значение координаты Y</param><param name="z">Значение координаты Z</param><param name="w">Значение координаты W</param></member>
        <member name="M:RGK.Math.Vector4D.#ctor">
Конструктор по умолчанию. Все координаты принимают нулевые значения.
</member>
        <member name="T:RGK.Math.Vector4D">
4D вектор
</member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersection.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersection.#ctor">
            <summary> Конструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersection.Intersect(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Curve2DIntersectionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Curve2DIntersectionReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Найти пересечения кривых </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iData"> Данные для пересечения </param>
            <param name="oReport"> Результат пересечения кривых </param>
            <returns> Код результата </returns>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DIntersection">
            <summary> Класс поиска пересечений 2D-кривых </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionReport.GetSolutionTolerance">
            <summary> Получить точность пересечения </summary>
            <returns> Точность пересечения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionReport.GetIntersectionPointData(System.UInt64)">
            <summary> Получить данные пересечения по индексу </summary>
            <param name="iIndex"> Номер точки пересечения </param>
            <returns> Данные пересечения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionReport.GetIntersectionCount">
            <summary> Получить количество точек пересечения </summary>
            <returns> Количество точек пересечения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionReport.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionReport.#ctor">
            <summary> Конструктор </summary>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DIntersectionReport">
            <summary> Результат поиска пересечений </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionPointData.SwapParameters">
            <summary> Поменять местами параметры (для исправления ошибок) </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionPointData.GetType">
            <summary> Получить тип пересечения </summary>
            <returns> Тип пересечения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionPointData.GetParameter2">
            <summary> Получить параметр на второй кривой </summary>
            <returns> Параметр на второй кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionPointData.GetParameter1">
            <summary> Получить параметр на первой кривой </summary>
            <returns> Параметр на первой кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionPointData.GetPoint">
            <summary> Получить точку пересечения </summary>
            <returns> Точка пересечения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionPointData.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionPointData.#ctor(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,&lt;unknown type&gt;)">
            <summary> Конструктор </summary>
            <param name="iPoint"> Точка пересечения </param>
            <param name="iParam1"> Параметр на первой кривой, соответствующий точке пересечения </param>
            <param name="iParam2"> Параметр на второй кривой, соответствующий точке пересечения </param>
            <param name="iType"> Тип пересечения </param>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DIntersectionPointData">
            <summary> Информация о пересечении </summary>
        </member>
        <member name="T:RGPlatform.Geometry.IntersectionType">
            <summary> Тип пересечения </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DSelfIntersectionData.Check(RGPlatform.Geometry.Context*)">
            <summary> Проверить корректность данных </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> RGK::Common::Success - если данные корректны, код ошибки - иначе</returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DSelfIntersectionData.GetTolerance">
            <summary> Получить точность поиска точек самопересечения </summary>
            <returns> Точность поиска точек самопересечения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DSelfIntersectionData.GetInterval">
            <summary> Получить параметрический интервал кривой, на котором выполняется поиск точек самопересечения </summary>
            <returns> Параметрический интервал кривой, на котором выполняется поиск точек самопересечения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DSelfIntersectionData.GetCurve">
            <summary> Получить кривую </summary>
            <returns> Кривая </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DSelfIntersectionData.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DSelfIntersectionData.#ctor(RGPlatform.Geometry.Curve2DGeometry!System.Runtime.CompilerServices.IsConst*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Конструктор </summary>
            <param name="iCurve"> Кривая </param>
            <param name="iInterval"> Параметрический интервал кривой, на котором выполняется поиск точек самопересечения </param>
            <param name="iTolerance"> Точность поиска точек самопересечения </param>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DSelfIntersectionData">
            <summary> Данные для поиска точек самопересечения двумерной кривой </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.Check(RGPlatform.Geometry.Context*)">
            <summary> Проверить корректность данных </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> RGK::Common::Success - если данные корректны, код ошибки - иначе</returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.GetSelectingPoint">
            <summary> Получить точку, по которой будет выбран ответ </summary>
            <returns> Точка, по которой будет выбран ответ </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.SetSelectingPoint(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Задать точку, по которой будет выбран ответ </summary>
Если точка задана, то будет выбран ближайший к этой точке ответ.
<param name="iPoint"> Точка, по которой будет выбран ответ </param></member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.GetTolerance">
            <summary> Получить точность вычисления пересечения </summary>
            <returns> Точность вычисления пересечения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.GetInterval2">
            <summary> Получить параметрический интервал второй кривой </summary>
            <returns> Параметрический интервал второй кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.GetCurve2">
            <summary> Получить первую пересекаемую кривую </summary>
            <returns> Первая пересекаемая кривая </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.GetInterval1">
            <summary> Получить параметрический интервал первой кривой </summary>
            <returns> Параметрический интервал первой кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.GetCurve1">
            <summary> Получить первую пересекаемую кривую </summary>
            <returns> Первая пересекаемая кривая </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DIntersectionData.#ctor(RGPlatform.Geometry.Curve2DGeometry!System.Runtime.CompilerServices.IsConst*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Curve2DGeometry!System.Runtime.CompilerServices.IsConst*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Конструктор </summary>
            <param name="iCurve1"> Первая пересекаемая кривая </param>
            <param name="iInterval"> Параметрический интервал первой кривой, на котором выполняется поиск пересечений </param>
            <param name="iCurve2"> Вторая пересекаемая кривая </param>
            <param name="iInterva2"> Параметрический интервал второй кривой, на котором выполняется поиск пересечений </param>
            <param name="iTolerance"> Точность вычисления пересечения </param>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DIntersectionData">
            <summary> Данные для пересечения двумерных кривых </summary>
        </member>
        <member name="D:RGPlatform.ULongLongSet">
Множество 64 битных целых
</member>
        <member name="D:RGPlatform.ULongLongVector">
Множество 64 битных целых
</member>
        <member name="D:RGPlatform.ULongLong">
64 битное целое
</member>
        <member name="T:RGPlatform.Common.Unit">
Единица измерения физических величин
</member>
        <member name="D:RGPlatform.Common.StringSet">
Упорядоченное множество строк
</member>
        <member name="D:RGPlatform.Common.StringVector">
Множество строк
</member>
        <member name="D:RGPlatform.Common.StringPtr">
Ссылка на строку
</member>
        <member name="D:RGPlatform.Common.WordVector">
Множество слов
</member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry._ConvertRGKParamToRGP(RGPlatform.Geometry.Context*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конвертировать RGK-параметр на соответствующей RGK-кривой (см. ConvertToRGK) в RGP-параметр.
- iContext - контекст геометрии
- iRGKParam - RGK-параметр
- iRGPParam - RGP-параметр
</member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FitParamToInterval(RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Подогнать параметр так, чтобы он лежал не дальше одного периода от интервала
- iGaugeInterval - интервал, относительно которого подгоняется параметр
- ioParam - параметр, для которого выполняется подгонка
- iPeriod - период кривой
</member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertRGKParamToRGP(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Curve2DGeometry!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конвертировать RGK-параметр на соответствующей RGK-кривой (см. ConvertToRGK) в RGP-параметр.
- iContext - контекст геометрии
- iCurve - кривая, для которой выполняется конвертация
- iRGKParam - RGK-параметр
- iRGPParam - RGP-параметр
</member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.#ctor">
Конструктор
</member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.EvaluateCurvatureDerivative(System.Double,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Вычислить производную кривизны</summary>
            <param name="iTolerance"> Линейная точность </param>
            <param name="iDerivatives"> Производные, степень &gt;=3 </param>
            <param name="oCurvatureDerivative"> Производная </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.MakeOffset(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Curve2DGeometry.MakeOffsetData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Curve2DGeometry.MakeOffsetResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Построить эквидистантную кривую</summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.CreateCropped(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Построить кривую, совпадающую с данной на участке, ограниченном интервалом</summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iInterval"> Интервал </param>
            <param name="ioCurve"> Построенная кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ApproximateWithArcs(RGPlatform.Geometry.Context*,System.Double,std.vector&lt;std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,std.allocator&lt;std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary />
            <param name="iContext">Контекст геометрии</param>
            <param name="iTolerance">Максимальное отклонение от исходной кривой.</param>
            <param name="ioCurves">Массив дуг или отрезков, аппроксимирующий исходную кривую.</param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.CreateCropped(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Построить кривую, совпадающую с данной на участке, ограниченном двумя точками </summary>
            <remarks> Направление роста параметра определяется порядком точек </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint1"> Начальная точка сегмента кривой </param>
            <param name="iPoint2"> Конечная точка сегмента кривой </param>
            <param name="iTolerance"> Погрешность, с которой точки лежат на кривой </param>
            <param name="iInsideCurveBounds">
                <para> true - учитывается только кривая в своих границах, точки сегмента должны лежать внутри этих границ </para>
                <para> false - учитывается носитель кривой целиком, точки сегмента должны лежать на носителе </para>
            </param>
            <param name="ioCurve"> Построенная кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.CreateReversed(RGPlatform.Geometry.Context*,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Построить кривую, совпадающую с данной, но с противоположной параметризацией </summary>
            <remarks> Данная операция возможна не для всех типов кривых </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="ioCurve"> Построенная кривая </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGK(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Преобразовать кривую в набор RGK-кривых </summary>
По данной кривой строится набор пар {RGK-кривая, RGK-интервал}.
<param name="iContext"> Контекст геометрии </param><param name="iInterval"> Интервал RGP-кривой </param><param name="oResult"> Результат преобразования </param><returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns></member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.AddPair(RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.RGKCurvePair!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Добавить пару {кривая, интервал} </summary>
            <param name="iPair"> Добавляемая пара </param>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.op_Subscript(System.UInt64)">
            <summary> Получить пару {кривая, интервал} по индексу </summary>
            <returns> Пара {кривая, интервал} </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.GetAt(System.UInt64,RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.RGKCurvePair*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить пару {кривая, интервал} по индексу </summary>
            <param name="iIndex"> Индекс пары </param>
            <param name="oPair"> Пара </param>
            <returns> true - если пара с указанным индексом существует, false - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.GetCount">
            <summary> Получить число пар </summary>
            <returns> Число пар </returns>
        </member>
        <member name="F:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.RGKCurvePair._interval">
            <summary> RGK-интервал </summary>
        </member>
        <member name="F:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.RGKCurvePair._curve">
            <summary> RGK-кривая </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.RGKCurvePair.#ctor">
            <summary> Конструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.RGKCurvePair.#ctor(std.shared_ptr&lt;RGK.Geometry.Curve!System.Runtime.CompilerServices.IsConst&gt;,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конструктор </summary>
            <param name="iCurve"> RGK-кривая </param>
            <param name="iInterval"> RGK-интервал </param>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult.RGKCurvePair">
            <summary> Пара {кривая, интервал} в терминах RGK </summary>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DGeometry.ConvertToRGKResult">
            <summary> Объект результата преобразования кривой в набор RGK-кривых </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.EvaluateCurvature(RGPlatform.Geometry.Context*,System.Double,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить значение вектора кривизны к кривой по параметру iU </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iU"> Параметр на кривой, в котором вычисляется вектор кривизны </param>
            <param name="oCurvature"> Вычисленное значение вектора кривизны </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.EvaluateNormal(RGPlatform.Geometry.Context*,System.Double,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить значение нормали к кривой по параметру iU </summary>
            <remarks> Вектор нормали нормируется на 1. </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iU"> Параметр на кривой, в котором вычисляется нормаль </param>
            <param name="oNormal"> Вычисленное значение нормали </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.EvaluateTangent(RGPlatform.Geometry.Context*,System.Double,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить значение касательной к кривой по параметру iU </summary>
            <remarks> Вектор касательной нормируется на 1. </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iU"> Параметр на кривой, в котором вычисляется касательная </param>
            <param name="oTangent"> Вычисленное значение касательной </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.EvaluatePoint(RGPlatform.Geometry.Context*,System.Double,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить значение кривой по параметру iU </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iU"> Параметр на кривой, в котором вычисляется значение </param>
            <param name="oPoint"> Вычисленное значение </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.Evaluate(RGPlatform.Geometry.Context*,System.Double,System.UInt32,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить координаты точки и все производные по параметру кривой. Пакетный расчёт производных. </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iU"> Параметр на кривой, в котором вычисляются производные </param>
            <param name="iMaxDerivOrder"> Максимальный порядок рассчитываемых производных </param>
            <param name="oDerivatives"> Значения вычисленных производных </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.Evaluate(RGPlatform.Geometry.Context*,System.Double,System.UInt32,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить значение производной (заданного порядка) кривой по заданному параметру </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iU"> Параметр на кривой, в котором вычисляется производная </param>
            <param name="iDerivOrder"> Порядок производной (&gt;=0) </param>
            <param name="oDerivative"> Значение вычисленной производной </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertArcLengthToParameter(RGPlatform.Geometry.Context*,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Вычислить параметр на кривой по длине дуги от указанного параметра </summary>
Вычислить параметр кривой, соответствующий точке, лежащей на указанном расстоянии от
указанного параметра. Расстояние до точки меряется по кривой. 
<param name="iContext"> Контекст геометрии </param><param name="iStartParam"> Параметр, от которого отсчитывается расстояние по кривой </param><param name="iLength"> Длина дуги </param><param name="oParam"> Найденный параметр, соответствующий указанной длине дуги </param><returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns></member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FindNearestPoint(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить параметр точки на кривой, ближайшей к передаваемой точке </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, для которой ищется ближайшая точка на кривой </param>
            <param name="iTolerance"> Точность, с которой ищется ближайшая точка </param>
            <param name="oParam"> Найденный параметр ближайшей точки на кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.Parameterise(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
            <summary> Определить параметр точки, лежащей на кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка на кривой </param>
            <param name="ioParam"> Найденный параметр на кривой (на входе может содержать начальное приближение) </param>
            <param name="iUseGuess"> Использовать ли начальное приближение </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToPolyline(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,RGPlatform.Geometry.Polyline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Адаптивный алгоритм получения полилинии.</summary>
            <remarks> Точки добавляются к уже имеющимся в ioPolyline. </remarks>
            <param name="iRGKContext"> Контекст RGK </param>
            <param name="iInterval"> Интервал, на котором выполняется расчёт полилинии </param>
            <param name="iScale"> Условный масштаб преобразования в единицы измерения устройства</param>
            <param name="ioPolyline"> Результирующая полилиния</param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.ConvertToPolyline(RGK.Common.Context*,System.Double,RGPlatform.Geometry.Polyline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Адаптивный алгоритм получения полилинии.</summary>
            <remarks> Точки добавляются к уже имеющимся в ioPolyline. </remarks>
            <param name="iRGKContext"> Контекст RGK </param>
            <param name="iScale"> Условный масштаб преобразования в единицы измерения устройства</param>
            <param name="ioPolyline"> Результирующая полилиния</param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.OutputPoints(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Curve2DGeometry.FacetParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;RGPlatform.Geometry.Point2D,std.allocator&lt;RGPlatform.Geometry.Point2D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Адаптивный алгоритм расчёта точек на кривой с учётом параметров точности </summary>
            <remarks> Точки добавляются к уже имеющимся в ioPoints, ioParams. </remarks>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iInterval"> Интервал, на котором выполняется расчёт точек </param>
            <param name="iOptions"> Параметры разбиения </param>
            <param name="oPoints"> Массив насчитанных точек </param>
            <param name="oParams"> Массив параметров, в которых насчитаны точки </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FacetParameters.ConvertToRGK">
            <summary> Преобразовать объект в RGK-представление </summary>
            <returns> Вычисленное RGK-представление </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FacetParameters.UseGeneral">
            <summary> Использовать общий алгоритм разбиения? </summary>
            <returns> true - да, false - нет </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FacetParameters.GetChordalMaximumLength">
            <summary> Получить максимально допустимую длину хорды </summary>
            <returns> Максимально допустимая длина хорды </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FacetParameters.GetAngularTolerance">
            <summary> Получить максимально допустимое угловое уклонение </summary>
            <returns> Максимально допустимое угловое уклонение </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FacetParameters.GetChordalTolerance">
            <summary> Получить максимальное расстояние между кривой и хордой </summary>
            <returns> Максимальное расстояние между кривой и хордой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FacetParameters.#ctor(System.Double,System.Double,System.Double,System.Boolean)">
            <summary> Конструктор </summary>
            <param name="iChordalTolerance"> Максимальное расстояние между кривой и хордой </param>
            <param name="iAngularTolerance"> Максимально допустимое угловое уклонение </param>
            <param name="iChordalMaximumLength"> Максимально допустимая длина хорды </param>
            <param name="iGeneral"> Использовать общий алгоритм разбиения </param>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DGeometry.FacetParameters">
            <summary> Класс параметров для построения сетки точек на кривой </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FindArea(RGPlatform.Geometry.Context*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить площадь которую огрничивает кривая </summary>
            <param name="iTolerance"> Точность вычисления </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.GetInterval(RGPlatform.Geometry.Context*,RGK.Geometry.Interval*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить интервал кривой </summary>
            <param name="oInterval"> Интервал кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.GetEndParameter(RGPlatform.Geometry.Context*)">
            <summary> Вычислить конечный параметр кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> Конечный параметр кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.GetStartParameter(RGPlatform.Geometry.Context*)">
            <summary> Вычислить начальный параметр кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> Начальный параметр кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.GetEndPoint(RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить конечную точку кривой </summary>
            <param name="oPoint"> Конечная точка кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.GetStartPoint(RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить начальную точку кривой </summary>
            <param name="oPoint"> Начальная точка кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.IsPeriodic">
            <summary> Проверить, является ли кривая периодической </summary>
            <returns> true - кривая является периодической, false - кривая не является периодической </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.IsClosed">
            <summary> Проверить, является ли кривая замкнутой </summary>
            <returns> true - кривая является замкнутой, false - кривая не является замкнутой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.GetRectangleWithClipping(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Rectangle2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить ограничивающий прямоугольник с заданной обрезкой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iClipInteval"> Интервал, задающий обрезку </param>
            <param name="oRect"> Вычисленный ограничивающий прямоугольник </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.GetDistanceWithClipping(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение расстояния от точки до кривой с заданной обрезкой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="iClipInteval"> Интервал, задающий обрезку </param>
            <param name="oDistance"> Расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.GetDistance(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение расстояния от точки до объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="oDistance"> Расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.EstimateDistance(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оценка расстояния от точки до объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="oExact"> Флаг, определяющий является ли вычисленное приближённое расстояние точным </param>
            <param name="oDistance"> Приближённое расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FindLength(RGPlatform.Geometry.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить длину кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iInterval"> Интервал, соответствующий участку кривой, длина которого ищется </param>
            <param name="iTolerance"> Точность вычисления длины кривой </param>
            <param name="oLength"> Вычисленная длина кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.FindLength(RGPlatform.Geometry.Context*,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить длину кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iTolerance"> Точность вычисления длины кривой </param>
            <param name="oLength"> Вычисленная длина кривой </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.AsCurve2DGeometry">
            <summary> Получить геометрию как двумерную кривую </summary>
            <returns> Указатель на данный объект двумерной кривой </returns>
            <summary> Получить геометрию как двумерную кривую </summary>
            <returns> Указатель на данный объект двумерной кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Curve2DGeometry.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="T:RGPlatform.Geometry.Curve2DGeometry">
            <summary> Базовый класс двумерной кривой </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.CreateSymmetricPoint(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Line2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Для заданной двумерной точки создать симметричную относительно заданной оси </summary>
Метод создаёт двумерную точку, симметричную данной относительно заданной оси симметрии.
<param name="iContext"> Контекст геометрии </param><param name="iPoint"> Заданная точка, для которой строится симметричная </param><param name="iAxis"> Ось симметрии </param><param name="oResultPoint"> Результат </param><returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.ConvertToRGK">
            <summary> Преобразовать данную точку в RGK-точку </summary>
            <returns> Вычисленная RGK-точка </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.PsscalarProd(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить псевдоскалярное произведение векторов, заданных двумя точками </summary>
            <param name="iPt1"> Первая точка, задающая радиус-вектор </param>
            <param name="iPt2"> Вторая точка, задающая радиус-вектор </param>
            <returns> Псевдоскалярное произведение </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.ScalarProd(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить скалярное произведение векторов, заданных двумя точками </summary>
            <param name="iPt1"> Первая точка, задающая радиус-вектор </param>
            <param name="iPt2"> Вторая точка, задающая радиус-вектор </param>
            <returns> Скалярное произведение </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.IsCollinear(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
            <summary> Проверка, что два вектора коллиниарны </summary>
            <param name="iOther"> Второй вектор, с которым проверяется коллиниарность </param>
            <param name="iPrecision"> Угловая точность </param>
            <returns> true - если векторы коллиниарны, false - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.GetAngle(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение угла между векторами </summary>
            <param name="iOther">Вектор, до которого нужно посчитать угол</param>
            <returns>Значение угла между векторами в радианах</returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Angle">
            <summary> Получить угол радиус-вектора точки относительно оси X </summary>
            <returns> Угол радиус-вектора точки относительно оси X </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Turned90(System.Boolean)">
            <summary> Получить точку, полученную поворотом относительно точки (0,0), на 90 градусов </summary>
            <param name="iCCW"> true - поворот осуществляется против часовой стрелки, false - по часовой стрелке </param>
            <returns> Новая точка, полученная поворотом относительно точки (0,0), на 90 градусов </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Normalized">
            <summary> Получить вектор, заданный точкой, нормированный до единичной длины </summary>
            <returns> Вектор, заданный точкой, нормированный до единичной длины </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Normalize">
            <summary> Нормировать вектор, заданный точкой, до единичной длины </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.DistanceTo2(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить квадрат расстояния до точки </summary>
            <param name="iOther"> Точка, до которой вычисляется квадрат расстояния </param>
            <returns> Квадрат расстояния до точки </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.DistanceTo(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить расстояние до точки </summary>
            <param name="iOther"> Точка, до которой вычисляется расстояние </param>
            <returns> Расстояние до точки </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Hypot2">
            <summary> Получить квадрат расстояния до точки (0,0) </summary>
            <returns> Квадрат расстояния до точки (0,0) </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Hypot">
            <summary> Получить расстояние до точки (0,0) </summary>
            <returns> Расстояние до точки (0,0) </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.CreateSizeByDifference(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать размер по разности точек </summary>
Покоординатное вычитание
<param name="iPoint1"> Уменьшаемая точка </param><param name="iPoint2"> Вычитаемая точка </param><returns> Размер - результат вычитания </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_Division(System.Double)">
            <summary> Получить точку делением (масштабированием) </summary>
Покоординатное деление
<param name="iD"> Коэффициент масштабирования </param><returns> Новая точка - результат масштабирования </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_DivisionAssignment(System.Double)">
            <summary> Оператор деления (масштабирования) </summary>
Покоординатное деление
<param name="iD"> Коэффициент масштабирования </param><returns> Ссылка на себя </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_Multiply(System.Double)">
            <summary> Получить точку умножением (масштабированием) </summary>
Покоординатное умножение
<param name="iD"> Коэффициент масштабирования </param><returns> Новая точка - результат масштабирования </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_MultiplicationAssignment(System.Double)">
            <summary> Оператор умножения (масштабирования) </summary>
Покоординатное умножение
<param name="iD"> Коэффициент масштабирования </param><returns> Ссылка на себя </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_SubtractionAssignment(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор вычитания </summary>
Покоординатное вычитание
<param name="iPoint"> Вычитаемая точка </param><returns> Ссылка на себя </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_AdditionAssignment(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор сложения </summary>
Покоординатное сложение
<param name="iPoint"> Прибавляемая точка </param><returns> Ссылка на себя </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_SubtractionAssignment(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор вычитания </summary>
Покоординатное вычитание
<param name="iSize"> Вычитаемый размер </param><returns> Ссылка на себя </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_AdditionAssignment(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор сложения </summary>
Покоординатное сложение
<param name="iSize"> Прибавляемый размер </param><returns> Ссылка на себя </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_UnaryNegation">
            <summary> Оператор вычисления точки с противоположными координатами </summary>
            <returns> Новая точка, симметричная данной относительно (0,0) </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.op_Subtraction(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор вычитания </summary>
Покоординатное вычитание
<param name="iSize"> Вычитаемый размер </param><returns> Новая точка - результат вычитания </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_Subtraction(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор вычитания </summary>
Покоординатное вычитание
<param name="iPoint"> Вычитаемая точка </param><returns> Новая точка - результат вычитания </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_Addition(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор сложения </summary>
Покоординатное сложение
<param name="iPoint"> Прибавляемая точка </param><returns> Новая точка - результат сложения </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_Addition(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор сложения </summary>
Покоординатное сложение
<param name="iSize"> Прибавляемый размер </param><returns> Новая точка - результат сложения </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.Offset(System.Double,System.Double)">
            <summary> Переместить точку на заданные приращения по осям </summary>
            <param name="iDx"> Смещение по X </param>
            <param name="iDy"> Смещение по Y </param>
            <returns> Ссылка на себя </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.OffsetBy(System.Double,System.Double)">
            <summary> Получить точку смещением на заданные приращения по осям </summary>
            <param name="iDx"> Смещение по X </param>
            <param name="iDy"> Смещение по Y </param>
            <returns> Новая точка - результат смещения </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.op_Inequality(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор "!=" </summary>
Оператор проверки на неравенство
<param name="iOther"> Точка, с которой сравнивается данная </param><returns> true - не равны, false - равны </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.op_Equality(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор "==" </summary>
Оператор проверки на равенство
<param name="iOther"> Точка, с которой сравнивается данная </param><returns> true - равны, false - не равны </returns></member>
        <member name="M:RGPlatform.Geometry.Point2D.SetNull">
            <summary> Установить нулевые координаты </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Set(System.Double,System.Double)">
            <summary> Установить координаты </summary>
            <param name="iX"> X-координата </param>
            <param name="iY"> Y-координата </param>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.YRef">
            <summary> Получить ссылку на координату Y </summary>
            <returns> Ссылка на Y-координату точки </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.XRef">
            <summary> Получить ссылку на координату X </summary>
            <returns> Ссылка на X-координату точки </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Y">
            <summary> Получить координату Y </summary>
            <returns> Y-координата точки </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.X">
            <summary> Получить координату X </summary>
            <returns> X-координата точки </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.TransformPoint(RGPlatform.Geometry.AffineMap2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать трансформированную копию точки </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.GetDistance(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение расстояния от точки до объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="oDistance"> Расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.EstimateDistance(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оценка расстояния от точки до объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="oExact"> Флаг, определяющий является ли вычисленное приближённое расстояние точным </param>
            <param name="oDistance"> Приближённое расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.GetRectangle(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Rectangle2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение ограничивающего прямоугольника </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oRect"> Вычисленный ограничивающий прямоугольник </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.Dispose">
Деструктор
</member>
        <member name="M:RGPlatform.Geometry.Point2D.#ctor(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конструктор по размеру </summary>
            <param name="iSize"> Размер, по которому строится точка </param>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.#ctor(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конструктор копирования </summary>
            <param name="iOther"> Вторая точка </param>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.#ctor(System.Double,System.Double)">
            <summary> Конструктор по координатам </summary>
            <param name="iX"> X-координата </param>
            <param name="iY"> Y-координата </param>
        </member>
        <member name="M:RGPlatform.Geometry.Point2D.#ctor">
            <summary> Конструктор по умолчанию </summary>
        </member>
        <member name="T:RGPlatform.Geometry.Point2D">
            <summary> Двумерная точка </summary>
        </member>
        <member name="M:RGK.Math.Vector2D.end">
Константный итератор на конец.

Итератор на конец.
</member>
        <member name="M:RGK.Math.Vector2D.begin">
Константный итератор на начало.

Итератор на начало.
</member>
        <member name="M:RGK.Math.Vector2D.LeftChainAngle(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Расчёт левого угла между векторами, в предположении,
что векторы iNext и iPrev соединены цепочкой. Вначале вектор iPrev,
непосредственно за ним вектор iNext.

<param name="iPrev">Первый вектор цепочки</param><param name="iNext">Второй вектор цепочки</param><returns>Значение угла между векторами в радианах от нуля до двух Пи</returns></member>
        <member name="M:RGK.Math.Vector2D.MakeOrtho(System.Double)">
Получение ортогонального вектора
<returns>Новый ортогональный вектор</returns></member>
        <member name="M:RGK.Math.Vector2D.IsNormal(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Проверка ортогональности векторов с заданной точностью
<param name="iAnother">Вектор, с которым сравнивается данный</param><param name="iLinearTolerance">Линейная точность сравнения </param><param name="iAngularTolerance">Угловая точность сравнения </param><returns>true если векторы ортогональны, false если не ортогональны</returns></member>
        <member name="M:RGK.Math.Vector2D.IsColinear(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Проверка параллельности векторов с заданной точностью
<param name="iAnother">Вектор, с которым сравнивается данный</param><param name="iLinearTolerance">Линейная точность сравнения </param><param name="iAngularTolerance">Угловая точность сравнения </param><returns>true если векторы параллельны, false если не параллельны</returns></member>
        <member name="M:RGK.Math.Vector2D.GetAngle(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получение угла между векторами
<param name="iOther">Вектор, до которого нужно посчитать угол</param><returns>Значение угла между векторами в радианах</returns></member>
        <member name="M:RGK.Math.Vector2D.CutCoord(System.Int32)">
Отбрасывание заданной координаты вектора
<returns>Результирующий вектор</returns></member>
        <member name="M:RGK.Math.Vector2D.CutCoordSelf(System.Int32)">
Отбрасывание заданной координаты вектора
</member>
        <member name="M:RGK.Math.Vector2D.GetMaxCoord">
Получение максимальной из координат по модулю
<returns>Координата, модуль которой является максимальным</returns></member>
        <member name="M:RGK.Math.Vector2D.CopyXY(System.Single*)">
Получение массива значений координат
<param name="oResult">Адрес массива координат. Массив должен содержать 2 элемента</param></member>
        <member name="M:RGK.Math.Vector2D.CopyXY(System.Double*)">
Получение массива значений координат
<param name="oResult">Адрес массива координат. Массив должен содержать 2 элемента</param></member>
        <member name="M:RGK.Math.Vector2D.Magnitude2">
Получить длину вектора в квадрате
<returns>Значение длины вектора в квадрате</returns></member>
        <member name="M:RGK.Math.Vector2D.Magnitude">
Получить длину вектора
<returns>Значение длины вектора</returns></member>
        <member name="M:RGK.Math.Vector2D.SetXY(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Задание значений координат вектора по трёхмерному вектору
<param name="iVector"> Трёхмерный вектор </param></member>
        <member name="M:RGK.Math.Vector2D.SetXY(System.Single!System.Runtime.CompilerServices.IsConst*)">
Задание значений координат вектора по значениям через указатель на массив
<param name="iValues"> Значение компонент </param></member>
        <member name="M:RGK.Math.Vector2D.SetXY(System.Double!System.Runtime.CompilerServices.IsConst*)">
Задание значений координат вектора по значениям через указатель на массив
<param name="iValues"> Значение компонент </param></member>
        <member name="M:RGK.Math.Vector2D.SetXY(System.Double)">
Задание значений координат вектора равными переданному значению
<param name="iValue"> Значение, в которое установятся, все компоненты вектора </param></member>
        <member name="M:RGK.Math.Vector2D.SetXY(System.Double,System.Double)">
Задание значений координат вектора
<param name="iX">Координата X</param><param name="iY">Координата Y</param></member>
        <member name="M:RGK.Math.Vector2D.SetNormByLength(System.Double,System.Double)">
Нормирование вектора на заданную длину
</member>
        <member name="M:RGK.Math.Vector2D.SetNorm(System.Double,System.Double)">
Нормирование вектора на заданную длину
</member>
        <member name="M:RGK.Math.Vector2D.SetNorm(System.Double)">
Нормирование вектора на длину 1
</member>
        <member name="M:RGK.Math.Vector2D.GetNorm(System.Double)">
Нормирование вектора на длину 1
<returns>Новый объект, являющийся результатом нормирования</returns></member>
        <member name="M:RGK.Math.Vector2D.GetNormByLength(System.Double,System.Double)">
Нормирование вектора на заданную длину
<param name="iDistance">Длина нормирования вектора</param><returns>Новый объект, являющийся результатом нормирования</returns></member>
        <member name="M:RGK.Math.Vector2D.ExtProduct(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Псевдоскалярное произведение с другим вектором
</member>
        <member name="M:RGK.Math.Vector2D.DotProduct(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Скалярное произведение с другим вектором
</member>
        <member name="M:RGK.Math.Vector2D.op_Subtraction(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Вычитание векторов
<param name="iToDecr">Вектор, который вычитается из данного</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector2D.op_Addition(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сумма векторов
<param name="iToAdd">Вектор, с которым складывается данный</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector2D.op_Division(System.Double)">
Масштабирование вектора. Деление значений координат на заданное число
<param name="iLambda">Значение делителя</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector2D.op_Multiply(System.Double)">
Масштабирование вектора. Умножение значений координат на заданное число
<param name="iLambda">Значение множителя</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector2D.op_Multiply(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Скалярное произведение векторов
<param name="iToMul">Второй множитель</param><returns>Значение скалярного произведение векторов</returns></member>
        <member name="M:RGK.Math.Vector2D.op_SubtractionAssignment(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Вычитание векторов
<param name="iToDecr">Вектор, который вычитается из данного</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector2D.op_AdditionAssignment(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сумма векторов
<param name="iToAdd">Вектор, с которым складывается данный</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector2D.op_DivisionAssignment(System.Double)">
Масштабирование вектора. Деление значений координат на заданное число
<param name="iLambda">Значение делителя</param><returns>Ссылка на объект</returns></member>
        <member name="M:RGK.Math.Vector2D.op_MultiplicationAssignment(System.Double)">
Масштабирование вектора. Умножение значений координат на заданное число
<param name="iLambda">Значение множителя</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector2D.op_UnaryNegation">
Противоположный вектор. Умножение значений координат вектора на -1
<returns>Объект, являющийся противоположным вектором</returns></member>
        <member name="M:RGK.Math.Vector2D.IsComponentNaN(RGK.Math.Coordinates)">
Проверяет компоненту вектора на NaN
</member>
        <member name="M:RGK.Math.Vector2D.IsNaN">
Проверяет, что хотя бы одна координата вектора установлена в NaN
</member>
        <member name="M:RGK.Math.Vector2D.SetNaN">
Установка координат вектора в NaN
</member>
        <member name="M:RGK.Math.Vector2D.Flush">
Обнуление координат вектора
</member>
        <member name="M:RGK.Math.Vector2D.op_Subscript(System.Int32)">
Получение значения координаты вектора по индексу
<param name="idx">Индекс координаты 0 = X, 1 = Y</param><returns>Значение координаты</returns>
Получение ссылки на значение координаты вектора по индексу
<param name="idx">Индекс координаты 0 = X, 1 = Y</param><returns>Ссылка на координату</returns></member>
        <member name="M:RGK.Math.Vector2D.Vector">
Получение координат вектора в виде массива
<returns>Массив из 2 элементов, содержащий координаты X,Y</returns></member>
        <member name="M:RGK.Math.Vector2D.IsEqual(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Проверка двух векторов на равенство
<param name="iOther">Вектор, с которым сравнивается данный</param><param name="iLinearTolerance">Линейная точность, с которой производится сравнение</param><param name="iAngularTolerance">Угловая точность, с которой производится сравнение</param><returns>true если векторы равны, false если не равны</returns></member>
        <member name="M:RGK.Math.Vector2D.CompareByU(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сравнение двух векторов по координате U
</member>
        <member name="M:RGK.Math.Vector2D.CompareByV(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сравнение двух векторов по координате V
</member>
        <member name="M:RGK.Math.Vector2D.IsEqual(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Проверка двух векторов на равенство
<param name="iOther">Вектор, с которым сравнивается данный</param><param name="iLinearTolerance">Линейная точность, с которой производится сравнение</param><returns>true если векторы равны, false если не равны</returns></member>
        <member name="M:RGK.Math.Vector2D.IsEqual(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка двух векторов на равенство
<param name="iOther">Вектор, с которым сравнивается данный</param><returns>true если векторы равны, false если не равны</returns></member>
        <member name="M:RGK.Math.Vector2D.y">
Получение координаты Y
<returns>Значение координаты Y</returns></member>
        <member name="M:RGK.Math.Vector2D.x">
Получение координаты X
<returns>Значение координаты X</returns></member>
        <member name="M:RGK.Math.Vector2D.op_Assign(System.Double!System.Runtime.CompilerServices.IsConst*)">
Оператор присваивания по массиву значений
<param name="iToCopy">Массив значений координат вектора в порядке X, Y, Z. Массив должен содержать 3 элемента.</param></member>
        <member name="M:RGK.Math.Vector2D.#ctor(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор по двум векторам. Результатом является разница векторов iP2 - iP1
<param name="iP1">Первый вектор разницы</param><param name="iP1">Второй вектор разницы</param></member>
        <member name="M:RGK.Math.Vector2D.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор по вектору в пространстве (проецируется на Z = 0)
<param name="iV">Вектор в пространстве</param></member>
        <member name="M:RGK.Math.Vector2D.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*)">
Конструктор по массиву значений
<param name="iVals">Массив значений координат вектора в порядке X, Y. Массив должен содержать 2 элемента.</param></member>
        <member name="M:RGK.Math.Vector2D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*)">
Конструктор по массиву значений
<param name="iVals">Массив значений координат вектора в порядке X, Y. Массив должен содержать 2 элемента.</param></member>
        <member name="M:RGK.Math.Vector2D.#ctor(System.Double,System.Double)">
Конструктор по координатам
<param name="iX">Значение координаты X</param><param name="iY">Значение координаты Y</param></member>
        <member name="M:RGK.Math.Vector2D.#ctor">
Конструктор по умолчанию. Все координаты принимают нулевые значения.
</member>
        <member name="T:RGK.Math.Vector2D">
2D вектор
<seealso cref="!:Векторы (точки)" /></member>
        <member name="M:RGPlatform.Geometry.Size2D.Angle">
Получить угол наклона отрезка к оси X
<summary> Получить угол наклона отрезка к оси X </summary><returns> Угол наклона к оси X </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.Cy">
            <summary> Получить Y координату </summary>
            <returns> Y координата </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Size2D.Cx">
            <summary> Получить X координату </summary>
            <returns> X координата </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Size2D.op_DivisionAssignment(System.Double)">
            <summary> Оператор "/=" </summary>
Оператор покоординатного деления на число.
<param name="iVal"> Число, на которое делится размер </param><returns> Ссылка на данный размер </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_MultiplicationAssignment(System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Оператор "*=" </summary>
Оператор покоординатного умножения на число.
<param name="iVal"> Число, на которое умножается размер </param><returns> Ссылка на данный размер </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_SubtractionAssignment(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор "-=" </summary>
Оператор покоординатного вычитания.
<param name="iSize"> Объект, который вычитается из данного </param><returns> Ссылка на данный размер </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_AdditionAssignment(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор "+=" </summary>
Оператор покоординатного сложения.
<param name="iSize"> Объект, с которым складывается данный </param><returns> Ссылка на данный размер </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_Division(System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Оператор "/" </summary>
Оператор покоординатного деления на число.
<param name="iVal"> Число, на которое делится размер </param><returns> Результат деления размера на число </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_Multiply(System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Оператор "*" </summary>
Оператор покоординатного умножения на число.
<param name="iVal"> Число, на которое умножается размер </param><returns> Результат умножения размера на число </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_UnaryNegation">
            <summary> Оператор вычисления противоположного значения </summary>
Создаёт размер с противоположными значениями координат.
<returns> Противоположный размер </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_Subtraction(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор "-" </summary>
Оператор покоординатного вычитания.
<param name="iSize"> Объект, который вычитается из данного </param><returns> Разность размеров </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_Addition(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор "+" </summary>
Оператор покоординатного сложения.
<param name="iSize"> Объект, с которым складывается данный </param><returns> Сумма размеров </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.GetLength">
            <summary> Вычислить длину (диагональ) </summary>
Метод вычисляет длину радиус-вектора с координатами (_Cx, _Cy).
<returns> Вычисленная длина </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_Inequality(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор "!=" </summary>
Оператор сравнения на неравенство
<param name="iOther"> Размер, с которым сравнивается данный </param><returns> true - не равны, false - равны </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.op_Equality(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оператор "==" </summary>
Оператор сравнения на равенство
<param name="iOther"> Размер, с которым сравнивается данный </param><returns> true - равны, false - не равны </returns></member>
        <member name="M:RGPlatform.Geometry.Size2D.#ctor(RGPlatform.Geometry.Size2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конструктор копирования </summary>
            <param name="iOther"> Другой объект размера </param>
        </member>
        <member name="M:RGPlatform.Geometry.Size2D.#ctor(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конструктор по точке </summary>
            <param name="iPoint"> Точка </param>
        </member>
        <member name="M:RGPlatform.Geometry.Size2D.#ctor(System.Double,System.Double)">
            <summary> Конструктор по координатам </summary>
            <param name="iDx"> X координата </param>
            <param name="iDy"> Y координата </param>
        </member>
        <member name="M:RGPlatform.Geometry.Size2D.#ctor">
            <summary> Конструктор по умолчанию </summary>
        </member>
        <member name="T:RGPlatform.Geometry.Size2D">
            <summary> Двумерный размер </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.#ctor">
Конструктор
</member>
        <member name="M:RGPlatform.Geometry.Geometry2D.IsCoincident(RGPlatform.Geometry.Context*,std.shared_ptr&lt;RGPlatform.Geometry.Geometry2D&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка совпадения геометрических объектов
<param name="iContext">Контекст создания линии</param><param name="iGeometry">Геометрический объект, с которым выполняется сравнение</param><param name="oCoincident">Результат сравнения</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGPlatform.Geometry.Geometry2D.Transform(RGPlatform.Geometry.Context*,RGPlatform.Geometry.AffineMap2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Создать трансформированную копию объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iTransformation"> Трансформация </param>
            <returns> Трансформированная копия объекта </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.Copy(RGPlatform.Geometry.Context*)">
            <summary> Создать копию объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <returns> Копия объекта </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.EstimateRectangle(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Rectangle2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оценить ограничивающий прямоугольник </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oRect"> Вычисленная оценка ограничивающего прямоугольника </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.GetRectangle(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Rectangle2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить ограничивающий прямоугольник </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="oRect"> Вычисленный ограничивающий прямоугольник </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.GetDistance(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получение расстояния от точки до объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="oDistance"> Расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.EstimateDistance(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Оценка расстояния от точки до объекта </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPoint"> Точка, до которой вычисляется расстояние </param>
            <param name="oExact"> Флаг, определяющий является ли вычисленное приближённое расстояние точным </param>
            <param name="oDistance"> Приближённое расстояние от точки до объекта </param>
            <returns> RGK::Common::Success - в случае успеха, код ошибки - иначе </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsGeometryPoint2D">
            <summary> Получить геометрию как двумерную точку </summary>
            <returns> Указатель на объект типа Point2D </returns>
            <summary> Получить геометрию как двумерную точку </summary>
            <returns> Указатель на объект типа Point2D </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsBaseSpline2D">
            <summary> Получить геометрию как абстракнтый двумерный сплайн </summary>
            <returns> Указатель на данный объект двумерного сплайна </returns>
            <summary> Получить геометрию как двумерный сплайн </summary>
            <returns> Указатель на данный объект двумерного сплайна </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPKSpline2D">
            <summary> Получить геометрию как сплайн парасолид</summary>
            <returns> Указатель на данный объект сплайна </returns>
            <summary> Получить геометрию как сплайн парасолид</summary>
            <returns> Указатель на данный объект сплайна </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPKArc2D">
            <summary> Получить геометрию как дугу двумерного эллипса </summary>
            <returns> Указатель на данный объект дуги двумерного эллипса </returns>
            <summary> Получить геометрию как дугу двумерного эллипса </summary>
            <returns> Указатель на данный объект дуги двумерного эллипса </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPKEllipticArc2D">
            <summary> Получить геометрию как дугу двумерного эллипса </summary>
            <returns> Указатель на данный объект дуги двумерного эллипса </returns>
            <summary> Получить геометрию как дугу двумерного эллипса </summary>
            <returns> Указатель на данный объект дуги двумерного эллипса </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPKEllipse2D">
            <summary> Получить геометрию как двумерный эллипс </summary>
            <returns> Указатель на данный объект двумерного эллипса </returns>
            <summary> Получить геометрию как двумерный эллипс </summary>
            <returns> Указатель на данный объект двумерного эллипса </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPKGeometry2D">
            <summary> Получить геометрию как геометрию парасолид </summary>
            <returns> Указатель на данный объект парасолид </returns>
            <summary> Получить геометрию как геометрию парасолид </summary>
            <returns> Указатель на данный объект парасолид </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPolyVector2D">
            <summary> Получить геометрию как набор двумерных векторов </summary>
            <returns> Указатель на данный объект набора двумерных векторов </returns>
            <summary> Получить геометрию как набор двумерных векторов </summary>
            <returns> Указатель на данный объект набора двумерных векторов </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsRegion2D">
            <summary> Получить геометрию как двумерный регион </summary>
            <returns> Указатель на данный объект двумерного региона </returns>
            <summary> Получить геометрию как двумерный регион </summary>
            <returns> Указатель на данный объект двумерного региона </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsCompositeCurve2D">
            <summary> Получить геометрию как двумерную составную кривую </summary>
            <returns> Указатель на данный объект двумерной составной кривой </returns>
            <summary> Получить геометрию как двумерную составную кривую </summary>
            <returns> Указатель на данный объект двумерной составной кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsRectangle2D">
            <summary> Получить геометрию как двумерный прямоугольник </summary>
            <returns> Указатель на данный объект двумерного прямоугольника </returns>
            <summary> Получить геометрию как двумерный прямоугольник </summary>
            <returns> Указатель на данный объект двумерного прямоугольника </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsSpline2D">
            <summary> Получить геометрию как двумерный сплайн </summary>
            <returns> Указатель на данный объект двумерного сплайна </returns>
            <summary> Получить геометрию как двумерный сплайн </summary>
            <returns> Указатель на данный объект двумерного сплайна </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPolyline2D">
            <summary> Получить геометрию как двумерную ломаную </summary>
            <returns> Указатель на данный объект двумерной ломаной </returns>
            <summary> Получить геометрию как двумерную ломаную </summary>
            <returns> Указатель на данный объект двумерной ломаной </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsEllipticArc2D">
            <summary> Получить геометрию как дугу двумерного эллипса </summary>
            <returns> Указатель на данный объект дуги двумерного эллипса </returns>
            <summary> Получить геометрию как дугу двумерного эллипса </summary>
            <returns> Указатель на данный объект дуги двумерного эллипса </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsArc2D">
            <summary> Получить геометрию как дугу двумерной окружности </summary>
            <returns> Указатель на данный объект дуги двумерной окружности </returns>
            <summary> Получить геометрию как дугу двумерной окружности </summary>
            <returns> Указатель на данный объект дуги двумерной окружности </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsEllipse2D">
            <summary> Получить геометрию как двумерный эллипс </summary>
            <returns> Указатель на данный объект двумерного эллипса </returns>
            <summary> Получить геометрию как двумерный эллипс </summary>
            <returns> Указатель на данный объект двумерного эллипса </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPKLine2D">
            <summary> Получить геометрию как двумерную прямую </summary>
            <returns> Указатель на данный объект двумерной прямой </returns>
            <summary> Получить геометрию как двумерную прямую </summary>
            <returns> Указатель на данный объект двумерной прямой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPKCircle2D">
            <summary> Получить геометрию как двумерную окружность </summary>
            <returns> Указатель на данный объект двумерной окружности </returns>
            <summary> Получить геометрию как двумерную окружность </summary>
            <returns> Указатель на данный объект двумерной окружности </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsCircle2D">
            <summary> Получить геометрию как двумерную окружность </summary>
            <returns> Указатель на данный объект двумерной окружности </returns>
            <summary> Получить геометрию как двумерную окружность </summary>
            <returns> Указатель на данный объект двумерной окружности </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsLine2D">
            <summary> Получить геометрию как двумерный отрезок </summary>
            <returns> Указатель на данный объект двумерного отрезка </returns>
            <summary> Получить геометрию как двумерный отрезок </summary>
            <returns> Указатель на данный объект двумерного отрезка </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsPoint2D">
            <summary> Получить геометрию как двумерную точку </summary>
            <returns> Указатель на объект двумерной точки </returns>
            <summary> Получить геометрию как двумерную точку </summary>
            <returns> Указатель на объект двумерной точки </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.AsCurve2DGeometry">
            <summary> Получить геометрию как двумерную кривую </summary>
            <returns> Указатель на данный объект двумерной кривой </returns>
            <summary> Получить геометрию как двумерную кривую </summary>
            <returns> Указатель на данный объект двумерной кривой </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.GetType">
            <summary> Получить тип геометрии </summary>
            <returns> Тип геометрии </returns>
        </member>
        <member name="F:ParasolidType">
ParasolidCurve - кривая основанная на представлении Parasolid
</member>
        <member name="F:LineTextType">
Текст
</member>
        <member name="F:PolyVecType">
Набор векторов(штриховка)
</member>
        <member name="F:RegionType">
Регион
</member>
        <member name="F:RectangleType">
Прямоугольник
</member>
        <member name="F:CompositeCurveType">
Составная кривая
</member>
        <member name="F:PolylineType">
Ломаная
</member>
        <member name="F:SplineType">
Сплайн
</member>
        <member name="F:EllipticArcType">
Дуга эллипса
</member>
        <member name="F:ArcType">
Дуга окружности
</member>
        <member name="T:RGPlatform.Geometry.Geometry2D.Type">
            <summary> Тип геометрии </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Geometry2D.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="T:RGPlatform.Geometry.Geometry2D">
            <summary> Базовый класс двумерной геометрии </summary>
            <remarks> Класс является абстрактным </remarks>
        </member>
        <member name="F:RGPlatform.Geometry.Context._context">
Контекст вычислений RGK
</member>
        <member name="M:RGPlatform.Geometry.Context.GetUnitPrecision">
            <summary> Получить относительную точность вычислений </summary>
Используется для сравнения интервалов в параметрической области кривых и поверхностей.
Параметры различаются с точностью до погрешностей, накапливаемых из-за машинной арифметики
<returns> Относительная точность вычислений </returns></member>
        <member name="M:RGPlatform.Geometry.Context.GetAngularPrecision">
            <summary> Получить угловую точность вычислений </summary>
Используется при математических вычислениях, связанных с использованием численных методов, 
при сравнении угловых значений между собой, а также при сравнении значений углов с нулевым значением.
<returns> Угловая точность вычислений </returns></member>
        <member name="M:RGPlatform.Geometry.Context.GetLinearPrecision">
            <summary> Получить линейную точность вычислений </summary>
Используется при математических вычислениях, связанных с использованием численных методов, 
при сравнении значений между собой, а также при сравнении линейных размеров с нулевым значением.
<returns> Линейная точность вычислений </returns></member>
        <member name="M:RGPlatform.Geometry.Context.GetRGKContext">
            <summary> Получить контекст вычислений RGK </summary>
            <returns> Контекст вычислений RGK </returns>
        </member>
        <member name="M:RGPlatform.Geometry.Context.Dispose">
            <summary> Деструктор </summary>
        </member>
        <member name="M:RGPlatform.Geometry.Context.#ctor(RGK.Common.Context*)">
            <summary> Конструктор </summary>
            <param name="iRGKContext"> Контекст вычислений RGK </param>
        </member>
        <member name="D:RGPlatform.Geometry.Context.RGKContext">
Контекст вычислений RGK
</member>
        <member name="T:RGPlatform.Geometry.Context">
            <summary> Контекст геометрии </summary>
        </member>
        <member name="M:RGK.Common.MainContext.Dispose">
Деструктор
</member>
        <member name="M:RGK.Common.MainContext.#ctor(RGK.Model.Session*)">
Конструктор
<param name="iSession">Сессия</param></member>
        <member name="T:RGK.Common.MainContext">
Инструментальный класс для создания и автоматического освобождения контекста основного потока
</member>
        <member name="M:RGK.Common.ThreadContext.Dispose">
Деструктор
</member>
        <member name="M:RGK.Common.ThreadContext.#ctor(RGK.Model.Session*)">
Конструктор
<param name="iSession">Сессия</param></member>
        <member name="T:RGK.Common.ThreadContext">
Инструментальный класс для создания и автоматического освобождения контекста по завершении использования
</member>
        <member name="M:RGK.Common.UsingContext.GetContext">
Получить контекст
</member>
        <member name="M:RGK.Common.UsingContext.op_MemberSelection">
Оператор приведения объекта к типу Context
</member>
        <member name="M:RGK.Common.UsingContext.op_Implicit~RGK.Common.Context*">
Оператор приведения объекта к типу Context
</member>
        <member name="M:RGK.Common.UsingContext.Dispose">
Деструктор
</member>
        <member name="M:RGK.Common.UsingContext.#ctor(RGK.Common.Context*,System.Boolean)">
Конструктор
<param name="iContext">Контекст</param><param name="lock">Необходимость автоматической блокировки контекста непосредственно в конструкторе</param></member>
        <member name="T:RGK.Common.UsingContext">
Вспомогательный класс для использования контекста
<remarks>
Инструментальный класс для автоматического освобождения контекста по завершении использования. 
Объекты данного класса удобно создавать в виде автоматических переменных при входе в метод или функцию.
При выходе из функции или метода, при вызове деструктора объекта, контекст автоматически освобождается.
Таким образом, отпадает необходимость ручного вызова методов Lock, Unlock
</remarks></member>
        <member name="D:RGK.Common.Context.ChangeList">
Список граней
</member>
        <member name="M:RGK.Common.Context.GetChangeLog">
Получить текущий журнал изменений, в который добавляются изменения. Может возвращаться 0, если изменения не протоколируются
<returns>Текущий журнал изменений</returns></member>
        <member name="M:RGK.Common.Context.IsErrorCheckingSuppressed">
Получить состояние подавления вывода диагностики об ошибках
<returns>Подавить вывод диагностики об ошибках</returns></member>
        <member name="M:RGK.Common.Context.SuppressErrorChecking(System.Boolean)">
Подавить вывод диагностики об ошибках
<param name="iSuppress">Подавить вывод диагностики об ошибках</param><returns>Предыдущее значение</returns></member>
        <member name="M:RGK.Common.Context.Undo(RGK.Common.ContextState!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Откатить изменения в модели до метки
<param name="iState">Метка, до которой выполняется откат. Все изменения удаляются. То есть повторить изменения не получится</param></member>
        <member name="M:RGK.Common.Context.BeginChanges(RGK.Common.ContextState*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Открыть новый журнал изменений в контексте
<param name="oState">Метка текущего состояния контекста, перед началом изменений. Метка становится неактуальной(точнее переносится в сессиию) при разблокировании тел. </param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Common.Context.GetMaxThreads">
Получить максимальное количество потоков, которое может запускаться внутри ядра для данного контекста
<returns>Максимальное количество потоков, которое может запускаться внутри ядра для данного контекста</returns></member>
        <member name="M:RGK.Common.Context.SetMaxThreads(System.UInt32)">
Установить максимальное количество потоков, которое может запускаться внутри ядра для данного контекста
<param name="iMaxThreads">Максимальное количество потоков, которое может запускаться внутри ядра для данного контекста</param></member>
        <member name="M:RGK.Common.Context.UnsetLock">
Разблокировать сессию из контекста
</member>
        <member name="M:RGK.Common.Context.SetLock">
Блокировать сессию из контекста. 
Вызов функции позволяет остановить выполнение ядра в других потоках.
</member>
        <member name="M:RGK.Common.Context.GetSizeBox">
            <summary>Максимально допустимые габариты модели</summary>
Максимальные габариты модели в сессии ограничены в выбранных единицах измерения.
Стандартными единицами измерения являются метры. 
Данный метод возвращает значение, равное половине размера куба, размещённого в глобальной системе координат 
с центром в точке (0, 0, 0)
<returns>Максимально допустимые габариты модели в текущей сессии ядра</returns></member>
        <member name="M:RGK.Common.Context.GetUnitPrecision">
Относительная точность. Используется для сравнения интервалов в параметрической области кривых и поверхностей.
Параметры различаются с точностью до погрешностей, накапливаемых из-за машинной арифметики
</member>
        <member name="M:RGK.Common.Context.GetAngularPrecision">
            <summary>Угловая точность сессии ядра</summary>
Угловая точность сессии ядра используется при математических вычислениях, связанных с использованием численных методов, 
при сравнении угловых значений между собой, а также при сравнении значений углов с нулевым значением
<returns>Угловая точность вычислений в текущей сессии ядра</returns></member>
        <member name="M:RGK.Common.Context.GetLinearPrecision">
            <summary>Линейная точность сессии ядра</summary>
Линейная точность сессии ядра используется при математических вычислениях, связанных с использованием численных методов, 
при сравнении значений между собой, а также при сравнении линейных размеров с нулевым значением
<returns>Линейная точность вычислений в текущей сессии ядра</returns></member>
        <member name="M:RGK.Common.Context.UnlockParts(std.vector&lt;std.shared_ptr&lt;RGK.Model.Part&gt;,std.allocator&lt;std.shared_ptr&lt;RGK.Model.Part&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Разблокировка группы ранее заблокированных в данном контексте тел одной транзакцией
<param name="iParts">Список ранее заблокированных в данном контексте тел</param><returns>
- Result::Success в случае, если разблокировка выполнена
- Result::CannotUnlockBody Тело не было блокировано контекстом или количество разблокировок больше количества блокировок.
</returns></member>
        <member name="M:RGK.Common.Context.LockParts(std.vector&lt;std.shared_ptr&lt;RGK.Model.Part&gt;,std.allocator&lt;std.shared_ptr&lt;RGK.Model.Part&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.shared_ptr&lt;RGK.Model.Part&gt;,std.allocator&lt;std.shared_ptr&lt;RGK.Model.Part&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Блокировка группы тел одной транзакцией.
Множество модифицируемых тел и множество тел, которые используются для вычислений, не должны иметь общих элементов
<param name="iModified">Список тел, предполагаемых к модификации</param><param name="iCalculated">Список тел, используемых для вычислений</param><returns>
- Result::Success в случае, если блокировка выполнена
- Result::CannotCalculateModifiedBody тело нельзя блокировать для вычислений, так как оно заблокировано для редактирования
- Result::CannotModifyModifiedBody Тело нельзя блокировать для редактирования, так как оно заблокировано для редактирования в другом контексте.
- Result::CannotModifyCalculatedBody Тело нельзя блокировать для редактирования, так как оно заблокировано для вычислений.
</returns></member>
        <member name="M:RGK.Common.Context.CanLockParts(std.vector&lt;std.shared_ptr&lt;RGK.Model.Part&gt;,std.allocator&lt;std.shared_ptr&lt;RGK.Model.Part&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.shared_ptr&lt;RGK.Model.Part&gt;,std.allocator&lt;std.shared_ptr&lt;RGK.Model.Part&gt;&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка возможности блокировки.
Множество модифицируемых тел и множество тел, которые используются для вычислений, не должны иметь общих элементов
<param name="iModified">Список тел, предполагаемых к модификации</param><param name="iCalculated">Список тел, используемых для вычислений</param><returns>
- Result::Success в случае, если блокировка возможна
- Result::CannotCalculateModifiedBody тело нельзя блокировать для вычислений, так как оно заблокировано для редактирования
- Result::CannotModifyModifiedBody Тело нельзя блокировать для редактирования, так как оно заблокировано для редактирования в другом контексте.
- Result::CannotModifyCalculatedBody Тело нельзя блокировать для редактирования, так как оно заблокировано для вычислений.
</returns></member>
        <member name="M:RGK.Common.Context.GetSession">
Получить сессию контекста
<returns>Сессия контекста</returns></member>
        <member name="T:RGK.Common.Context">
            <summary>Контекст вычислений в модели</summary>
            <remarks>
Контекст передаётся всем функциям, работающим с моделью.
Контекст используется для решения следующих задач:
- Протоколирование изменений в модели;
- Синхронизация параллельных вычислений;
- Доступ к активному набору данных (сессии) ядра;
- Получение параметров точности и других настроек ядра;
</remarks>
            <seealso cref="!:Сессия модели и контекст" />
        </member>
        <member name="M:RGK.Common.ReferenceCounting.IsLocked">
Получение счётчика использования объекта
<returns>Текущее значение счётчика использования объекта</returns></member>
        <member name="M:RGK.Common.ReferenceCounting.Unlock">
Уменьшение счётчика использования объекта
<returns>Значение счётчика, установленное после вызова метода</returns></member>
        <member name="M:RGK.Common.ReferenceCounting.Lock">
Увеличение счётчика использования объекта
<returns>Значение счётчика, установленное после вызова метода</returns></member>
        <member name="M:RGK.Common.ReferenceCounting.Dispose">
Деструктор
</member>
        <member name="M:RGK.Common.ReferenceCounting.#ctor">
Конструктор
</member>
        <member name="T:RGK.Common.ReferenceCounting">
Класс, обеспечивающий реализацию счётчика использования объекта модели
</member>
        <member name="T:RGK.Model.Synchronization">
Класс, обеспечивающий синхронизацию для работы с телами в многопоточном режиме
<seealso cref="!:Параллельные вычисления" /></member>
        <member name="M:RGPlatform.Geometry.RGKCheckResult(RGK.Common.Result)">
"Псевдоним" функции RGK::Instance::CheckResult
</member>
        <member name="M:RGPlatform.Geometry.RGKSucceeded(RGK.Common.Result)">
"Псевдонимы" функций RGK::Common::Succeeded и RGK::Common::Failed
</member>
        <member name="D:RGPlatform.Geometry.RGKContext">
Псевдонимы типов RGK
</member>
        <member name="D:RGPlatform.Geometry.AffineMap2DPtr">
Ссылка на 2D преобразование
</member>
        <member name="D:RGPlatform.Geometry.PartReferenceVector">
Массив ссылок на тела
</member>
        <member name="D:RGPlatform.Geometry.PartReferencePtr">
Ссылка на деталь RGK
</member>
        <member name="D:RGPlatform.Geometry.Curve2DPtrArray">
Массив 2D векторов
</member>
        <member name="D:RGPlatform.Geometry.Point2DArray">
Массив 2D точке
</member>
        <member name="D:RGPlatform.Geometry.UIntArray">
Массив целых значений
</member>
        <member name="D:RGPlatform.Geometry.IntArray">
Массив целых значений
</member>
        <member name="D:RGPlatform.Geometry.DoubleArray">
Массив вещественных значений
</member>
        <member name="D:RGPlatform.Geometry.Spline2DPtr">
Ссылка на 2D сплайн
</member>
        <member name="D:RGPlatform.Geometry.Rectangle2DPtr">
Ссылка на 2D прямоугольник
</member>
        <member name="D:RGPlatform.Geometry.Polyline2DPtr">
Ссылка на 2D полилинию
</member>
        <member name="D:RGPlatform.Geometry.Line2DPtr">
Ссылка на 2D отрезок
</member>
        <member name="D:RGPlatform.Geometry.EllipticArc2DPtr">
Ссылка на 2D дугу эллипса
</member>
        <member name="D:RGPlatform.Geometry.Ellipse2DPtr">
Ссылка на 2D эллипс
</member>
        <member name="D:RGPlatform.Geometry.CompositeCurve2DPtr">
Ссылка на 2D составную кривую
</member>
        <member name="D:RGPlatform.Geometry.Circle2DPtr">
Ссылка на 2D окружность
</member>
        <member name="D:RGPlatform.Geometry.Arc2DPtr">
Ссылка на 2D дугу
</member>
        <member name="D:RGPlatform.Geometry.Curve2DGeometryPtr">
Ссылка на 2D кривую
</member>
        <member name="D:RGPlatform.Geometry.Size2DPtr">
Ссылка на 2D размер
</member>
        <member name="D:RGPlatform.Geometry.Region2DPtr">
Ссылка на 2D регион
</member>
        <member name="D:RGPlatform.Geometry.Point2DPtr">
Ссылка на 2D точку
</member>
        <member name="D:RGPlatform.Geometry.IntRectangle2DPtr">
Ссылка на 2D прямоугольник с целочисленными координатами
</member>
        <member name="D:RGPlatform.Geometry.IntPoint2DPtr">
Ссылка на 2D точку с целочисленными координатами
</member>
        <member name="D:RGPlatform.Geometry.Geometry2DPtr">
Ссылка на 2D геометрию
</member>
        <member name="T:RGPlatform.Geometry.OffsetBuilder2DOptions">
Класс настроек создания эквидистанты двумерной кривой
</member>
        <member name="T:RGPlatform.Geometry.OffsetBuilder2D">
Класс построения эквидистант двумерных кривых 
</member>
        <member name="M:RGK.Geometry.Curve.FindMinRadius(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Расcчитать минимальный радиус кривизны кривой
<param name="iContext">Контекст вычисления</param><param name="iInterval">Интервал</param><param name="iTolerance">Точность поиска</param><param name="oRadius">Радиус</param><param name="oParams">Параметр</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.IterateToNearestPoint(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить параметр точки на кривой, ближайшей к передаваемой точке
<param name="iContext">Контекст вычисления</param><param name="iPoint">Точка, для которой ищется ближайшая точка на поверхности</param><param name="iLinearTolerance">Точность, с которой ищется ближайшая точка</param><param name="oApproximationParam">Первое приближение</param><param name="oParam">Найденный параметр ближайшей точки на поверхности</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса поверхности функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.Curve._FindMinimalBoundingBox(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.LCS3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Получить наименьший (ориентированный) ограничивающий параллелепипед
для кривой на интервале в заданной (или текущей) системе координат</summary>
            <param name="iContext">Указатель на контекст вычисления</param>
            <param name="iInterval">Интервал параметров, для которого выполняется расчёт ограничивающего параллелепипеда</param>
            <param name="oBox">Результирующий ограничивающий параллелепипед для кривой</param>
            <param name="oLCS">Система координат ограничивающего параллелепипеда</param>
            <param name="iEstimate">Выполнить быструю приблизительную оценку</param>
            <returns>
- Result::NotSupported данный тип интервала не поддерживается
- Result::Success в случае успешного выполнения
</returns>
        </member>
        <member name="M:RGK.Geometry.Curve._FindBoundingBox(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
            <summary>Получить ограничивающий параллелепипед для кривой на интервале в заданной или глобальной системе координат</summary>
            <param name="iContext">Указатель на контекст вычисления</param>
            <param name="iInterval">Интервал параметров, для которого выполняется расчёт ограничивающего параллелепипеда</param>
            <param name="oBox">Результирующий ограничивающий параллелепипед для кривой</param>
            <param name="ipLCS">Система координат для поиска ограничивающего параллелепипеда</param>
            <param name="iEstimate">Выполнить быструю приблизительную оценку</param>
            <returns>
- Result::NotSupported данный тип интервала не поддерживается
- Result::Success в случае успешного выполнения
</returns>
        </member>
        <member name="M:RGK.Geometry.Curve._MakeNURBSCurve(RGK.Common.Context*,RGK.Geometry.MakeNURBSCurveData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.MakeNURBSCurveReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание NURBS-кривой, которая совпадает с кривой на интервале с заданной точностью
<param name="iContext">Контекст вычисления</param><param name="iData">Данные для интерполяции</param><param name="oReport">Результат построения</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve._FindNearestPoint(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить параметр точки на кривой, ближайшей к передаваемой точке
<param name="iContext">Контекст вычисления</param><param name="iPoint">Точка, для которой ищется ближайшая точка на кривой</param><param name="iTolerance">Точность, с которой ищется ближайшая точка</param><param name="oParam">Найденный параметр ближайшей точки на кривой</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.Curve._Parameterise(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
Определить параметр точки, лежащей на кривой
<param name="iContext">Контекст вычисления</param><param name="iPoint">Точка на кривой</param><param name="ioParam">Найденный параметр на кривой (на входе может содержать начальное приближение)</param><param name="iUseGuess">Использовать ли начальное приближение</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotOnCurve точка не лежит на кривой
- Result::NotSupported для данного класса кривой функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.Curve.IsPlanar(RGK.Common.Context*,RGK.Geometry.Curve.IsPlanarData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Curve.IsPlanarReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Проверка, что кривая или её участок является плоской</summary>
            <param name="iData">Параметры проверки</param>
            <param name="oReport">Результаты проверки</param>
            <returns>
- Result::Success в случае успешного выполнения
</returns>
        </member>
        <member name="M:RGK.Geometry.Curve.IsPlanarReport.GetLineInterval">
            <summary>Для кривой, которая лежит на прямой, возвращается соответствующий интервал на построенной прямой</summary>
            <returns>интервал на прямой</returns>
        </member>
        <member name="M:RGK.Geometry.Curve.IsPlanarReport.GetGeometry">
            <summary>Плоскость или прямая для плоского случая</summary>
            <returns>Плоскость или прямая для плоского случая</returns>
        </member>
        <member name="M:RGK.Geometry.Curve.IsPlanarReport.GetType">
            <summary>Тип кривой</summary>
            <returns>Тип кривой</returns>
        </member>
        <member name="M:RGK.Geometry.Curve.IsPlanarReport.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="F:Linear">
Кривая лежит на прямой

Линейный
</member>
        <member name="F:Planar">
Кривая лежит на плоскости
</member>
        <member name="F:NonPlanar">
Не плоская кривая
</member>
        <member name="T:RGK.Geometry.Curve.IsPlanarReport.Type">
Тип кривой
</member>
        <member name="T:RGK.Geometry.Curve.IsPlanarReport">
            <summary>Результаты проверки, что кривая или её участок является плоской</summary>
        </member>
        <member name="M:RGK.Geometry.Curve.IsPlanarData.#ctor(RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Double)">
            <summary>Конструктор для участка кривой</summary>
            <param name="iInterval">Интервал в параметрической области, задающий участок кривой</param>
            <param name="iCreate">Возвращать плоскость или прямую, если участок кривой плоский</param>
            <param name="iTolerance">Точность</param>
        </member>
        <member name="M:RGK.Geometry.Curve.IsPlanarData.#ctor(System.Boolean,System.Double)">
            <summary>Конструктор для всей кривой</summary>
            <param name="iCreate">Возвращать плоскость или прямую, если кривая плоская</param>
            <param name="iTolerance">Точность</param>
        </member>
        <member name="T:RGK.Geometry.Curve.IsPlanarData">
            <summary>Параметры проверки, что кривая или её участок является плоской</summary>
        </member>
        <member name="M:RGK.Geometry.Curve.MakeNURBSCurve(RGK.Common.Context*,RGK.Geometry.MakeNURBSCurveData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.MakeNURBSCurveReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание NURBS-кривой, которая совпадает с кривой на интервале с заданной точностью
<param name="iContext">Контекст вычисления</param><param name="iData">Данные для интерполяции</param><param name="oReport">Результат построения</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.MakeNormalOffset(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGK.Geometry.Surface!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,std.shared_ptr&lt;RGK.Geometry.Curve!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод построения эквидистанты к кривой на поверхности (по нормалям к поверхности)
<param name="iContext">Контекст вычисления</param><param name="iInterval">Входной интервал</param><param name="iSurface">Входная поверхность</param><param name="iOffset">Величина сдвига</param><param name="iTolerance">Входная точность</param><param name="oCurve">Выходная кривая</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.MakeEquidistantOnSurface(RGK.Common.Context*,RGK.Geometry.Curve.EquidistantOnSurfaceData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Curve.EquidistantOnSurfaceReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод построения эквидистанты к кривой на поверхности
<param name="iContext">Контекст вычисления</param><param name="iData">Параметры построения эквидистантной поверхности</param><param name="oReport">Результат построения</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.EquidistantOnSurfaceReport.GetParametersOnCurve(System.UInt32)">
Получить интервал эквидистантной кривой
<param name="iIndex">Индекс кривой</param></member>
        <member name="M:RGK.Geometry.Curve.EquidistantOnSurfaceReport.GetEquidistantCurve(System.UInt32)">
Получить эквидистантную кривую
<param name="iIndex">Индекс кривой</param></member>
        <member name="M:RGK.Geometry.Curve.EquidistantOnSurfaceReport.GetEquidistantCurvesCount">
Получить количество эквидистантных кривых
<returns>
- Количество кривых
</returns></member>
        <member name="M:RGK.Geometry.Curve.EquidistantOnSurfaceReport.Dispose">
Деструктор
</member>
        <member name="M:RGK.Geometry.Curve.EquidistantOnSurfaceReport.#ctor">
Конструктор
</member>
        <member name="T:RGK.Geometry.Curve.EquidistantOnSurfaceReport">
            <summary>Отчёт построения эквидистантной кривой</summary>
        </member>
        <member name="M:RGK.Geometry.Curve.EquidistantOnSurfaceData.Dispose">
Деструктор
</member>
        <member name="M:RGK.Geometry.Curve.EquidistantOnSurfaceData.#ctor(std.shared_ptr&lt;RGK.Generators.ScalarLaw&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGK.Geometry.Surface!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Curve.EquidistantOnSurfaceData.OffsetMethod,System.Double,RGK.Geometry.Curve.EquidistantOnSurfaceData.OffsetSide)">
Конструктор
<param name="iOffsetLaw">Кривая, задающая по X-компоненте переменную величину смещения. Параметризация кривой, для которой строится смещение, и кривой закона совпадают на интервале, на котором строится смещение</param><param name="iInterval">Параметрический интервал кривой, для которого строится смещение</param><param name="iSurface">Поверхность, по которой строится смещение</param><param name="iMethod">Метод смещения. По умолчанию, по геодезической линии</param><param name="iTolerance">Запрашиваемая точность построения эквидистанты. По умолчанию, 1.0e-5</param><param name="iSide">Выбираемая сторона. По умолчанию, Left</param></member>
        <member name="M:RGK.Geometry.Curve.EquidistantOnSurfaceData.#ctor(System.Double,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGK.Geometry.Surface!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Curve.EquidistantOnSurfaceData.OffsetMethod,System.Double,RGK.Geometry.Curve.EquidistantOnSurfaceData.OffsetSide)">
Конструктор
<param name="iOffset">Положительная величина смещения</param><param name="iInterval">Параметрический интервал кривой, для которого строится смещение</param><param name="iSurface">Поверхность, по которой строится смещение</param><param name="iMethod">Метод смещения. По умолчанию, по геодезической линии</param><param name="iTolerance">Запрашиваемая точность построения эквидистанты. По умолчанию, 1.0e-5</param><param name="iSide">Выбираемая сторона. По умолчанию, Left</param></member>
        <member name="F:Right">
Направление определяется векторным произведением касательной к кривой и нормалью к плоскости
</member>
        <member name="F:Left">
Направление определяется векторным произведением нормали к плоскости и касательной к кривой
</member>
        <member name="T:RGK.Geometry.Curve.EquidistantOnSurfaceData.OffsetSide">
Направление смещения
</member>
        <member name="F:ArcLength">
По длине кривой, образованной пересечением нормальной плоскости с поверхностью
</member>
        <member name="F:Geodesic">
По геодезической линии
</member>
        <member name="T:RGK.Geometry.Curve.EquidistantOnSurfaceData.OffsetMethod">
Метод смещения
</member>
        <member name="T:RGK.Geometry.Curve.EquidistantOnSurfaceData">
            <summary>Параметры построения эквидистантной кривой</summary>
        </member>
        <member name="M:RGK.Geometry.Curve.FindLength(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean,System.Int32)">
Получить длину кривой
<param name="iContext">Контекст вычисления</param><param name="iInterval">Параметрический интервал кривой, на котором считается длина</param><param name="iTolerance">Запрашиваемая точность вычисления длины</param><param name="oLength">Найденная длина</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.FindSelfIntersections(RGK.Common.Context*,RGK.Geometry.Curve.SelfIntersectionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Curve.IntersectReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Найти самопересечения кривой на заданном параметрическом интервале
<param name="iContext">Контекст вычисления</param><param name="iData">Данные для пересечения кривых</param><param name="oReport">Результат поиска самопересечений</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.SelfIntersectionData.Dispose">
Деструктор
</member>
        <member name="M:RGK.Geometry.Curve.SelfIntersectionData.#ctor(std.shared_ptr&lt;RGK.Geometry.Curve!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Конструктор
<param name="iCurve">Кривая</param><param name="iInterval">Параметрический интервал кривой, на котором выполняется поиск самопересечений</param><param name="iTolerance">Точность вычисления самопересечения</param></member>
        <member name="T:RGK.Geometry.Curve.SelfIntersectionData">
Данные для самопересечения кривой
</member>
        <member name="M:RGK.Geometry.Curve.IntersectCurve(RGK.Common.Context*,RGK.Geometry.Curve.IntersectData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Curve.IntersectReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Найти пересечение кривых на заданных параметрических интервалах
<param name="iContext">Контекст вычисления</param><param name="iData">Данные для пересечения кривых</param><param name="oReport">Результат поиска пересечений</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.IntersectReport.GetSolutionTolerance">
Получить точность пересечения
<returns>Точность пересечения</returns></member>
        <member name="M:RGK.Geometry.Curve.IntersectReport.GetTypeOfIntersection(System.UInt32)">
Получить тип точки пересечения
<param name="iIndex">Номер точки пересечения</param><returns>Тип точки пересечения</returns></member>
        <member name="F:EndOfCoincidence">
Конец интервала совпадения кривых

Конец интервала совпадения кривых
</member>
        <member name="F:StartOfCoincidence">
Начало интервала совпадения кривых

Начало интервала совпадения кривых
</member>
        <member name="F:TangentIntersection">
Касание кривых в точке пересечения

Касание кривых в точке пересечения
</member>
        <member name="F:SimpleIntersection">
Простое пересечение

Простое пересечение
</member>
        <member name="T:RGK.Geometry.Curve.IntersectReport.Type">
Тип пересечения
</member>
        <member name="M:RGK.Geometry.Curve.IntersectReport.GetParametersOnCurve2(System.UInt32)">
Получить параметр в точке пересечения для второй кривой
<param name="iIndex">Номер точки пересечения</param><returns>Параметр в точке пересечения для второй кривой</returns></member>
        <member name="M:RGK.Geometry.Curve.IntersectReport.GetParametersOnCurve1(System.UInt32)">
Получить параметр в точке пересечения для первой кривой
<param name="iIndex">Номер точки пересечения</param><returns>Параметр в точке пересечения для первой кривой</returns></member>
        <member name="M:RGK.Geometry.Curve.IntersectReport.GetIntersectionPoint(System.UInt32)">
Получить точку пересечения по индексу
<param name="iIndex">Номер точки пересечения</param><returns>Точка пересечения</returns></member>
        <member name="M:RGK.Geometry.Curve.IntersectReport.GetIntersectionCount">
Получить количество пересечений
<returns>Количество пересечений</returns></member>
        <member name="M:RGK.Geometry.Curve.IntersectReport.Dispose">
Деструктор
</member>
        <member name="M:RGK.Geometry.Curve.IntersectReport.#ctor">
Конструктор
</member>
        <member name="T:RGK.Geometry.Curve.IntersectReport">
            <summary>Результат поиска пересечений</summary>
        </member>
        <member name="M:RGK.Geometry.Curve.IntersectData.SetSurface(std.shared_ptr&lt;RGK.Geometry.Surface!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Задать поверхность, на которой лежат обе кривые
<param name="iSurface">Поверхность, на которой лежат обе кривые</param></member>
        <member name="M:RGK.Geometry.Curve.IntersectData.SetBox(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Задать ограничения на область поиска пересечений
<param name="iBox">Ограничения на область поиска пересечений</param></member>
        <member name="M:RGK.Geometry.Curve.IntersectData.Dispose">
Деструктор
</member>
        <member name="M:RGK.Geometry.Curve.IntersectData.#ctor(std.shared_ptr&lt;RGK.Geometry.Curve!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGK.Geometry.Curve!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Конструктор
<param name="iCurve1">Первая пересекаемая кривая</param><param name="iInterval">Параметрический интервал первой кривой, на котором выполняется поиск пересечений</param><param name="iCurve2">Вторая пересекаемая кривая</param><param name="iInterva2">Параметрический интервал второй кривой, на котором выполняется поиск пересечений</param><param name="iTolerance">Точность вычисления пересечения</param></member>
        <member name="T:RGK.Geometry.Curve.IntersectData">
Данные для пересечения кривых
</member>
        <member name="M:RGK.Geometry.Curve.FindInterval(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,RGK.Geometry.Interval*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Определить интервал на кривой по двум точкам
<param name="iContext">Контекст вычисления</param><param name="iPoint1">Первая точка</param><param name="iPoint2">Вторая точка</param><param name="iTolerance">Точность положения точки на кривой</param><param name="oInterval">Найденный интервал</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.FindNearestPoint(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить параметр точки на кривой, ближайшей к передаваемой точке
<param name="iContext">Контекст вычисления</param><param name="iPoint">Точка, для которой ищется ближайшая точка на кривой</param><param name="iTolerance">Точность, с которой ищется ближайшая точка</param><param name="oParam">Найденный параметр ближайшей точки на кривой</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.Curve.Transform(RGK.Common.Context*,RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,std.shared_ptr&lt;RGK.Geometry.Geometry!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание копии геометрии с применением аффинного преобразования
<param name="iContext">Контекст создания линии</param><param name="iMap">Аффинное преобразование</param><param name="iTolerance">Допустимая точность преобразований</param><param name="oCopy">Возвращается трансформированная геометрия</param><param name="oExact">Возвращается true-для точного преобразования</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Curve.Parameterise(RGK.Common.Context*,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
Определить параметр точки, лежащей на кривой
<param name="iContext">Контекст вычисления</param><param name="iPoint">Точка на кривой</param><param name="ioParam">Найденный параметр на кривой (на входе может содержать начальное приближение)</param><param name="iUseGuess">Использовать ли начальное приближение</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotOnCurve точка не лежит на кривой
- Result::NotSupported для данного класса кривой функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.Curve.FindMinimalBoundingBox(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.LCS3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary>Получить наименьший (ориентированный) ограничивающий параллелепипед
для кривой на интервале в заданной (или текущей) системе координат</summary>
            <param name="iContext">Указатель на контекст вычисления</param>
            <param name="iInterval">Интервал параметров, для которого выполняется расчёт ограничивающего параллелепипеда</param>
            <param name="oBox">Результирующий ограничивающий параллелепипед для кривой</param>
            <param name="oLCS">Система координат ограничивающего параллелепипеда</param>
            <param name="iEstimate">Выполнить быструю приблизительную оценку</param>
            <returns>
- Result::NotSupported данный тип интервала не поддерживается
- Result::Success в случае успешного выполнения
</returns>
        </member>
        <member name="M:RGK.Geometry.Curve.FindBoundingBox(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*,System.Boolean)">
            <summary>Получить ограничивающий параллелепипед для кривой на интервале в заданной или глобальной системе координат</summary>
            <param name="iContext">Указатель на контекст вычисления</param>
            <param name="iInterval">Интервал параметров, для которого выполняется расчёт ограничивающего параллелепипеда</param>
            <param name="oBox">Результирующий ограничивающий параллелепипед для кривой</param>
            <param name="ipLCS">Система координат для поиска ограничивающего параллелепипеда</param>
            <param name="iEstimate">Выполнить быструю приблизительную оценку</param>
            <returns>
- Result::NotSupported данный тип интервала не поддерживается
- Result::Success в случае успешного выполнения
</returns>
        </member>
        <member name="M:RGK.Geometry.Curve.OutputPoints(RGK.Common.Context*,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Curve.OutputPointsOptions!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Адаптивный алгоритм расчёта точек на кривой с учётом параметров точности
<param name="iContext">Контекст вычисления</param><param name="iInterval">Интервал, на котором выполняется расчёт точек</param><param name="iOptions">Параметры разбиения</param><param name="oPoints">Массив насчитанных точек</param><param name="oParams">Массив параметров, в которых насчитаны точки</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
- Result::NotConverged ошибка сходимости алгоритма (вероятна ошибка в реализации функции Evaluate)
</returns></member>
        <member name="M:RGK.Geometry.Curve.OutputPointsOptions.#ctor(RGK.Common.FacetParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <param name="iChordalTolerance">Максимальное расстояние между кривой и хордой</param>
            <param name="iAngularTolerance">Максимально допустимое угловое уклонение</param>
            <param name="iChordalMaximumLength">Максимально допустимая длина хорды</param>
            <param name="iGeneral">Использовать общий алгоритм разбиения</param>
        </member>
        <member name="T:RGK.Geometry.Curve.OutputPointsOptions">
Класс постановки задачи для адаптивного алгоритма расчёта точек на кривой с учётом параметров точности
</member>
        <member name="M:RGK.Geometry.Curve.EvaluateCurvature(RGK.Common.Context*,System.Double,RGK.Math.Vector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить значение кривизны по параметру iU
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляется кривизна</param><param name="oCurvature">Значение вычисленной кривизны</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::ZeroVector значение первой производной меньше системной точности
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.Curve.EvaluateNormal(RGK.Common.Context*,System.Double,RGK.Math.Vector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить значение нормали по параметру iU
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляется нормаль</param><param name="oDerivative">Значение вычисленной нормали</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::NormalIsNotSignificant очень маленькая кривизна в точке. Радиус кривизны не определяется
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.Curve.EvaluateTangent(RGK.Common.Context*,System.Double,RGK.Math.Vector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить значение касательной по параметру iU
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляется касательная</param><param name="oDerivative">Значение вычисленной касательной</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.Curve.EvaluatePoint(RGK.Common.Context*,System.Double,RGK.Math.Vector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить значение кривой по параметру iU
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляются координаты точки на кривой</param><param name="oPoint">Значение вычисленной точки</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.Curve.EvaluatePoints(RGK.Common.Context*,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить координаты точки и все производные по параметру кривой. Пакетный расчёт производных
<param name="iContext">Контекст вычисления</param><param name="iU">Параметры на кривой, в которых вычисляются производные</param><param name="iMaxDerivOrder">Максимальный порядок рассчитываемых производных</param><param name="oDerivatives">Значения вычисленных производных</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.Curve.Evaluate(RGK.Common.Context*,System.Double,System.UInt32,std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить координаты точки и все производные по параметру кривой. Пакетный расчёт производных
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляются производные</param><param name="iMaxDerivOrder">Максимальный порядок рассчитываемых производных</param><param name="oDerivatives">Значения вычисленных производных</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.Curve.Evaluate(RGK.Common.Context*,System.Double,System.UInt32,RGK.Math.Vector3D*)">
Получить координаты точки и все производные по параметру кривой. Пакетный расчёт производных
<param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляются производные</param><param name="iMaxDerivOrder">Максимальный порядок рассчитываемых производных</param><param name="oDerivatives">Значения вычисленных производных (массив векторов размера не менее iMaxDerivOrder+1)</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.Curve.Evaluate(RGK.Common.Context*,System.Double,System.UInt32,RGK.Math.Vector3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить значение производной (iDerivOrder) кривой по параметру iU
<summary>В базовом классе метод реализован на основе сплайн-представления</summary><param name="iContext">Контекст вычисления</param><param name="iU">Параметр на кривой, в котором вычисляется производная</param><param name="iDerivOrder">Порядок производной (&gt;=0)</param><param name="oDerivative">Значение вычисленной производной</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported для данного класса кривой функциональность не реализована
- Result::BadParameter параметр за границами параметрической области.
- Result::NullPointer недопустимая передача нулевого указателя
</returns></member>
        <member name="M:RGK.Geometry.Curve.GetInterval(RGK.Geometry.Interval*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить параметры границы кривой
<summary>В базовом классе метод реализован на основе сплайн-представления</summary><param name="oInterval">Интервал</param><returns>
- Result::Success в случае успешного выполнения
- Result::NotSupported - для данного класса кривой функциональность не реализована
</returns></member>
        <member name="M:RGK.Geometry.Curve.IsCurve">
Проверить, является ли объект кривой
<returns>true если объект является кривой</returns></member>
        <member name="T:RGK.Geometry.Curve">
Класс кривой
<seealso cref="!:Геометрия" /><seealso cref="!:Кривая" /></member>
        <member name="M:RGK.Common.FacetParameters.GetMeshGeneratorType">
Получить тип сетки
<returns>Тип сетки</returns></member>
        <member name="M:RGK.Common.FacetParameters.SetMeshGeneratorType(RGK.Generators.Faceter.MeshGeneratorType)">
Установить тип сетки
<param name="iMeshGeneratorType">Тип сетки</param></member>
        <member name="M:RGK.Common.FacetParameters.Set(System.Double,System.Double,System.Double)">
Установить параметры точности 
<param name="iLinearTolerance">Максимально допустимое линейное уклонение </param><param name="iAngularTolerance">Максимально допустимое угловое уклонение </param><param name="iChodalMaximumLength">Максимально допустимая длина хорды </param></member>
        <member name="M:RGK.Common.FacetParameters.GetChordalMaximumLength">
Получить максимально допустимую длину хорды
<returns>Максимально допустимая длина хорды</returns></member>
        <member name="M:RGK.Common.FacetParameters.GetAngularTolerance">
Получить максимально допустимое угловое уклонение
<returns>Максимально допустимое угловое уклонение</returns></member>
        <member name="M:RGK.Common.FacetParameters.GetLinearTolerance">
Получить максимально допустимое линейное уклонение
<returns>Максимально допустимое линейное уклонение</returns></member>
        <member name="M:RGK.Common.FacetParameters.#ctor(System.Double,System.Double,System.Double,RGK.Generators.Faceter.MeshGeneratorType)">
Метод устанавливает точность расчёта сетки
<param name="iBody">Тело, для которого необходимо рассчитывать масс-инерционные характеристики </param><param name="iLinearTolerance">Максимально допустимое линейное уклонение</param><param name="iAngularTolerance">Максимально допустимое угловое уклонение</param><param name="iChordalMaximumLength">Максимально допустимая длина хорды</param></member>
        <member name="T:RGK.Common.FacetParameters">
            <summary>Параметры расчёта сетки</summary>
Объекты данного класса используются для задания параметров точности при генерации плоскогранной аппроксимации 
тел и других элементов модели
<seealso cref="!:Генерация плоскогранной модели" /></member>
        <member name="M:RGK.Generators.AngularToleranceFaceError.#ctor(std.shared_ptr&lt;RGK.Mesh.SurfaceMesh&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="iMesh">Сетка</param></member>
        <member name="M:RGK.Generators.AngularToleranceFaceError.MakeBorder(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить треугольник в виде углов
<param name="oBorder">Полилиния</param></member>
        <member name="M:RGK.Generators.AngularToleranceFaceError.GetFace">
Получить грань, на которой есть "плохой" треугольник
</member>
        <member name="M:RGK.Generators.AngularToleranceFaceError.GetType">
Получить тип ошибки
<returns>Тип ошибки</returns></member>
        <member name="T:RGK.Generators.AngularToleranceFaceError">
            <summary>Класс ошибки, связанной с превышением максимально допустимого углового уклонения внутри параметрической области треугольника</summary>
Класс ошибки, связанной с превышением максимально допустимого углового уклонения внутри параметрической области треугольника
</member>
        <member name="M:RGK.Generators.AngularToleranceFaceFaceError.#ctor(std.shared_ptr&lt;RGK.Mesh.SurfaceMesh&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="iMesh">Сетка</param></member>
        <member name="M:RGK.Generators.AngularToleranceFaceFaceError.MakeBorder2(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить второй треугольник в виде углов
<param name="oBorder">Полилиния</param></member>
        <member name="M:RGK.Generators.AngularToleranceFaceFaceError.MakeBorder1(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить первый треугольник в виде углов
<param name="oBorder">Полилиния</param></member>
        <member name="M:RGK.Generators.AngularToleranceFaceFaceError.GetFace">
Получить грань, на которой есть "плохие" треугольники
</member>
        <member name="M:RGK.Generators.AngularToleranceFaceFaceError.GetType">
Получить тип ошибки
<returns>Тип ошибки</returns></member>
        <member name="T:RGK.Generators.AngularToleranceFaceFaceError">
            <summary>Класс ошибки, связанной с превышением максимально допустимого углового уклонения между соседними треугольниками</summary>
Класс ошибки, связанной с превышением максимально допустимого углового уклонения между соседними треугольниками
</member>
        <member name="M:RGK.Generators.LinearToleranceFaceError.#ctor(std.shared_ptr&lt;RGK.Mesh.SurfaceMesh&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="iMesh">Сетка</param></member>
        <member name="M:RGK.Generators.LinearToleranceFaceError.MakeBorder(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить треугольник в виде углов
<param name="oBorder">Полилиния</param></member>
        <member name="M:RGK.Generators.LinearToleranceFaceError.GetFace">
Получить грань, на которой есть "плохой" треугольник
</member>
        <member name="M:RGK.Generators.LinearToleranceFaceError.GetType">
Получить тип ошибки
<returns>Тип ошибки</returns></member>
        <member name="T:RGK.Generators.LinearToleranceFaceError">
            <summary>Класс ошибки, связанной с превышением максимально допустимого расстояния между треугольником и поверхностью</summary>
Класс ошибки, связанной с превышением максимально допустимого расстояния между треугольником и поверхностью
</member>
        <member name="M:RGK.Generators.ChordLengthEdgeError.#ctor(std.shared_ptr&lt;RGK.Mesh.SurfaceMesh&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="iMesh">Сетка</param></member>
        <member name="M:RGK.Generators.ChordLengthEdgeError.MakeBorder(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить длинную сторону
<param name="oBorder">Полилиния</param></member>
        <member name="M:RGK.Generators.ChordLengthEdgeError.GetFace">
Получить грань, на которой есть треугольник с длинной стороной
</member>
        <member name="M:RGK.Generators.ChordLengthEdgeError.GetType">
Получить тип ошибки
<returns>Тип ошибки</returns></member>
        <member name="T:RGK.Generators.ChordLengthEdgeError">
            <summary>Класс ошибки, связанной с превышением максимально допустимой длины стороны треугольника</summary>
Класс ошибки, связанной с превышением максимально допустимой длины стороны треугольника
</member>
        <member name="M:RGK.Generators.DegeneratedFaceError.#ctor(std.shared_ptr&lt;RGK.Mesh.SurfaceMesh&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="oBorder">Сетка</param></member>
        <member name="M:RGK.Generators.DegeneratedFaceError.MakeBorder(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить треугольник в виде углов
<param name="oBorder">Полилиния</param></member>
        <member name="M:RGK.Generators.DegeneratedFaceError.GetFace">
Получить грань, на которой есть вырожденный треугольник
</member>
        <member name="M:RGK.Generators.DegeneratedFaceError.GetType">
Получить тип ошибки
<returns>Тип ошибки</returns></member>
        <member name="T:RGK.Generators.DegeneratedFaceError">
            <summary>Класс ошибки, связанной с вырождением треугольника</summary>
Класс ошибки, связанной с вырождением треугольника
</member>
        <member name="M:RGK.Generators.SelfIntersectionError.#ctor(std.shared_ptr&lt;RGK.Mesh.SurfaceMesh&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="iMesh">Сетка</param></member>
        <member name="M:RGK.Generators.SelfIntersectionError.MakeBorder(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Получить описание границ двх пересекающихся треугольников
<param name="oBorder">Полилиния</param><param name="tIndex">Номер треугольника пересекающегося(1 или 2) </param></member>
        <member name="M:RGK.Generators.SelfIntersectionError.IsComplanar">
ПроверкаЮ что треугольники не пересекаются, а перекрываются друг другом
</member>
        <member name="M:RGK.Generators.SelfIntersectionError.GetTriangles(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить треугольники образающие пересечение 
</member>
        <member name="M:RGK.Generators.SelfIntersectionError.GetType">
Получить тип ошибки
<returns>Тип ошибки</returns></member>
        <member name="T:RGK.Generators.SelfIntersectionError">
            <summary>Класс ошибки, связанной с дырками на сетке</summary>
Класс ошибки, связанной с дырками на сетке
</member>
        <member name="M:RGK.Generators.HoleError.#ctor(std.shared_ptr&lt;RGK.Mesh.SurfaceMesh&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="iMesh">Сетка</param></member>
        <member name="M:RGK.Generators.HoleError.MakeBorder(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить дырку в виде набора точек, образующих край дырки
<param name="oBorder">Полилиния</param></member>
        <member name="M:RGK.Generators.HoleError.GetFace">
Получить грань, на которой есть дырки
</member>
        <member name="M:RGK.Generators.HoleError.GetType">
Получить тип ошибки
<returns>Тип ошибки</returns></member>
        <member name="T:RGK.Generators.HoleError">
            <summary>Класс ошибки, связанной с дырками на сетке</summary>
Класс ошибки, связанной с дырками на сетке
</member>
        <member name="M:RGK.Generators.Faceter.Report.CheckReport.GetErrors">
Получить вектор ошибок
<returns>Вектор ошибок</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckReport.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.Faceter.Report.CheckReport.#ctor">
Конструктор
</member>
        <member name="T:RGK.Generators.Faceter.Report.CheckReport">
Результаты проверки
</member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetFaceterData">
Получить параметры сеточного разбиения
<returns>Параметры сеточного разбиения</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetFaceterData(RGK.Generators.Faceter.Data!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Установка параметров сеточного разбиения
<param name="iFacetParameters">Параметры сеточного разбиения</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetCheckAngularTolerance">
Получить флаг проверки, что угловое уклонение внутри параметрической области треугольника не больше максимально допустимого
<returns>Флаг проверки, что угловое уклонение внутри параметрической области треугольника не больше максимально допустимого</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetCheckAngularTolerance(System.Boolean)">
Установка флага проверки, что угловое уклонение внутри параметрической области треугольника не больше максимально допустимого
<param name="iCheck">Флаг проверки, что угловое уклонение внутри параметрической области треугольника не больше максимально допустимого</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetCheckSideAngularTolerance">
Получить флаг проверки, что угловое уклонение между соседними треугольниками одной грани не больше максимально допустимого
<returns>Флаг проверки, что угловое уклонение между соседними треугольниками одной грани не больше максимально допустимого</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetCheckSideAngularTolerance(System.Boolean)">
Установка флага проверки, что угловое уклонение между соседними треугольниками одной грани не больше максимально допустимого
<param name="iCheck">Флаг проверки, что угловое уклонение между соседними треугольниками одной грани не больше максимально допустимого</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetCheckLinearTolerance">
Получить флаг проверки, что расстояние между треугольником и поверхностью не больше максимально допустимого
<returns>Флаг проверки, что расстояние между треугольником и поверхностью не больше максимально допустимого</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetCheckLinearTolerance(System.Boolean)">
Установка флага проверки, что расстояние между треугольником и поверхностью не больше максимально допустимого
<param name="iCheck">Флаг проверки, что расстояние между треугольником и поверхностью не больше максимально допустимого</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetCheckChordalMaximumLength">
Получить флаг проверки, что длина стороны треугольника не больше максимально допустимой
<returns>Флаг проверки, что длина стороны треугольника не больше максимально допустимой</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetCheckChordalMaximumLength(System.Boolean)">
Установка флага проверки, что длина стороны треугольника не больше максимально допустимой
<param name="iCheck">Флаг проверки, что длина стороны треугольника не больше максимально допустимой</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetCheckIntersection">
Получить флаг проверки пересечения треугольников в UV-области
<returns>Флаг проверки пересечения треугольников в UV-области</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetCheckIntersection(System.Boolean)">
Установка флага проверки пересечения треугольников в UV-области
<param name="iCheck">Флаг проверки пересечения треугольников в UV-области</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetDegeneracyParameters(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить параметры проверки вырожденных треугольников
<param name="oArea">Минимально допустимая площадь треугольника</param><param name="oUVArea">Минимально допустимая площадь треугольника в UV</param><param name="oAngle">Минимально допустимый угол</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetDegeneracyParameters(System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
Установка параметров проверки вырожденных треугольников
<param name="iArea">Минимально допустимая площадь треугольника</param><param name="iUVArea">Минимально допустимая площадь треугольника в UV</param><param name="iAngle">Минимально допустимый угол</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetCheckDegeneratedFaces">
Получить флаг проверки вырожденных треугольников
<returns>Флаг проверки вырожденных треугольников</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetCheckDegeneratedFaces(System.Boolean)">
Установка флага проверки вырожденных треугольников
<param name="iCheck">Флаг проверки вырожденных треугольников</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetCheckSelfIntersections">
Получить флаг проверки на самопересечения
<returns>Флаг проверки самопересечений</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetCheckSelfIntersection(System.Boolean)">
Установка флага проверки дырок
<param name="iCheck">Флаг проверки дырок</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.GetCheckHoles">
Получить флаг проверки дырок
<returns>Флаг проверки дырок</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.SetCheckHoles(System.Boolean)">
Установка флага проверки дырок
<param name="iCheck">Флаг проверки дырок</param></member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.#ctor(System.Double,System.Double,System.Double)">
Конструктор
</member>
        <member name="M:RGK.Generators.Faceter.Report.CheckData.#ctor">
Конструктор по умолчанию
</member>
        <member name="T:RGK.Generators.Faceter.Report.CheckData">
Данные для проверки
</member>
        <member name="F:RGK.Generators.MeshError._mesh">
Данные триангуляции
</member>
        <member name="M:RGK.Generators.MeshError.#ctor(std.shared_ptr&lt;RGK.Mesh.SurfaceMesh&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="iMesh">Сетка</param></member>
        <member name="M:RGK.Generators.MeshError.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.MeshError.GetType">
Получить тип ошибки
<returns>Тип ошибки</returns></member>
        <member name="F:TriangleIntersections">
Пересечение треугольников
</member>
        <member name="F:AngularToleranceFace">
Угловое уклонение внутри параметрической области треугольника больше максимально допустимого
</member>
        <member name="F:AngularToleranceFaceFace">
Угловое уклонение между соседними треугольниками одной грани больше максимально допустимого
</member>
        <member name="F:LinearToleranceFace">
Расстояние между треугольником и поверхностью больше максимально допустимого
</member>
        <member name="F:ChordLengthEdge">
Длина стороны треугольника больше максимально допустимой
</member>
        <member name="F:DegeneratedFace">
Вырожденный треугольник
</member>
        <member name="F:Hole">
Дыра в сетке
</member>
        <member name="T:RGK.Generators.MeshError.ErrorType">
Тип ошибки
</member>
        <member name="T:RGK.Generators.MeshError">
            <summary>Класс ошибки, выявленной при проверке сетки</summary>
        </member>
        <member name="F:RGK.Generators.Faceter.Report._errorStage">
Стадия, на которой произошла ошибка
</member>
        <member name="F:RGK.Generators.Faceter.Report._retCode">
Результат работы генератора
</member>
        <member name="F:RGK.Generators.Faceter.Report._mesh">
Данные триангуляции
</member>
        <member name="M:RGK.Generators.Faceter.Report.BuildMeshData(RGK.Common.Context*,RGK.Generators.BufferedMeshData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*,System.Boolean)">
Это сделано для того, чтобы в классе были только методы интерпретации данных для пользователей без примеси методов модификации для генератора.
</member>
        <member name="M:RGK.Generators.Faceter.Report.Check(RGK.Common.Context*,RGK.Generators.Faceter.Report.CheckData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Generators.Faceter.Report.CheckReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка корректности сетки
<param name="iData">Данные для проверки</param><param name="oReport">Результат проверки</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.GetMeshPtr">
Получить ссылку на внутреннее представление триангуляции
</member>
        <member name="M:RGK.Generators.Faceter.Report.GetMesh">
Получить ссылку на внутреннее представление триангуляции
</member>
        <member name="M:RGK.Generators.Faceter.Report.BuildMeshData(RGK.Common.Context*,RGK.Generators.BufferedMeshData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конвертация сетки в формат хранения типизированных буферов
<param name="ioData">Информация о буферах, в которые пишется сетка</param><returns>
- Result::Success в случае успешного выполнения
- Result::MemoryFull в случае, если не удалось выделить запрошенный объём памяти
</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.BuildMeshData(RGK.Common.Context*,RGK.Generators.BufferedMeshData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конвертация сетки в формат хранения типизированных буферов
<param name="ioData">Информация о буферах, в которые пишется сетка</param><param name="oBounds">Ограничивающий параллелепипед</param><returns>
- Result::Success в случае успешного выполнения
- Result::MemoryFull в случае, если не удалось выделить запрошенный объём памяти
</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.GetErrorStage">
Получить стадию, на которой произошла ошибка
<returns>Номер стадии</returns></member>
        <member name="M:RGK.Generators.Faceter.Report.ResetRetCode(RGK.Generators.Faceter.Report.RetCode,System.UInt32)">
Установить результат построения сетки
<param name="iRetCode">Результат построения сетки</param><param name="iErrorStage">Номер стадии, на котором произошла ошибка</param></member>
        <member name="M:RGK.Generators.Faceter.Report.GetRetCode">
Получить результат построения сетки
<returns>Результат построения сетки</returns></member>
        <member name="F:DegenerateUVPolygon">
Вырожденный (не разбиваемый однозначно на треугольники) многоугольник в uv-области 
</member>
        <member name="F:ZeroArealUVPolygon">
Многоугольник нулевой площади в uv-области
</member>
        <member name="F:WrongOrientedUVPolygon">
Неверно ориентированный многоугольник в uv-области 
</member>
        <member name="F:SelfintersectingUVPolygon">
Самопересекающийся многоугольник в uv-области
</member>
        <member name="F:OpenUVPolygon">
Незамкнутый многоугольник в uv-области
</member>
        <member name="F:MeshVertexCoincidence">
В сетке имеются совпадающие вершины 
</member>
        <member name="F:CouldNotDetermineUvBox">
Как минимум на одной грани не определён uv-бокс
</member>
        <member name="F:TooShortEdge">
Слишком короткое ребро (длина менее контекстной точности)
</member>
        <member name="F:LongerThanPeriod">
Длина цикла на грани больше периода грани (грань не разрезана)
</member>
        <member name="F:NoSurface">
В текущей модели не определена как минимум одна поверхность
</member>
        <member name="F:NoTopolCoEdge">
В текущей модели не определено как минимум одно топологическое коребро или ребро
</member>
        <member name="F:NoTopolFace">
В текущей модели не определена как минимум одна топологическая грань
</member>
        <member name="F:IncompliantGeom">
В текущей модели геометрия несовместима
</member>
        <member name="F:IncompliantTopol">
В текущей модели топология несовместима
</member>
        <member name="F:InvalidBound">
Некорректная исходная (граничная) полигональная сетка
</member>
        <member name="F:NotSpecified">
Причину ошибки определить не удалось
</member>
        <member name="T:RGK.Generators.Faceter.Report.RetCode">
Результат построения сетки
</member>
        <member name="M:RGK.Generators.Faceter.Report.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.Faceter.Report.#ctor">
Конструктор
</member>
        <member name="T:RGK.Generators.Faceter.Report">
Класс результатов построения сетки
</member>
        <member name="M:RGK.Generators.Faceter.Data.GetMeshGeneratorMode">
Получить признак сшивки граневых сеток
<returns>Признак сшивки граневых сеток</returns></member>
        <member name="M:RGK.Generators.Faceter.Data.SetMeshGeneratorMode(RGK.Generators.Faceter.MeshGeneratorMode)">
Установить признак сшивки граневых сеток
<param name="iDoLinkage">Признак сшивки граневых сеток: true - сшивать, false - не сшивать</param></member>
        <member name="M:RGK.Generators.Faceter.Data.GetMeshGeneratorType">
Получить тип сетки
<returns>Тип сетки</returns></member>
        <member name="M:RGK.Generators.Faceter.Data.SetMeshGeneratorType(RGK.Generators.Faceter.MeshGeneratorType)">
Установить тип сетки
<param name="iMeshGeneratorType">Тип сетки</param></member>
        <member name="M:RGK.Generators.Faceter.Data.GetMaxAspectRatio">
Получить предельно допустимое значение aspect ratio треугольников сетки
<returns>Предельно допустимое значение aspect ratio треугольников сетки</returns></member>
        <member name="M:RGK.Generators.Faceter.Data.GetSurfaceDistanceTolerance">
Получить максимальную дистанцию между треугольником и поверхностью
<returns>Максимальная дистанция между треугольником и поверхностью</returns></member>
        <member name="M:RGK.Generators.Faceter.Data.GetNormalAngleTolerance">
Получить максимальное значение угла, рассчитываемое как максимально допустимый угол между 
любыми двумя нормалями к поверхности внутри её двухпараметрической треугольной области, отсекаемой фасетой 
<returns>Максимальное значение угла между нормалями</returns></member>
        <member name="M:RGK.Generators.Faceter.Data.GetSideLengthTolerance">
Получить максимально допустимую длина стороны треугольника
<returns>Максимально допустимая длина стороны треугольника</returns></member>
        <member name="M:RGK.Generators.Faceter.Data.SetMaxAspectRatio(System.Double)">
Установить предельно допустимое значение aspect ratio треугольников сетки
<param name="iValue">Предельно допустимое значение aspect ratio треугольников сетки</param></member>
        <member name="M:RGK.Generators.Faceter.Data.SetSurfaceDistanceTolerance(System.Double)">
Установить максимальную дистанцию между треугольником и поверхностью
<param name="iValue">Максимальная дистанция между треугольником и поверхностью</param></member>
        <member name="M:RGK.Generators.Faceter.Data.SetNormalAngleTolerance(System.Double)">
Установить максимальное значение угла, рассчитываемое как максимально допустимый угол между 
любыми двумя нормалями к поверхности внутри её двухпараметрической треугольной области, отсекаемой фасетой 
<param name="iValue">Максимальное значение угла между нормалями</param></member>
        <member name="M:RGK.Generators.Faceter.Data.SetSideLengthTolerance(System.Double)">
Установить максимально допустимую длина стороны треугольника
<param name="iValue">Максимально допустимая длина стороны треугольника</param></member>
        <member name="M:RGK.Generators.Faceter.Data.AddFace(std.shared_ptr&lt;RGK.Model.Face&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Добавить грань, для которой строится сетка
<param name="iFace">Грань, на которой строится сетка</param></member>
        <member name="M:RGK.Generators.Faceter.Data.AddBody(std.shared_ptr&lt;RGK.Model.Body&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Добавить тело, для которого строится сетка
<param name="iBody">Тело, на котором строится сетка</param></member>
        <member name="M:RGK.Generators.Faceter.Data.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.Faceter.Data.#ctor(RGK.Generators.Faceter.Data!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор копирования
</member>
        <member name="M:RGK.Generators.Faceter.Data.#ctor">
Конструктор
Конструктор копирования
</member>
        <member name="T:RGK.Generators.Faceter.Data">
Класс входных параметров построения сетки 
</member>
        <member name="M:RGK.Generators.Faceter.Create(RGK.Generators.Faceter.Data!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,RGK.Generators.Faceter.Report*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Построение сетки по стадиям (отладочный метод)
<param name="iData">Параметры генерации сетки</param><param name="iStage">Номер стадии. При значениях, не входящих в диапазон [0..N], сетка строится целиком</param><param name="oReport">Результаты построения сетки</param></member>
        <member name="M:RGK.Generators.Faceter.Create(RGK.Generators.Faceter.Data!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Generators.Faceter.Report*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Run mesh generation
<param name="iData">Parameters for the generation</param><param name="oReport">Result of the generation</param><returns>Return resulting code</returns></member>
        <member name="M:RGK.Generators.Faceter.op_Assign(RGK.Generators.Faceter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="M:RGK.Generators.Faceter.#ctor">
Защита от создания пустого экземпляра класса
</member>
        <member name="M:RGK.Generators.Faceter.#ctor(RGK.Generators.Faceter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="M:RGK.Generators.Faceter.CheckEdgeForExclude(std.shared_ptr&lt;RGK.Model.Edge&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка что ребро исключается из сетки в режиме IF_EDGE_LINE_LIST_EXCLUDE_SPLIT_EDGE
<param name="iEdge">Ребро</param><returns>true - ребро должно исключаться</returns></member>
        <member name="F:Other">
Сетка для прочих нужд
</member>
        <member name="F:Meshing">
Сетка для дальнейших расчётов
</member>
        <member name="F:Visualizing">
Сетка для визуализации
</member>
        <member name="T:RGK.Generators.Faceter.MeshGeneratorMode">
Режим генератора сетки
</member>
        <member name="F:Mixed">
Смешанная сетка. Для поверхностей двойной кривизны строится регулярное разбиение. Для линейчатых поверхностей используется нерегулярная сетка.
Такой тип сетки предлагается использовать в задачах визуализации для минимизации количества треугольников.
</member>
        <member name="F:Regular">
Регулярная сетка.
Такой тип сетки предлагается использовать в расчётных задачах.
</member>
        <member name="F:NonRegular">
Нерегулярная сетка. Используется по умолчанию.
Обычно такой тип сетки строится быстрее других.
</member>
        <member name="T:RGK.Generators.Faceter.MeshGeneratorType">
Тип генератора сетки
</member>
        <member name="M:RGK.Generators.Faceter.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.Faceter.#ctor(RGK.Common.Context*)">
Конструктор
<param name="iContext">Контекст вычислений</param></member>
        <member name="T:RGK.Generators.Faceter">
Класс генератора сетки для элементов модели 
<seealso cref="!:Генерация плоскогранной модели" /></member>
        <member name="M:RGK.Generators.BufferedMeshData.GetEdgeIndexDataType">
Получить тип индексных данных, которые пишутся в буфер рёбер
</member>
        <member name="M:RGK.Generators.BufferedMeshData.GetFaceIndexDataType">
Получить тип индексных данных, которые пишутся в буфер граней
</member>
        <member name="M:RGK.Generators.BufferedMeshData.GetEdgeAssoc">
Получить буфер для хранения информации о связи рёбер с индексными данными
</member>
        <member name="M:RGK.Generators.BufferedMeshData.GetFaceAssoc">
Получить буфер для хранения информации о связи граней с индексными данными
</member>
        <member name="M:RGK.Generators.BufferedMeshData.GetEdgeIndexBuffer">
Получить индексный буфер полининий(рёбер)
</member>
        <member name="M:RGK.Generators.BufferedMeshData.GetFaceIndexBuffer">
Получить индексный буфер сеток(граней)
</member>
        <member name="M:RGK.Generators.BufferedMeshData.GetVertexBuffer(RGK.Generators.BufferedMeshData.VertexDeclaration.VertexDataType)">
Получить вершинный буфер по типу данных
<param name="iVertexDataType"> Тип данных, для которых запрашивается буфер </param></member>
        <member name="M:RGK.Generators.BufferedMeshData.GetVertexDeclaration">
Получить вектор описаний вершинных буферов
</member>
        <member name="M:RGK.Generators.BufferedMeshData.SetEdgeIndexDeclaration(std.shared_ptr&lt;RGK.Generators.MeshBuffer&gt;,RGK.Generators.BufferedMeshData.EdgeIndexDataType,std.shared_ptr&lt;RGK.Generators.BufferedMeshData.AssocTopolArray&gt;)">
Установить буфер индексов и его формат для полилиний(рёбра)
<param name="iBuffer">Буфер, в который пишутся данные</param><param name="iType">Тип индексных данных, которые пишутся в буфер</param><param name="iAssoc">Буфер для хранения информации о связи рёбер с индексными данными</param></member>
        <member name="M:RGK.Generators.BufferedMeshData.SetFaceIndexDeclaration(std.shared_ptr&lt;RGK.Generators.MeshBuffer&gt;,RGK.Generators.BufferedMeshData.FaceIndexDataType,std.shared_ptr&lt;RGK.Generators.BufferedMeshData.AssocTopolArray&gt;)">
Установить буфер индексов и его формат для сеток(грани)
<param name="iBuffer">Буфер, в который пишутся данные</param><param name="iType">Тип индексных данных, которые пишутся в буфер</param><param name="iAssoc">Буфер для хранения информации о связи граней с индексными данными</param></member>
        <member name="M:RGK.Generators.BufferedMeshData.AddVertexDeclaration(RGK.Generators.BufferedMeshData.VertexDeclaration!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Добавить описание запрашиваемых вершинных данных, которыми предполагается заполнять буфер
<param name="iVertexDeclaration">Описание вершинных данных</param></member>
        <member name="M:RGK.Generators.BufferedMeshData.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.BufferedMeshData.#ctor">
Конструктор
</member>
        <member name="F:IF_EDGE_LINE_LIST_EXCLUDE_SPLIT_EDGE">
Полилиния представляется набором отрезков, то есть множеством пар индексов {(1,2),(2,3),...} Но при этом индексы не строятся для рёбер разрезания
</member>
        <member name="F:IF_EDGE_LINE_STRIP">
Полилиния представляется набором индексов {1,2,3,4,...}
</member>
        <member name="F:IF_EDGE_LINE_LIST">
Полилиния представляется набором отрезков, то есть множеством пар индексов {(1,2),(2,3),...}. По умолчанию полилиния строится именно в этом формате
</member>
        <member name="T:RGK.Generators.BufferedMeshData.EdgeIndexDataType">
Типы данных, которые могут храниться в индексных буферах для полилиний
</member>
        <member name="F:IF_FACE_TRIANGLE_ADJACENCY">
Triangle adjacency-формат сетки
</member>
        <member name="F:IF_FACE_TRIANGLE_STRIP">
Triangle strip-формат сетки
</member>
        <member name="F:IF_FACE_TRIANGLE_LIST">
Triangle list-формат сетки. По умолчанию сетка строится именно в этом формате
</member>
        <member name="T:RGK.Generators.BufferedMeshData.FaceIndexDataType">
Типы данных, которые могут храниться в индексных буферах для сеток
</member>
        <member name="D:RGK.Generators.BufferedMeshData.AssocTopolArrayPtr">
Ссылка на множество диапазонов индексов для топологических элементов
</member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopolArray.CheckAllTopolInvalid">
Проверка, что вся хранящаяся топология не валидная
</member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopolArray.size">
Получить число элементов
</member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopolArray.end">
Получить итератор для конца массива
</member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopolArray.begin">
Получить итератор для начала массива
</member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopolArray.GetAssocTopol(System.UInt32,RGK.Generators.BufferedMeshData.AssocTopol*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить элемент по заданному индексу
<param name="iIndex">Заданый индекс элемента </param><param name="oAssocTopol">Элемент топологии</param><returns>
Common::Success - в случае успеха
Common::ArrayIndexOutOfBoundary - если индекс выходит за пределы допустимого диапазона               
</returns></member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopolArray.GetAssocTopol(std.shared_ptr&lt;RGK.Model.Topol&gt;!System.Runtime.CompilerServices.IsConst,RGK.Generators.BufferedMeshData.AssocTopol*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить элемент ассоциируемого с заданным топологическим элементом
<param name="iTopol">Заданыё топологический элемент </param><param name="oAssocTopol">Ассоциируемый с ним элемент </param><returns>
Common::Success - в случае успеха
Common::ElementNotContained - в случае, если данный топологический элемент не содержится в списке                
</returns></member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopolArray.GetIndex(std.shared_ptr&lt;RGK.Model.Topol&gt;!System.Runtime.CompilerServices.IsConst)">
Поиск индекса топологического элемента
<param name="iTopol"> Искомый элемент </param><returns>
Индекс элемента в хранимом массиве. -1 - в случае если такого элемента нет.
</returns></member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopolArray.Push(RGK.Generators.BufferedMeshData.AssocTopol!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Добавление топологического элемента.
Данный метод не предполагает проверки на наличие добавляемого элемента
<param name="iTopol">Добавляемы топологический элемент</param></member>
        <member name="T:RGK.Generators.BufferedMeshData.AssocTopolArray">
            <summary>Множество диапазонов индексов для топологических элементов</summary>
        </member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopol.GetTopolID">
Получить идентификатор топологического элемента, для которого определена группа индексов
<returns>Идентификатор топологического элемента</returns></member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopol.GetTopol">
Получить топологический элемент, для которого определена группа индексов
<returns>Топологический элемент</returns></member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopol.GetCount">
Получить количество индексов в группе
<returns>Количество индексов в группе</returns></member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopol.GetStart">
Получить смещение в буфере индексов начала группы индексов для отдельного топологического элемента
<returns>Смещение в буфере индексов начала группы индексов для отдельного топологического элемента</returns></member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopol.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.BufferedMeshData.AssocTopol.#ctor(System.UInt32,System.UInt32,std.shared_ptr&lt;RGK.Model.Topol&gt;)">
Конструктор
</member>
        <member name="T:RGK.Generators.BufferedMeshData.AssocTopol">
            <summary>Класс для хранения ссылок набора элементов сетки на исходный топологический элемент</summary>
Индексы в буферах индексных данных группируются по принадлежности к топологическим элементам.
В буфере сеточных данных для каждой грани формируется своя группа индексов.
В буфере данных полилиний для каждого ребра формируется своя группа индексов.
То есть в массиве индексов сначала идут индексы для одного топологического элемента, затем для второго и так для всех элементов.
</member>
        <member name="M:RGK.Generators.BufferedMeshData.VertexDeclaration.GetType">
Получить тип данных
<returns>Тип данных</returns></member>
        <member name="M:RGK.Generators.BufferedMeshData.VertexDeclaration.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.BufferedMeshData.VertexDeclaration.#ctor(std.shared_ptr&lt;RGK.Generators.MeshBuffer&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Generators.BufferedMeshData.VertexDeclaration.VertexDataType,System.UInt32)">
Конструктор
<param name="iBuffer">Буфер , в который пишутся данные</param><param name="iType">Тип вершинных данных, которые пишутся в буфер</param><param name="iOffset">Смещение, с которым пишутся данные по каждой вершине (т.к. один буфер может хранить смешанные данные, 
например, координаты и нормали)</param></member>
        <member name="M:RGK.Generators.BufferedMeshData.VertexDeclaration.#ctor">
Конструктор
</member>
        <member name="F:VDT_UV_COORDINATES">
Значение uv-координат
</member>
        <member name="F:VDT_DERIVATIVES">
Значение производных
</member>
        <member name="F:VDT_CURVATURE">
Значение кривизны
</member>
        <member name="F:VDT_NORMAL">
Координаты нормалей
</member>
        <member name="F:VDT_NORMAL_2">
Координаты нормалей. Данный формат может использоваться для задания нормалей в вершинах, когда третья компонента вычисляется
</member>
        <member name="F:VDT_POSITION">
Координаты вершин
</member>
        <member name="T:RGK.Generators.BufferedMeshData.VertexDeclaration.VertexDataType">
Типы данных, которые могут храниться в вершинных буферах
</member>
        <member name="T:RGK.Generators.BufferedMeshData.VertexDeclaration">
Описание вершинных данных. Класс постановки задачи 
</member>
        <member name="T:RGK.Generators.BufferedMeshData">
            <summary>Класс хранения сетки в формате типизированных буферов</summary> 
В первую очередь объекты данного класса используются для хранения данных сетки плоскогранной аппроксимации тел и других элементов модели.
Класс используется одновременно для постановки задачи конвертации и получения результатов конвертации.
<seealso cref="!:Генерация плоскогранной модели" /></member>
        <member name="M:RGK.Generators.MeshBuffer.CopyToHost(System.Void*,System.UInt32)">
Копировать данные буфера в оперативную память
<param name="iHostBuffer"> Указатель на область оперативной памяти</param><param name="iSize"> Количество копируемых байтов </param><returns>
Common::Success - в случае успеха (информация была скопирована из входного буфера в текущий)
</returns></member>
        <member name="M:RGK.Generators.MeshBuffer.CopyToHost(System.Void*,System.UInt32,System.UInt32,System.UInt32)">
Копировать данные буфера в оперативную память
<param name="iHostBuffer"> Указатель на область оперативной памяти</param><param name="iOffsetSrc"> Смещение в байтах, с которого начинается копирование </param><param name="iOffsetDst"> Первый байт, в который производится копирование </param><param name="iSize"> Количество копируемых байтов </param><returns>
Common::Success - в случае успеха (информация была скопирована из входного буфера в текущий)
</returns></member>
        <member name="M:RGK.Generators.MeshBuffer.Copy(std.shared_ptr&lt;RGK.Generators.MeshBuffer&gt;,System.UInt32,System.UInt32,System.UInt32)">
Метод для копирования одного буфера в другой
<param name="iMeshBuffer"> Исходный буфер, из которого копируется информация </param><param name="iOffsetSrc"> Смещение в байтах, с которого начинается копирование </param><param name="iOffsetDst"> Первый байт, в который производится копирование </param><param name="iSize"> Количество копируемых байтов </param><returns>
Common::Success - в случае успеха (информация была скопирована из входного буфера в текущий)
</returns></member>
        <member name="M:RGK.Generators.MeshBuffer.GetGLId">
Получить идентификатор на устройстве. Получить не нулевое значение только в случае реализации на вычислительном устройстве (GPU)
<returns>Идентификатор на графическом вычислительном устройстве</returns></member>
        <member name="M:RGK.Generators.MeshBuffer.GetGPUPointer(RGK.Common.Context*)">
Получить текущий адрес буфера
<returns>Адрес на данные в памяти устройства (GPU)</returns></member>
        <member name="M:RGK.Generators.MeshBuffer.GetHostPointer">
Получить текущий адрес(в оперативной памяти) буфера 
<returns>Адрес на данные в памяти CPU</returns>
Получить текущий адрес(в оперативной памяти) буфера 
<returns>Адрес на данные в памяти CPU</returns></member>
        <member name="M:RGK.Generators.MeshBuffer.GetSize">
Получить текущий размер буфера
<returns>Размер буфера</returns></member>
        <member name="M:RGK.Generators.MeshBuffer.SetSize(System.UInt32)">
Установить размер буфера
<param name="iSize">Размер буфера</param><returns>
- Result::Success в случае успешного выполнения
- Result::MemoryFull в случае, если не удалось выделить запрошенный объём памяти
</returns></member>
        <member name="M:RGK.Generators.MeshBuffer.SetData(System.Void*,System.UInt32,System.UInt32)">
Запись данных в буфер
<param name="iData">Данные для записи</param><param name="iSize">Размер данных</param><param name="iOffset">Смещение в буфере</param></member>
        <member name="M:RGK.Generators.MeshBuffer.Dispose">
Деструктор
</member>
        <member name="T:RGK.Generators.MeshBuffer">
            <summary>Интерфейс класса, реализующего работу с данными сетки</summary>
В разных типах приложений для хранения представления данных плоскогранной аппроксимации тел и других элементов модели
используются разные механизмы. Класс MeshBuffer является абстрактным классом, предполагающих пользовательскую реализацию.
Для обеспечения работоспособности механизма хранения сетки, приложение должно реализовать виртуальные методы данного класса и установить 
указатель на соответствующий менеджер сеточных данных в методе RGK::Instance::SetMeshBufferFactory
<seealso cref="!:Генерация плоскогранной модели" /></member>
        <member name="M:RGK.Generators.BaseGenerator.SendTimeEvent">
Послать сообщение синхронизации по времени
</member>
        <member name="M:RGK.Generators.BaseGenerator.SendEvent(RGK.Generators.Event!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Послать сообщение
<param name="iEvent">Обрабатываемое событие</param></member>
        <member name="M:RGK.Generators.BaseGenerator.GetTracking">
Получить режим вывода подробной информации в класс Report генератора.
По умолчанию режим выставляется из сессии
<returns>Режим идентификации топологических элементов</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.SetTracking(System.Boolean)">
Установить режим вывода подробной информации в класс Report генератора.
По умолчанию режим выставляется из сессии
<param name="iTracking">true-включить;false-выключить режим вывода подробной информации в класс Report генератора</param></member>
        <member name="M:RGK.Generators.BaseGenerator.GetIdentify">
Получить режим идентификации топологических элементов.
По умолчанию режим выставляется из сессии
<returns>Режим идентификации топологических элементов</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.SetIdentify(System.Boolean)">
Установить режим идентификации топологических элементов.
По умолчанию режим выставляется из сессии
<param name="iIdentify">true-включить;false-выключить режим идентификации топологических элементов</param></member>
        <member name="M:RGK.Generators.BaseGenerator.GetID">
Получить идентификатор операции
<returns>Идентификатор операции</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.SetID(System.UInt32)">
Установить идентификатор операции
<param name="iID">Идентификатор операции</param></member>
        <member name="M:RGK.Generators.BaseGenerator.SetTolerance(System.Double)">
Установить точность вычислений
<param name="iTolerance">Точность вычислений</param></member>
        <member name="M:RGK.Generators.BaseGenerator.GetTolerance">
Получить точность вычислений
<returns>Точность вычислений</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.CanHandleEvent(RGK.Generators.EventType)">
Проверка возможности обработки события
<param name="iType">Тип события</param><returns>true - событие данного типа обрабатывается</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.Init">
            <summary>Инициализация генератора</summary>
Инициализация генератора должна быть обязательно вызвана из пользовательской функции генератора, для которой будет выполняться мониторинг
</member>
        <member name="M:RGK.Generators.BaseGenerator.GetMonitor">
Получить монитор для отслеживания процесса выполнения генератора
<returns>Монитор для отслеживания процесса выполнения генератора</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.GetInterrupted">
Получить признак того, что выполнение генератора было прервано
<returns>true если выполнение генератора было прервано</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.GetInterruptInfo">
Получить информацию о причине прерывания генератора, если выполнение генератора было прервано
<returns>Информация о причине прерывания генератора</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.Interrupt(std.shared_ptr&lt;RGK.Generators.InterruptionInfo&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Прервать выполнение генератора</summary>
Предполагается, что метод будет вызываться из функции обратного вызова.
Возможен вызов метода из другого потока
<param name="iInfo">Информация  о причине прерывания генератора</param></member>
        <member name="M:RGK.Generators.BaseGenerator.GetTiming">
Получить текущее время выполнения операции генератора
<returns>Текущее время выполнения операции генератора</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.SetTiming(System.Double)">
Установить временной интервал синхронизации процесса выполнения генератора с монитором
<param name="iTiming">Примерный временной интервал вызова монитора по событию временной синхронизации. Задаётся в секундах</param><returns>Результат выполнения метода. Common::Success в случае успешного выполнения</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.SetMonitor(std.shared_ptr&lt;RGK.Interfaces.MonitoringOfGenerator&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Установить функцию обратного вызова для отслеживания процесса выполнения генератора
<remarks>Генератор не удаляет объект монитора при завершении</remarks><param name="iMonitor">Класс управления процессом выполнения генератора</param><returns>Результат выполнения метода. Common::Success в случае успешного выполнения</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.SetVersion(RGK.Common.Version)">
Установить версию генератора
<param name="iVersion">Номер версии</param></member>
        <member name="M:RGK.Generators.BaseGenerator.GetVersion">
Получить версию генератора
<returns>Номер версии</returns></member>
        <member name="M:RGK.Generators.BaseGenerator.op_Assign(RGK.Generators.BaseGenerator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="M:RGK.Generators.BaseGenerator.#ctor">
Защита от создания пустого экземпляра класса
</member>
        <member name="M:RGK.Generators.BaseGenerator.#ctor(RGK.Generators.BaseGenerator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="M:RGK.Generators.BaseGenerator.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.BaseGenerator.#ctor(RGK.Common.Context*)">
            <summary>Конструктор</summary>
            <param name="iContext">Контекст вычисления</param>
        </member>
        <member name="T:RGK.Generators.BaseGenerator">
            <summary>Базовый класс генераторов</summary>
Генераторы используются в модели для создания тел при помощи различных методов и их модификации
<seealso cref="!:Генераторы" /></member>
        <member name="M:RGK.Generators.InterruptionInfo.GetReason">
            <returns>Текстовое описание причины прерывания</returns>
        </member>
        <member name="M:RGK.Generators.InterruptionInfo.Dispose">
Деструктор
</member>
        <member name="M:RGK.Generators.InterruptionInfo.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="M:RGK.Generators.InterruptionInfo.#ctor(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;)">
            <summary>Конструктор</summary>
            <param name="iReason">Текстовое описание причины прерывания</param>
        </member>
        <member name="T:RGK.Generators.InterruptionInfo">
            <summary>Причина прерывания процесса выполнения генератора пользователем</summary>
Допускается порождение из этого класса для расширения информации о причине остановки генератора
<seealso cref="!:Генераторы" /></member>
        <member name="M:RGK.Generators.TesselationEvent.GetTriangleCount">
Получить количество добавленных треугольников
<returns> Количество добавленных треугольников</returns></member>
        <member name="M:RGK.Generators.TesselationEvent.GetTrianglesTotal">
Получить общее время количество треугольников
<returns>Общее количество треугольников</returns></member>
        <member name="M:RGK.Generators.TesselationEvent.GetType">
Получить тип события
<returns>Тип события</returns></member>
        <member name="M:RGK.Generators.TesselationEvent.Dispose">
Деструктор
</member>
        <member name="T:RGK.Generators.TesselationEvent">
            <summary>Событие генерации треугольников сеточным генератором.
Может использоваться для прерывания процесса расчёта сетки при превышении порогового значения количества треугольников в сетке</summary>
        </member>
        <member name="M:RGK.Generators.CreateTopolEvent.#ctor(std.shared_ptr&lt;RGK.Model.Topol&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Конструктор</summary>
            <param name="iTopol">Создаваемый топологический элемент</param>
        </member>
        <member name="M:RGK.Generators.CreateTopolEvent.GetTopol">
Получить создаваемый топологический элемент
<returns>Создаваемый топологический элемент</returns></member>
        <member name="M:RGK.Generators.CreateTopolEvent.GetType">
Получить тип события
<returns>Тип события</returns></member>
        <member name="M:RGK.Generators.CreateTopolEvent.Dispose">
Деструктор
</member>
        <member name="T:RGK.Generators.CreateTopolEvent">
            <summary>Событие создания топологического элемента</summary>
        </member>
        <member name="M:RGK.Generators.TimeEvent.#ctor(System.Double)">
            <summary>Конструктор</summary>
            <param name="iTime">Общее время выполнения генератора. Задаётся в секундах</param>
        </member>
        <member name="M:RGK.Generators.TimeEvent.GetTime">
Получить общее время выполнения генератора
<returns>Общее время выполнения генератора</returns></member>
        <member name="M:RGK.Generators.TimeEvent.GetType">
Получить тип события
<returns>Тип события</returns></member>
        <member name="M:RGK.Generators.TimeEvent.Dispose">
Деструктор
</member>
        <member name="T:RGK.Generators.TimeEvent">
            <summary>Событие завершения временного интервала синхронизации</summary>
        </member>
        <member name="M:RGK.Generators.Event.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="M:RGK.Generators.Event.GetType">
Получить тип события
<returns>Тип события</returns></member>
        <member name="M:RGK.Generators.Event.Dispose">
Деструктор
</member>
        <member name="T:RGK.Generators.Event">
            <summary>Событие, которое передаётся в функцию обратного вызова</summary>
В различных типах генераторов могут быть свои классы, порождённые из Event, для расширения информации о событии
<seealso cref="!:Генераторы" /></member>
        <member name="T:RGK.Generators.EventType">
Типы событий
<seealso cref="!:Генераторы" /></member>
        <member name="F:TesselationEventType">
Событие генерации треугольников сеточным генератором
</member>
        <member name="F:CreateTopolEventType">
Событие создания топологического элемента
</member>
        <member name="F:TimeEventType">
Событие завершения временного интервала синхронизации
</member>
        <member name="M:RGK.Common.Timer.GetElapsedTime">
Получить время с начала отсчёта
</member>
        <member name="M:RGK.Common.Timer.Start">
Начать отсчёт времени
</member>
        <member name="M:RGK.Common.Timer.#ctor">
Конструктор
</member>
        <member name="T:RGK.Common.Timer">
Класс таймера
</member>
        <member name="M:RGK.Common.BaseTools.GetContext">
Контекст, в котором создан генератор
</member>
        <member name="M:RGK.Common.BaseTools.Dispose">
Деструктор
</member>
        <member name="M:RGK.Common.BaseTools.#ctor(RGK.Common.Context*)">
            <summary>Конструктор</summary>
Конструктор любого инструментального класса предполагает наличие контекста, который можно получить в сессии модели
</member>
        <member name="T:RGK.Common.BaseTools">
            <summary>Базовый класс для всех инструментальных классов</summary>
Класс реализует набор методов для хранения и доступа к общесистемным данным и методы организации работы в многопоточном режиме
</member>
        <member name="M:RGK.Math.BoundingBox.CreateByPoints(System.UInt64,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*)">
            <summary>Создание ограничивающего параллелепипеда по заданным точкам</summary>
            <param name="iPointsCount">Количество точек</param>
            <param name="iPoints">Набор точек</param>
            <returns>Ограничивающий параллелепипед для заданного набора точек</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.CreateByPoints(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Создание ограничивающего параллелепипеда по четырём заданным точкам</summary>
            <param name="iPoint1">Первая точка</param>
            <param name="iPoint2">Вторая точка</param>
            <param name="iPoint3">Третья точка</param>
            <param name="iPoint4">Четвёртая точка</param>
            <returns>Ограничивающий параллелепипед для заданных точек</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.CreateByPoints(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Создание ограничивающего параллелепипеда по трём заданным точкам</summary>
            <param name="iPoint1">Первая точка</param>
            <param name="iPoint2">Вторая точка</param>
            <param name="iPoint3">Третья точка</param>
            <returns>Ограничивающий параллелепипед для заданных точек</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.CreateByPoints(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Создание ограничивающего параллелепипеда по двум заданным точкам</summary>
            <param name="iPoint1">Первая точка</param>
            <param name="iPoint2">Вторая точка</param>
            <returns>Ограничивающий параллелепипед для заданных точек</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.CreateSizeBox(RGK.Common.Context*)">
            <summary>Создание ограничивающего параллелепипеда со сторонами, соответствующими
максимально допустимым габаритам модели, полученным из контекста вычислений</summary>
            <param name="iContext">Контекст вычислений</param>
            <returns>Ограничивающий параллелепипед максимально допустимых габаритов модели</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.InitByPoints(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Инициализация ограничивающего параллелепипеда по четырём заданным точкам</summary>
Ограничивающий параллелепипед инициализируется покоординатными минимумами
и максимумами заданных точек, то есть таковым, чтобы являться наименьшим
и содержащим четыре заданные точки
<param name="iPoint1">Первая точка</param><param name="iPoint2">Вторая точка</param><param name="iPoint3">Третья точка</param><param name="iPoint4">Четвёртая точка</param></member>
        <member name="M:RGK.Math.BoundingBox.InitByPoints(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Инициализация ограничивающего параллелепипеда по трём заданным точкам</summary>
Ограничивающий параллелепипед инициализируется покоординатными минимумами
и максимумами заданных точек, то есть таковым, чтобы являться наименьшим
и содержащим три заданные точки
<param name="iPoint1">Первая точка</param><param name="iPoint2">Вторая точка</param><param name="iPoint3">Третья точка</param></member>
        <member name="M:RGK.Math.BoundingBox.InitByPoints(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Инициализация ограничивающего параллелепипеда по двум заданным точкам</summary>
Ограничивающий параллелепипед инициализируется покоординатными минимумами
и максимумами заданных точек, то есть таковым, чтобы являться наименьшим
и содержащим две заданные точки
<param name="iPoint1">Первая точка</param><param name="iPoint2">Вторая точка</param></member>
        <member name="M:RGK.Math.BoundingBox.InitByPoint(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Инициализация ограничивающего параллелепипеда по заданной точке</summary>
            <param name="iPoint">Точка</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.SelfMove(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Перемещение ограничивающего параллелепипеда на заданный вектор </summary>
            <param name="iVector"> Вектор, задающий перемещение </param>
        </member>
        <member name="M:RGK.Math.BoundingBox.Mapping(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить ограничивающий параллелепипед,
после применения операции аффинного преобразования</summary>
            <param name="iMap">Аффинное преобразование</param>
            <returns>Новый ограничивающий параллелепипед</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.SelfMapping(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить ограничивающий параллелепипед, после применения операции аффинного преобразования</summary>
            <param name="iMap">Аффинное преобразование</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetEdges(std.pair&lt;RGK.Math.Vector3D,RGK.Math.Vector3D&gt;*)">
            <summary>Получить все ребра данного ограничивающего параллелепипеда</summary>
            <param name="oEdges">Ребра данного ограничивающего параллелепипеда</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetEdges(std.vector&lt;std.pair&lt;RGK.Math.Vector3D,RGK.Math.Vector3D&gt;,std.allocator&lt;std.pair&lt;RGK.Math.Vector3D,RGK.Math.Vector3D&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить все ребра данного ограничивающего параллелепипеда</summary>
            <param name="oEdges">Ребра данного ограничивающего параллелепипеда</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetVertices(RGK.Math.Vector3D*)">
            <summary>Получить все вершины данного ограничивающего параллелепипеда</summary>
            <param name="oVertices">Вершины данного ограничивающего параллелепипеда </param>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetVertices(std.vector&lt;RGK.Math.Vector3D,std.allocator&lt;RGK.Math.Vector3D&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить все вершины данного ограничивающего параллелепипеда</summary>
            <param name="oVertices">Вершины данного ограничивающего параллелепипеда </param>
        </member>
        <member name="M:RGK.Math.BoundingBox.Union(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Объединение данного ограничивающего параллелепипеда и ограничивающего параллелепипеда iBox</summary>
            <param name="iBox">Ограничивающий параллелепипед для объединения</param>
            <returns>Ограничивающий параллелепипед объединения</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Union(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Объединение данного ограничивающего параллелепипеда и точки iPoint</summary>
            <param name="iPoint">Точка для объединения</param>
            <returns>Ограничивающий параллелепипед объединения</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Unite(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Объединение данного ограничивающего параллелепипеда с ограничивающим параллелепипедом iBox</summary>
            <param name="iBox">Ограничивающий параллелепипед для объединения</param>
            <returns>Ссылка на данный ограничивающий параллелепипед</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Unite(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Объединение данного ограничивающего параллелепипеда с точкой iPoint</summary>
            <param name="iPoint">Точка для объединения</param>
            <returns>Ссылка на данный ограничивающий параллелепипед</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsValid">
            <summary>Проверка на корректность данного ограничивающего параллелепипеда</summary>
Проверка на корректность данного ограничивающего параллелепипеда.
Параллелепипед считается корректным в случае если он определён и вектора,
задающие его границы также являются корректными (конечными величинами).
<returns>
- true, если является корректным
- false, если не является корректным
</returns></member>
        <member name="M:RGK.Math.BoundingBox.Intersection(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Common.Context*)">
            <summary>Пересечение данного ограничивающего параллелепипеда и ограничивающего
параллелепипеда iBox, используя параметры контекста iContext</summary>
            <param name="iBox">Ограничивающий параллелепипед для пересечения</param>
            <param name="oResult">Выходной ограничивающий параллелепипед пересечения</param>
            <param name="iContext">Контекст вычислений</param>
            <returns>
- true, если пересекаются
- false, если не пересекаются
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Intersection(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>Пересечение данного ограничивающего параллелепипеда и ограничивающего
параллелепипеда iBox, используя точность iTolerance</summary>
            <param name="iBox">Ограничивающий параллелепипед для пересечения</param>
            <param name="oResult">Выходной ограничивающий параллелепипед пересечения</param>
            <param name="iTolerance">Используемая точность</param>
            <returns>
- true, если пересекаются
- false, если не пересекаются
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Intersection(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.BoundingBox*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Пересечение данного ограничивающего параллелепипеда и ограничивающего параллелепипеда iBox</summary>
            <param name="iBox">Ограничивающий параллелепипед для пересечения</param>
            <param name="oResult">Выходной ограничивающий параллелепипед пересечения</param>
            <returns>
- true, если пересекаются
- false, если не пересекаются
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Intersect(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>Пересечение данного ограничивающего параллелепипеда с плоскостью</summary>
            <param name="iPoint">Точка на плоскости</param>
            <param name="iZAxis">Ось Z системы координат</param>
            <param name="iTolerance">Точность</param>
            <returns>
- true, если пересекаются
- false, если не пересекаются
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Intersect(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Common.Context*)">
            <summary>Пересечение данного ограничивающего параллелепипеда с ограничивающим
параллелепипедом iBox, используя параметры контекста iContext</summary>
            <param name="iBox">Интервал для пересечения</param>
            <param name="iContext">Контекст вычислений</param>
            <returns>
- true, если пересекаются
- false, если не пересекаются
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Intersect(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Пересечение данного ограничивающего параллелепипеда с ограничивающим параллелепипедом iBox</summary>
            <param name="iBox">Интервал для пересечения</param>
            <returns>
- true, если пересекаются
- false, если не пересекаются
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Intersects(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Common.Context*)">
            <summary>Проверить, пересекается ли данный ограничивающий параллелепипед
с ограничивающим параллелепипедом iBox, используя параметры контекста iContext</summary>
            <param name="iBox">Ограничивающий параллелепипед для проверки</param>
            <param name="iContext">Контекст вычислений</param>
            <returns>
- true, если пересекается
- false, если не пересекается
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Intersects(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>Проверить, пересекается ли данный ограничивающий параллелепипед
с ограничивающим параллелепипедом iBox, используя точность iTolerance</summary>
            <param name="iBox">Ограничивающий параллелепипед для проверки</param>
            <param name="iTolerance">Используемая точность</param>
            <returns>
- true, если пересекается
- false, если не пересекается
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Intersects(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Проверить, пересекается ли данный ограничивающий параллелепипед
с ограничивающим параллелепипедом iBox</summary>
            <param name="iBox">Ограничивающий параллелепипед для проверки</param>
            <returns>
- true, если пересекается
- false, если не пересекается
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsEqual(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>Проверить, является ли данный ограничивающий параллелепипед
равным ограничивающему параллелепипеду iBox, используя точность iTolerance</summary>
            <param name="iBox">Ограничивающий параллелепипед для проверки</param>
            <param name="iTolerance">Порог равенства значений</param>
            <returns>
- true, если равны
- false, если не равны
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsInfiniteXYZ">
            <summary>Проверить, является ли данный ограничивающий параллелепипед
бесконечным по всем осям</summary>
            <returns>
- true, если является бесконечным
- false, если не является бесконечным
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsInfiniteZ">
            <summary>Проверить, является ли данный ограничивающий параллелепипед
бесконечным по оси Z</summary>
            <returns>
- true, если является бесконечным по оси
- false, если не является бесконечным по оси
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsInfiniteY">
            <summary>Проверить, является ли данный ограничивающий параллелепипед
бесконечным по оси Y</summary>
            <returns>
- true, если является бесконечным по оси
- false, если не является бесконечным по оси
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsInfiniteX">
            <summary>Проверить, является ли данный ограничивающий параллелепипед
бесконечным по оси X</summary>
            <returns>
- true, если является бесконечным по оси
- false, если не является бесконечным по оси
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsInfinite">
            <summary>Проверить, является ли данный ограничивающий параллелепипед
бесконечным (хотя бы по одной оси)</summary>
            <returns>
- true, если является бесконечным
- false, если не является бесконечным
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsVacuous">
            <summary> Проверка на вырожденность, когда хотя бы одна из границ не определена</summary>
            <returns>
- true, если является вырожденным
- false, если не является вырожденным
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.IsNull(System.Double,RGK.Math.BoundingBox.BoundingBoxNorm)">
            <summary>Проверить, является ли данный ограничивающий параллелепипед
вырожденным по норме (т.е. его норма не превосходит заданный порог)</summary>
            <param name="iTolerance">Порог равенства нулю</param>
            <param name="iNorm">Используемая норма</param>
            <returns>
- true, если является вырожденным
- false, если не является вырожденным
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Contains(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Common.Context*)">
            <summary>Проверить, содержится ли ограничивающий параллелепипед iBox в
данном ограничивающем параллелепипеде, используя параметры контекста iContext</summary>
            <param name="iBox">ограничивающий параллелепипед для проверки принадлежности данному ограничивающему параллелепипеду</param>
            <param name="iContext">Контекст вычислений</param>
            <returns>
- true, если содержится
- false, если не содержится
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Contains(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Common.Context*)">
            <summary>Проверить, содержит ли данный ограничивающий параллелепипед
точку iPoint, используя параметры контекста iContext</summary>
            <param name="iPoint">Точка для проверки принадлежности данному ограничивающему параллелепипеду</param>
            <param name="iContext">Контекст вычислений</param>
            <returns>
- true, если содержит
- false, если не содержит
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Contains(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>Проверить, содержится ли ограничивающий параллелепипед iBox в
данном ограничивающем параллелепипеде, используя точность iTolerance</summary>
            <param name="iBox">ограничивающий параллелепипед для проверки принадлежности данному ограничивающему параллелепипеду</param>
            <param name="iTolerance">Используемая точность</param>
            <returns>
- true, если содержится
- false, если не содержится
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Contains(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary>Проверить, содержит ли данный ограничивающий
параллелепипед точку iPoint, используя точность iTolerance</summary>
            <param name="iPoint">Точка для проверки принадлежности данному ограничивающему параллелепипеду</param>
            <param name="iTolerance">Используемая точность</param>
            <returns>
- true, если содержит
- false, если не содержит
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Contains(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Проверить, содержится ли ограничивающий параллелепипед
iBox в данном ограничивающем параллелепипеде</summary>
            <param name="iBox">ограничивающий параллелепипед для проверки принадлежности данному ограничивающему параллелепипеду</param>
            <returns>
- true, если содержится
- false, если не содержится
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Contains(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Проверить, содержит ли данный ограничивающий параллелепипед точку iPoint</summary>
            <param name="iPoint">Точка для проверки принадлежности данному ограничивающему параллелепипеду</param>
            <returns>
- true, если содержит
- false, если не содержит
</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Offsetted(System.Double)">
            <summary>Получить ограничивающий параллелепипед
отступа от данного на величину iOffset во всех направлениях</summary>
            <param name="iOffset">Значение отступа</param>
            <returns>Ограничивающий параллелепипед отступа</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Offset(System.Double)">
            <summary>Отступ от текущих размеров данного ограничивающего параллелепипеда на величину iOffset во всех направлениях</summary>
            <param name="iOffset">Значение отступа</param>
            <returns>Ссылка на данный ограничивающий параллелепипед</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Scaled(System.Double)">
            <summary>Получить в iScaleFactor раз масштабированный
ограничивающий параллелепипед с тем же центром</summary>
            <param name="iScaleFactor">Значение коэффициента масштабирования</param>
            <returns>Масштабированный ограничивающий параллелепипед</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.Scale(System.Double)">
            <summary>Изменить размеры ограничивающего параллелепипеда в iScaleFactor раз, не меняя его центр</summary>
            <param name="iScaleFactor">Значение коэффициента масштабирования</param>
            <returns>Ссылка на данный ограничивающий параллелепипед</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.SetDiagonal(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Изменить размеры ограничивающего параллелепипеда, не меняя его центр</summary>
            <param name="iDiagonal">Новое значение диагонали (вектора размеров вдоль осей) ограничивающего параллелепипеда</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.SetCenter(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Переместить центр ограничивающего параллелепипеда
в точку iCenter, не меняя его размеры</summary>
            <param name="iCenter">Новое значение центра ограничивающего параллелепипеда</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.SetBounds(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить значения начала и конца ограничивающего параллелепипеда
равными iMinBound и iMaxBound соответственно</summary>
            <param name="iMinBound">Новое значение начала ограничивающего параллелепипеда</param>
            <param name="iMaxBound">Новое значение конца ограничивающего параллелепипеда</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.SetMaxBound(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить значение конца ограничивающего параллелепипеда
равным iMaxBound</summary>
            <param name="iMaxBound">Новое значение конца ограничивающего параллелепипеда</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.SetMinBound(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить значение начала ограничивающего параллелепипеда
равным iMinBound</summary>
            <param name="iMinBound">Новое значение начала ограничивающего параллелепипеда</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetBoxData(System.Single*)">
            <summary>Поместить данные о BoundBox в массив (необходима для низкоуровневой работы).
порядок следования данных такой: _min.x,y,z,_max.x,y,z</summary>
            <param name="ioBoxData">Массив, в который будут записаны данные</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetBoxData(System.Double*)">
            <summary>Поместить данные о BoundBox в массив (необходима для низкоуровневой работы).
порядок следования данных такой: _min.x,y,z,_max.x,y,z</summary>
            <param name="ioBoxData">Массив, в который будут записаны данные</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetNorm(System.Double,RGK.Math.BoundingBox.BoundingBoxNorm)">
            <summary>Получить норму данного ограничивающего параллелепипеда (с округлением к нулю)</summary>
            <param name="iTolerance">Линейная точность</param>
            <param name="iNorm">Используемая норма</param>
            <returns>Норма</returns>
        </member>
        <member name="F:SurfaceAreaNorm">
Площадь поверхности
</member>
        <member name="F:VolumeNorm">
Объём
</member>
        <member name="F:MaxSizeNorm">
Наибольший размер по осям
</member>
        <member name="F:MinNonZeroSizeNorm">
Наименьший ненулевой размер по осям
</member>
        <member name="F:DiagonalMagnitudeNorm">
Евклидова длина диагонали (используемая по умолчанию)
</member>
        <member name="T:RGK.Math.BoundingBox.BoundingBoxNorm">
Возможные "нормы" ограничивающего параллелепипеда
</member>
        <member name="M:RGK.Math.BoundingBox.GetVolume">
            <summary>Получить объём данного ограничивающего параллелепипеда</summary>
            <returns>Объём</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetSurfaceArea">
            <summary>Получить площадь поверхности данного ограничивающего параллелепипеда</summary>
            <returns>Площадь поверхности</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMaxDistanceTo(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить максимальное расстояние от заданного
ограничивающего параллелепипеда до данного</summary>
            <param name="iBox">Заданный ограничивающий параллелепипед</param>
            <returns>Максимальное расстояние между ограничивающими параллелепипедами</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMaxDistanceTo(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить максимальное расстояние от заданной
точки до данного ограничивающего параллелепипеда</summary>
            <param name="iPoint">Заданная точка</param>
            <returns>Максимальное расстояние от точки до ограничивающего параллелепипеда</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetDistanceTo(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить расстояние от заданного
ограничивающего параллелепипеда до данного</summary>
            <param name="iBox">Заданный ограничивающий параллелепипед</param>
            <returns>Расстояние между ограничивающими параллелепипедами</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetDistanceTo(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить расстояние от заданной точки до
данного ограничивающего параллелепипеда</summary>
            <param name="iPoint">Заданная точка</param>
            <returns>Расстояние от точки до ограничивающего параллелепипеда</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMaxDistanceTo2(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить квадрат максимального расстояния от заданного
ограничивающего параллелепипеда до данного</summary>
            <param name="iBox">Заданный ограничивающий параллелепипед</param>
            <returns>Квадрат максимального расстояния между ограничивающими параллелепипедами</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMaxDistanceTo2(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить квадрат максимального расстояния от заданной
точки до данного ограничивающего параллелепипеда</summary>
            <param name="iPoint">Заданная точка</param>
            <returns>Квадрат максимального расстояния от точки до ограничивающего параллелепипеда</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetDistanceTo2(RGK.Math.BoundingBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить квадрат расстояния от заданного
ограничивающего параллелепипеда до данного</summary>
            <param name="iBox">Заданный ограничивающий параллелепипед</param>
            <returns>Квадрат расстояния между ограничивающими параллелепипедами</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetDistanceTo2(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Получить квадрат расстояния от заданной точки
до данного ограничивающего параллелепипеда</summary>
            <param name="iPoint">Заданная точка</param>
            <returns>Квадрат расстояния от точки до ограничивающего параллелепипеда</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMinNonZeroSize(System.Double)">
            <summary>Получить минимальную ненулевую длину ограничивающего
параллелепипеда вдоль осей (если таковая существует)</summary>
            <param name="iTolerance">Линейная точность</param>
            <returns>Минимальная ненулевая длина ограничивающего параллелепипеда вдоль осей</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMinSize">
            <summary>Получить минимальную длину ограничивающего параллелепипеда вдоль осей</summary>
            <returns>Минимальная длина ограничивающего параллелепипеда вдоль осей</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMaxSize">
            <summary>Получить максимальную длину ограничивающего параллелепипеда вдоль осей</summary>
            <returns>Максимальная длина ограничивающего параллелепипеда вдоль осей</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetSizeZ">
            <summary>Получить длину ограничивающего параллелепипеда вдоль оси Z</summary>
            <returns>Длина ограничивающего параллелепипеда вдоль оси Z</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetSizeY">
            <summary>Получить длину ограничивающего параллелепипеда вдоль оси Y</summary>
            <returns>Длина ограничивающего параллелепипеда вдоль оси Y</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetSizeX">
            <summary>Получить длину ограничивающего параллелепипеда вдоль оси X</summary>
            <returns>Длина ограничивающего параллелепипеда вдоль оси X</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetDiagonal">
            <summary>Получить диагональ ограничивающего параллелепипеда</summary>
            <returns>Диагональ ограничивающего параллелепипеда</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetCenter">
            <summary>Получить середину ограничивающего параллелепипеда</summary>
            <returns>Середина ограничивающего параллелепипеда</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMaxBound">
            <summary>Получить конец ограничивающего параллелепипеда</summary>
            <returns>Конец ограничивающего параллелепипеда</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.GetMinBound">
            <summary>Получить начало ограничивающего параллелепипеда</summary>
            <returns>Начало ограничивающего параллелепипеда</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.op_FunctionCall(System.Boolean,System.Int32)">
            <summary>Получить координату минимума или максимума вдоль соответствующей оси</summary>
            <param name="iMin">Минимум (true) или максимум (false)</param>
            <param name="iCoord">Необходимая координата</param>
            <returns>Искомая координата</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.op_Subscript(System.Boolean)">
            <summary>Получить минимум или максимум ограничивающего параллелепипеда</summary>
            <param name="iMin">Минимум (true) или максимум (false)</param>
            <returns>Искомая точка</returns>
        </member>
        <member name="M:RGK.Math.BoundingBox.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Конструктор по значениям начала (iMinBound) и конца (iMaxBound)</summary>
Конструктор по двум точкам - точке начала (iMinBound) и точке конца (iMaxBound).
ВНИМАНИЕ: Данный конструктор не делает проверок на правильный порядок начала и конца,
поэтому данный метод нельзя использовать для построения ограничивающего параллелепипеда
по двум точкам, вместо него можно воспользоваться методом CreateByPoints() для
создания нового ограничивающего параллелепипеда или методом InitByPoints() для
инициализации данного
<param name="iMinBound">Начало ограничивающего параллелепипеда</param><param name="iMaxBound">Конец ограничивающего параллелепипеда</param></member>
        <member name="M:RGK.Math.BoundingBox.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор по значениям</summary>
            <param name="iMinX">Минимальный размер вдоль первой оси</param>
            <param name="iMinY">Минимальный размер вдоль второй оси</param>
            <param name="iMinZ">Минимальный размер вдоль третье оси</param>
            <param name="iMaxX">Максимальный размер вдоль первой оси</param>
            <param name="iMaxY">Максимальный размер вдоль второй оси</param>
            <param name="iMaxZ">Максимальный размер вдоль третье оси</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*)">
            <summary>Конструктор по массиву значений</summary>
            <param name="iValues">Массив 6 значений [Xmin, ..., Zmax]</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Конструктор для одной точки iPoint - создаёт вырожденный ограничивающий параллелепипед
с точкой iPoint в качестве начала и конца, который ограничивает только эту точку</summary>
            <param name="iPoint">Точка, определяющая ограничивающий параллелепипед</param>
        </member>
        <member name="M:RGK.Math.BoundingBox.#ctor">
            <summary>Конструктор по умолчанию - создаёт вырожденный ограничивающий параллелепипед
Границы такого параллелепипеда не определены</summary>
        </member>
        <member name="T:RGK.Math.BoundingBox">
            <summary>Класс ограничивающего параллелепипеда в трёхмерном пространстве,
имеющий точки начала и конца, а также ребра, параллельные осям координат</summary>
Класс ограничивающего параллелепипеда в трёхмерном пространстве, имеющий
точки начала и конца, а также ребра, параллельные осям координат.
Конструкторы данного класса не делают проверок на правильный порядок
точек начала и конца, поэтому вся ответственность за корректность
создаваемого ограничивающего параллелепипеда ложится на его создателя
</member>
        <member name="M:RGK.Math.AffineMap3D.ResetOperations">
Выполнить сброс операций
</member>
        <member name="M:RGK.Math.AffineMap3D.Reflect(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Выполнить преобразования отражения относительно точки
<param name="iPoint">Точка отражения</param><param name="iVector">Отражаемый вектор</param><param name="iLinearTolerance">Допуск, с которым выполняется нормирование вектора</param></member>
        <member name="M:RGK.Math.AffineMap3D.Map(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double*,RGK.Math.RepresentationType)">
Выполнить преобразование вектора в соответствии с картой
<param name="iVector">Исходный вектор</param><param name="oResult">Результирующий вектор</param><param name="oRep">Тип представления</param></member>
        <member name="M:RGK.Math.AffineMap3D.IsOrthogonal(System.Double)">
Проверка, что матрица ортогональна
<returns>true, если матрица ортогональна</returns><param name="iTolerance">Точность</param></member>
        <member name="M:RGK.Math.AffineMap3D.HasOnlyUniformScale(System.Double)">
Проверка, что матрица не содержит неоднородного масштабирования 
<returns>true, если не содержит</returns><param name="iTolerance">Точность</param></member>
        <member name="M:RGK.Math.AffineMap3D.IsEqual(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Проверка эквивалентности преобразований
</member>
        <member name="M:RGK.Math.AffineMap3D.IsIdentity(System.Double)">
Проверка единичного (эквивалентного) преобразования
<param name="iLinearTolerance">Допуск, с которым выполняется сравнение с единичным преобразованием</param><returns>true, если преобразование является единичным (эквивалентным)</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Degenerated(System.Double)">
Проверка вырожденного преобразования
<param name="iLinearTolerance">Допуск, с которым выполняется проверка вырожденности</param><returns>true, если преобразование является вырожденным</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Map(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Выполнить преобразование вектора в соответствии с картой и весом
<param name="iVector">Исходный вектор</param><param name="iWeight">Вес</param><returns>Результирующий вектор</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Map(RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Выполнить преобразование поворота и переноса системы координат в соответствии с картой
<param name="iLCS">Исходная система координат</param><returns>Результирующая система координат</returns></member>
        <member name="M:RGK.Math.AffineMap3D.VMap(RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Выполнить преобразование поворота системы координат в соответствии с картой
<param name="iLCS">Исходная система координат</param><returns>Результирующая система координат</returns></member>
        <member name="M:RGK.Math.AffineMap3D.VMap(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Выполнить преобразование вектора в соответствии с картой
<param name="iVector">Исходный вектор</param><returns>Результирующий вектор</returns></member>
        <member name="M:RGK.Math.AffineMap3D.VMap(System.Double,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Выполнить преобразование точки в соответствии с картой
<param name="iX">Координата X исходной точки</param><param name="iY">Координата Y исходной точки</param><param name="iZ">Координата Z исходной точки</param><param name="oX">Координата X результирующей точки</param><param name="oY">Координата Y результирующей точки</param><param name="oZ">Координата Z результирующей точки</param></member>
        <member name="M:RGK.Math.AffineMap3D.Map(System.Double,System.Double,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Выполнить преобразование точки в соответствии с картой
<param name="iX">Координата X исходной точки</param><param name="iY">Координата Y исходной точки</param><param name="iZ">Координата Z исходной точки</param><param name="iWeight">Вес точки</param><param name="oX">Координата X результирующей точки</param><param name="oY">Координата Y результирующей точки</param><param name="oZ">Координата Z результирующей точки</param><param name="oHomgn">Признак гомогенного преобразования</param></member>
        <member name="M:RGK.Math.AffineMap3D.Rotate(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Double)">
Выполнить поворот карты преобразования в соответствии с матрицей поворотов
<param name="iRotationMatrix">Матрица поворотов</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param><param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param></member>
        <member name="M:RGK.Math.AffineMap3D.InvMap">
Создание новой карты преобразования, содержащей обратное преобразование
<returns>Новый объект карты преобразования</returns></member>
        <member name="M:RGK.Math.AffineMap3D.InvMapSelf">
Преобразование текущей карты преобразования в обратную
<returns>Ссылка на текущий объект после выполнения преобразования</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Determinant">
Рассчитать определитель матрицы 3x3
</member>
        <member name="M:RGK.Math.AffineMap3D.CheckScaled(System.Double)">
Проверка наличия преобразования масштабирования в карте
</member>
        <member name="M:RGK.Math.AffineMap3D.Scaled">
Признак наличия преобразования масштабирования в карте
<returns>ненулевое значение, если карта содержит преобразование масштабирования</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Scale(System.Double,System.Double)">
Выполнить масштабирование преобразования карты вдоль осей с одинаковым масштабом
<param name="iFactor">Значение масштаба</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param></member>
        <member name="M:RGK.Math.AffineMap3D.Scale(System.Double,System.Double,System.Double,System.Double)">
Выполнить масштабирование преобразования карты вдоль осей
<param name="iFactorX">Значение масштаба вдоль оси X</param><param name="iFactorY">Значение масштаба вдоль оси Y</param><param name="iFactorZ">Значение масштаба вдоль оси Z</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param></member>
        <member name="M:RGK.Math.AffineMap3D.ScaleZ(System.Double,System.Double)">
Выполнить масштабирование преобразования карты вдоль оси Z
<param name="iFactor">Значение масштаба вдоль оси Z</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param></member>
        <member name="M:RGK.Math.AffineMap3D.ScaleY(System.Double,System.Double)">
Выполнить масштабирование преобразования карты вдоль оси Y
<param name="iFactor">Значение масштаба вдоль оси Y</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param></member>
        <member name="M:RGK.Math.AffineMap3D.ScaleX(System.Double,System.Double)">
Выполнить масштабирование преобразования карты вдоль оси X
<param name="iFactor">Значение масштаба вдоль оси X</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param></member>
        <member name="M:RGK.Math.AffineMap3D.SetLCSOrts(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Установить значения карты преобразования в соответствии с направлениями осей системы координат
<param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param><param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param></member>
        <member name="M:RGK.Math.AffineMap3D.Transferred">
Признак наличия преобразования переноса в карте
<returns>ненулевое значение, если карта содержит преобразование переноса</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Transfer(System.Double,System.Double,System.Double)">
Выполнить смещение (перенос) преобразований в карте вдоль осей
<param name="iAlongX">Перенос вдоль оси X</param><param name="iAlongY">Перенос вдоль оси Y</param><param name="iAlongZ">Перенос вдоль оси Z</param></member>
        <member name="M:RGK.Math.AffineMap3D.Rotated">
Признак наличия преобразования вращения в карте
<returns>ненулевое значение, если карта содержит преобразование поворота</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Rotate(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
Поворот карты направляющим углам
<param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param><param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param></member>
        <member name="M:RGK.Math.AffineMap3D.RotateZ(System.Double,System.Double,System.Double)">
Поворот карты относительно своей оси Z
<param name="iAngle">Угол поворота в радианах</param><param name="iLinearTolerance">Tolerance with which the resulting scaling is considered to be 1</param><param name="iAngularTolerance">Tolerance with which the resulting rotation angle is considered to be 0</param></member>
        <member name="M:RGK.Math.AffineMap3D.RotateY(System.Double,System.Double,System.Double)">
Поворот карты относительно своей оси Y
<param name="iAngle">Угол поворота в радианах</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param><param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param></member>
        <member name="M:RGK.Math.AffineMap3D.RotateX(System.Double,System.Double,System.Double)">
Поворот карты относительно своей оси X
<param name="iAngle">Угол поворота в радианах</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param><param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param></member>
        <member name="M:RGK.Math.AffineMap3D.InvNormZ(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
            <param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param>
            <param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param>
        </member>
        <member name="M:RGK.Math.AffineMap3D.NormZ(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
            <param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param>
            <param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param>
        </member>
        <member name="M:RGK.Math.AffineMap3D.Transfer(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Перенос карты вдоль вектора направления
<param name="iTranslation">Вектор переноса</param></member>
        <member name="M:RGK.Math.AffineMap3D.Rotate(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Double)">
Поворот карты вокруг оси
<param name="iCenter">Центр поворота</param><param name="iAxis">Направление оси, относительно которой производится поворот</param><param name="iAxis">Угол поворота в радианах</param></member>
        <member name="M:RGK.Math.AffineMap3D.ClearT">
Обнуление вектора трансформации
</member>
        <member name="M:RGK.Math.AffineMap3D.GetT">
Получение вектора, задающего перенос системы координат, для данного преобразования
<returns> Вектор переноса системы координат </returns></member>
        <member name="M:RGK.Math.AffineMap3D.GetMap(System.Double*,System.Int32)">
Получение значений параметров преобразования в виде массива
<param name="iViewMatrix">Массив значений матрицы преобразования</param><param name="iSize">Размер массива значений матрицы преобразования. Количество элементов массива должно быть равно 12(вся матрица преобразований), 9(только повороты и масштабирование) или 3(только перемещение)</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadSize в случае неверно переданного размера массива
</returns></member>
        <member name="M:RGK.Math.AffineMap3D.SetMap(System.Double!System.Runtime.CompilerServices.IsConst*,System.Double,System.Int32)">
Установка значений параметров преобразования в виде массива
<param name="iViewMatrix">Массив значений матрицы преобразования. Количество элементов массива должно быть равно 12</param><param name="iSize">Размер массива значений матрицы преобразования. Количество элементов массива должно быть равно 12(вся матрица преобразований), 9(только повороты и масштабирование) или 3(только перемещение)</param><returns>
- Result::Success в случае успешного выполнения
- Result::BadSize в случае неверно переданного размера массива
</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Multiply(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Перемножение преобразований
<param name="iToMul">Карта, на которую производится умножение</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param><param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param><returns>Новая карта, соответствующая суммарному преобразованию</returns></member>
        <member name="M:RGK.Math.AffineMap3D.MultiplySelf(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Перемножение преобразований
<param name="iToMul">Карта, на которую производится умножение</param><param name="iLinearTolerance">Допуск, с которым результирующее преобразование масштабирования считается единичным</param><param name="iAngularTolerance">Допуск, с которым результирующее преобразование поворота считается нулевым</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.AffineMap3D.ResetMap">
Сброс карты в исходное состояние
</member>
        <member name="M:RGK.Math.AffineMap3D.op_Assign(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор присваивания
<param name="iToCopy">Исходная карта преобразования</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.AffineMap3D.Dispose">
Деструктор
</member>
        <member name="M:RGK.Math.AffineMap3D.#ctor(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="iMap">Исходная карта преобразования</param></member>
        <member name="M:RGK.Math.AffineMap3D.#ctor">
Конструктор по умолчанию
</member>
        <member name="T:RGK.Math.AffineMap3D">
Класс, реализующий функциональность карты аффинного преобразования 3D объектов
<seealso cref="!:Аффинное преобразование" /></member>
        <member name="M:RGK.Math.LCS3D.GetNorm(System.Double)">
Преобразование ортогональной СК в ортонормированную
<param name="iLinearTolerance">Линейная точность</param><returns>Ортонормированная СК</returns></member>
        <member name="M:RGK.Math.LCS3D.InModel(System.Double)">
Простая проверка на то, что начало локальной системы координат лежит в пределах текущей модели
<param name="iBoxSize">Половина размера модели</param><returns>true, если начало системы координат лежит в пределах модели</returns></member>
        <member name="M:RGK.Math.LCS3D.IsRight(System.Double,System.Double)">
Проверка, что система координат является правой
</member>
        <member name="M:RGK.Math.LCS3D.IsOrthogonal(System.Double,System.Double)">
Оси системы координат ортогональны
<returns>True если оси системы координат ортогональны</returns></member>
        <member name="M:RGK.Math.LCS3D.GetZAxis">
Получение направления оси Z
<returns>Вектор направления оси Z</returns></member>
        <member name="M:RGK.Math.LCS3D.GetYAxis">
Получение направления оси Y
<returns>Вектор направления оси Y</returns></member>
        <member name="M:RGK.Math.LCS3D.GetXAxis">
Получение направления оси X
<returns>Вектор направления оси X</returns></member>
        <member name="M:RGK.Math.LCS3D.GetOrigin">
Получение начала системы координат
<returns>Точка начала системы координат</returns></member>
        <member name="M:RGK.Math.LCS3D.Rebuild(RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Double,System.Double)">
Перестроение системы координат
</member>
        <member name="M:RGK.Math.LCS3D.Multiply(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Получение новой системы координат в соответствии с картой преобразования
<param name="iMap">Карта преобразования</param><returns>Новая система координат</returns></member>
        <member name="M:RGK.Math.LCS3D.MultiplySelf(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Преобразование системы координат в соответствии с картой преобразования
<param name="iMap">Карта преобразования</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.LCS3D.GetMovementTo(RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Получить карту преобразования в глобальном пространстве, из одной системы координат в другую
<param name="iAnother">Вторая система координат</param><returns>Карта аффинного преобразования</returns></member>
        <member name="M:RGK.Math.LCS3D.GetMapToGlobal(System.Double)">
Получить карту из локальных координат в глобальные.
<returns>Карта аффинного преобразования</returns></member>
        <member name="M:RGK.Math.LCS3D.IsEqual(RGK.Math.LCS3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Оператор сравнения
<param name="ToBeCompared">Исходная система координат</param><returns>true если системы координат совпадают, false если не совпадают</returns></member>
        <member name="M:RGK.Math.LCS3D.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Конструктор.
Направления осей системы координат совпадают с направлением глобальных осей.
<param name="iorigin">Точка начала системы координат</param><param name="ixAxis">Направление оси X</param><param name="iOnXYPlane">Направление нормали к плоскости XY</param></member>
        <member name="M:RGK.Math.LCS3D.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Конструктор.
Направления осей системы координат совпадают с направлением глобальных осей.
<param name="iorigin">Точка начала системы координат</param><param name="ixAxis">Направление оси X</param></member>
        <member name="M:RGK.Math.LCS3D.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор.
Направления осей системы координат совпадают с направлением глобальных осей.
<param name="iorigin">Точка начала системы координат</param></member>
        <member name="M:RGK.Math.LCS3D.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор
<param name="origin">Точка начала системы координат</param><param name="xAxis">Направление оси X</param><param name="yAxis">Направление оси Y</param><param name="zAxis">Направление оси Z</param></member>
        <member name="M:RGK.Math.LCS3D.#ctor">
            <summary>Конструктор по умолчанию</summary>
Конструктор. По умолчанию система расположена в точке (0,0,0),
оси координат направлены вдоль глобальных осей X,Y,Z
</member>
        <member name="T:RGK.Math.LCS3D">
Класс 3D системы координат
<seealso cref="!:Локальная система координат" /></member>
        <member name="D:RGK.Math.Vector3DArray">
Массив 3D векторов
</member>
        <member name="M:RGK.Math.Norm(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
L2-норма вектора, она же модуль, она же длина.
</member>
        <member name="M:RGK.Math.CrossProduct(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Векторное произведение. Симметричная форма.
</member>
        <member name="M:RGK.Math.Vector3D.end">
Константный итератор на конец.

Итератор на конец.
</member>
        <member name="M:RGK.Math.Vector3D.begin">
Константный итератор на начало.

Итератор на начало.
</member>
        <member name="M:RGK.Math.Vector3D.IsValidNonZero(System.Double)">
Проверка следующих условий:
1. Ни одна из компонент вектора не равна Inf или NaN
2. Хотя бы одна из компонент вектора не равна нулю с заданной линейной точностью
<returns>true - вектор удовлетворяет вышеперечисленным условиям</returns></member>
        <member name="M:RGK.Math.Vector3D.IsValidNonZero">
Проверка следующих условий:
1. Ни одна из компонент вектора не равна Inf или NaN
2. Хотя бы одна из компонент вектора является нормальным числом (не ноль и не денормализованное число)
<returns>true - вектор удовлетворяет вышеперечисленным условиям</returns></member>
        <member name="M:RGK.Math.Vector3D.IsValid">
Проверяет, что ни одна из компонент вектора не равна Inf или NaN
<returns>true - вектор удовлетворяет вышеперечисленным условиям</returns></member>
        <member name="M:RGK.Math.Vector3D.MakeOrtho(System.Double)">
Получение ортогонального вектора
<returns>Новый ортогональный вектор</returns></member>
        <member name="M:RGK.Math.Vector3D.IsNormal(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Проверка ортогональности векторов с заданной точностью
<param name="iAnother">Вектор, с которым сравнивается данный</param><param name="iLinearTolerance">Линейная точность сравнения </param><param name="iAngularTolerance">Угловая точность сравнения </param><returns>true если векторы ортогональны, false если не ортогональны</returns></member>
        <member name="M:RGK.Math.Vector3D.IsColinear(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Проверка параллельности векторов с заданной точностью
<param name="iAnother">Вектор, с которым сравнивается данный</param><param name="iLinearTolerance">Линейная точность сравнения </param><param name="iAngularTolerance">Угловая точность сравнения </param><returns>true если векторы параллельны, false если не параллельны</returns></member>
        <member name="M:RGK.Math.Vector3D.CutCoord(System.Int32)">
Отбрасывание заданной координаты вектора
<returns>Результирующий вектор</returns></member>
        <member name="M:RGK.Math.Vector3D.CutCoordSelf(System.Int32)">
Отбрасывание заданной координаты вектора
</member>
        <member name="M:RGK.Math.Vector3D.GetMinCoordinate(System.Boolean)">
Получение минимального значения координаты
<param name="iWithSign"> Если true ищется знаковый минимум, иначе минимум по абсолютному значению</param></member>
        <member name="M:RGK.Math.Vector3D.GetMaxCoordinate(System.Boolean)">
Получение максимального значения координаты
<param name="iWithSign"> Если true ищется знаковый максимум, иначе максимум по абсолютному значению</param></member>
        <member name="M:RGK.Math.Vector3D.MaxNorm">
Норма вектора, определённая через максимальное значение модулей его компонент
N(v) = max(|x|, |y|, |z|)
<returns> норма вектора </returns></member>
        <member name="M:RGK.Math.Vector3D.GetMaxCoord">
Получение максимальной из координат по модулю
<returns>Координата, модуль которой является максимальным</returns></member>
        <member name="M:RGK.Math.Vector3D.CopyXYZ(System.Single*)">
Получение массива значений координат
<param name="oResult">Адрес массива координат. Массив должен содержать 3 элемента</param></member>
        <member name="M:RGK.Math.Vector3D.CopyXYZ(System.Double*)">
Получение массива значений координат
<param name="oResult">Адрес массива координат. Массив должен содержать 3 элемента</param></member>
        <member name="M:RGK.Math.Vector3D.GetXYZ(System.Double*,System.Int32)">
Получение вектора координат точки
</member>
        <member name="M:RGK.Math.Vector3D.GetZRef">
Получение координаты Z
<returns>Значение координаты Z</returns></member>
        <member name="M:RGK.Math.Vector3D.GetYRef">
Получение координаты Y
<returns>Значение координаты Y</returns></member>
        <member name="M:RGK.Math.Vector3D.GetXRef">
Получение координаты X
<returns>Значение координаты X</returns></member>
        <member name="M:RGK.Math.Vector3D.GetZ">
Получение координаты Z
<returns>Значение координаты Z</returns></member>
        <member name="M:RGK.Math.Vector3D.GetY">
Получение координаты Y
<returns>Значение координаты Y</returns></member>
        <member name="M:RGK.Math.Vector3D.GetX">
Получение координаты X
<returns>Значение координаты X</returns></member>
        <member name="M:RGK.Math.Vector3D.GetAngle(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получение угла между векторами
<param name="iOther">Вектор, до которого нужно посчитать угол</param><returns>Значение угла между векторами в радианах</returns></member>
        <member name="M:RGK.Math.Vector3D.DistanceTo2(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить квадрат расстояния от точки заданной вектором до указанной точки
<param name="iPointTo">Точка до которой ищется квадрат расстояние </param><returns>Расстояние</returns></member>
        <member name="M:RGK.Math.Vector3D.DistanceTo(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить расстояния от точки заданной вектором до указанной точки
<param name="iPointTo">Точка до которой ищется расстояние </param><returns>Расстояние</returns></member>
        <member name="M:RGK.Math.Vector3D.Magnitude2">
Получить длину вектора в квадрате
<returns>Значение длины вектора в квадрате</returns></member>
        <member name="M:RGK.Math.Vector3D.Magnitude">
Получить длину вектора
<returns>Значение длины вектора</returns></member>
        <member name="M:RGK.Math.Vector3D.SetXYZ(System.Single!System.Runtime.CompilerServices.IsConst*)">
Задание значений координат вектора по значениям передаваем через указатель на массив
<param name="iValues"> Значение компонент </param></member>
        <member name="M:RGK.Math.Vector3D.SetXYZ(System.Double!System.Runtime.CompilerServices.IsConst*)">
Задание значений координат вектора по значениям через указатель на массив
<param name="iValues"> Значение компонент </param></member>
        <member name="M:RGK.Math.Vector3D.SetXYZ(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Задание значений координат вектора по двумерному вектору
<param name="iVector"> Двумерный вектор </param></member>
        <member name="M:RGK.Math.Vector3D.SetXYZ(System.Double)">
Задание значений координат вектора равными переданному значению
<param name="iComponentsValue"> Значение, в которое установятся, все компоненты вектора </param></member>
        <member name="M:RGK.Math.Vector3D.SetXYZ(System.Double,System.Double,System.Double)">
Задание значений координат вектора
<param name="x">Координата X</param><param name="y">Координата Y</param><param name="z">Координата Z</param></member>
        <member name="M:RGK.Math.Vector3D.Permult(RGK.Math.Coordinates,RGK.Math.Coordinates,RGK.Math.Coordinates)">
Переставить компоненты вектора
</member>
        <member name="M:RGK.Math.Vector3D.SetNormByLength(System.Double,System.Double)">
Нормирование вектора на заданную длину
</member>
        <member name="M:RGK.Math.Vector3D.SetNorm(System.Double)">
Нормирование вектора на длину 1
</member>
        <member name="M:RGK.Math.Vector3D.GetNorm(System.Double)">
Нормирование вектора на длину 1
<returns>Новый объект, являющийся результатом нормирования</returns></member>
        <member name="M:RGK.Math.Vector3D.GetNormByLength(System.Double,System.Double)">
Нормирование вектора на заданную длину
<param name="iDistance">Длина нормирования вектора</param><returns>Новый объект, являющийся результатом нормирования</returns></member>
        <member name="M:RGK.Math.Vector3D.ComponentMultiply(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Покомпонентное произведение векторов
<param name="iToMul"> Вектор, на который умножаем данный</param><returns> Новый объект, компоненты которого являются компонент текущего объекта и вектора iToMul</returns></member>
        <member name="M:RGK.Math.Vector3D.VectorMultiply(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Векторное произведение векторов
<param name="iToMul">Вектор, на который умножается данный</param><returns>Новый объект, являющийся векторным произведением текущего объекта и вектора iToMul</returns></member>
        <member name="M:RGK.Math.Vector3D.VMap(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Аффинное преобразование вектора
<param name="iMap">Карта преобразования</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector3D.VMapSelf(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Аффинное преобразование вектора
<param name="iMap">Карта преобразования</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Multiply(RGK.Math.ProjectiveMap3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проекционное преобразование вектора
<param name="iMap">Карта преобразования</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Multiply(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Аффинное преобразование вектора
<param name="iMap">Карта преобразования</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Subtraction(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Вычитание векторов
<param name="iToDecr">Вектор, который вычитается из данного</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Addition(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сумма векторов
<param name="iToAdd">Вектор, с которым складывается данный</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Division(System.Double)">
Масштабирование вектора. Деление значений координат на заданное число
<param name="iLambda">Значение делителя</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Multiply(System.Double)">
Масштабирование вектора. Умножение значений координат на заданное число
<param name="iLambda">Значение множителя</param><returns>Новый объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Multiply(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Скалярное произведение векторов
<param name="iToMul">Второй множитель</param><returns>Значение скалярного произведение векторов</returns></member>
        <member name="M:RGK.Math.Vector3D.op_MultiplicationAssignment(RGK.Math.ProjectiveMap3D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проекционное преобразование вектора
<param name="iMap">Карта преобразования</param></member>
        <member name="M:RGK.Math.Vector3D.op_MultiplicationAssignment(RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Аффинное преобразование вектора
<param name="iMap">Карта преобразования</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_SubtractionAssignment(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Вычитание векторов
<param name="iToDecr">Вектор, который вычитается из данного</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_AdditionAssignment(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сумма векторов
<param name="iToAdd">Вектор, с которым складывается данный</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_DivisionAssignment(System.Double)">
Масштабирование вектора. Деление значений координат на заданное число
<param name="iLambda">Значение делителя</param><returns>Ссылка на объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_MultiplicationAssignment(System.Double)">
Масштабирование вектора. Умножение значений координат на заданное число
<param name="iLambda">Значение множителя</param><returns>Ссылка на текущий объект</returns></member>
        <member name="M:RGK.Math.Vector3D.op_UnaryNegation">
Противоположный вектор. Умножение значений координат вектора на -1
<returns>Объект, являющийся противоположным вектором</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Subscript(System.Int32)">
Получение значения координаты вектора по индексу
<param name="idx">Индекс координаты 0 = X, 1 = Y, 2 = Z</param><returns>Значение координаты</returns>
Получение ссылки на значение координаты вектора по индексу
<param name="idx">Индекс координаты 0 = X, 1 = Y, 2 = Z</param><returns>Ссылка на координату</returns></member>
        <member name="M:RGK.Math.Vector3D.Flush">
Обнуление координат вектора
</member>
        <member name="M:RGK.Math.Vector3D.Vector">
Получение координат вектора в виде массива
<returns>Массив из 3 элементов, содержащий координаты X,Y,Z</returns></member>
        <member name="M:RGK.Math.Vector3D.IsEqual(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
Проверка двух векторов на равенство
<param name="iOther">Вектор, с которым сравнивается данный</param><param name="iLinearTolerance">Линейная точность, с которой производится сравнение</param><param name="iAngularTolerance">Угловая точность, с которой производится сравнение</param><returns>true если векторы равны, false если не равны</returns></member>
        <member name="M:RGK.Math.Vector3D.IsEqual(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Проверка двух векторов на равенство
<param name="iOther">Вектор, с которым сравнивается данный</param><param name="iLinearTolerance">Линейная точность, с которой производится сравнение</param><returns>true если векторы равны, false если не равны</returns></member>
        <member name="M:RGK.Math.Vector3D.IsEqual(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка двух векторов на равенство
<param name="iOther">Вектор, с которым сравнивается данный</param><returns>true если векторы равны, false если не равны</returns></member>
        <member name="M:RGK.Math.Vector3D.op_Assign(System.Double!System.Runtime.CompilerServices.IsConst*)">
Оператор присваивания по массиву значений
<param name="iToCopy">Массив значений координат вектора в порядке X, Y, Z. Массив должен содержать 3 элемента.</param></member>
        <member name="M:RGK.Math.Vector3D.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор по двум векторам. Результатом является разница векторов iP2 - iP1
<param name="iP1">Первый вектор разницы</param><param name="iP1">Второй вектор разницы</param></member>
        <member name="M:RGK.Math.Vector3D.#ctor(System.Double)">
Конструктор по одному числу, все компоненты, устанавливаются в это значение
<param name="iVal">Значение компонент</param></member>
        <member name="M:RGK.Math.Vector3D.#ctor(RGK.Math.Vector2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор по вектору на плоскости
<param name="iV">Вектор с координатами X и Y</param></member>
        <member name="M:RGK.Math.Vector3D.#ctor(System.Single!System.Runtime.CompilerServices.IsConst*)">
Конструктор по массиву значений
<param name="iVals">Массив значений координат вектора в порядке X, Y, Z. Массив должен содержать 3 элемента.</param></member>
        <member name="M:RGK.Math.Vector3D.#ctor(System.Double!System.Runtime.CompilerServices.IsConst*)">
Конструктор по массиву значений
<param name="iVals">Массив значений координат вектора в порядке X, Y, Z. Массив должен содержать 3 элемента.</param></member>
        <member name="M:RGK.Math.Vector3D.op_Assign(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор присваивания по вектору
<param name="iOther">Исходный вектор</param></member>
        <member name="M:RGK.Math.Vector3D.#ctor(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Копирующий конструктор по вектору
</member>
        <member name="M:RGK.Math.Vector3D.#ctor(System.Double,System.Double,System.Double)">
Конструктор по координатам
<param name="x">Значение координаты X</param><param name="y">Значение координаты Y</param><param name="z">Значение координаты Z</param></member>
        <member name="M:RGK.Math.Vector3D.#ctor">
Деструктор
Конструктор по умолчанию. Все координаты принимают нулевые значения.
</member>
        <member name="D:RGK.Math.Vector3D.value_type">
Тип элементов вектора
</member>
        <member name="D:RGK.Math.Vector3D.size_type">
Тип для индексации компонент вектора
</member>
        <member name="T:RGK.Math.Vector3D">
3D вектор
<seealso cref="!:Векторы (точки)" /></member>
        <member name="F:TopolChange">
Измененения в топологических элементах
</member>
        <member name="F:Attribute">
Атрибуты
</member>
        <member name="F:Representation">
Представления
</member>
        <member name="F:Surface">
Поверхности
</member>
        <member name="F:Curve">
Кривые
</member>
        <member name="F:AffineMap">
Карты преобразования
</member>
        <member name="F:LCS3D">
Системы координат
</member>
        <member name="F:Axis3D">
3D оси
</member>
        <member name="F:Vector3D">
3D векторы
</member>
        <member name="F:PartInstance">
Экземпляры подсборок
</member>
        <member name="F:Assembly">
Подсборки
</member>
        <member name="F:CoEdge">
R-рёбра
</member>
        <member name="F:CoFace">
R-грани
</member>
        <member name="F:Vertex">
Вершины
</member>
        <member name="F:Edge">
Рёбра
</member>
        <member name="F:Loop">
Циклы
</member>
        <member name="F:Face">
Грани
</member>
        <member name="F:Shell">
Оболочки
</member>
        <member name="F:Region">
Регионы
</member>
        <member name="F:Body">
Тела
</member>
        <member name="T:RGK.Common.Statistics.Type">
Тип элемента модели
</member>
        <member name="T:RGK.Common.Statistics">
Класс, предназначенный для сбора статистики об использовании элементов модели
<seealso cref="!:Топология" /><seealso cref="!:Геометрия" /></member>
        <member name="T:RGK.Math.RepresentationType">
Тип представления матрицы
</member>
        <member name="F:UndefinedRepresentation">
Неизвестное представление
</member>
        <member name="F:WeightedRational">
Рациональное представление с координатами точек с весами
</member>
        <member name="F:HomogeniousRational">
Рациональное представление с гомогенными координатами
</member>
        <member name="F:NonRational">
Нерациональное (возможно, Декартово) представление
</member>
        <member name="T:RGK.Math.Coordinates">
Координата
</member>
        <member name="F:H">
Координата H
</member>
        <member name="F:Z">
Координата Z
</member>
        <member name="F:Y">
Координата Y
</member>
        <member name="F:X">
Координата X
</member>
        <member name="M:RGK.Geometry.Interval._DrawParameterInInterval(System.Double)">
Без проверки типа интервала
</member>
        <member name="M:RGK.Geometry.Interval.Trace(std.basic_ostream&lt;System.Char,std.char_traits{System.Char}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Отладочный метод. Вывод объекта в поток.
</member>
        <member name="M:RGK.Geometry.Interval.ContainParamOn0Period(System.Double,System.Double)">
Проверка, что передаваемый параметр лежит внутри данного интервала на нулевом периоде для периодичного интервала
<param name="iParam">Параметр, для которого проверяется вложенность</param><param name="iTolerance">Точность, с которой сравнивается совпадение границ</param><returns>Common::Success - в случае если параметр лежит в интервала</returns></member>
        <member name="M:RGK.Geometry.Interval.FindPeriod(System.Double)">
Поиск периода, на котором находиться заданный параметр
<param name="iParam"> Заданный параметр </param><returns> Значение периода, если интервал периодичный, ноль в противном случае </returns></member>
        <member name="M:RGK.Geometry.Interval.ParametersOnOnePeriod(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Приведение заданых параметров к одинаковому периоду.(Период не обязательно нулевой)
Если интервал не периодичен параметры не изменяется
<param name="iParam1"> Параметр </param><param name="iParam2"> Параметр </param></member>
        <member name="M:RGK.Geometry.Interval.Unite(RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,RGK.Geometry.Interval*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Объединение интервалов. Обработка периодического случая
<param name="iInterval">Интервал, с которым выполняется объединение</param><param name="iPeriod">Период</param><param name="iTolerance">Точность, с которой сравнивается совпадение границ</param><param name="oIntersection">Объединение интервалов</param><returns>
true - интервалы пересекаются
false - интервалы не пересекаются
</returns></member>
        <member name="M:RGK.Geometry.Interval.GetCenter">
Получение параметра, задающего середину интервала
</member>
        <member name="M:RGK.Geometry.Interval.GetLinearPrecision(RGK.Common.Context*)">
Определить точность сравнения размеров в параметрической области
<param name="iContext">Контекст вычисления, из которого берётся относительная точность</param><returns>Точность</returns></member>
        <member name="M:RGK.Geometry.Interval.GetParameter(System.Double)">
Получить параметр на интервале по относительной длине интервала
<param name="iInterval">Относительная длина интервала</param><returns>Параметр</returns></member>
        <member name="M:RGK.Geometry.Interval.Intersect(RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,RGK.Geometry.Interval*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Пересечение интервалов
<param name="iInterval">Интервал, с которым выполняется пересечение</param><param name="iTolerance">Точность, с которой сравнивается совпадение границ</param><param name="oIntersection">Пересечение интервалов</param><returns>
true - интервалы пересекаются
false - интервалы не пересекаются
</returns></member>
        <member name="M:RGK.Geometry.Interval.DrawParameterInInterval(System.Double)">
Для конечного интервала вписать передаваемый параметр в интервал
<param name="iParameter">Параметр</param><returns>
Новое значение параметра
</returns></member>
        <member name="M:RGK.Geometry.Interval.ConvertParamFromInterval1ToInterval2(System.Double,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Линейное отображение параметра с одного интервала на другой
<param name="iParam">Параметр на интервале 1</param><param name="interval1">Интервал 1</param><param name="interval2">Интервал 2</param><returns>параметр на втором интервале</returns></member>
        <member name="M:RGK.Geometry.Interval.ContainParam(System.Double,System.Double)">
Проверка, что передаваемый параметр лежит внутри данного интервала
<param name="iParam">Параметр, для которого проверяется вложенность</param><param name="iTolerance">Точность, с которой сравнивается совпадение границ</param><returns>&gt;Common::Success - передаваемый параметр лежит внутри данного интервала</returns></member>
        <member name="M:RGK.Geometry.Interval.IsEqualIntervalWithoutType(RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Проверка, что интервалы совпадают с заданной точностью без совпадения типа
<param name="iInterval">Интервал</param><param name="iTolerance">Точность, с которой сравнивается совпадение границ</param><returns>true - интервал oInterval совпадает с интервалом</returns></member>
        <member name="M:RGK.Geometry.Interval.IsEqualInterval(RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Проверка, что интервалы совпадают с заданной точностью
<param name="iInterval">Интервал</param><param name="iTolerance">Точность, с которой сравнивается совпадение границ</param><returns>true - интервал oInterval совпадает с интервалом</returns></member>
        <member name="M:RGK.Geometry.Interval.IsNestedInterval(RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
Проверка, что передаваемый в параметре интервал совпадает с данным интервалом или вложен в него
<param name="iInterval">Интервал, для которого проверяется вложенность</param><param name="iTolerance">Точность, с которой сравнивается совпадение границ</param><returns>true - интервал oInterval совпадает с интервалом или вложен в него</returns></member>
        <member name="M:RGK.Geometry.Interval.Revert">
Инвертировать интервал
<returns>Интервал, у которого начало и конец наоборот по отношению к исходному</returns></member>
        <member name="M:RGK.Geometry.Interval.GetType">
Получить тип интервала
<returns>Тип интервала</returns></member>
        <member name="M:RGK.Geometry.Interval.SetType(RGK.Geometry.Interval.Type)">
Установить тип интервала
<param name="iType">Тип интервала</param></member>
        <member name="M:RGK.Geometry.Interval.SetEnd(System.Double)">
Установить конец интервала
<param name="iEnd">Конец интервала</param></member>
        <member name="M:RGK.Geometry.Interval.SetStart(System.Double)">
Установить начало интервала
<param name="iStart">Начало интервала</param></member>
        <member name="M:RGK.Geometry.Interval.EndPoints">
Получить конечные точки интервала в виде массива
<returns>Конечные точки интервала в виде массива</returns></member>
        <member name="M:RGK.Geometry.Interval.op_Subscript(System.Int32)">
Получить начало или конец интервала.
<returns>Начало интервала если end == 0, конец если end == 1</returns>
Получить начало или конец интервала.
<returns>Начало интервала если end == 0, конец если end == 1</returns></member>
        <member name="M:RGK.Geometry.Interval.GetLength">
Получить длину интервала
<returns>Длина интервала</returns></member>
        <member name="M:RGK.Geometry.Interval.GetEnd">
Получить конец интервала
<returns>Конец интервала</returns></member>
        <member name="M:RGK.Geometry.Interval.GetStart">
Получить начало интервала
<returns>Начало интервала</returns></member>
        <member name="M:RGK.Geometry.Interval.Set(System.Double,System.Double,RGK.Geometry.Interval.Type)">
Установить интервал
<param name="iStart">Начало интервала</param><param name="iEnd">Конец интервала</param><param name="iType">Тип интервала</param></member>
        <member name="M:RGK.Geometry.Interval.op_AdditionAssignment(System.Double)">
Прибавляет к концам интервала заданное значение
</member>
        <member name="M:RGK.Geometry.Interval.op_MultiplicationAssignment(System.Double)">
Умножает оба конца интервала на заданное значение
</member>
        <member name="M:RGK.Geometry.Interval.#ctor(System.Double,System.Double)">
Конструктор интервала по двум параметрам
<param name="iStart">Начало интервала</param><param name="iEnd">Конец интервала</param></member>
        <member name="M:RGK.Geometry.Interval.#ctor(System.Double,System.Double,RGK.Geometry.Interval.Type)">
Конструктор интервала по двум параметрам и типу интервала
<param name="iStart">Начало интервала</param><param name="iEnd">Конец интервала</param><param name="iType">Тип интервала</param></member>
        <member name="M:RGK.Geometry.Interval.#ctor">
Конструктор интервала по умолчанию
</member>
        <member name="F:Finite">
Ограниченный
</member>
        <member name="F:Infinite">
Бесконечный
</member>
        <member name="F:Periodic">
Периодический
</member>
        <member name="T:RGK.Geometry.Interval.Type">
Тип интервала
</member>
        <member name="T:RGK.Geometry.Interval">
Интервал на действительной оси. Может использоваться для задания интервалов параметризации кривых и поверхностей
<seealso cref="!:Геометрия" /><seealso cref="!:Интервал на действительной оси" /></member>
        <member name="M:RGK.Instance.IsCLInitialized">
Проверка была ли инициализированна платформа
</member>
        <member name="M:RGK.Instance.GetCLPlatform">
Получить текущую платформу для вычислений на OpenCL
</member>
        <member name="M:RGK.Instance.CheckResult(RGK.Common.Context*,RGK.Common.Result)">
Функция обработки ошибки
<param name="iContext">Контекст вычисления</param><param name="iResult">Значение кода ошибки</param><returns>Ретранслированный код ошибки</returns></member>
        <member name="M:RGK.Instance.CheckResult(RGK.Common.Context*,std.shared_ptr&lt;RGK.Common.ErrorReport!System.Runtime.CompilerServices.IsConst&gt;)">
Функция обработки ошибки
<param name="iContext">Контекст вычисления</param><param name="iError">Отчёт об ошибке</param><returns>Ретранслированный код ошибки</returns></member>
        <member name="M:RGK.Instance.CheckResult(RGK.Common.Result)">
Функция обработки ошибки
<param name="iResult">Значение кода ошибки</param><returns>Ретранслированный код ошибки</returns></member>
        <member name="M:RGK.Instance.GetErrorChecking">
Получить класс обработки уведомлений об ошибках
<returns>Класс обработки уведомлений об ошибках</returns></member>
        <member name="M:RGK.Instance.SetErrorChecking(std.shared_ptr&lt;RGK.Interfaces.ErrorChecking&gt;)">
Установить класс обработки уведомлений об ошибках
<param name="iErrorChecking">Класс обработки уведомлений об ошибках</param></member>
        <member name="M:RGK.Instance.GetMeshBufferFactory">
Получить реализацию интерфейса фабрики класса, реализующего работу с буфером, в который пишутся результаты работы сеточного генератора
<returns>Фабрика класса, реализующего работу с буфером, в который пишутся результаты работы сеточного генератора</returns></member>
        <member name="M:RGK.Instance.SetMeshBufferFactory(std.shared_ptr&lt;RGK.Interfaces.MeshBufferFactory&gt;)">
Установить реализацию интерфейса фабрики класса, реализующего работу с буфером, в который пишутся результаты работы сеточного генератора
<param name="iFactory">Фабрика класса, реализующего работу с буфером, в который пишутся результаты работы сеточного генератора</param></member>
        <member name="M:RGK.Instance.GetVersion">
Получить номер версии ядра
<returns>Номер версии</returns></member>
        <member name="M:RGK.Instance.GetResultString(RGK.Common.Result,System.Boolean)">
Получение строки, соответствующей коду результата
<param name="iCode">Значение кода результата</param><param name="iGetID">В строке возвращать код результата</param><returns>Строка, соответствующая коду результата</returns></member>
        <member name="M:RGK.Instance.GetDeviceType(RGK.Instance.DeviceType*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить тип устройства для массовых параллельных вычислений
<param name="oDeviceType">Тип устройства для массовых параллельных вычислений</param><remarks>Получение типа устройста имеет смысл только в конфигруации библиотеки, в которой поддерживается OpenCL</remarks><returns>
- Result::Success в случае успешного выполнения
- Result::KernelNotStarted в случае, если ядро не было запущено
- Result::KernelAlreadyStopped в случае, если ядро уже было остановлено
</returns></member>
        <member name="M:RGK.Instance.SetDeviceType(RGK.Instance.DeviceType)">
Задать тип устройства для массовых параллельных вычислений
<param name="iDeviceType">Тип устройства для массовых параллельных вычислений</param><remarks>Параметры должны задаваться до старта ядра</remarks><remarks>Задание типа устройста имеет смысл только в конфигруации библиотеки, в которой поддерживается OpenCL</remarks><returns>
- Result::Success в случае успешного выполнения
- Result::KernelAlreadyStarted в случае, если ядро уже запущено
</returns></member>
        <member name="F:UndefinedDevice">
Неизвестное (неопределённое) устройство
</member>
        <member name="F:GLDevice">
Устройство, которое будет позволять работать с gl-данными
</member>
        <member name="F:Accelerator">
Ускоритель
</member>
        <member name="F:CPU">
CPU-устройство
</member>
        <member name="F:GPU">
GPU-устройство
</member>
        <member name="T:RGK.Instance.DeviceType">
Тип устройства для массовых параллельных вычислений
</member>
        <member name="M:RGK.Instance.GetMaxThreads(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить максимальное количество потоков, выполняемых на центральном процессоре
<param name="oMaxThreads">Максимальное количество потоков, выполняемых на центральном процессоре</param><returns>
- Result::Success в случае успешного выполнения
- Result::KernelNotStarted в случае, если ядро не было запущено
- Result::KernelAlreadyStopped в случае, если ядро уже было остановлено
</returns></member>
        <member name="M:RGK.Instance.SetMaxThreads(System.Int32)">
Задать максимальное количество потоков, выполняемых на центральном процессоре
<param name="iMaxThreads">Максимальное количество потоков, выполняемых на центральном процессоре</param><remarks>Параметры должны задаваться до старта ядра</remarks><returns>
- Result::Success в случае успешного выполнения
- Result::KernelAlreadyStarted в случае, если ядро уже запущено
</returns></member>
        <member name="M:RGK.Instance.GetState(RGK.Instance.State*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить состояние ядра
<param name="oState">Состояние ядра</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="F:Error">
Ядро не запустилось из-за критических ошибок
</member>
        <member name="F:Partial">
Ядро запущено с некритичными ошибками
</member>
        <member name="F:Stopped">
Ядро остановлено
</member>
        <member name="F:Started">
Ядро успешно запущено
</member>
        <member name="F:NotStarted">
Ядро не запускалось
</member>
        <member name="T:RGK.Instance.State">
Текущее состояние запуска ядра
</member>
        <member name="M:RGK.Instance.End">
Завершить работу ядра
<returns>
- Result::Success в случае успешного выполнения
- Result::KernelAlreadyStopped в случае, если ядро уже было остановлено
- Result::KernelNotStarted в случае, если ядро не было запущено
</returns></member>
        <member name="M:RGK.Instance.Start">
Стартовать ядро.
Если ядро не было инициализировано явно,
то инициализация выполняется при создании первой сессии (см. RGK::Model::Session)
<returns>
- Result::Success в случае успешного выполнения
- Result::KernelAlreadyStarted в случае, если ядро уже запущено
- Result::KernelStartError в случае ошибки инициализации ядра. Обычно проблемы могут быть связаны с инициализацией устройства для массовых параллельных вычислений
- Result::KernelStartPartiallySuccessful в случае возникновения некритичной ошибки в процессе инициализации
- Result::KernelAlreadyStartedPartiallySuccessful в случае, если ядро уже запущено с некритичной ошибкой
- Result::KernelAlreadyStartedError в случае, если ядро уже запускалось и возникла ошибка критичная для выполнения ядра
</returns></member>
        <member name="T:RGK.Instance">
            <summary>Инициализация ядра</summary>
Класс автоматически создаётся в одном экземпляре на всё приложение (процесс) 
и хранит общесистемные настройки ядра. Все методы класса являются статическими.
</member>
        <member name="M:RGK.Common.Version.SetVersion(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>Установить номер версии</summary>
            <remarks>Используется для выбора версии генератора</remarks>
            <param name="iMajor">Номер основной версии ядра</param>
            <param name="iMinor">Номер вспомогательной версии ядра</param>
            <param name="iBuild">Номер сборки</param>
            <param name="iRevision">Номер исправлений в сборке</param>
            <returns>
- Result::Success в случае успешного выполнения
- Result::BadVersion - недопустимый номер версии
</returns>
        </member>
        <member name="M:RGK.Common.Version.GetVersion(System.UInt32*)">
            <summary>Получить номер версии</summary>
            <param name="oVersion">Номер версии</param>
        </member>
        <member name="M:RGK.Common.Version.GetSubVersion(RGK.Common.Version.Type)">
            <summary>Получить часть номера версии по типу</summary>
            <param name="iType">Тип части версии</param>
            <returns>Номер версии</returns>
        </member>
        <member name="F:Revision">
Номер исправлений в сборке
</member>
        <member name="F:Build">
Номер сборки
</member>
        <member name="F:Minor">
Номер вспомогательной версии ядра
</member>
        <member name="F:Major">
Номер основной версии ядра
</member>
        <member name="T:RGK.Common.Version.Type">
Типы частей, из которых состоит номер версии
</member>
        <member name="M:RGK.Common.Version.Dispose">
Деструктор
</member>
        <member name="M:RGK.Common.Version.op_Equality(RGK.Common.Version!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор сравнения версий
<param name="iVersion">Номер версии</param><returns>true-версии совпадают</returns></member>
        <member name="M:RGK.Common.Version.op_LessThan(RGK.Common.Version!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор сравнения версий
<param name="iVersion">Номер версии</param><returns>true-версия более ранняя по сравнению с передаваемой в параметре</returns></member>
        <member name="M:RGK.Common.Version.op_Assign(RGK.Common.Version!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор копирования версии
<param name="iVersion">Номер версии</param><returns>Ссылка на сам объект</returns></member>
        <member name="M:RGK.Common.Version.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
Конструктор
<remarks>Используется для задания текущей версии ядра в Instance</remarks><param name="iMajor">Номер основной версии ядра</param><param name="iMinor">Номер вспомогательной версии ядра</param><param name="iBuild">Номер сборки</param><param name="iRevision">Номер исправлений в сборке</param></member>
        <member name="M:RGK.Common.Version.#ctor(RGK.Common.Version!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Копирующий конструктор
<param name="iVersion">Номер версии</param></member>
        <member name="M:RGK.Common.Version.#ctor">
Конструктор
</member>
        <member name="T:RGK.Common.Version">
            <summary>Номер версии ядра</summary>
Номер версии состоит из четырёх частей:
- Номер основной версии ядра;
- Номер вспомогательной версии ядра;
- Номер сборки;
- Номер исправлений в сборке.
</member>
        <member name="M:RGK.Common.FlagSet.ClearFlag(System.Int32)">
Очистка флага
</member>
        <member name="M:RGK.Common.FlagSet.IsFlagSet(System.Int32)">
Проверка значения флага
<returns>Ненулевое значение, если данный флаг или комбинация флагов установлены</returns></member>
        <member name="M:RGK.Common.FlagSet.GetBits(System.Int32,System.Int32)">
Получение битов по маске со сдвигом
</member>
        <member name="M:RGK.Common.FlagSet.GetBits(System.Int32)">
Получение значение битов по маске
</member>
        <member name="M:RGK.Common.FlagSet.IsBitTrue(System.Int32)">
Проверка значения флага в конкретной позиции
</member>
        <member name="M:RGK.Common.FlagSet.SwapBit(System.Int32)">
Изменение значение флага в конкретной позиции на противоположное
</member>
        <member name="M:RGK.Common.FlagSet.ClearBit(System.Int32)">
Очистка значения флага в конкретной позиции
</member>
        <member name="M:RGK.Common.FlagSet.SetBit(System.Int32)">
Установка единичного значения флага в конкретной позиции
</member>
        <member name="M:RGK.Common.FlagSet.SetFlag(System.Int32)">
Установка значения флага
</member>
        <member name="M:RGK.Common.FlagSet.op_Inequality(RGK.Common.FlagSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор "!="
</member>
        <member name="M:RGK.Common.FlagSet.op_Equality(RGK.Common.FlagSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор "=="
</member>
        <member name="M:RGK.Common.FlagSet.op_Assign(RGK.Common.FlagSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор присваивания
</member>
        <member name="M:RGK.Common.FlagSet.Dispose">
Деструктор
</member>
        <member name="M:RGK.Common.FlagSet.#ctor(RGK.Common.FlagSet!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Копирующий конструктор. Установка значения набора флагов с исходного объекта
</member>
        <member name="M:RGK.Common.FlagSet.#ctor(System.Int32)">
Конструктор. Установка заданного значения набора флагов
</member>
        <member name="T:RGK.Common.FlagSet">
            <summary>Класс побитового хранения набора флагов</summary>
        </member>
        <member name="D:RGK.fstream">
Тип для потока ввода/вывода в/из файла
</member>
        <member name="D:RGK.ofstream">
Тип для потока вывода в файл
</member>
        <member name="D:RGK.ifstream">
Тип для потока ввода из файла
</member>
        <member name="D:RGK.filebuf">
Тип файлового буфера
</member>
        <member name="D:RGK.ostream">
Тип для потока вывода
</member>
        <member name="D:RGK.istream">
Тип для потока ввода
</member>
        <member name="D:RGK.streambuf">
Тип потокового буфера
</member>
        <member name="D:RGK.ostringstream">
Тип для потока вывода в строку
</member>
        <member name="D:RGK.istringstream">
Тип для потока ввода из строки
</member>
        <member name="M:RGK.Geometry.Geometry.AsCompositeSpline">
Получить объект как составную кривую
<returns>Составная кривая или nullptr в случае если объект не является составной кривой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsSphereConeIntersection">
Получить объект как кривую пересечения Сферы и Конуса
<returns>Кривая пересечения Сферы с Конусом или nullptr в случае если объект не является точкой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsCylinderSphereIntersection">
Получить объект как кривую пересечения Цилиндра и Сферы
<returns>Кривая пересечения Цилиндра со Сферой или nullptr в случае если объект не является точкой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsCylinderCylinderIntersection">
Получить объект как кривую пересечения Цилиндра и Цилиндра
<returns>Кривая пересечения Цилиндра с Цилиндром или nullptr в случае если объект не является точкой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsTorusSphereIntersection">
Получить объект как кривую пересечения Тора и Сферы
<returns>Кривая пересечения Тора со Сферой или nullptr в случае если объект не является точкой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsPoint">
Получить объект как точку 
<returns>Точка или nullptr в случае если объект не является точкой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsSurface">
Получить объект как поверхность 
<returns>Поверхность или nullptr в случае если объект не является поверхностью</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsCurve">
Получить объект как кривую
<returns>Кривая или nullptr в случае если объект не является кривой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsTorus">
Получить объект как тор
<returns>Тор или nullptr в случае если объект не является тором</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsSphere">
Получить объект как сферу
<returns>Сфера или nullptr в случае если объект не является сферой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsPlane">
Получить объект как плоскость
<returns>Плоскость или nullptr в случае если объект не является плоскостью</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsOffsetSurface">
Получить объект как эквидистантную поверхность
<returns>Эквидистантная поверхность или nullptr в случае если объект не является эквидистантной поверхность</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsNURBSSurface">
Получить объект как NURBS-поверхность
<returns>NURBS-поверхность или nullptr в случае если объект не является NURBS-поверхностью</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsMultipleSurfacesBlending">
Получить объект как поверхность сглаживания
<returns>Поверхность сглаживания или nullptr в случае если объект не является поверхностью сглаживания</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsIsoclineSurface">
Получить объект как изоклин-поверхность
<returns>Изоклин-поверхность или nullptr в случае если объект не является изоклин-поверхностью</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsCylinder">
Получить объект как цилиндр
<returns>Цилиндр или nullptr в случае если объект не является цилиндром</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsCone">
Получить объект как конус
<returns>Конус или nullptr в случае если объект не является конусом</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsParametricCurve">
Получить объект как параметрическую кривую
<returns>Параметрическая кривая или nullptr в случае если объект не является параметрической кривой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsNURBSCurve">
Получить объект как NURBS-кривую
<returns>NURBS-кривая или nullptr в случае если объект не является NURBS-кривой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsLine">
Получить объект как отрезок 
<returns>Отрезок или nullptr в случае если объект не является отрезком</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsIsoclineCurve">
Получить объект как изоклин-кривую
<returns>Изоклин-кривая или nullptr в случае если объект не является изоклин-кривой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsIntersectionCurve">
Получить объект как кривую пересечения 
<returns>Кривая пересечения или nullptr в случае если объект не является кривой пересечения</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsSilhouetteCurve">
Получить объект как очерковую
<returns>Очерковая или nullptr в случае если объект не является очерковой</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsPolylineCurve">
Получить объект как полилинию
<returns>Полилиния или nullptr в случае если объект не является полилинией</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsEllipse">
Получить объект как эллипс
<returns>Эллипс или nullptr в случае если объект не является эллипсом</returns></member>
        <member name="M:RGK.Geometry.Geometry.AsCircle">
Получить объект как окружность
<returns>Окружность или nullptr в случае если объект не является окружностью</returns></member>
        <member name="M:RGK.Geometry.Geometry.IsSurface">
Проверить, является ли объект поверхностью 
<returns>true если объект является поверхностью</returns></member>
        <member name="M:RGK.Geometry.Geometry.IsCurve">
Проверить, является ли объект кривой 
<returns>true если объект является кривой</returns></member>
        <member name="M:RGK.Geometry.Geometry.GetType">
Получить тип геометрии объекта
<returns>Тип геометрии объекта</returns></member>
        <member name="D:RGK.Geometry.Geometry.TypeSet">
Список типов геометрических объектов
</member>
        <member name="F:CompositeSplineType">
Составная кривая
</member>
        <member name="F:CylinderSphereIntersectionType">
Кривая пересечения цилиндра со сферой
</member>
        <member name="F:SphereConeIntersectionType">
Кривая пересечения сферы с конусом
</member>
        <member name="F:CylinderCylinderIntersectionType">
Кривая пересечения цилиндра с цилиндром
</member>
        <member name="F:TorusSphereIntersectionType">
Кривая пересечения тора со сферой
</member>
        <member name="F:PointType">
Точка

Точка
</member>
        <member name="F:TorusType">
Тор
</member>
        <member name="F:SphereType">
Сфера
</member>
        <member name="F:PlaneType">
Плоскость
</member>
        <member name="F:OffsetSurfaceType">
Эквидистантная поверхность
</member>
        <member name="F:NURBSSurfaceType">
Сплайн-поверхность
</member>
        <member name="F:ArcBlendingOfThreeSurfacesType">
Поверхность сопряжения трёх поверхностей
</member>
        <member name="F:ArcBlendingOfTwoSurfacesType">
Поверхность сопряжения двух поверхностей
</member>
        <member name="F:MultipleSurfacesBlendingType">
Поверхность затягивания
</member>
        <member name="F:IsoclineSurfaceType">
Изоклин-поверхность
</member>
        <member name="F:CylinderType">
Цилиндр
</member>
        <member name="F:ConeType">
Конус
</member>
        <member name="F:SilhouetteCurveType">
Очерковая кривая
</member>
        <member name="F:PolylineCurveType">
Ломанная кривая
</member>
        <member name="F:ParametricCurveType">
Параметрическая кривая
</member>
        <member name="F:NURBSCurveType">
Сплайн-кривая
</member>
        <member name="F:LineType">
Прямая

Прямая
</member>
        <member name="F:IsoclineCurveType">
Изоклин-кривая
</member>
        <member name="F:IntersectionCurveType">
Кривая пересечения
</member>
        <member name="F:EllipseType">
Эллипс

Эллипс
</member>
        <member name="F:CircleType">
Окружность

Окружность
</member>
        <member name="F:UndefinedType">
Тип не определён

Тип не определён
</member>
        <member name="T:RGK.Geometry.Geometry.Type">
Тип геометрического объекта
</member>
        <member name="M:RGK.Geometry.Geometry.IsCoincident(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.Geometry!System.Runtime.CompilerServices.IsConst&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка совпадения геометрических объектов
<param name="iContext">Контекст создания линии</param><param name="iGeometry">Геометрический объект, с которым выполняется сравнение</param><param name="iData">Выполнять сравнение по данным. То есть объекты считаются одинаковыми в случае совпадения всех параметров объектов</param><param name="oCoincident">Результат сравнения</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Geometry.Transform(RGK.Common.Context*,RGK.Math.AffineMap3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,std.shared_ptr&lt;RGK.Geometry.Geometry!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание копии геометрии с применением аффинного преобразования
<param name="iContext">Контекст создания линии</param><param name="iMap">Аффинное преобразование</param><param name="iTolerance">Допустимая точность преобразований</param><param name="oCopy">Возвращается трансформированная геометрия</param><param name="oExact">Возвращается true-для точного преобразования</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="M:RGK.Geometry.Geometry.Copy(RGK.Common.Context*,std.shared_ptr&lt;RGK.Geometry.Geometry!System.Runtime.CompilerServices.IsConst&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание копии геометрии
<param name="iContext">Контекст создания линии</param><param name="oCopy">Копия геометрического объекта</param><returns>
- Result::Success в случае успешного выполнения
</returns></member>
        <member name="T:RGK.Geometry.Geometry">
Базовый класс для геометрических классов поверхностей, кривых и точек
<seealso cref="!:Геометрия" /></member>
        <member name="F:TFModelDirection._destination">
конечная точка задающая направление прямой на которой лежит вектор
</member>
        <member name="F:TFModelDirection._type">
тип создания
</member>
        <member name="M:TFModelDirection.GetParents(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CParentsArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ParentType,System.UInt32!System.Runtime.CompilerServices.IsConst)">
Методы для вызова в соответствующих виртуальных методах объектов, содержащих TFModelPoint
</member>
        <member name="M:TFModelDirection.SetDestinationModelPoint(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFModelDirection.DirectionType)">
            <summary>Установить значение угла и скорректировать тип</summary>
        </member>
        <member name="M:TFModelDirection.SetDirectionAngleWithOX(RealParameter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить значение угла и скорректировать тип</summary>
        </member>
        <member name="M:TFModelDirection.SetDirectionMagnitude(RealParameter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Установить значение длинны и скорректировать тип</summary>
        </member>
        <member name="M:TFModelDirection.GetDirectionMagnitude">
            <summary>Удалить</summary>
        </member>
        <member name="M:TFModelDirection.GetEditDestinationModelPoint">
            <summary>Получить точку задающую направление (может быть не задана)</summary>
        </member>
        <member name="M:TFModelDirection.GetDestinationModelPoint">
            <summary>Получить точку задающую направление (может быть не задана)</summary>
        </member>
        <member name="M:TFModelDirection.HaveDestinationModelPoint">
            <summary>Направление использует TFModelPoint в качестве точки назначения? </summary>
        </member>
        <member name="M:TFModelDirection.GetType">
            <summary>Получить тип направления</summary>
        </member>
        <member name="M:TFModelDirection.GetDirectionBackward(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Вычислить вектор направления от указанной точки в обратном направлении</summary>
            <param name="iSource">Точка начала</param>
            <param name="iDoc"> Документ</param>
            <param name="iPageScale">Масштаб страницы</param>
        </member>
        <member name="M:TFModelDirection.GetDirectionForward(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Вычислить вектор направления от указанной точки</summary>
            <param name="iSource">Точка начала</param>
            <param name="iDoc"> Документ</param>
            <param name="iPageScale">Масштаб страницы</param>
        </member>
        <member name="M:TFModelDirection.GetDirectionForwardInDefUnits(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,RealParameter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RealParameter*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить длину и угол наклона направления в виде параметров (всегда в ед. изм по умолчанию). Внутри приосходит создание новых копий параметров в ед. измерения по умолчанию. Создавался для вывода в диалоги</summary>
            <param name="iSource">Точка начала</param>
            <param name="iDoc"> Документ</param>
            <param name="iPageScale">Масштаб страницы</param>
            <param name="oMagnitude"> Длинна</param>
            <param name="oAngle">Угол</param>
        </member>
        <member name="M:TFModelDirection.GetDirectionForward(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Вычислить вектор направления от указанной точки</summary>
            <param name="iSource">Точка начала</param>
            <param name="iDoc"> Документ</param>
            <param name="iPageScale">Масштаб страницы</param>
        </member>
        <member name="M:TFModelDirection.#ctor(RealParameter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RealParameter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Угол направления</summary>
            <param name="iAngleWithOX"> Угол с осью X (угол наклона) </param>
            <param name="iMagnitude"> Величиная направления (Длинна вектора)</param>
        </member>
        <member name="M:TFModelDirection.#ctor(System.Double,System.Double)">
            <summary> Угол направления</summary>
            <param name="iAngleWithOX"> Угол с осью X (угол наклона в радианах)</param>
            <param name="iMagnitude"> Величиная направления (Длинна вектора в милиметрах)</param>
        </member>
        <member name="M:TFModelDirection.#ctor(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конструктор по вектору направления</summary>
            <param name="iDirection"> Направление </param>
        </member>
        <member name="M:TFModelDirection.#ctor(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RealParameter!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конструктор по двумя модельным точкам</summary>
            <param name="iDestination"> Вторая точка направления </param>
            <param name="iMagnitude">Величина  направления</param>
        </member>
        <member name="M:TFModelDirection.#ctor(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Конструктор по двумя модельным точкам</summary>
            <param name="iDestination"> Вторая точка направления </param>
            <param name="iMagnitude">Величина  направления</param>
        </member>
        <member name="M:TFModelDirection.#ctor(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFModelDirection.DirectionType)">
            <summary> Конструктор по двумя модельным точкам</summary>
            <param name="iDestination"> Вторая точка направления </param>
            <param name="iMagnitude">Величина  направления</param>
        </member>
        <member name="M:TFModelDirection.#ctor">
Конструктор по умолчанию
</member>
        <member name="F:PointPoint">
От точки до точки, длинна равна растоянию от точки до точки (Legacy state)
</member>
        <member name="F:Vector">
Постоянное направление, задается вектором/ углом с осью OX и длинной
</member>
        <member name="F:Point">
Направление между двумя точками, 
прямая направленная от первой точки ко второй, по данной прямой откладывается длинна производной от первой точки
</member>
        <member name="T:TFModelDirection.DirectionType">
Тип направления
</member>
        <member name="M:WeightedPoints.#ctor(System.Int32,System.Int32,System.Double**,EndsTreatment,DataRepresentation,System.Double*)">
            <summary>  Инициализация точек</summary>
            <param name="dimension"> Размерность </param>
            <param name="quantity"> Количество </param>
            <param name="values"> Точки в виде массива указателей </param>
            <param name="closeness"> Признак замкнутости сплайна </param>
            <param name="representation"> Тип представления точек </param>
            <param name="weights"> Веса точек </param>
        </member>
        <member name="M:PreciseGeometryUtils.FaceterLegacy(DRAW*,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Double,std.allocator&lt;System.Double&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Теселятор олбъектов созданных в 15 версии</summary>
            <summary> Можно вызвать один раз при импорте моделей из 15 версии или ниже</summary>
            <param name="iDraw"> Объект </param>
            <param name="oX"> X </param>
            <param name="oY"> Y </param>
            <returns> true - если нет ошибок, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.IsEqualGeometry(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;)">
            <summary> Проверка двух геометрий на равенство </summary>
            <param name="iGeometry1"> Первая кривая </param>
            <param name="iGeometry2"> Вторая кривая </param>
            <returns> true - если геометрии равны, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.ConvertToRGK(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;)">
            <summary> Получить RGP кривую как RGK кривую </summary>
            <param name="iCurve"> RGP кривая </param>
            <returns> Указатель на RGK кривую </returns>
        </member>
        <member name="T:SplineData">
            <summary> Построить геометрию сплайна </summary>
            <param name="iSplineData"> Данные сплайна </param>
            <param name="iIsControlPoints"> Флаг типа сплайна: true - сплайн по управляющим точкам, false - проходящий через точки </param>
            <param name="iIsOpenSpline"> Флаг замкнутого сплайна </param>
            <param name="iEndPoint1"> Точка начальной касательной </param>
            <param name="iEndPoint2"> Точка конечной касательной </param>
            <param name="iToModelSpaceScale"> Коэффициент преобразования в координаты модели </param>
            <returns> Указатель на геометрию сплайна </returns>
        </member>
        <member name="M:PreciseGeometryUtils.FindDistance(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
            <summary> Найти расстояние между кривыми </summary>
            <param name="iCurve1"> Указатель на геометрию первой кривой </param>
            <param name="iCurve2"> Указатель на геометрию второй кривой </param>
            <param name="iToModelSpaceScale"> Коэффициент преобразования в координаты модели </param>
            <param name="oDistance"> Найденное расстояние </param>
            <param name="iFindMaxDistance"> true - максимальное расстояние между кривыми, false - минимальное </param>
            <returns> true - если удалось найти расстояние </returns>
        </member>
        <member name="M:PreciseGeometryUtils.FormAdaptivePolyline(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,System.Double,System.Double)">
            <summary> Построить адаптивную полилинию по кривой (записывает данные в глобальную полилинию) </summary>
            <param name="iCurve"> Указатель на геометрию кривой </param>
            <param name="iToModelSpaceScale"> Коэффициент преобразования в координаты модели </param>
            <param name="iOffsetCoef"> Коэффициент точности полилинии </param>
            <returns> true - если удалось построить полилинию </returns>
        </member>
        <member name="M:PreciseGeometryUtils.FormAdaptivePolyline(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,System.Double,std.vector&lt;TFPoint,std.allocator&lt;TFPoint&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Построить адаптивную полилинию по кривой </summary>
            <param name="iCurve"> Указатель на геометрию кривой </param>
            <param name="iToModelSpaceScale"> Коэффициент преобразования в координаты модели </param>
            <param name="oPline"> Построенная полилиния </param>
            <param name="iOffsetCoef"> Коэффициент точности полилинии </param>
            <returns> true - если удалось построить полилинию </returns>
        </member>
        <member name="M:PreciseGeometryUtils.GetFullGeometry(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;)">
            <summary> Получить полную геометрию из исходной геометрии (дуги заменяет на замкнутые кривые) </summary>
            <param name="iGeometry"> Указатель на исходную геометрию </param>
            <returns> Указатель на полную геометрию </returns>
        </member>
        <member name="M:PreciseGeometryUtils.GetEllipticArcAsEllipse(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;)">
            <summary> Получить геометрию эллипса из геометрии дуги эллипса </summary>
            <param name="iArc"> Указатель на геометрию дуги эллипса </param>
            <returns> Указатель на геометрию эллипса, полученную из геометрии дуги </returns>
        </member>
        <member name="M:PreciseGeometryUtils.GetArcAsCircle(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;)">
            <summary> Получить геометрию окружности из геометрии дуги окружности </summary>
            <param name="iArc"> Указатель на геометрию дуги окружности </param>
            <returns> Указатель на геометрию окружности, полученную из геометрии дуги </returns>
        </member>
        <member name="M:PreciseGeometryUtils.IntersectSelf(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,std.vector&lt;PreciseGeometryUtils.InterPointData,std.allocator&lt;PreciseGeometryUtils.InterPointData&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double)">
            <summary> Найти все точки самопересечения кривой </summary>
            <param name="iCurve"> Кривая </param>
            <param name="oResults"> Найденные точки самопересечения </param>
            <param name="iToModelScale"> Коэффициент преобразования в координаты модели </param>
            <param name="iTolerance"> Точность поиска пересечений </param>
            <returns> false - в случае ошибки. true иначе. </returns>
        </member>
        <member name="M:PreciseGeometryUtils.IntersectCurves(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,std.vector&lt;PreciseGeometryUtils.InterPointData,std.allocator&lt;PreciseGeometryUtils.InterPointData&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean,System.Double)">
            <summary> Найти все точки пересечения двух кривых </summary>
            <param name="iCurve1"> Первая кривая </param>
            <param name="iInterval1"> Интервал для первой кривой </param>
            <param name="iCurve2"> Вторая кривая </param>
            <param name="iInterval2"> Интервал для второй кривой </param>
            <param name="iIncludeBound1"> true - в случае, если первая кривая имеет границу, учитывать границу, false - не учитывать </param>
            <param name="iIncludeBound2"> true - в случае, если вторая кривая имеет границу, учитывать границу, false - не учитывать </param>
            <param name="oResults"> Найденные точки пересечения </param>
            <param name="iToModelScale"> Коэффициент преобразования в координаты модели </param>
            <param name="iFiniteLines"> Флаг интервала для прямых (true - конечный, false - бесконечный) </param>
            <param name="iTolerance"> Точность поиска пересечений </param>
            <returns> -1 - в случае ошибки. Количество пересечений иначе. </returns>
        </member>
        <member name="M:PreciseGeometryUtils.IntersectCurves(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,System.Boolean,System.Boolean,std.vector&lt;PreciseGeometryUtils.InterPointData,std.allocator&lt;PreciseGeometryUtils.InterPointData&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean,System.Double)">
            <summary> Найти все точки пересечения двух кривых </summary>
            <param name="iCurve1"> Первая кривая </param>
            <param name="iCurve2"> Вторая кривая </param>
            <param name="iIncludeBound1"> true - в случае, если первая кривая имеет границу, учитывать границу, false - не учитывать </param>
            <param name="iIncludeBound2"> true - в случае, если вторая кривая имеет границу, учитывать границу, false - не учитывать </param>
            <param name="oResults"> Найденные точки пересечения </param>
            <param name="iToModelScale"> Коэффициент преобразования в координаты модели </param>
            <param name="iFiniteLines"> Флаг интервала для прямых (true - конечный, false - бесконечный) </param>
            <param name="iTolerance"> Точность поиска пересечений </param>
            <returns> -1 - в случае ошибки. Количество пересечений иначе. </returns>
        </member>
        <member name="M:PreciseGeometryUtils.FindTouchPointForCircleAndCurve(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,System.Double,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Найти точку касания окружности и кривой </summary>
            <param name="iCenter"> Центр окружности </param>
            <param name="iRadius"> Радиус окружности </param>
            <param name="iCurve"> Кривая </param>
            <param name="iToModelScale"> Коэффициент преобразования в координаты модели </param>
            <param name="oResult"> Найденная точка пересечения </param>
            <param name="iTolerance"> Точность поиска пересечений </param>
            <returns> true - в случае успеха </returns>
        </member>
        <member name="M:PreciseGeometryUtils.IntersectCurves(IMAGE*,IMAGE*,System.Boolean,System.Boolean,CArray&lt;TFPoint,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced&amp;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Найти все точки пересечения двух кривых </summary>
            <param name="iImage1"> Первая кривая </param>
            <param name="iImage2"> Вторая кривая </param>
            <param name="iIncludeBound1"> true - в случае, если первая кривая имеет границу, учитывать границу, false - не учитывать </param>
            <param name="iIncludeBound2"> true - в случае, если вторая кривая имеет границу, учитывать границу, false - не учитывать </param>
            <param name="oResults"> Найденные точки пересечения </param>
            <param name="iTolerance"> Точность поиска пересечений </param>
            <returns> -1 - в случае ошибки. Количество пересечений иначе. </returns>
        </member>
        <member name="M:PreciseGeometryUtils.EvaluateStartEnd(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,System.UInt64,System.Boolean,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Вычислить производную кривой в одном из её концов </summary>
            <param name="iCurve"> Указатель на кривую </param>
            <param name="iDerivOrder"> Степень производной </param>
            <param name="iStart"> true - производная в начале, false - производная в конце </param>
            <param name="iToModelScale"> Коэффициент преобразования в координаты модели </param>
            <param name="oX"> X-координата вычисленной производной </param>
            <param name="oY"> Y-координата вычисленной производной </param>
            <returns> true - производная рассчитана успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.ConvertNaturalParameterToParameter(DRAW!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Преобразовать натуральный параметр на кривой в параметр на кривой </summary>
            <param name="iDraw"> Кривая, на которой вычисляется параметр </param>
            <param name="iParameter"> Натуральный параметр на кривой </param>
            <param name="iParamIsNormalized"> Передаваемый натуральный параметр нормирован на общую длину кривой </param>
            <param name="oParameter"> Параметр на кривой, соответствующий переданному натуральному </param>
            <returns> true - параметр рассчитан успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.FindNaturalParameter(DRAW!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Double,System.Boolean,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Вычислить натуральный параметр точки на кривой </summary>
            <param name="iDraw"> Кривая, на которой вычисляется параметр </param>
            <param name="iX"> X-координата точки для которой вычисляется параметр </param>
            <param name="iY"> Y-координата точки для которой вычисляется параметр </param>
            <param name="iTolerance"> Точность расчёта параметра </param>
            <param name="iNormalize"> Нормировать ли параметр на длину кривой </param>
            <param name="oParameter"> Рассчитанный параметр </param>
            <returns> true - параметр рассчитан успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.DistanceOnCurveBetweenPoints(DRAW!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Вычислить расстояние по кривой между двумя точками </summary>
Функция вычисляет расстояние по кривой между параметрами точек на кривой, ближайших к передаваемым.
<param name="iDraw"> Кривая, по которой вычисляется расстояние </param><param name="iFromX"> X-координата точки, от которой считается расстояние </param><param name="iFromY"> Y-координата точки, от которой считается расстояние </param><param name="iToX"> X-координата точки, до которой считается расстояние </param><param name="iToY"> Y-координата точки, до которой считается расстояние </param><param name="iTolerance"> Точность расчёта расстояния </param><returns> true - расстояние рассчитано успешно, false - иначе </returns></member>
        <member name="M:PreciseGeometryUtils.FindNearestPoint(FlatObject*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить точку на кривой, ближайшую к передаваемой точке </summary>
            <param name="iCurve"> Кривая, на которой ищется ближайшая точка </param>
            <param name="iPoint"> Точка, для которой ищется ближайшая точка на кривой </param>
            <param name="oPoint"> Ближайшая точка на кривой </param>
            <returns> true - точка вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.FindNearestPoint(FlatObject*,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить точку на кривой, ближайшую к передаваемой точке </summary>
            <param name="iCurve"> Кривая, на которой ищется ближайшая точка </param>
            <param name="iX"> X-координата точки, для которой ищется ближайшая точка на кривой </param>
            <param name="iY"> Y-координата точки, для которой ищется ближайшая точка на кривой </param>
            <param name="oX"> X-координата ближайшей точки на кривой </param>
            <param name="oY"> Y-координата ближайшей точки на кривой </param>
            <returns> true - точка вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.FindNearestPoint(std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,System.Double,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Получить точку на кривой, ближайшую к передаваемой точке </summary>
            <param name="iCurve"> Кривая, на которой ищется ближайшая точка </param>
            <param name="iToModelScale"> Коэффициент преобразования в координаты модели </param>
            <param name="iX"> X-координата точки, для которой ищется ближайшая точка на кривой </param>
            <param name="iY"> Y-координата точки, для которой ищется ближайшая точка на кривой </param>
            <param name="oX"> X-координата ближайшей точки на кривой </param>
            <param name="oY"> Y-координата ближайшей точки на кривой </param>
            <param name="iTolerance"> Точность, поумолчанию = -1, в этом случае берётся из контекста </param>
            <returns> true - точка вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CreateRGPGeometryContext">
            <summary> Создать геометрический контекст модуля RGP </summary>
            <returns> Геометрический контекст модуля RGP </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleThroughPointTangentToSpline(FlatObject*,System.Double,System.Double,PreciseGeometryUtils.BaseCircleConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, проходящая через точку и касательная к сплайну </summary>
            <param name="iCurve"> Сплайн </param>
            <param name="iX"> X-координата точки, через которую проходит окружность </param>
            <param name="iY"> Y-координата точки, через которую проходит окружность </param>
            <param name="iData"> Данные для построения окружности </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToTwoEllipses(PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к двум эллипсам </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToEllipseAndPath(PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к эллипсу и пути </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iPathOffsetIsLeft"> Искомый центр находится слева от пути (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToEllipseAndSpline(PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к эллипсу и сплайну </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iSplineOffsetIsLeft"> Искомый центр находится слева от сплайна (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToCircleAndEllipse(PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к окружности и эллипсу </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToLineAndEllipse(PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к прямой и эллипсу </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToTwoPaths(PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к двум путям </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iPathOffsetIsLeft1"> Искомый центр находится слева от первого пути (если смотреть вдоль направления роста параметра) </param>
            <param name="iPathOffsetIsLeft2"> Искомый центр находится слева от второго пути (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToSplineAndPath(PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к сплайну и пути </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iSplineOffsetIsLeft"> Искомый центр находится слева от сплайна (если смотреть вдоль направления роста параметра) </param>
            <param name="iPathOffsetIsLeft"> Искомый центр находится слева от пути (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToTwoSplines(PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к двум сплайнам </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iSplineOffsetIsLeft1"> Искомый центр находится слева от первого сплайна (если смотреть вдоль направления роста параметра) </param>
            <param name="iSplineOffsetIsLeft2"> Искомый центр находится слева от второго сплайна (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToCircleAndPath(PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к окружности и пути </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iPathOffsetIsLeft"> Искомый центр находится слева от пути (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToCircleAndSpline(PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к окружности и сплайну </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iSplineOffsetIsLeft"> Искомый центр находится слева от сплайна (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToLineAndPath(PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к прямой и пути </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iPathOffsetIsLeft"> Искомый центр находится слева от пути (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.CircleTangentToLineAndSpline(PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,PreciseGeometryUtils.CircleConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Окружность, касательная к прямой и сплайну </summary>
            <param name="iData"> Данные для построения окружности </param>
            <param name="iSplineOffsetIsLeft"> Искомый центр находится слева от сплайна (если смотреть вдоль направления роста параметра) </param>
            <param name="oResult"> Результат построения окружности </param>
            <returns> true - окружность вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineTangentToTwoPaths(PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, касательная к двум путям </summary>
            <param name="iData"> Данные для построения прямой </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineTangentToSplineAndPath(PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, касательная к сплайну и пути </summary>
            <param name="iData"> Данные для построения прямой </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineTangentToTwoSplines(PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, касательная к двум сплайнам </summary>
            <param name="iData"> Данные для построения прямой </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineTangentToEllipseAndPath(PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, касательная к эллипсу и пути </summary>
            <param name="iData"> Данные для построения прямой </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineTangentToEllipseAndSpline(PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, касательная к эллипсу и сплайну </summary>
            <param name="iData"> Данные для построения прямой </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineTangentToCircleAndPath(PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, касательная к окружности и пути </summary>
            <param name="iData"> Данные для построения прямой </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineTangentToCircleAndSpline(PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, касательная к окружности и сплайну </summary>
            <param name="iData"> Данные для построения прямой </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineThroughPointTangentToPath(System.Double,System.Double,FlatObject*,System.Double,System.Double,System.Boolean,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, проходящая через точку и касательная к пути </summary>
            <param name="iX"> X координата точки, через которую проходит прямая </param>
            <param name="iY"> Y координата точки, через которую проходит прямая </param>
            <param name="iCurve"> Путь </param>
            <param name="iApproxTouchPointX"> Приближённое значение X координаты точки касания (в координатах TFlex) </param>
            <param name="iApproxTouchPointY"> Приближённое значение Y координаты точки касания (в координатах TFlex) </param>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineThroughPointTangentToSpline(System.Double,System.Double,FlatObject*,System.Double,System.Double,System.Boolean,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, проходящая через точку и касательная к сплайну </summary>
            <param name="iX"> X координата точки, через которую проходит прямая </param>
            <param name="iY"> Y координата точки, через которую проходит прямая </param>
            <param name="iCurve"> Сплайн </param>
            <param name="iApproxTouchPointX"> Приближённое значение X координаты точки касания (в координатах TFlex) </param>
            <param name="iApproxTouchPointY"> Приближённое значение Y координаты точки касания (в координатах TFlex) </param>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineParallelToLineTangentToPath(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Double,System.Double,System.Boolean,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, параллельная данной и касательная к пути </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iDrawLine"> Индекс прямой </param>
            <param name="iDrawPath"> Индекс пути </param>
            <param name="iApproxTouchPointX"> Приближённое значение X координаты точки касания (в координатах TFlex) </param>
            <param name="iApproxTouchPointY"> Приближённое значение Y координаты точки касания (в координатах TFlex) </param>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.LineParallelToLineTangentToSpline(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Double,System.Double,System.Boolean,PreciseGeometryUtils.LineConstructionResult*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Прямая, параллельная данной и касательная к сплайну </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iDrawLine"> Индекс прямой </param>
            <param name="iDrawPolyline"> Индекс сплайна </param>
            <param name="iApproxTouchPointX"> Приближённое значение X координаты точки касания (в координатах TFlex) </param>
            <param name="iApproxTouchPointY"> Приближённое значение Y координаты точки касания (в координатах TFlex) </param>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
            <param name="oResult"> Результат построения прямой </param>
            <returns> true - прямая вычислена успешно, false - иначе </returns>
        </member>
        <member name="F:PreciseGeometryUtils.CircleConstructionResult._y">
Y координата найденного центра окружности (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.CircleConstructionResult._x">
X координата найденного центра окружности (в координатах TFlex)
</member>
        <member name="T:PreciseGeometryUtils.CircleConstructionResult">
Объект результатов построения окружности
</member>
        <member name="F:PreciseGeometryUtils.LineConstructionResult._y2">
Y координата второй точки построенной прямой (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.LineConstructionResult._x2">
X координата второй точки построенной прямой (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.LineConstructionResult._y1">
Y координата первой точки построенной прямой (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.LineConstructionResult._x1">
X координата первой точки построенной прямой (в координатах TFlex)
</member>
        <member name="T:PreciseGeometryUtils.LineConstructionResult">
Объект результатов построения прямой
</member>
        <member name="F:PreciseGeometryUtils.BaseConstructionResult._additionalIntersectionPoints">
Массив дополнительных точек пересечения (например, точек касания)
</member>
        <member name="T:PreciseGeometryUtils.BaseConstructionResult">
Базовый объект результатов построения кривых
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData._pline2">
Ломаная, приближённо описывающая вторую кривую (может быть не задана)
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData._pline1">
Ломаная, приближённо описывающая первую кривую (может быть не задана)
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData._toModelSpaceScale">
Коэффициент преобразования в координаты модели
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData._curve2">
Индекс второй кривой
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData._curve1">
Индекс первой кривой
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData._doc">
Ссылка на документ
</member>
        <member name="M:PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData.#ctor(TFDocument!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Double,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,std.shared_ptr&lt;RGPlatform.Geometry.Curve2DGeometry&gt;,System.Double)">
            <summary> Конструктор </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
            <param name="iRadius"> Радиус окружности (в координатах TFlex) </param>
            <param name="iApproxCenter"> Приближённое значение центра окружности (в координатах TFlex) </param>
            <param name="iCurve1"> Первая кривая </param>
            <param name="iCurve2"> Вторая кривая </param>
            <param name="iToModelSpaceScale"> Коэффициент преобразования в координаты модели </param>
        </member>
        <member name="T:PreciseGeometryUtils.CircleTangentToTwoCurvesConstructionData">
Объект данных для построения окружности, касательной к двум кривым
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData._draw2">
Индекс второй кривой
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData._draw1">
Индекс первой кривой
</member>
        <member name="F:PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData._doc">
Ссылка на документ
</member>
        <member name="M:PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData.#ctor(TFDocument!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Double,System.Double,System.Double,System.Int32,System.Int32)">
            <summary> Конструктор </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
            <param name="iRadius"> Радиус окружности (в координатах TFlex) </param>
            <param name="iApproxCenterX"> Приближённое значение X координаты центра окружности (в координатах TFlex) </param>
            <param name="iApproxCenterY"> Приближённое значение Y координаты центра окружности (в координатах TFlex) </param>
            <param name="iDraw1"> Индекс первой кривой </param>
            <param name="iDraw2"> Индекс второй кривой </param>
        </member>
        <member name="T:PreciseGeometryUtils.CircleTangentToTwoDrawsConstructionData">
Объект данных для построения окружности, касательной к двум кривым
</member>
        <member name="F:PreciseGeometryUtils.BaseCircleConstructionData._approxCenterY">
Приближённое значение Y координаты центра окружности (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.BaseCircleConstructionData._approxCenterX">
Приближённое значение X координаты центра окружности (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.BaseCircleConstructionData._radius">
Радиус окружности (в координатах TFlex)
</member>
        <member name="M:PreciseGeometryUtils.BaseCircleConstructionData.#ctor(System.Boolean,System.Double,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Конструктор </summary>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
            <param name="iRadius"> Радиус окружности (в координатах TFlex) </param>
            <param name="iApproxCenter"> Приближённое значение центра окружности (в координатах TFlex) </param>
        </member>
        <member name="T:PreciseGeometryUtils.BaseCircleConstructionData">
Базовый объект данных для построения окружности
</member>
        <member name="F:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData._approxCurve2TouchPointY">
Приближённое значение Y координаты точки касания ко второй кривой (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData._approxCurve2TouchPointX">
Приближённое значение X координаты точки касания ко второй кривой (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData._approxCurve1TouchPointY">
Приближённое значение Y координаты точки касания к первой кривой (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData._approxCurve1TouchPointX">
Приближённое значение X координаты точки касания к первой кривой (в координатах TFlex)
</member>
        <member name="F:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData._draw2">
Индекс второй кривой
</member>
        <member name="F:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData._draw1">
Индекс первой кривой
</member>
        <member name="F:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData._doc">
Ссылка на документ
</member>
        <member name="M:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData.#ctor(TFDocument!System.Runtime.CompilerServices.IsConst*,System.Boolean,System.Int32,System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary> Конструктор </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
            <param name="iDraw1"> Индекс первой кривой </param>
            <param name="iDraw2"> Индекс второй кривой </param>
            <param name="iApproxCurve1TouchPointX"> Приближённое значение X координаты точки касания к первой кривой (в координатах TFlex) </param>
            <param name="iApproxCurve1TouchPointY"> Приближённое значение Y координаты точки касания к первой кривой (в координатах TFlex) </param>
            <param name="iApproxCurve2TouchPointX"> Приближённое значение X координаты точки касания ко второй кривой (в координатах TFlex) </param>
            <param name="iApproxCurve2TouchPointY"> Приближённое значение Y координаты точки касания ко второй кривой (в координатах TFlex) </param>
        </member>
        <member name="T:PreciseGeometryUtils.LineTangentToTwoCurvesConstructionData">
Базовый объект данных для построения прямой
</member>
        <member name="F:PreciseGeometryUtils.BaseConstructionData._calculateAddInterPoints">
true - рассчитывать дополнительные точки пересечения, false - не рассчитывать
</member>
        <member name="M:PreciseGeometryUtils.BaseConstructionData.#ctor(System.Boolean)">
            <summary> Конструктор </summary>
            <param name="iCalculateAddInterPoints"> true - рассчитывать дополнительные точки пересечения, false - не рассчитывать </param>
        </member>
        <member name="T:PreciseGeometryUtils.BaseConstructionData">
Базовый объект данных для геометрических построений
</member>
        <member name="T:PreciseGeometryUtils.PolylineData">
Структура, описывающая ломаную
</member>
        <member name="M:PreciseGeometryUtils.PointOnCurveRelativeToPoint(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Точка относительно узла </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iKnot"> Индекс узла </param>
            <param name="iDraw"> Индекс кривой </param>
            <param name="iParam"> Значение параметра на кривой </param>
            <param name="oX"> X-координата точки на кривой (в координатах TFlex) </param>
            <param name="oY"> Y-координата точки на кривой (в координатах TFlex) </param>
            <param name="iNVersion"> Версия объекта, для которого вычисляется точка </param>
            <returns> true - точка вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.PointByParameterOnCurve(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Точка по параметру на кривой </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iDraw"> Индекс кривой </param>
            <param name="iParam"> Значение параметра на кривой </param>
            <param name="oX"> X-координата точки на кривой (в координатах TFlex) </param>
            <param name="oY"> Y-координата точки на кривой (в координатах TFlex) </param>
            <param name="iNVersion"> Версия объекта, для которого вычисляется точка </param>
            <returns> true - точка вычислена успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.IntersectCurves(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Double,System.Double,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Найти ближайшую к данной точку пересечения двух кривых </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iDraw1"> Индекс первой кривой </param>
            <param name="iDraw2"> Индекс второй кривой </param>
            <param name="iX"> X-координата точки, до которой ищется ближайшая (в координатах TFlex) </param>
            <param name="iY"> Y-координата точки, до которой ищется ближайшая (в координатах TFlex) </param>
            <param name="oX"> X-координата точки пересечения (в координатах TFlex) </param>
            <param name="oY"> Y-координата точки пересечения (в координатах TFlex) </param>
            <param name="oIndex"> Индекс точки пересечения </param>
            <param name="iNVersion"> Версия объекта, для которого ищется пересечение </param>
            <returns> true - пересечение найдено успешно, false - иначе </returns>
        </member>
        <member name="M:PreciseGeometryUtils.IntersectCurves(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.Int32,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
            <summary> Найти точку пересечения двух кривых </summary>
            <param name="iDoc"> Ссылка на документ </param>
            <param name="iDraw1"> Индекс первой кривой </param>
            <param name="iDraw2"> Индекс второй кривой </param>
            <param name="iIndex"> Индекс точки пересечения </param>
            <param name="oX"> X-координата точки пересечения (в координатах TFlex) </param>
            <param name="oY"> Y-координата точки пересечения (в координатах TFlex) </param>
            <param name="iNVersion"> Версия объекта, для которого ищется пересечение </param>
            <returns> true - пересечение найдено успешно, false - иначе </returns>
        </member>
        <member name="F:PreciseGeometryUtils.InterPointData._parameter1">
Параметры ни кривых
</member>
        <member name="F:PreciseGeometryUtils.InterPointData._type">
Тип точки пересечения
</member>
        <member name="F:PreciseGeometryUtils.InterPointData._nDraw2">
Индекс второй пересекаемой кривой
</member>
        <member name="F:PreciseGeometryUtils.InterPointData._nDraw1">
Индекс первой пересекаемой кривой
</member>
        <member name="F:PreciseGeometryUtils.InterPointData._y">
Y-координата точки пересечения
</member>
        <member name="F:PreciseGeometryUtils.InterPointData._x">
X-координата точки пересечения
</member>
        <member name="M:PreciseGeometryUtils.InterPointData.GetParameter1">
            <summary> Получить параметер на кривой соответствующий точке пересечения </summary>
            <returns> Параметер пересесения </returns>
        </member>
        <member name="M:PreciseGeometryUtils.InterPointData.IsTouchPoint">
            <summary> Является ли точка касательной </summary>
            <returns> true - если точка пересечения - касательная точка </returns>
        </member>
        <member name="M:PreciseGeometryUtils.InterPointData.GetPoint(RGPlatform.Geometry.Point2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Создать точку пересечения </summary>
            <param name="oPoint"> Точка пересесения </param>
            <param name="iToModelSpaceScale"> Коэффициент преобразования в координаты модели </param>
        </member>
        <member name="M:PreciseGeometryUtils.InterPointData.GetTFPoint(System.Double)">
            <summary> Создать точку пересечения типа TFPoint </summary>
            <param name="iToModelSpaceScale"> Коэффициент преобразования в координаты модели </param>
            <returns> Точка пересесения </returns>
        </member>
        <member name="M:PreciseGeometryUtils.InterPointData.GetPoint(System.Double)">
            <summary> Создать точку пересечения </summary>
            <param name="iToModelSpaceScale"> Коэффициент преобразования в координаты модели </param>
            <returns> Точка пересесения </returns>
        </member>
        <member name="M:PreciseGeometryUtils.InterPointData.#ctor(RGPlatform.Geometry.Curve2DIntersectionPointData!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Конструктор по данным RGP </summary>
        </member>
        <member name="M:PreciseGeometryUtils.InterPointData.#ctor(System.Double,System.Double,System.Int32,System.Int32,&lt;unknown type&gt;)">
            <summary> Конструктор общего вида </summary>
            <param name="iX"> X-координата точки пересечения </param>
            <param name="iY"> Y-координата точки пересечения </param>
            <param name="iNDraw1"> Индекс первой пересекаемой кривой </param>
            <param name="iNDraw2"> Индекс второй пересекаемой кривой </param>
            <param name="iType"> Тип точки пересечения </param>
        </member>
        <member name="M:PreciseGeometryUtils.InterPointData.#ctor">
Конструктор по умолчанию
</member>
        <member name="T:PreciseGeometryUtils.InterPointData">
Данные о точке пересечения (в том числе, точке касания).
</member>
        <member name="F:TouchPoint">
Точка касания
</member>
        <member name="F:SimplePoint">
Простое пересечение (трансверсальное)
</member>
        <member name="T:PreciseGeometryUtils.InterPointType">
Тип точки пересечения
</member>
        <member name="T:PreciseGeometryUtils">
Класс содержит вспомогательные методы для вычислений на точной геометрии
</member>
        <member name="D:RGK.Constraints.JointLCSPtr">
Класс, обеспечивающий хранение ссылки на систему координат, используемую для привязки деталей в сопряжениях
</member>
        <member name="D:RGK.Constraints.LCSLCSJointPtr">
Класс, обеспечивающий хранение ссылки на сопряжения деталей, привязанных друг к другу по системам координат, с заданием дополнительных степеней свободы через интервалы перемещений вдоль осей и интервалы углов поворотов вокруг осей целевой системы координат, привязанной к первой детали
</member>
        <member name="D:RGK.Constraints.JointPartPtr">
Класс, обеспечивающий хранение ссылки на сопрягаемую деталь
</member>
        <member name="D:RGK.Constraints.JointTopolsPtr">
Класс, обеспечивающий хранение ссылки на сопряжение по набору топологических элементов, в том числе граней, рёбер, вершин и тел
</member>
        <member name="D:RGK.Constraints.JointFaceSurfacePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по грани
</member>
        <member name="D:RGK.Constraints.JointGeometrySurfacePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по поверхности, заданной в явном виде
</member>
        <member name="D:RGK.Constraints.JointSurfacePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по поверхности
</member>
        <member name="D:RGK.Constraints.JointEdgeCurvePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по ребру
</member>
        <member name="D:RGK.Constraints.JointGeometryCurvePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по кривой, заданной в явном виде
</member>
        <member name="D:RGK.Constraints.JointCurvePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по кривой
</member>
        <member name="D:RGK.Constraints.JointGeometryPtr">
Класс, обеспечивающий хранение ссылки на сопряжение по геометрии
</member>
        <member name="D:RGK.Constraints.JointTopolPlanePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по плоскости: грани, рёбра
</member>
        <member name="D:RGK.Constraints.JointCoordsPlanePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по плоскости, заданной в явном виде
</member>
        <member name="D:RGK.Constraints.JointPlanePtr">
Класс, обеспечивающий хранение ссылки на сопряжение по плоскости
</member>
        <member name="D:RGK.Constraints.JointTopolAxisPtr">
Класс, обеспечивающий хранение ссылки на сопряжение по оси: ось цилиндрической, конической или тороидальной грани; прямое ребро; ось кругового или эллиптического ребра
</member>
        <member name="D:RGK.Constraints.JointCoordsAxisPtr">
Класс, обеспечивающий хранение ссылки на сопряжение по оси, заданной в явном виде
</member>
        <member name="D:RGK.Constraints.JointAxisPtr">
Класс, обеспечивающий хранение ссылки на сопряжение по оси
</member>
        <member name="D:RGK.Constraints.JointTopolPointPtr">
Класс, обеспечивающий хранение ссылки на сопряжение по точке: вершина; центр кругового или эллиптического ребра; центр сферической грани
</member>
        <member name="D:RGK.Constraints.JointCoordsPointPtr">
Класс, обеспечивающий хранение ссылки на сопряжение по точке, заданной в явном виде
</member>
        <member name="D:RGK.Constraints.JointPointPtr">
Класс, обеспечивающий хранение ссылки на сопряжение по точке
</member>
        <member name="D:RGK.Constraints.JointElementPtr">
Класс, обеспечивающий хранение ссылки на соединительный элемент
</member>
        <member name="D:RGK.Constraints.MassInertialPropertiesPtr">
Класс, обеспечивающий хранение ссылки на масс-инерционные характеристики

Класс, обеспечивающий хранение ссылки на масс-инерционные характеристики
</member>
        <member name="D:RGK.Constraints.PerpendicularPtr">
Класс, обеспечивающий хранение ссылки на сопряжение перпендикулярности
</member>
        <member name="D:RGK.Constraints.ParallelPtr">
Класс, обеспечивающий хранение ссылки на сопряжение параллельности
</member>
        <member name="D:RGK.Constraints.SheavePtr">
Класс, обеспечивающий хранение ссылки на сопряжение передачи типа отношения линейных скоростей
</member>
        <member name="D:RGK.Constraints.ScrewPtr">
Класс, обеспечивающий хранение ссылки на сопряжение передачи типа «Винт» (колесо-рейка)
</member>
        <member name="D:RGK.Constraints.GearPtr">
Класс, обеспечивающий хранение ссылки на сопряжение передачи типа «Колеса» (угловые скорости)
</member>
        <member name="D:RGK.Constraints.AnglePtr">
Класс, обеспечивающий хранение ссылки на сопряжение сохранения угла между элементами
</member>
        <member name="D:RGK.Constraints.DistancePtr">
Класс, обеспечивающий хранение ссылки на сопряжение сохранения расстояния между элементами
</member>
        <member name="D:RGK.Constraints.CoAxisPtr">
Класс, обеспечивающий хранение ссылки на сопряжение соосности
</member>
        <member name="D:RGK.Constraints.TangentPtr">
Класс, обеспечивающий хранение ссылки на сопряжение касания
</member>
        <member name="D:RGK.Constraints.CoincidencePtr">
Класс, обеспечивающий хранение ссылки на сопряжение совпадения
</member>
        <member name="D:RGK.Constraints.JointArray">
Массив сопряжений
</member>
        <member name="D:RGK.Constraints.JointPtr">
Класс, обеспечивающий хранение ссылки на сопряжение
</member>
        <member name="D:RGK.Tools.SheetBodyToolsPtr">
Класс, обеспечивающий хранение ссылки на инструментальный класс по работе с листовыми телами
</member>
        <member name="D:RGK.Tools.WireBodyToolsPtr">
Класс, обеспечивающий хранение ссылки на инструментальный класс по работе с проволочными телами
</member>
        <member name="D:RGK.Interfaces.UserDataWriterPtr">
Класс, обеспечивающий хранение ссылки на интерфейс класса, реализующего запись секции пользовательких данных в обменный файл
</member>
        <member name="D:RGK.Interfaces.UserDataStructurePtr">
Класс, обеспечивающий хранение ссылки на структуру пользовательских данных
</member>
        <member name="D:RGK.Interfaces.UserDataReaderPtr">
Класс, обеспечивающий хранение ссылки на интерфейс класса, реализующего чтение секции пользовательких данных из обменного файла
</member>
        <member name="D:RGK.Interfaces.CustomSelectorPtr">
Класс, обеспечивающий хранение ссылки на класс, для перекрытия реализации селектора
</member>
        <member name="D:RGK.Interfaces.ErrorCheckingPtr">
Класс, обеспечивающий хранение ссылки на класс обработки уведомлений об ошибках
</member>
        <member name="D:RGK.Interfaces.MonitoringOfGeneratorPtr">
Класс, обеспечивающий хранение ссылки на класс управления процессом выполнения генератора
</member>
        <member name="D:RGK.Interfaces.MeshBufferFactoryPtr">
Класс, обеспечивающий хранение ссылки на интерфейс фабрики класса, реализующего работу с буфером, в который пишутся результаты работы сеточного генератора

Класс, обеспечивающий хранение ссылки на интерфейс фабрики класса, реализующего работу с буфером, в который пишутся результаты работы сеточного генератора
</member>
        <member name="D:RGK.Store.UserDataStructurePtr">
Класс, обеспечивающий хранение ссылки на описание стурктуры пользовательских данных
</member>
        <member name="D:RGK.Store.ReadNodeArray">
Массив экземпляров класса чтения данных из узла
</member>
        <member name="D:RGK.Store.ReadNodePtr">
Класс, обеспечивающий хранение ссылки на класс чтения данных из узла
</member>
        <member name="D:RGK.Store.WriteNodePtr">
Класс, обеспечивающий хранение ссылки на класс записи данных в узел
</member>
        <member name="D:RGK.Tools.Validation.ShellsCompatibilityErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с оболочками
</member>
        <member name="D:RGK.Tools.Validation.ShellsCompatibilityErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с оболочками
</member>
        <member name="D:RGK.Tools.Validation.GeneralTopolErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с топологическим элементом
</member>
        <member name="D:RGK.Tools.Validation.GeneralTopolErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с топологическим элементом
</member>
        <member name="D:RGK.Tools.Validation.RegionErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с регионом
</member>
        <member name="D:RGK.Tools.Validation.RegionErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с регионом
</member>
        <member name="D:RGK.Tools.Validation.TopolPtrErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с несоответствием указателей
</member>
        <member name="D:RGK.Tools.Validation.TopolPtrErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с несоответствием указателей
</member>
        <member name="D:RGK.Tools.Validation.EdgeCoEdgeCompatibilityErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с несоответствием параметров ребра и R-ребра
</member>
        <member name="D:RGK.Tools.Validation.EdgeCoEdgeCompatibilityErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с несоответствием параметров ребра и R-ребра
</member>
        <member name="D:RGK.Tools.Validation.DiscrepancyErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с несоответствием геометрии связанных топологических элементов
</member>
        <member name="D:RGK.Tools.Validation.DiscrepancyErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с несоответствием геометрии связанных топологических элементов
</member>
        <member name="D:RGK.Tools.Validation.EdgeVertexErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с несоответствием вершин и геометрии ребра
</member>
        <member name="D:RGK.Tools.Validation.EdgeVertexErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с несоответствием вершин и геометрии ребра
</member>
        <member name="D:RGK.Tools.Validation.FacesCompatibilityErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с совместимостью граней
</member>
        <member name="D:RGK.Tools.Validation.FacesCompatibilityErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с совместимостью граней
</member>
        <member name="D:RGK.Tools.Validation.IntersectionErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с пересечением элементов
</member>
        <member name="D:RGK.Tools.Validation.IntersectionErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с пересечением элементов
</member>
        <member name="D:RGK.Tools.Validation.FaceErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с гранью
</member>
        <member name="D:RGK.Tools.Validation.ShellErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с оболочкой
</member>
        <member name="D:RGK.Tools.Validation.ShellErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с оболочкой
</member>
        <member name="D:RGK.Tools.Validation.FaceErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с гранью
</member>
        <member name="D:RGK.Tools.Validation.LoopsCompatibilityErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с совместимостью циклов
</member>
        <member name="D:RGK.Tools.Validation.LoopsCompatibilityErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с совместимостью циклов
</member>
        <member name="D:RGK.Tools.Validation.CoEdgesCompatibilityErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную со связностью R-рёбер в цикле
</member>
        <member name="D:RGK.Tools.Validation.CoEdgesCompatibilityErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную со связностью R-рёбер в цикле
</member>
        <member name="D:RGK.Tools.Validation.LoopErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку в цикле
</member>
        <member name="D:RGK.Tools.Validation.LoopErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку в цикле
</member>
        <member name="D:RGK.Tools.Validation.CoEdgeErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с R-ребром
</member>
        <member name="D:RGK.Tools.Validation.CoEdgeErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку, связанную с R-ребром
</member>
        <member name="D:RGK.Tools.Validation.CheckErrorWeakPtr">
Класс, обеспечивающий хранение ссылки на ошибку
</member>
        <member name="D:RGK.Tools.Validation.CheckErrorPtr">
Класс, обеспечивающий хранение ссылки на ошибку
</member>
        <member name="D:RGK.Model.EdgeWithFlags">
Информация о разрезаемом ребре
</member>
        <member name="D:RGK.Model.TopolChangePtr">
Класс, обеспечивающий хранение ссылки на изменения в топологических элементах
</member>
        <member name="D:RGK.Model.PartArray">
Массив деталей
</member>
        <member name="D:RGK.Model.TopolPathArray">
Массив путей к топологическим элементам в сборке
</member>
        <member name="D:RGK.Model.TopolPathPtr">
Класс, обеспечивающий хранение ссылки на путь к топологическому элементу в сборке
</member>
        <member name="D:RGK.Model.PartInstancePathArray">
Набор путей к подсборкам
</member>
        <member name="D:RGK.Model.PartInstanceWeakPathSet">
Набор путей к подсборкам
</member>
        <member name="D:RGK.Model.PartInstanceWeakArray">
Класс, обеспечивающий хранение ссылки на экземпляр детали
</member>
        <member name="D:RGK.Model.PartInstancePathPtr">
Класс, обеспечивающий хранение ссылки на связанный путь от сборки более верхнего уровня к сборке нижнего уровня
</member>
        <member name="D:RGK.Model.PartInstanceWeakPtr">
Класс, обеспечивающий хранение ссылки на экземляр детали
</member>
        <member name="D:RGK.Model.PartInstanceArray">
Путь в подсборке
</member>
        <member name="D:RGK.Model.PartInstancePtr">
Класс, обеспечивающий хранение ссылки на экземляр детали
</member>
        <member name="D:RGK.Model.PartWeakPtr">
Класс, обеспечивающий хранение ссылки на деталь
</member>
        <member name="D:RGK.Model.PartPtr">
Класс, обеспечивающий хранение ссылки на деталь
</member>
        <member name="D:RGK.Model.AssemblyWeakPtr">
Класс, обеспечивающий хранение ссылки на сборку
</member>
        <member name="D:RGK.Model.AssemblyArray">
Множество сборок
</member>
        <member name="D:RGK.Model.AssemblyPtr">
Класс, обеспечивающий хранение ссылки на сборку
</member>
        <member name="D:RGK.Model.BodyWeakPtr">
Класс, обеспечивающий хранение ссылки на тело
</member>
        <member name="D:RGK.Model.BodyArray">
Множество тел
</member>
        <member name="D:RGK.Model.BodyPtr">
Класс, обеспечивающий хранение ссылки на тело
</member>
        <member name="D:RGK.Model.StringAttributePtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.IntAttributePtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.IntArrayAttributePtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.DoubleArrayAttributePtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.DoubleAttributePtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.CompositeAttributePtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.BinaryAttributePtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.AttributeListPtr">
Класс, обеспечивающий хранение ссылки список атрибутов элемента модели
</member>
        <member name="D:RGK.Model.AttributeList">
Класс списка атрибутов элемента модели
</member>
        <member name="D:RGK.Model.AttributePtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.AttributeDefinitionPtr">
Класс, обеспечивающий хранение ссылки на атрибут
</member>
        <member name="D:RGK.Model.RegionArray">
Множество регионов
</member>
        <member name="D:RGK.Model.RegionWeakPtr">
Класс, обеспечивающий хранение ссылки на регион
</member>
        <member name="D:RGK.Model.RegionPtr">
Класс, обеспечивающий хранение ссылки на регион
</member>
        <member name="D:RGK.Model.CoFaceWeakPtr">
Класс, обеспечивающий хранение ссылки на R-грань
</member>
        <member name="D:RGK.Model.CoFacePtr">
Класс, обеспечивающий хранение ссылки на R-грань
</member>
        <member name="D:RGK.Model.ShellWeakPtr">
Класс, обеспечивающий хранение ссылки на оболочку
</member>
        <member name="D:RGK.Model.ShellArray">
Множество оболочек
</member>
        <member name="D:RGK.Model.ShellPtr">
Класс, обеспечивающий хранение ссылки на оболочку
</member>
        <member name="D:RGK.Model.CoEdgeWeakPtr">
Класс, обеспечивающий хранение ссылки на R-ребро
</member>
        <member name="D:RGK.Model.CoEdgeArray">
Множество R-рёбер
</member>
        <member name="D:RGK.Model.CoEdgePtr">
Класс, обеспечивающий хранение ссылки на R-ребро
</member>
        <member name="D:RGK.Model.LoopWeakPtr">
Класс, обеспечивающий хранение ссылки на цикл
</member>
        <member name="D:RGK.Model.LoopArray">
Множество циклов
</member>
        <member name="D:RGK.Model.LoopPtr">
Класс, обеспечивающий хранение ссылки на цикл
</member>
        <member name="D:RGK.Model.FaceWeakArray">
Множество граней
</member>
        <member name="D:RGK.Model.FaceWeakPtr">
Класс, обеспечивающий хранение ссылки на грань
</member>
        <member name="D:RGK.Model.FaceArray">
Множество граней
</member>
        <member name="D:RGK.Model.FacePtr">
Класс, обеспечивающий хранение ссылки на грань
</member>
        <member name="D:RGK.Model.VertexWeakPtr">
Класс, обеспечивающий хранение ссылки на вершину
</member>
        <member name="D:RGK.Model.VertexArray">
Множество вершин
</member>
        <member name="D:RGK.Model.VertexPtr">
Класс, обеспечивающий хранение ссылки на вершину
</member>
        <member name="D:RGK.Model.EdgeWeakArray">
Множество рёбер
</member>
        <member name="D:RGK.Model.EdgeWeakPtr">
Класс, обеспечивающий хранение ссылки на ребро
</member>
        <member name="D:RGK.Model.EdgeArray">
Множество рёбер
</member>
        <member name="D:RGK.Model.EdgePtr">
Класс, обеспечивающий хранение ссылки на ребро
</member>
        <member name="D:RGK.Model.TopolWeakArray">
Множество топологических элементов
</member>
        <member name="D:RGK.Model.TopolArray">
Множество топологических элементов
</member>
        <member name="D:RGK.Model.TopolWeakPtr">
Класс, обеспечивающий хранение ссылки на топологию
</member>
        <member name="D:RGK.Model.TopolPtr">
Класс, обеспечивающий хранение ссылки на топологию
</member>
        <member name="D:RGK.Model.ChangeLogPtr">
Класс, обеспечивающий хранение ссылки на изменения
</member>
        <member name="D:RGK.Math.ParamArray">
Множество параметров
</member>
        <member name="T:RGK.Math.FaceBoundary">
Информация о границе Loop-а или Face-а
</member>
        <member name="D:RGK.Geometry.GeometryArray">
Массив геометрических объектов
</member>
        <member name="D:RGK.Geometry.SurfaceArray">
Массив поверхностей
</member>
        <member name="D:RGK.Geometry.ParametricCurveArray">
Массив параметрических кривых
</member>
        <member name="D:RGK.Geometry.CurveArray">
Массив кривых
</member>
        <member name="D:RGK.Geometry.CLMeshRepresentationPtr">
Класс, обеспечивающий хранение ссылки на сетку в формате OpenCL
</member>
        <member name="D:RGK.Geometry.SilhouetteCurvePtr">
Класс, обеспечивающий хранение ссылки на кривую очерка
</member>
        <member name="D:RGK.Geometry.SphereConeIntersectionPtr">
Класс, обеспечивающий хранение ссылки на процедурную форму кривой пересечения Сферы и Конуса
</member>
        <member name="D:RGK.Geometry.CylinderSphereIntersectionPtr">
Класс, обеспечивающий хранение ссылки на процедурную форму кривой пересечения Цилиндра и Сферы
</member>
        <member name="D:RGK.Geometry.CylinderCylinderIntersectionPtr">
Класс, обеспечивающий хранение ссылки на процедурную форму кривой пересечения Цилиндра и Цилиндра
</member>
        <member name="D:RGK.Geometry.TorusSphereIntersectionPtr">
Класс, обеспечивающий хранение ссылки на процедурную форму кривой пересечения Тора и Сферы
</member>
        <member name="D:RGK.Geometry.OffsetSurfacePtr">
Класс, обеспечивающий хранение ссылки на поверхность смещения
</member>
        <member name="D:RGK.Geometry.MultipleSurfacesBlendingPtr">
Класс, обеспечивающий хранение ссылки на поверхность затягивания
</member>
        <member name="D:RGK.Geometry.IsoclineSurfacePtr">
Класс, обеспечивающий хранение ссылки на изоклин-поверхность
</member>
        <member name="D:RGK.Geometry.IsoclineCurvePtr">
Класс, обеспечивающий хранение ссылки на изоклин-кривую
</member>
        <member name="D:RGK.Geometry.GeometryPtr">
Класс, обеспечивающий хранение ссылки на геометрический объект
</member>
        <member name="D:RGK.Geometry.IntersectionCurvePtr">
Класс, обеспечивающий хранение ссылки на кривую пересечения пересечение
</member>
        <member name="D:RGK.Geometry.EllipsePtr">
Класс, обеспечивающий хранение ссылки на эллипс
</member>
        <member name="D:RGK.Geometry.CylinderPtr">
Класс, обеспечивающий хранение ссылки на цилиндр
</member>
        <member name="D:RGK.Geometry.CirclePtr">
Класс, обеспечивающий хранение ссылки на окружность
</member>
        <member name="D:RGK.Geometry.TorusPtr">
Класс, обеспечивающий хранение ссылки на тор
</member>
        <member name="D:RGK.Geometry.SpherePtr">
Класс, обеспечивающий хранение ссылки на сферу
</member>
        <member name="D:RGK.Geometry.ConePtr">
Класс, обеспечивающий хранение ссылки на конус
</member>
        <member name="D:RGK.Geometry.LinePtr">
Класс, обеспечивающий хранение ссылки на прямую
</member>
        <member name="D:RGK.Geometry.PointPtr">
Класс, обеспечивающий хранение ссылки на точку
</member>
        <member name="D:RGK.Geometry.SurfacePtr">
Класс, обеспечивающий хранение ссылки на поверхность
</member>
        <member name="D:RGK.Geometry.PlanePtr">
Класс, обеспечивающий хранение ссылки на плоскость
</member>
        <member name="D:RGK.Geometry.ReparameterizedCurvePtr">
Класс, обеспечивающий хранение ссылки на репараметризованную кривую
</member>
        <member name="D:RGK.Geometry.NURBSSurfacePtr">
Класс, обеспечивающий хранение ссылки на NURBS-поверхность
</member>
        <member name="D:RGK.Geometry.ParametricCurvePtr">
Класс, обеспечивающий хранение ссылки на параметрическую кривую
</member>
        <member name="D:RGK.Geometry.CompositeSplinePtr">
Класс, обеспечивающий хранение ссылки на составную кривую
</member>
        <member name="D:RGK.Geometry.NURBSCurvePtr">
Класс, обеспечивающий хранение ссылки на NURBS-кривую
</member>
        <member name="D:RGK.Geometry.CurvePtr">
Класс, обеспечивающий хранение ссылки на кривую
</member>
        <member name="D:RGK.Generators.ScalarLawPtr">
Класс, обеспечивающий хранение ссылки на скалярный закон
</member>
        <member name="D:RGK.Generators.LawPtr">
Класс, обеспечивающий хранение ссылки на закон
</member>
        <member name="D:RGK.Generators.InterruptionInfoPtr">
Класс, обеспечивающий хранение ссылки на информацию о прерывании
</member>
        <member name="D:RGK.Generators.IntersectionPointPtr">
Класс, обеспечивающий хранение ссылки на точку
</member>
        <member name="D:RGK.Generators.IntersectionSegmentPtr">
Класс, обеспечивающий хранение ссылки на сегмент пересечения
</member>
        <member name="D:RGK.Generators.IntersectionGraphPtr">
Класс, обеспечивающий хранение ссылки на граф пересечений
</member>
        <member name="D:RGK.Generators.MeshBufferPtr">
Класс, обеспечивающий хранение ссылки на сеточный буфер
</member>
        <member name="D:RGK.Generators.BufferedMeshDataPtr">
Класс, обеспечивающий хранение ссылки на сетку
</member>
        <member name="D:RGK.Common.ErrorReportPtr">
Класс, обеспечивающий хранение ссылки на отчёт об ошибке
</member>
        <member name="M:RGK.Common.CombinePartialResult(RGK.Common.Result,RGK.Common.Result)">
            <returns>
r - если !PartiallySucceeded(r)
Success - если r == Success, r0 = Success
PartialSuccess - если r == PartialSuccess, r0 = Success
               - если r == Success, r0 = PartialSuccess
               - если r == PartialSuccess, r0 = PartialSuccess
</returns>
        </member>
        <member name="M:RGK.Common.PartiallySucceeded(RGK.Common.Result)">
            <returns>r == Result::Success или r == Result::PartialSuccess</returns>
            <remarks>Проверка на наличие ошибки</remarks>
        </member>
        <member name="M:RGK.Common.Succeeded(RGK.Common.Result)">
            <returns>r == Result::Success</returns>
            <remarks>Проверка на наличие ошибки</remarks>
        </member>
        <member name="M:RGK.Common.Failed(RGK.Common.Result)">
            <returns>r != Result::Success</returns>
            <remarks>Проверка на наличие ошибки</remarks>
        </member>
        <member name="T:RGK.Common.Result">
Перечисление ошибок, возвращаемых различными методами классов ядра
<seealso cref="!:Обработка ошибок" /></member>
        <member name="F:Last">
Последний (счётчик)

Последний (счётчик)
</member>
        <member name="F:ZeroInterval">
Интервал нулевой длинны некорректно.				
</member>
        <member name="F:DivisionByZero">
Деление на 0
</member>
        <member name="F:SameName">
Недопустимо дублирование имён 
</member>
        <member name="F:EmptyString">
Недопустима пустая строка
</member>
        <member name="F:UnsupportedGeometryType">
Некорректный или неподдерживаемый тип геометрии
</member>
        <member name="F:BlendingBeakFaceProcessingFailed">
Ошибка при обработке клювовидной сглаживающей грани
</member>
        <member name="F:EdgeTangentEpsilonTooTight">
Точность сравнения рёбер на гладкую стыковку слишком высокая
</member>
        <member name="F:BlendFaceExtensionRequired">
Требуется расширение сглаживающей грани
</member>
        <member name="F:BlendFaceHasToBeSplitted">
Сглаживающая грань должна быть разделена на две
</member>
        <member name="F:BlendingSmoothProcessingBadData">
Некорректные входные данные для smooth-обработок переполнений операций сглаживания
</member>
        <member name="F:BlendFaceHaveToBeSplitted">
Сглаживающая грань должна быть разделена на две
</member>
        <member name="F:OverlappingProcessingAreas">
Области обработок перекрываются
</member>
        <member name="F:NoValidBlendGeometryGenerated">
Не построено ни одного сглаживающего набора, удовлетворяющего требованиям алгоритма
</member>
        <member name="F:SpecialCaseWasDetected">
Частный случай не был выявлен
</member>
        <member name="F:BadRadius">
Плохой радиус
</member>
        <member name="F:InternalError">
Внутренняя ошибка алгоритма
</member>
        <member name="F:ThickenError">
Ошибка алгоритмов оболочки, придания толщины, построения эквидистантного тела.
</member>
        <member name="F:SurfacesAreNotEqual">
Поверхности не совпадают.
Возникает в методе CheckParametricCurves при объединении поверхностей
</member>
        <member name="F:NoFullCoverageOfExtendedFace">
Ошибка алгоритма продолжения граней - нет полного покрытия продолжаемой
грани ограничивающими, т.е. продолжаемые рёбра "проходят мимо".
</member>
        <member name="F:CubicSplineInterpolationHang">
Ошибка построения аппроксимирующей кривой.
Алгоритм выполнил слишком много операций (скорее всего, просто завис).
Возникает в CubicSplineInterpolation::Builder.
Например, может возвращаться из ParametricCurve::ProjectCurveOnSurface.
</member>
        <member name="F:CubicSplineInterpolationFail">
Ошибка построения интерполирующей кривой.
Не удаётся построить кусок кривой значимого размера, удовлетворяющего требованиям.
Возникает в CubicSplineInterpolation::Builder.
Например, может возвращаться из ParametricCurve::ProjectCurveOnSurface.
</member>
        <member name="F:LoopBoundaryUnconnected">
Ошибка построения UV-контура для цикла/контура.
Не удаётся составить единый связный контур из UV-кривых отдельных R-рёбер.
Возникает в FaceBoundaryBuilder, может возвращаться из методов (Loop|Face)::UpdateBoundaryGeometry.
</member>
        <member name="F:IncorrectBlendBody">
Некорректное сглаживающее тело
</member>
        <member name="F:InfiniteLooping">
Зацикливание
</member>
        <member name="F:DifferentSessions">
Разные сессии
</member>
        <member name="F:CalculationError">
Ошибка расчёта.
Ошибка может возвращаться при вызове метода RGK::Interfaces::ConstraintResolver::Run
</member>
        <member name="F:FacesCuttingExtensionError">
Ошибка обрезки/продолжения граней
</member>
        <member name="F:BadSize">
Некорректно задан размер массива.
Ошибка может возвращаться при вызове метода RGK::Math::AffineMap3D::SetMap,
RGK::Math::AffineMap3D::GetMap
</member>
        <member name="F:InvalidTopol">
Топологический элемент был удалён или находится в некорректном состоянии
</member>
        <member name="F:ErrorSplittingEdge">
Ошибка при разбиении ребра
</member>
        <member name="F:UnknownIntersectionType">
Неизвестный тип пересечения
</member>
        <member name="F:UnexpectedTopology">
Ожидается другая топология
</member>
        <member name="F:UnexpectedGeometry">
Ожидается другая геометрия
</member>
        <member name="F:BadRegionType">
Неизвестный тип региона
</member>
        <member name="F:BadOrientation">
Неизвестная ориентация
</member>
        <member name="F:UnexpectedSegmentsSequence">
Неожиданная последовательность сегментов пересечения
</member>
        <member name="F:CannotFormLoop">
Ошибка при формировании цикла
</member>
        <member name="F:NoOuterLoop">
На грани отсутствует внешний цикл
</member>
        <member name="F:ShellNotFound">
Не найдена искомая оболочка
</member>
        <member name="F:RegionNotFound">
Не найден искомый регион
</member>
        <member name="F:UnsuitableTopol">
Топологический элемент данного типа не может быть обработан в алгоритме
</member>
        <member name="F:BeakShapedBlendFaceFound">
Отсутствует боковое ребро поверхности сглаживания - опорные рёбра сходятся в одной вершине
</member>
        <member name="F:AmbiguousResult">
Результат операции, не определён, может возвращаться тогда, когда есть несколько альтернатив,
из которых нельзя выбрать одну единственную
</member>
        <member name="F:AmbiguousIdentifiers">
Неразличимые идентификаторы
</member>
        <member name="F:NotAnalyticalGeometry">
Не является аналитической геометрией (кривая/поверхность)
</member>
        <member name="F:UndefinedIntersectionGraphValidationResult">
Не удалось проверить корректность графа пересечения
</member>
        <member name="F:NotOnTopology">
Геометрический объект (точка или кривая) не принадлежит топологии
</member>
        <member name="F:PointBodyContainmentError">
Ошибка при определении положения точки относительно тела
</member>
        <member name="F:UnknownSegmentType">
Тип сегмента пересечения неизвестен или не удовлетворяет запросу
</member>
        <member name="F:UnknownPointType">
Тип точки пересечения неизвестен или не удовлетворяет запросу
</member>
        <member name="F:VertexNotOnBoundary">
Вершина, указанная в качестве стартовой точки сечения или одной из точек соответствия не принадлежит границе листового тела
</member>
        <member name="F:BadGuideMatching">
Направляющая неправильно пересекает сечения
</member>
        <member name="F:BadSectionMatching">
Некорректно заданы соответствия сечений 
</member>
        <member name="F:NoStartingVertex">
Для периодической составной кривой необходимо указать начальную вершину
</member>
        <member name="F:BadGuide">
Неправильная направляющая.
Например, не пересекает сечения или не совпадает по признаку периодичности.
</member>
        <member name="F:BadSection">
Неправильное сечение генератора тел и поверхностей по сечениям.
Не является составной кривой или листовым телом без отверстий, либо не совпадает по признаку периодичности
</member>
        <member name="F:WrongOrder">
Неправильный порядок элементов.
Например, неправильный порядок точек в заготовке сегмента пересечения
</member>
        <member name="F:ArrayZeroSize">
Нулевой размер массива при работе с OpenCL
</member>
        <member name="F:EmptyUVBox">
Нулевой UV Box
</member>
        <member name="F:BadCurve">
Ошибка при попытке воспользоваться кривой
</member>
        <member name="F:BadSurface">
Ошибка при попытке воспользоваться поверхностью, поверхность имеет дефекты (вырожденные области, нулевые нормали и др.).
Ошибка может возвращаться при вызове методов:
RGK::Geometry::MultipleSurfacesBlendingGenerator::G1ContinuousBlendee::Create
</member>
        <member name="F:BadLoopType">
Ошибка при определении типа нового цикла.
Ошибка может возвращаться при вызове методов:
RGK::Generators::Boolean::Run, RGK::Generators::BooleanBlending::Run
</member>
        <member name="F:IntersectionGraphBuilderError">
Ошибка при построении графа пересечения.
Ошибка может возвращаться при вызове методов:
RGK::Generators::Boolean::Run, RGK::Generators::BooleanBlending::Run
</member>
        <member name="F:BadCoFaceOrientation">
В твёрдом теле R-грань ориентирована противоположно грани.
Ошибка может возвращаться при вызове методов:
RGK::Generators::Boolean::Run, RGK::Generators::BooleanBlending::Run
</member>
        <member name="F:UndefinedLoop">
Цикл имеет тип Undefined.
Ошибка может возвращаться при вызове методов:
RGK::Generators::Boolean::Run, RGK::Generators::BooleanBlending::Run 
</member>
        <member name="F:BadIntersectionGraph">
Неправильно заполнен граф пересечения.
Ошибка может возвращаться при вызове методов:
RGK::Generators::Boolean::Run, RGK::Generators::BooleanBlending::Run 
</member>
        <member name="F:ToleranceTooTight">
Запрашиваемая точность не может быть достигнута
</member>
        <member name="F:FaceterFatalError">
Фатальная ошибка триангуляции (смотрите метод Faceter::Report::GetErrorCode для получения дополнительной информации об ошибке фасетера)
</member>
        <member name="F:GuideMustBeG1Continuity">
Составная кривая должна иметь G1-непрерывность
</member>
        <member name="F:BadCurves">
Неверный набор кривых
</member>
        <member name="F:EmptyBody">
Тело не содержит ни одной грани
</member>
        <member name="F:EmptyProtocol">
Протоколирование не включено или протокол пуст
</member>
        <member name="F:CantOpenFile">
Ошибка открытия файла
</member>
        <member name="F:SystemError">
Системная ошибка. Например, ошибка выделения памяти или возникновение исключения.
</member>
        <member name="F:ReferenceError">
Ошибка чтения ссылки из обменного файла
</member>
        <member name="F:ReadError">
Ошибка чтения модели из обменного файла
</member>
        <member name="F:WriteError">
Ошибка сохранения модели в обменный файл
</member>
        <member name="F:InconsistentGeneratorData">
Внутренняя информация генератора некорректна.
Ошибка может возвращаться при вызову методов:
RGK::Generators::EdgeBlend::TwoEdgesProcessingMMM
</member>
        <member name="F:IncorrectConfiguration">
Неверная конфигурация рёбер в вершине.
Ошибка может возвращаться при вызове методов:
RGK::Generators::EdgeBlend::TwoEdgesProcessingMMM
</member>
        <member name="F:FewEdges">
Недостаточное количество рёбер.
Ошибка может возвращаться при вызове методов:
RGK::Generators::EdgeBlend::TwoEdgesProcessingMMM
</member>
        <member name="F:TooComplexObject">
Модифицируемый объект слишком сложный для проведения модификации.
Ошибка может возвращаться при вызове методов:
RGK::Generators::EdgeBlend::InteriorProcessing
</member>
        <member name="F:FaceNotInBlendSheet">
Передаваемая грань не содержится в передаваемом сглаживающем листе.
Ошибка может возвращаться при вызове методов:
RGK::Generators::EdgeBlend::MakeEdgeFace
</member>
        <member name="F:NoCommonEdge">
Передаваемые данные не содержат общего ребра.
Ошибка может возвращаться при вызове методов:
RGK::Generators::EdgeBlend::CliffEdgeProcessing
</member>
        <member name="F:LCSIsNotRight">
Система координат не является правой
</member>
        <member name="F:NoIntersectionsFound">
Пересечений не найдено.
Ошибка может возвращаться при вызове методов:
RGK::Generators::EdgeBlend::CreateIsoparametricLine
RGK::Generators::EdgeBlend::BlendSheetConnectedCompt::FindBaseEdgeIntersections
</member>
        <member name="F:NotDistinctFaces">
Передаваемые грани совпадают.
Ошибка может возвращаться при вызове метода RGK::Model::Face::AreFacesSmoothlyConnected
</member>
        <member name="F:NotPolyLine">
Кривая не является ломаной
</member>
        <member name="F:ConnectedParts">
Соседние куски поверхности сглаживания связаны через концы обоих интервалов.
Ошибка может возвращаться при вызове методов:
RGK::Generators::EdgeBlend::MakeBasicSheets
</member>
        <member name="F:EdgeNotToBeBlended">
Ребро не находится в списке сглаживаемых.
Ошибка может возвращаться при вызове методов:
RGK::Generators::EdgeBlend::Data::EdgesAreTangent
</member>
        <member name="F:IncorrectData">
Некорректные входные данные
</member>
        <member name="F:WrongNumberOfPoints">
Некорректное количество точек.
Ошибка может возвращаться при вызове методов:
RGK::Geometry::NURBSCurve::CreateSurfaceGlobalInt
</member>
        <member name="F:CannotFindNearestPoint">
Не найдена ближайшая точка.
Ошибка может возвращаться при вызове методов:
    RGK::Geometry::Surface::NURBSSurface
</member>
        <member name="F:UnexpectedValue">
Неожиданное значение для числа с плавающей точкой. В результате внутренних вычислений алгоритм встретил
недопустимое значение для числа с плавающей точкой (обычно равное бесконечности или NaN). Обычно означает
внутреннюю ошибку в вычислениях.
</member>
        <member name="F:TooManyThreads">
Количество запрашиваемых для создания внутри ядра потоков превышает максимально установленное для сессии.
Ошибка может возвращаться при вызове методов:
    RGK::Common::Context::SetMaxThreads
</member>
        <member name="F:BadTopol">
Некорректная топология
</member>
        <member name="F:DifferentBodies">
Склеиваемые вершины не принадлежат одному телу
</member>
        <member name="F:StateNotValid">
Откат к неактуальному состоянию.
Ошибка может возвращаться при вызове методов:
    RGK::Model::Session::Undo
</member>
        <member name="F:NotAvailableWhenThreadContext">
Операция недоступна, если созданы контексты для выполнения в других потоках.
Ошибка может возвращаться при вызове методов:
    RGK::Model::Session::KeepChanges
    RGK::Model::Session::Undo
</member>
        <member name="F:DontKeepChanges">
В сессии не включён режим ведения журнала изменений.
Ошибка может возвращаться при вызове методов:
    RGK::Model::Session::GetState
    RGK::Model::Session::Undo
</member>
        <member name="F:AlreadyInSession">
Деталь уже добавлена в сессию.
Ошибка может возвращаться при вызове методов:
    RGK::Generators::TopologyModifier::AddBodyToModel
</member>
        <member name="F:NotOnLine">
Точка не лежит на прямой
</member>
        <member name="F:NotOnPlane">
Точка не лежит на плоскости
</member>
        <member name="F:Undefined">
Результат не определён

Интервал не определён

Не задан

Не задан
</member>
        <member name="F:ForeignChangeLog">
Журнал изменений из другой сессии или контекста.
Ошибка может возвращаться при вызове методов:
    RGK::Model::Session::Undo
    RGK::Model::Session::Redo
    RGK::Common::Context::Undo
    RGK::Common::Context::Redo
</member>
        <member name="F:BadInterval">
Интервал задан некорректно.
Ошибка может возвращаться при вызове методов:
    RGK::Geometry::Interval::IsNestedInterval
</member>
        <member name="F:UndefinedInterval">
Интервал не определён.
Ошибка может возвращаться при вызове методов:
    RGK::Surface::MakeCurveUIsoparam
    RGK::Surface::MakeCurveVIsoparam
    RGK::Geometry::Interval::IsNestedInterval
</member>
        <member name="F:ElementNotContained">
Контейнер не содержит запрашиваемого элемента
</member>
        <member name="F:GeometryCollapseToPoint">
Геометрия (кривая или поверхность) вырождается в точку.
Ошибка может возвращаться при создании/копировании
геометрий, а также при вызове методов:
    RGK::Surface::MakeCurveUIsoparam
    RGK::Surface::MakeCurveVIsoparam
</member>
        <member name="F:CannotCreateIntersectionCurve">
Не могу создать кривую пересечения
</member>
        <member name="F:CannotCreateCircle">
Невозможно создать окружность
</member>
        <member name="F:CannotCreateLine">
Невозможно создать прямую
</member>
        <member name="F:CannotCreateStringAttribute">
Невозможно создать строковый атрибут
</member>
        <member name="F:CannotCreatePlane">
Невозможно создать плоскость
</member>
        <member name="F:CoplanarVectors">
Векторы компланарны
</member>
        <member name="F:NotUnique">
 По переданным параметрам нельзя однозначно определить объект
</member>
        <member name="F:AxisNotInCirclePlane">
 Ось не лежит в плоскости окружности
</member>
        <member name="F:BadLength">
Ненулевой размер меньше, либо равен допустимой точности
</member>
        <member name="F:NotOrthogonal">
Два вектора не ортогональны
</member>
        <member name="F:IdenticalLines">
При расчёте пересечения определено совпадение прямых
</member>
        <member name="F:Skew">
При расчёте пересечения определено скрещивание прямых
</member>
        <member name="F:Parallel">
При расчёте пересечения определена параллельность прямых
</member>
        <member name="F:NotTriangle">
Точки не образуют треугольник
</member>
        <member name="F:NotOnGeometry">
Точка не лежит на геометрии
</member>
        <member name="F:NotOnSurface">
Точка не лежит на поверхности
</member>
        <member name="F:NotOnCurve">
Точка не лежит на кривой
</member>
        <member name="F:MemoryFull">
Недостаточно оперативной памяти для работы ядра
</member>
        <member name="F:ForeignAttribute">
Атрибут не принадлежит объекту.
Ошибка может возвращаться при вызове методов:
    RGK::Model::Topol::DeleteAttribute
    RGK::Model::CompositeAttribute::DeleteAttribute
</member>
        <member name="F:AssemblyStillReferenced">
Удаление сборки, которая используется в модели
</member>
        <member name="F:BodyStillReferenced">
Удаление тела, которое используется в модели (например, в сборке)
</member>
        <member name="F:DeletedJoint">
Попытка повторного удаления сопряжения
</member>
        <member name="F:DeletedInstance">
Попытка повторного удаления экземпляра элемента сборки
</member>
        <member name="F:DeletedAssembly">
Попытка повторного удаления сборки
</member>
        <member name="F:DeletedBody">
Попытка повторного удаления тела
</member>
        <member name="F:RecursionInAssembly">
Рекурсия в описании сборки
</member>
        <member name="F:UserInterrupt">
Выполнение генератора прервано пользователем
</member>
        <member name="F:BadVersion">
Недопустимый номер версии
</member>
        <member name="F:OutsideSizeBox">
Размеры превышают ограничения на максимально допустимые размеры модели
</member>
        <member name="F:NotSupported">
Данный метод обработки не поддерживается
</member>
        <member name="F:BadParameterSequence">
Последовательность параметров не является строго возрастающей
Ошибка может возвращаться при вызове методов интерполяции
</member>
        <member name="F:BadParameter">
Параметр за границами параметрической области.
Ошибка может возвращаться при вызове метода: RGK::Geometry::Curve::EvaluateNormal
</member>
        <member name="F:NotConverged">
Ошибка сходимости алгоритма
</member>
        <member name="F:NormalIsNotSignificant">
Очень маленькое значение кривизны в точке. Радиус кривизны не определяется.
Ошибка может возвращаться при вызове метода: RGK::Geometry::Curve::EvaluateNormal
</member>
        <member name="F:BadAngle">
Недопустимое значение угла.
Ошибка может возвращаться при вызове метода RGK::Geometry::Cone::Create
</member>
        <member name="F:ZeroVector">
Нулевой вектор
</member>
        <member name="F:LCSNotOrthogonal">
Оси системы координат не ортогональны.
Ошибка может возвращаться при вызове методов: RGK::Geometry::Circle::Create, RGK::Geometry::Ellipse::Create
</member>
        <member name="F:RadiusLessOrEqualZero">
Радиус меньше или равен нулю.
Ошибка может возвращаться при вызове методов: RGK::Geometry::Circle::Create, RGK::Geometry::Ellipse::Create
</member>
        <member name="F:StillReferenced">
Элемент нельзя удалить, так как он используется.
Ошибка может возвращаться при вызове метода RGK::Geometry::Geometry::Release
</member>
        <member name="F:BadBodyType">
Тип тела не соответствует требуемому.
</member>
        <member name="F:BadIndex">
Некорректно задан индекс массива.
Ошибка может возвращаться при вызове метода RGK::Geometry::NURBSCurve::ModifyControlPoint
</member>
        <member name="F:BadWeights">
Некорректно заданы веса контрольных точек для NURBS.
Ошибка может возвращаться при вызове метода RGK::Geometry::NURBSCurve::Create
</member>
        <member name="F:BadDegree">
Некорректно задана степень NURBS.
Ошибка может возвращаться при вызове метода RGK::Geometry::NURBSCurve::Create
</member>
        <member name="F:BadKnots">
Некорректно заданная последовательность узлов.
Ошибка может возвращаться при вызове метода RGK::Geometry::NURBSCurve::Create
</member>
        <member name="F:OldObjectState">
Состояние объекта устарело
</member>
        <member name="F:InvalidTypeCast">
Неправильный тип данных (неверное преобразование типов)
</member>
        <member name="F:ArrayIndexOutOfBoundary">
Индекс массива за границами допустимого диапазона
</member>
        <member name="F:InvalidObjectState">
Состояния объекта не позволяет осуществить запрошенный метод
</member>
        <member name="F:ParameterNotExpected">
Значение параметра не соответствует ожидаемому
</member>
        <member name="F:InvalidInputParameter">
Входной параметр некорректен
</member>
        <member name="F:InvalidCLObject">
Объект OpenCL был неправильно сформирован
</member>
        <member name="F:NullPointer">
Недопустима передача нулевого указателя
</member>
        <member name="F:MemoryBufferTooSmall">
Буфер мал для хранения требуемой информации. 
Буфер может быть как CLMemoryBuffer, так и HostMemoryBuffer
</member>
        <member name="F:CLProgramBuildError">
Ошибка компиляции программы OpenCL
</member>
        <member name="F:CLKernelCreateError">
Ошибка, возникающая при создании kernel функции OpenCL
</member>
        <member name="F:CLKernelDimError">
Недопустимый параметр размерности для ядра OpenCL
</member>
        <member name="F:CLKernelRuntimeError">
Ошибка, возникающая при исполнении kernel функции OpenCL
</member>
        <member name="F:CLKernelArgumentError">
Ошибка, возникающая при задании аргументов kernel функции OpenCL
</member>
        <member name="F:CLBufferIOError">
Ошибка, возникающая при операциях чтения/записи буфера OpenCL
</member>
        <member name="F:CLInvalidQueue">
Ошибка некорректной очереди исполнения. Ошибка может возникать в 
случае когда объект OpenCL, с которым работает очередь, принадлежит другой платформе
</member>
        <member name="F:CLNullQueue">
Ошибка, возникающая в случае когда исполнительная очередь команд OpenCL не определена
</member>
        <member name="F:CLCannotCreateQueue">
Ошибка, возникающая при неудачного создании очереди выполнения команд OpenCL
</member>
        <member name="F:CLCannotCreateBuffer">
Ошибка, возникающая при неудачной попытке создания буферов OpenCL 
</member>
        <member name="F:CLPlatformNotInitialized">
Ошибка отсутствия инициализации OpenCL платформы.
Может выдаваться классами использующими платформу OpenCL
</member>
        <member name="F:CLResourceIsNull">
Ошибка, получаемая если один из используемых OpenCL ресурсов нулевой (не был определён)
</member>
        <member name="F:CLUndefinedDevice">
Ошибка получения типа устройства для параллельных вычислений.
Ошибка может возвращаться при вызове метода RGK::OpenCL::CLPlatform::GetDeviceInfo
</member>
        <member name="F:CLDeviceError">
Ошибка получения параметров устройства для параллельных вычислений.
Ошибка может возвращаться при вызове метода RGK::OpenCL::CLPlatform::GetDeviceInfo
</member>
        <member name="F:BadMeshAssoc">
В сетке нет достаточной информации о связанности сетки и топологических элементов.
Ошибка может возникать в методах обрабатывающих сетку тел
</member>
        <member name="F:WrongNumberOfEdges">
Неверное количество рёбер.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::Glue
</member>
        <member name="F:WrongDimension">
Неверная размерность параметра/значения функции
</member>
        <member name="F:WrongDir">
Значение параметра не совпадает с индуцированным топологией.
Ошибка может возвращаться при вызове метода RGK::Generators::EulrerOperators::Glue
</member>
        <member name="F:NonManifold">
Требуется обобщённая топология, а она не включена.
Ошибка может возвращаться при вызове метода RGK::Generators::EulrerOperators::Glue
</member>
        <member name="F:DifferentEdgeType">
Рёбра не являются одновременно кольцевыми, рёбрами с совпадающими концами или рёбрами с различными концами.
Ошибка может возвращаться при вызове метода RGK::Generators::EulrerOperators::Glue
</member>
        <member name="F:BadCoEdges">
Передаваемый массив R-рёбер не содержит всех R-рёбер обоих рёбер, содержит дубликаты или содержит R-рёбра в неверном порядке.
Ошибка может возвращаться при вызове метода RGK::Generators::EulrerOperators::Glue
</member>
        <member name="F:NotLaminarSide">
Для ламинарного ребра попытка образовать грань с неправильной стороны.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::SlitEdge
</member>
        <member name="F:BadCoEdge">
Передаётся неверное R-ребро.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::OpenZip
</member>
        <member name="F:EdgeNotOpen">
У ребра нет двух несовпадающих концов.
Ошибка может возвращаться при вызове метода: RGK::Generators::EulerOperators::MergeVertices
</member>
        <member name="F:VertexNotManifold">
Вершина имеет некорректную топологию (not manifold).
Ошибка может возвращаться при вызове методов: RGK::Generators::EulerOperators::SplitVertex
</member>
        <member name="F:EdgeNotLaminar">
Ребро не является ламинарным, то есть ребром, содержащим одно R-ребро
</member>
        <member name="F:EdgeNotManifold">
Edge has incorrenct (not manifold) topology.
Ошибка может возвращаться при вызове методов: RGK::Generators::EulerOperators::DeleteVertex,
RGK::Generators::EulerOperators::CloseZip, RGK::Generators::EulerOperators::DeleteEdgeMakeLoop,
RGK::Generators::EulerOperators::DeleteRingFace, RGK::Generators::EulerOperators::DeleteRingLoop,
RGK::Generators::EulerOperators::DeleteEdgeMergeFaces, RGK::Generators::EulerOperators::DeleteEdgeMergeLoops,
RGK::Model::Edge::FindFaces
</member>
        <member name="F:BadEdge">
Неподходящее для операции ребро.
Ошибка может возвращаться при вызове метода BasicTest::LoadEdge, например
</member>
        <member name="F:BadFace">
Неподходящая для операции грань.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::Unslit
</member>
        <member name="F:BadLoop">
Неподходящий для операции цикл.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::TransferLoop
</member>
        <member name="F:FaceContainsLoop">
Грань уже содержит цикл, который нужно перенести.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::TransferLoop
</member>
        <member name="F:DifferentShells">
Одна из оболочек не является общей для обеих граней.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::TransferLoop
</member>
        <member name="F:DifferentFaces">
Смежные с ребром грани не совпадают.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteEdgeMergeLoops
</member>
        <member name="F:RingEdge">
Ребро является кольцевым.
Ошибка может возвращаться при вызове методов: RGK::Generators::EulerOperators::DeleteEdgeMergeFaces,
RGK::Generators::EulerOperators::DeleteEdgeMergeLoops
</member>
        <member name="F:NotTwoFaces">
Число граней, смежных с ребром, не равно 2.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteEdgeMergeFaces
</member>
        <member name="F:NotTwoLoops">
Число циклов, связанных с ребром, не равно 2.
Ошибка может возвращаться при вызове методов: RGK::Generators::EulerOperators::DeleteRingLoop,
RGK::Generators::EulerOperators::DeleteEdgeMergeLoops
</member>
        <member name="F:FewCoEdges">
Менее двух R-рёбер связаны с ребром.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteRingLoop
</member>
        <member name="F:FewFaces">
Менее двух граней связаны с ребром
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteRingFace
</member>
        <member name="F:NotRingEdge">
Ребро не является кольцом.
Ошибка может возвращаться при вызове методов: RGK::Generators::EulerOperators::DeleteRingFace, RGK::Generators::EulerOperators::DeleteRingLoop
</member>
        <member name="F:DifferentLoops">
R-рёбра у передаваемого ребра не принадлежат одному циклу.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteEdgeMakeLoop
</member>
        <member name="F:RinglikePairOfEdges">
Совпадают обе пары вершин.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::CloseZip
</member>
        <member name="F:ForeignCoEdge">
R-ребро не принадлежит циклу.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteLoopMakeEdge
</member>
        <member name="F:LoopsNotInTheSameFace">
Циклы принадлежат различным граням
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteLoopMakeEdge
</member>
        <member name="F:LoopsNotDistinct">
Циклы совпадают
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteLoopMakeEdge
</member>
        <member name="F:ExpectedNullPointer">
Требуется передача нулевого указателя.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::MakeEdgeFace
</member>
        <member name="F:NotIsolatedLoop">
Цикл не является состоящим из одной вершины.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteIsolatedLoop
</member>
        <member name="F:NoCommonLoop">
Нет общего цикла.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::CloseZip
</member>
        <member name="F:NoCommonVertex">
Нет общей вершины.
Ошибка может возвращаться при вызове методов RGK::Generators::EulerOperators::SplitVertex, RGK::Generators::EulerOperators::CloseZip
</member>
        <member name="F:NotDistinctCoEdges">
Передаваемые R-рёбра совпадают.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::SplitVertex
</member>
        <member name="F:ForeignEdge">
Удаляемая вершина не является концом ребра, которое "выживает".
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::MergeEdges
</member>
        <member name="F:BadVertex">
Вершина с неподходящей для выполнения метода топологией.
Ошибка может возвращаться при вызове методов: RGK::Generators::EulerOperators::MergeEdges, RGK::Generators::EulerOperators::CloseZip
</member>
        <member name="F:TooManyEdges">
С вершиной связано больше одного ребра. Невозможно удаление вершины.
Ошибка может возвращаться при вызове метода RGK::Generators::EulerOperators::DeleteVertex
</member>
        <member name="F:KernelStartPartiallySuccessful">
Ядро запустилось, но в процессе инициализация возникла некритичная ошибка.
Как результат возникновения ошибки, может быть замедление выполнения ядра, так как не используется аппаратное ускорение.
Ошибка может возвращаться при вызове метода RGK::Instance::Start
</member>
        <member name="F:KernelStartError">
Ошибка инициализации ядра. Ошибка инициализации может быть критичной для выполнения функций ядра
Ошибка может возвращаться при вызове метода RGK::Instance::Start
</member>
        <member name="F:KernelNotStarted">
Ядро не было запущено при выполнении одной из функций.
Ошибка может возвращаться при вызове метода RGK::Instance::End
</member>
        <member name="F:KernelAlreadyStopped">
Ошибка остановки ядра. Повторная остановка ядра недопустима.
Ошибка может возвращаться при вызове метода RGK::Instance::End
</member>
        <member name="F:KernelAlreadyStartedError">
Ошибка инициализации ядра. Повторная инициализация недопустима. В процессе предыдущей инициализации возникли ошибка критичная для выполнения ядра
Ошибка может возвращаться при вызове метода RGK::Instance::Start
</member>
        <member name="F:KernelAlreadyStartedPartiallySuccessful">
Ошибка инициализации ядра. Повторная инициализация недопустима. В процессе предыдущей инициализации возникли некритичные ошибки
Ошибка может возвращаться при вызове метода RGK::Instance::Start
</member>
        <member name="F:KernelAlreadyStarted">
Ошибка инициализации ядра. Повторная инициализация недопустима.
Ошибка может возвращаться при вызове метода RGK::Instance::Start
</member>
        <member name="F:ForeignContext">
Попытка разблокировать контекст, созданный в другой сессии.
Ошибка может возвращаться методом RGK::Session::ReleaseThreadContext
</member>
        <member name="F:UndefinedFormat">
Ошибка чтения обменного файла. Формат файла не является RGK_XML.
Ошибка может возвращаться методом Model::Storage::Read
</member>
        <member name="F:NotImplemented">
В текущей версии ядра данная функциональность не реализована
</member>
        <member name="F:UndefinedContext">
Не задан контекст
</member>
        <member name="F:CannotUnlockBody">
Тело не было блокировано контекстом или количество разблокировок больше количества блокировок.
Ошибка может возвращаться методом RGK::Common::Context::UnlockBodies
</member>
        <member name="F:CannotCalculateModifiedBody">
Тело нельзя блокировать для вычислений, так как оно заблокировано для редактирования.
Ошибка может возвращаться методом RGK::Common::Context::LockBodies
</member>
        <member name="F:CannotModifyModifiedBody">
Тело нельзя блокировать для редактирования, так как оно заблокировано для редактирования в другом контексте.
Ошибка может возвращаться методом RGK::Common::Context::LockBodies
</member>
        <member name="F:CannotModifyCalculatedBody">
Тело нельзя блокировать для редактирования, так как оно заблокировано для вычислений.
Ошибка может возвращаться методом RGK::Common::Context::LockBodies
</member>
        <member name="F:PartialSuccess">
Операция обработки множества объектов завершилась с частичным успехом.
Часть объектов обработана успешно, часть с ошибкой.
</member>
        <member name="F:Success">
Успешное выполнение метода. Отсутствие ошибок

Безошибочная генерация
</member>
        <member name="D:RGK.Common.String.utf8_wstring_convert">
Конвертер между utf-8 и utf-16/32 (wchar_t).
</member>
        <member name="D:RGK.Common.String.codecvt_utf8">
Правило преобразования между utf-8 и внутренним представлением String
</member>
        <member name="M:RGK.Common.String.op_Implicit~std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;">
Преобразование в wchar_t-строку
<returns>Строка в формате wchar_t</returns></member>
        <member name="M:RGK.Common.String.op_Implicit~std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;">
Преобразование в UTF-8 строку
<returns>Строка в формате UTF-8 </returns></member>
        <member name="M:RGK.Common.String.#ctor(std.basic_string&lt;System.Char,std.char_traits{System.Char},std.allocator&lt;System.Char&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор. Создание из wchar_t-строки
<param name="str">Исходная строка в формате wchar_t для создания копии</param></member>
        <member name="M:RGK.Common.String.#ctor(System.Char!System.Runtime.CompilerServices.IsConst*)">
Конструктор. Создание из wchar_t-строки
<param name="str">Исходная строка в формате wchar_t для создания копии</param>
Преобразование массива символов в строку
</member>
        <member name="M:RGK.Common.String.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор. Создание из UTF-8 строки
<param name="str">Исходная строка в формате UTF-8 для создания копии</param></member>
        <member name="M:RGK.Common.String.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Конструктор. Создание из UTF-8 строки
<param name="str">Исходная строка в формате UTF-8 для создания копии</param></member>
        <member name="M:RGK.Common.String.#ctor(RGK.Common.String!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Конструктор. Создаёт копию
<param name="iSource">Исходная строка для создания копии</param></member>
        <member name="M:RGK.Common.String.#ctor">
Конструктор. Создаёт пустую строку
</member>
        <member name="T:RGK.Common.String">
            <remarks>Если класс объявить как DLLEXPORT и поместить реализацию в cpp-файл,
то возникает проблема, описанная здесь:
http://social.msdn.microsoft.com/Forums/en/vclanguage/thread/191de00a-53c9-4bd9-9cb6-e844eb224ca2
Поэтому String сделан inline-классом.
Но в этом случае код для методов String будет сгенерирован в разных модулях.
Чтобы избежать связанных с этим LNK4217 и LNK4049 в MSVC, нужно включить Function-level linking опцией /Gy.
</remarks>
Класс для представления текстовых строк
</member>
        <member name="P:TFlex.Model.Model2D.Area.OutlineColor">
            <summary>Цвет линий обводки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.OutlinePatternName">
            <summary>Имя образца штриховой линии обводки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.OutlinePatternScale">
            <summary>Масштаб штрихов линий обводки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.Width">
            <summary>Толщина линий обводки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.OutlineWidth">
            <summary>Толщина линий обводки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.Outline">
            <summary>Наличие обводки у контуров штриховки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.ApplyContours">
            <summary>Подтвердить создание автоматически найденных контуров</summary>
            <returns>true, если создан хотя бы один контур</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.FindContour(System.Double,System.Double,TFlex.Model.Model2D.FindAreaContourOptions)">
            <summary>Автоматический поиск контуров штриховки по точке.</summary>
            <remarks>Последовательность вызовов данной функции должна
завершаться вызовом функции ApplyContours</remarks>
            <param name="x">Координата X точки поиска</param>
            <param name="y">Координата Y точки поиска</param>
            <param name="options">Опции поиска контуров</param>
            <returns>true, если найден хотя бы один контур</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.FindContour(System.Double,System.Double)">
            <summary>Автоматический поиск контуров штриховки по точке.</summary>
            <remarks>Последовательность вызовов данной функции должна
завершаться вызовом функции ApplyContours</remarks>
            <param name="x">Координата X точки поиска</param>
            <param name="y">Координата Y точки поиска</param>
            <returns>true, если найден хотя бы один контур</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.PatternAngle">
            <summary>Угол штриховки по образцу</summary>
            <remarks>Данный метод выполняет указанное действие только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Pattern</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.PatternScale">
            <summary>Значение масштаба штриховки по образцу</summary>
            <remarks>Данный метод выполняет указанное действие только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Pattern</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.PatternName">
            <summary>Имя штриховки по образцу</summary>
            <remarks>Данный метод выполняет указанное действие только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Pattern</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.Circular">
            <summary>Параметр "Круговая штриховка"</summary>
            <remarks>Данный метод выполняет указанное действие только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Hatch.</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.LineWidth">
            <summary>Толщина линии</summary>
            <remarks>Данный метод выполняет указанное действие только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Hatch
или <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Pattern.</remarks>
            <example>
                <code name="Установка толщины линии">
public static void SetLineWidth(ModelObject ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка толщины линии");//Открытие блока изменений документа

   ob.LineWidth = 3;	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.EraseBackground">
            <summary>Параметр "невидимые линии" (очистка фона)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.HatchStep2">
            <summary>Второй шаг штриховки контура</summary>
            <remarks>Данный метод выполняет указанное действие только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Hatch</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.HatchStep1">
            <summary>Первый шаг штриховки контура</summary>
            <remarks>Данный метод выполняет указанное действие только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Hatch</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.HatchAngle2">
            <summary>Второй угол штриховки контура</summary>
            <remarks>Данное свойство имеет смысл только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Hatch</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.HatchAngle1">
            <summary>Первый угол штриховки контура</summary>
            <remarks>Данное свойство имеет смысл только в случае, 
если способ заполнения контура имеет значение <see cref="T:TFlex.Model.Model2D.AreaFillStyle" />.Hatch</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.FillStyle">
            <summary>Способ заполнения контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.DeleteAllContours">
            <summary>Удаление всех контуров</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.DeleteContour(System.Int32)">
            <summary>Удаление контура по указанному индексу</summary>
            <param name="index">Индекс (номер) контура</param>
            <summary>Удаление контура по указанному индексу</summary>
            <param name="index">Индекс (номер) контура</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.InsertContour(System.Int32)">
            <summary>Вставка контура по указанному индексу</summary>
            <param name="index">Индекс (номер) контура</param>
            <returns>Вставляемый контур</returns>
            <param name="index">Индекс (номер) контура</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.AppendContour">
            <summary>Добавление контура</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.GetContour(System.Int32)">
            <summary>Получение контура по указанному индексу</summary>
            <param name="index">Индекс (номер) контура</param>
            <returns>Контур с указанным индексом</returns>
            <summary>Получение контура по указанному индексу</summary>
            <param name="index">Индекс (номер) контура</param>
            <returns>Контур с указанным индексом</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.ContourCount">
            <summary>Количество контуров штриховки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Area.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.MakeCopy(TFlex.Model.Document,System.Double,System.Double,System.Double,System.Double,System.Boolean)">
            <summary>Создает копию штриховки в другом документе.</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Area.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Area">
            <summary>Область штриховки/заливки</summary>
            <example>
                <code name="Штриховка">
public static void Area()//Штриховка
{
   Document document = TFlex.Application.ActiveDocument; 
   document.BeginChanges("Штриховка");//Открытие блока изменений документа	
	
   Area area = new Area(document);
   area.FillStyle = AreaFillStyle.Fill;
   area.Color = 2;
                            
   Contour contour = area.AppendContour();//контур штриховки
   //добавление сегментов в контур
   ConstructionContourSegment s1 = new ConstructionContourSegment(contour); 
   s1.StartNode = new FreeNode(document, 75, 660);
   s1.EndNode = new FreeNode(document, 125, 660);
			
   ConstructionContourSegment s2 = new ConstructionContourSegment(contour); 
   s2.StartNode = new FreeNode(document, 125, 660);
   s2.EndNode = new FreeNode(document, 125, 630);

   ConstructionContourSegment s3 = new ConstructionContourSegment(contour); 
   s3.StartNode = new FreeNode(document, 125, 630);
   s3.EndNode = new FreeNode(document, 75, 630);

   FreeNode fn1 = new FreeNode(document, 75, 660);			
   FreeNode fn2 = new FreeNode(document, 75, 630);
   double r = 20;	
   //дуга окружности, проходящая через два узла с заданным радиусом
   TwoPointArcOutline twoPointArcOutline = new TwoPointArcOutline(document, fn1, fn2, r);

   OutlineContourSegment s4 = new OutlineContourSegment(contour);
   s4.Outline = twoPointArcOutline;

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.IcludeWawesElement">
            <summary>Включить в элементы для анализа волнистые линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.IcludeArrowElement">
            <summary>Включить в элементы для анализа линии со стрелками</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.IcludeAxisElement">
            <summary>Включить в элементы для анализа осевые линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.IcludeDashedElement">
            <summary>Включить в элементы для анализа штриховые линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.IcludeThinElement">
            <summary>Включить в элементы для анализа тонкие линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.IcludeThickElement">
            <summary>Включить в элементы для анализа основные линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.OnlyFragmentElement">
            <summary>Поиск только среди элементов фрагментов</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.OnlyVisibleElement">
            <summary>Поиск только среди видимых элементов</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.Islands">
            <summary>Автоматический поиск островов(внутренних контуров)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.OuterBound">
            <summary>Искать внешние контуры</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FindAreaContourOptions.Tolerance">
            <summary>Точность</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FindAreaContourOptions">
            <summary>Опции поиска контуров</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.AreaFillStyle">
            <summary>Способ заполниения области штриховки/заливки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AreaFillStyle.Fill">
            <summary>Сплошная заливка</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AreaFillStyle.Pattern">
            <summary>Штриховка по образцу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AreaFillStyle.Hatch">
            <summary>Штриховка под углом (круговая)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AreaFillStyle.Profile">
            <summary>Не заполнена</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Contour.DeleteAllSegments">
            <summary>Удаление всех сегментов контура</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Contour.DeleteSegment(System.Int32)">
            <summary>Удаление сегмента контура по указанному индексу</summary>
            <param name="index">Индекс (номер) сегмента</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Contour.GetSegment(System.Int32)">
            <summary>Получение сегмента контура по указанному индексу</summary>
            <param name="index">Индекс (номер) сегмента</param>
            <returns>Сегмент контура с указанным индексом</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.Contour.SegmentCount">
            <summary>Количество сегментов контура штриховки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Contour.GetEnumerator">
            <summary>Получить перечилитель</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Contour">
            <summary>Контур штриховки/заливки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlineContourSegment.Direction">
            <summary>Направление сегмента контура</summary>
            <remarks>True если сегмент контура направлен по положительному направлению 
линии изображения, false в противном случае</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlineContourSegment.EndIntersectionNumber">
            <summary>Номер пересечения в конце сегмента контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlineContourSegment.EndIntersectionOutline">
            <summary>Линия изображения, задающая конец сегмента контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlineContourSegment.StartIntersectionNumber">
            <summary>Номер пересечения в начале сегмента контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlineContourSegment.StartIntersectionOutline">
            <summary>Линия изображения, задающая начало сегмента контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlineContourSegment.Outline">
            <summary>Исходная линия изображения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.OutlineContourSegment.#ctor(TFlex.Model.Model2D.Contour,System.Int32)">
            <summary>Конструктор, вставляющий сегмент в контур по указанному индексу</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
            <param name="index">Номер сегмента, перед которым необходимо вставить данный сегмент</param>
        </member>
        <member name="M:TFlex.Model.Model2D.OutlineContourSegment.#ctor(TFlex.Model.Model2D.Contour)">
            <summary>Конструктор, добавляющий сегмент в конец контура</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
        </member>
        <member name="T:TFlex.Model.Model2D.OutlineContourSegment">
            <summary>Сегмент контура штриховки/заливки, созданный на основе линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionContourSegment.Direction">
            <summary>Направление сегмента контура</summary>
            <remarks>Параметр имеет смысл только в случае если заданы
одновременно два узла и линия построения. Если любой из элементов не задан,
то параметр имеет значение true.</remarks>
            <returns>true если сегмент контура направлен по положительному
направлению линии построения, false в противном случае</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionContourSegment.Construction">
            <summary>Линия построения, задающая сегмент контура или 0 если линия построения не задана</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionContourSegment.EndNode">
            <summary>Конечный узел сегмента контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionContourSegment.StartNode">
            <summary>Начальный узел или 0 если узел не задан</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionContourSegment.#ctor(TFlex.Model.Model2D.Contour,System.Int32)">
            <summary>Конструктор, вставляющий сегмент в контур по указанному индексу</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
            <param name="index">Номер сегмента, перед которым необходимо вставить данный сегмент</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionContourSegment.#ctor(TFlex.Model.Model2D.Contour)">
            <summary>Конструктор, добавляющий сегмент в конец контура</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
        </member>
        <member name="T:TFlex.Model.Model2D.ConstructionContourSegment">
            <summary>Сегмент контура штриховки/заливки, созданный на основе линии построения и/или узлов</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleContourSegment.#ctor(TFlex.Model.Model2D.Contour)">
            <summary>Конструктор, добавляющий сегмент в конец контура</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
        </member>
        <member name="T:TFlex.Model.Model2D.CircleContourSegment">
            <summary>Сегмент контура штриховки, являющийся окружностью.</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.PolylineContourSegment.#ctor(TFlex.Model.Model2D.Contour,System.Int32)">
            <summary>Конструктор, вставляющий сегмент в контур по указанному индексу</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
            <param name="index">Номер сегмента, перед которым необходимо вставить данный сегмент</param>
        </member>
        <member name="M:TFlex.Model.Model2D.PolylineContourSegment.#ctor(TFlex.Model.Model2D.Contour)">
            <summary>Конструктор, добавляющий сегмент в конец контура</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
        </member>
        <member name="T:TFlex.Model.Model2D.PolylineContourSegment">
            <summary>Сегмент контура штриховки, являющийся полилинией.</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LineContourSegment.#ctor(TFlex.Model.Model2D.Contour,System.Int32)">
            <summary>Конструктор, вставляющий сегмент в контур по указанному индексу</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
            <param name="index">Номер сегмента, перед которым необходимо вставить данный сегмент</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineContourSegment.#ctor(TFlex.Model.Model2D.Contour)">
            <summary>Конструктор, добавляющий сегмент в конец контура</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
        </member>
        <member name="T:TFlex.Model.Model2D.LineContourSegment">
            <summary>Сегмент контура штриховки, являющийся отрезком.</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ArcContourSegment.#ctor(TFlex.Model.Model2D.Contour,System.Int32)">
            <summary>Конструктор, вставляющий сегмент в контур по указанному индексу</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
            <param name="index">Номер сегмента, перед которым необходимо вставить данный сегмент</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ArcContourSegment.#ctor(TFlex.Model.Model2D.Contour)">
            <summary>Конструктор, добавляющий сегмент в конец контура</summary>
            <param name="source">Контур, к которому добавляется сегмент</param>
        </member>
        <member name="T:TFlex.Model.Model2D.ArcContourSegment">
            <summary>Сегмент контура штриховки, являющийся дугой.</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ContourSegment.m_Contour">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ContourSegment.m_Handle">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ContourSegment.IsCounterclockwise">
            <summary>Направление сегмента контура против часовой стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ContourSegment.Geometry">
            <summary>Геометрия сегмента контура</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ContourSegment.GeometryType">
            <summary>Тип геометрии сегмента контура</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ContourSegment">
            <summary>Сегмент контура штриховки/заливки</summary>
        </member>
        <member name="M:DrawDimUtils.Transform(TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFM.SSE.Matrix3d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Трансформировать точку </summary>
            <param name="ioPoint"> Точка, к которой применяются преобразования </param>
            <param name="iMap"> Карта преобразований</param>
        </member>
        <member name="M:DrawDimUtils.AsPoint(TFM.SSE.Vector2d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить TF2D::Point как TFPoint </summary>
            <param name="iPoint"> Конвертируемая точка типа TF2D::Point </param>
            <returns> Сконвертированная точка типа TFPoint </returns>
        </member>
        <member name="M:AbstractOrientedDrawData.IsOrientationChanged">
            <summary> Проверка, изменилась ли ориентация </summary>
            <returns> true - если ориентация изменилась, false - иначе </returns>
        </member>
        <member name="M:BaseConstructManager.OnTooltipListSelection(CTFView*,SelectableObject*,System.Int64)">
            <summary> Обработка выбора объекта из выпадающего списка (CTFTooltipCtrl) </summary>
            <remarks> Если здесь событие не обрабатывается, то посылаются TFE_LBUTTONDOWN и TFE_LBUTTONUP </remarks>
            <param name="view"> Указатель на активный вид </param>
            <param name="selectedObject"> Выбранный из списка объект </param>
            <param name="tf_param"> Входящие параметры </param>
            <returns> true - если обработал событие, false - иначе </returns>
        </member>
        <member name="M:mnp3d.IApiManip.BaseCreateElems">
virtual void BaseCreateParts() = 0;
</member>
        <member name="P:TFlex.Command.Automenu.default(System.Int32)">
            <summary>Получить кнопку по номеру</summary>
        </member>
        <member name="P:TFlex.Command.Automenu.Count">
            <summary>Количество кнопок</summary>
        </member>
        <member name="M:TFlex.Command.Automenu.#ctor(TFlex.Command.Button[])">
            <summary>Конструктор</summary>
            <param name="buttonArray">Массив кнопок автоменю</param>
        </member>
        <member name="T:TFlex.Command.Automenu">
            <summary>Класс автоменю</summary>
        </member>
        <member name="M:TFlex.Command.GroupButton.#ctor(System.String,TFlex.Command.Button[],System.Int32)">
            <summary>Конструктор</summary>
            <param name="groupName">Название кнопки</param>
            <param name="buttonArray">Массив команд</param>
            <param name="active">Индекс активной команды</param>
        </member>
        <member name="M:TFlex.Command.GroupButton.#ctor(System.String,TFlex.Command.Button[])">
            <summary>Конструктор</summary>
            <param name="groupName">Название кнопки</param>
            <param name="buttonArray">Массив команд</param>
        </member>
        <member name="T:TFlex.Command.GroupButton">
            <summary>Кнопка с вложенным списком команд</summary>
        </member>
        <member name="M:TFlex.Command.SeparatorButton.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Command.SeparatorButton">
            <summary>Разделитель кнопок в автоменю</summary>
        </member>
        <member name="M:TFlex.Command.CustomButton.#ctor(System.Int32,TFlex.KeyCode,System.String,TFlex.Command.Button.Style)">
            <summary>Конструктор</summary>
            <param name="nIcon">Идентификатор команды автоменю, под которым приложение зарегестрировало эту команду</param>
            <param name="keyCode">Код клавиатуры</param>
            <param name="title">Комментарии</param>
            <param name="style">Состояние кнопки</param>
        </member>
        <member name="M:TFlex.Command.CustomButton.#ctor(System.Int32,TFlex.KeyCode,System.String)">
            <summary>Конструктор</summary>
            <param name="nIcon">Идентификатор команды автоменю, под которым приложение зарегестрировало эту команду</param>
            <param name="keyCode">Код клавиатуры</param>
            <param name="title">Комментарии, отображающиеся при наведении курсора мыши на кнопку</param>
        </member>
        <member name="T:TFlex.Command.CustomButton">
            <summary>Кнопка с иконкой</summary>
        </member>
        <member name="M:TFlex.Command.SingleButton.#ctor(System.Int32,TFlex.KeyCode,TFlex.Command.Button.Style)">
            <summary>Конструктор</summary>
            <param name="CmdID">Идентификатор команды, которая будет выполнятся при нажатии на кнопку</param>
            <param name="keyCode">Код клавиатуры</param>
            <param name="style">Состояние одиночной кнопки</param>
        </member>
        <member name="T:TFlex.Command.SingleButton">
            <summary>Одиночная кнопка</summary>
        </member>
        <member name="M:TFlex.Command.DefaultButton.GetDefaultKey(TFlex.Command.DefaultButton.Kind)">
            <summary>Получить код клавиатуры для заданного типа кнопки</summary>
            <param name="kind">Тип кнопки</param>
        </member>
        <member name="M:TFlex.Command.DefaultButton.#ctor(TFlex.Command.DefaultButton.Kind,TFlex.Command.Button.Style)">
            <summary>Конструктор</summary>
            <param name="kind">Тип стандартной кнопки</param>
            <param name="style">Состояние стандартной кнопки</param>
        </member>
        <member name="M:TFlex.Command.DefaultButton.#ctor(TFlex.Command.DefaultButton.Kind,TFlex.KeyCode,TFlex.Command.Button.Style)">
            <summary>Конструктор</summary>
            <param name="kind">Тип стандартной кнопки</param>
            <param name="keyCode">Код клавиатуры</param>
            <param name="style">Состояние стандартной кнопки</param>
        </member>
        <member name="M:TFlex.Command.DefaultButton.#ctor(TFlex.Command.DefaultButton.Kind,TFlex.KeyCode)">
            <summary>Конструктор</summary>
            <param name="kind">Тип стандартной кнопки</param>
            <param name="keyCode">Код клавиатуры</param>
        </member>
        <member name="M:TFlex.Command.DefaultButton.#ctor(TFlex.Command.DefaultButton.Kind)">
            <summary>Конструктор по умолчанию</summary>
            <param name="kind">Тип стандартной кнопки</param>
        </member>
        <member name="F:TFlex.Command.DefaultButton.Kind.Parameters">
            <summary>Кнопка вызова диалога параметров</summary>
        </member>
        <member name="F:TFlex.Command.DefaultButton.Kind.Exit">
            <summary>Кнопка выхода из команды</summary>
        </member>
        <member name="F:TFlex.Command.DefaultButton.Kind.Cancel">
            <summary>Кнопка отмены команды</summary>
        </member>
        <member name="F:TFlex.Command.DefaultButton.Kind.OK">
            <summary>Кнопка принятия команды</summary>
        </member>
        <member name="T:TFlex.Command.DefaultButton.Kind">
            <summary>Перечислитель стандартных кнопок</summary>
        </member>
        <member name="T:TFlex.Command.DefaultButton">
            <summary>Стандартная кнопка</summary>
        </member>
        <member name="M:TFlex.Command.Button.StyleToInt(TFlex.Command.Button.Style)">
            <summary>Получить число соответствующее состоянию кнопки</summary>
            <param name="inStyle">Состояние кнопки</param>
        </member>
        <member name="F:TFlex.Command.Button.Style.Wait">
            <summary>Ожидание выбора объекта. Кнопка остается нажатой до выбора объекта</summary>
        </member>
        <member name="F:TFlex.Command.Button.Style.Checked">
            <summary>Нажата</summary>
        </member>
        <member name="F:TFlex.Command.Button.Style.Disabled">
            <summary>Недоступна</summary>
        </member>
        <member name="F:TFlex.Command.Button.Style.Default">
            <summary>Не нажата</summary>
        </member>
        <member name="T:TFlex.Command.Button.Style">
            <summary>Состояние кнопки</summary>
        </member>
        <member name="T:TFlex.Command.Button">
            <summary>Класс кнопки</summary>
        </member>
        <member name="M:tbb.interface8.internal.x86_rtm_rw_mutex.scoped_lock.try_acquire(tbb.interface8.internal.x86_rtm_rw_mutex*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
returns true if successful.  
</member>
        <member name="M:tbb.interface8.internal.x86_rtm_rw_mutex.scoped_lock.downgrade_to_reader">
Returns whether the downgrade happened without releasing and re-acquiring the lock 
</member>
        <member name="M:tbb.interface8.internal.x86_rtm_rw_mutex.scoped_lock.upgrade_to_writer">
Returns whether the upgrade happened without releasing and re-acquiring the lock 
</member>
        <member name="M:tbb.interface8.internal.x86_rtm_rw_mutex.scoped_lock.#ctor">
Equivalent to zero-initialization of *this. 
</member>
        <member name="T:tbb.interface8.internal.x86_rtm_rw_mutex.scoped_lock">
It helps to avoid the common problem of forgetting to release lock.
        It also nicely provides the "node" for queuing locks. 
</member>
        <member name="T:tbb.interface8.internal.x86_rtm_rw_mutex">
@ingroup synchronization 
</member>
        <member name="F:tbb.internal.atomic_backoff.LOOPS_BEFORE_YIELD">
Should be equal to approximately the number of "pause" instructions
        that take the same time as an context switch. Must be a power of two.
</member>
        <member name="T:tbb.internal.atomic_backoff">
See implementation of spin_wait_while_eq for an example. 
</member>
        <member name="T:tbb.proportional_split">
In order to make use of such facility Range objects must implement
splitting constructor with this type passed and initialize static
constant boolean field 'is_splittable_in_proportion' with the value
of 'true'

</member>
        <member name="T:tbb.split">
See description of parallel_for and parallel_reduce for example usages.
@ingroup algorithms

</member>
        <member name="T:tbb.internal.version_tag_v3">
Version tag can be necessary to prevent loader on Linux from using the wrong
    symbol in debug builds (when inline functions are compiled as out-of-line). *
</member>
        <member name="M:tbb.internal.handle_perror(System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
The standard offsetof macro is not sufficient for TBB as it can be used for
    POD-types only. The constant 0x1000 (not NULL) is necessary to appease GCC. *
</member>
        <member name="M:tbb.TBB_runtime_interface_version">
The version it returns is determined at runtime, not at compile/link time.
So it can be different than the value of TBB_INTERFACE_VERSION obtained at compile time.

</member>
        <member name="M:tbb.assertion_failure(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Int32,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
Normally called from __TBB_ASSERT macro.
        If assertion handler is null, print message for assertion failure and abort.
        Otherwise call the assertion handler. 
</member>
        <member name="P:TFlex.PickPointResult.SelectedObject">
            <summary>Объект документа, который был выбран в процессе ввода точки</summary>
            <remarks>При нулевом значении данного свойства пользователь просто указал точку</remarks>
        </member>
        <member name="P:TFlex.PickPointResult.View">
            <summary>Вид документа, в котором был произведён ввод точки</summary>
        </member>
        <member name="P:TFlex.PickPointResult.Key">
            <summary>Код клавиши, которая была нажата пользователем</summary>
            <remarks>В случае нажатия левой кнопки мыши возвращается KeyKode.keyENTER.
В случае нажатия правой кнопки мыши возвращается KeyKode.keyESCAPE. В последнем случае метод
IsOK возвращает false.</remarks>
        </member>
        <member name="P:TFlex.PickPointResult.PaperPoint">
            <summary>Выбранная точка в системе координат бумаги, без учёта масштаба текущей страницы</summary>
            <remarks>Данный параметр имеет смысл только в случае выбора точки в 2D виде или в 3D виде в режиме
активизации страницы рабочей плоскости.</remarks>
        </member>
        <member name="P:TFlex.PickPointResult.ModelPoint">
            <summary>Выбранная точка в системе координат модели, с учётом масштаба текущей страницы</summary>
            <remarks> Данный параметр имеет смысл только в случае выбора точки в 2D виде или в 3D виде в режиме
активизации страницы рабочей плоскости.</remarks>
        </member>
        <member name="P:TFlex.PickPointResult.Point">
            <summary>Выбранная точка</summary>
        </member>
        <member name="P:TFlex.PickPointResult.Y">
            <summary>Координата Y выбранной точки</summary>
        </member>
        <member name="P:TFlex.PickPointResult.X">
            <summary>Координата X выбранной точки</summary>
        </member>
        <member name="P:TFlex.PickPointResult.IsOK">
            <summary>Признак успешного завершения выбора точки или объекта. Если данный параметр равен false,
то макрос или команда, вызвавшая метод PickPoint должен завершить работу.
Иначе возможны сбои в работе системы.</summary>
        </member>
        <member name="T:TFlex.PickPointResult">
            <summary>Выходные параметры метода PickPoint</summary>
        </member>
        <member name="E:TFlex.PickPointParameters.MouseMove">
            <summary>Cобытие перемещения мыши при вызове метода PickPoint</summary>
        </member>
        <member name="P:TFlex.PickPointParameters.CanCreateNode">
            <summary>Признак того, что в процессе выбора элементов модели возможно создание новых узлов</summary>
        </member>
        <member name="P:TFlex.PickPointParameters.Filter">
            <summary>Фильтр, позволяющий в процессе выбора точки выбирать также элементы модели</summary>
        </member>
        <member name="P:TFlex.PickPointParameters.Prompt">
            <summary>Подсказка, которая появится в статусной строке. В случае, если подсказка не задана, она останется без изменений</summary>
        </member>
        <member name="P:TFlex.PickPointParameters.Automenu">
            <summary>Автоменю, которое будет выведено на экран в процессе выбора точки</summary>
        </member>
        <member name="T:TFlex.PickPointParameters">
            <summary>Входные параметры метода PickPoint</summary>
        </member>
        <member name="T:TFlex.PickPointMouseMove">
            <summary>Делегат представляющий метод, который будет обрабатывать событие перемещения мыши при вызове метода PickPoint</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы собятия</param>
        </member>
        <member name="P:TFlex.PickPointEventArgs.View">
            <summary>Вид (окно) в котором был произведён выбор точки</summary>
        </member>
        <member name="P:TFlex.PickPointEventArgs.y">
            <summary>Значение координаты Y в целочисленных координатах окна</summary>
        </member>
        <member name="P:TFlex.PickPointEventArgs.x">
            <summary>Значение координаты X в целочисленных координатах окна</summary>
        </member>
        <member name="T:TFlex.PickPointEventArgs">
            <summary>Класс, содержащий параметры вызова метода PickPoint</summary>
        </member>
        <member name="P:TFlex.Command.CommandUI.Document">
            <summary>Получить документ, который для данной команды является активным</summary>
            <remarks>Может быть 0, если ни один документ не открыт</remarks>
        </member>
        <member name="P:TFlex.Command.CommandUI.ID">
            <summary>Получить идентификатор команды</summary>
        </member>
        <member name="M:TFlex.Command.CommandUI.SetText(System.String)">
            <summary>Установить название команды</summary>
            <param name="name">Название команды</param>
        </member>
        <member name="M:TFlex.Command.CommandUI.SetRadio(System.Boolean)">
            <summary>Установить состояние "Включено" или "Выключено" в режиме переключателя в зависимости от значения параметра fSet</summary>
            <param name="fSet">Установить состояние "Включено" или "Выключено"</param>
        </member>
        <member name="M:TFlex.Command.CommandUI.SetRadio">
            <summary>Установить состояние "Включено" в режиме переключателя для данной команды</summary>
        </member>
        <member name="M:TFlex.Command.CommandUI.SetCheck(System.Boolean)">
            <summary>Установить состояние "Включено" для данной команды</summary>
            <param name="fSet">Установить состояние "Включено" или "Выключено"</param>
        </member>
        <member name="M:TFlex.Command.CommandUI.SetCheck">
            <summary>Установить состояние "Включено" для данной команды</summary>
        </member>
        <member name="M:TFlex.Command.CommandUI.Enable(System.Boolean)">
            <summary>Разрешить выполнение данной команды</summary>
            <param name="fEnable">Разрешить или запретить выполнение команды</param>
        </member>
        <member name="M:TFlex.Command.CommandUI.Enable">
            <summary>Разрешить выполнение данной команды</summary>
        </member>
        <member name="T:TFlex.Command.CommandUI">
            <summary>Данный класс является вспомогательным классом, 
обеспечивающим разрешение или блокировку выполнения команды, 
а также установку переключателя команды в режим "включено" или "выключено".</summary>
        </member>
        <member name="M:TFlexXML.TFXMLDocument.LoadXml(std.basic_string_view&lt;System.Char,std.char_traits{System.Char}&gt;)">
            <summary>Loads an XML document using the supplied string.</summary>
            <param name="strXML">A string containing the XML string to load into this XML document object. This string can contain an entire XML document or a well-formed fragment.</param>
            <returns>Boolean. Returns True if the XML load succeeded. Returns False and sets the documentElement property of the DOMDocument to Null if the XML load failed.</returns>
        </member>
        <member name="P:TFlex.Model.Weld.Length">
            <summary>Длина сварного шва</summary>
        </member>
        <member name="P:TFlex.Model.Weld.WeldType">
            <summary>Тип сварного шва</summary>
        </member>
        <member name="P:TFlex.Model.Weld.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Weld.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
            <param name="doc">Документ сварного шва</param>
        </member>
        <member name="T:TFlex.Model.Weld">
            <summary>Класс сварного шва</summary>
        </member>
        <member name="P:TFlex.Model.WeldType.Number">
            <summary>Номер типа сварного шва</summary>
        </member>
        <member name="P:TFlex.Model.WeldType.Caption">
            <summary>Обозначение сварного шва</summary>
        </member>
        <member name="P:TFlex.Model.WeldType.Standard">
            <summary>Стандарт сварного шва</summary>
        </member>
        <member name="P:TFlex.Model.WeldType.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.WeldType.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
            <param name="doc">Документ типа сварного шва</param>
        </member>
        <member name="T:TFlex.Model.WeldType">
            <summary>Класс типа сварного шва</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectKnotList.ArrowheadHeight">
            <summary>Высота стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectKnotList.ArrowheadWidth">
            <summary>Ширина стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectKnotList.ArrowheadSize">
            <summary>Размер стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectKnotList.ArrowheadType">
            <summary>Тип наконечника стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectKnotList.SignType">
            <summary>Тип знака на линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectKnotList.TextUnderTheLine">
            <summary>Текст под линией</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectKnotList.TextAboveTheLine">
            <summary>Текст над линией</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ObjectKnotList.IsUsingSizeParameter">
            <summary>Проверка на использование параметра размера наконечника стрелки или параметров ширины и высоты наконечника стрелки</summary>
            <returns>true - если в данный момент используется параметр размера наконечника стрелки. false - иначе (используются параметры ширины и высоты)</returns>
        </member>
        <member name="T:TFlex.Model.Model2D.ObjectKnotList">
            <summary>Список узлов объекта</summary>
        </member>
        <member name="M:CTfw32Doc.GetUndoManager(System.Boolean)">
            <summary> Получить Undo-менеджер </summary>
            <param name="createIfNone"> Флаг того, что если менеджер не создан, то нужно ли его создавать (true - нужно, false - нет) </param>
            <returns> Указатель на Undo-менеджер документа, или nullptr в случае, если данный документ не может управлять Undo (IsFragment() == true) </returns>
        </member>
        <member name="M:CTfw32Doc.IsObjectIncludedInCurrentChanges(CTFObject!System.Runtime.CompilerServices.IsConst*)">
            <summary> Проверяет, зарегистрирован ли объект в текущем изменении документа (в текущем Undo-блоке) </summary>
            <param name="object"> Указатель на объект </param>
            <returns> true - если объект зарегистрирован в текущем изменении, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectReplacement(CTFObject*,CTFObject*)">
            <summary> Зарегистрировать замену объекта в документе на новый объект </summary>
            <remarks>
Ответственность за удаление заменяющего объекта передаётся документу.
В случае неудачи (например, если Undo-блок не открыт или данный документ не может изменяться) - удаляет заменяющий объект сразу.
Сценарий использования: 
1. Создаём заменяющий объект в куче.
2. Находим в документе объект, который хотим заменить.
3. Передаём указатели на заменяемый и заменяющий объекты в данный метод.
</remarks>
            <param name="objectInDoc"> Указатель на заменяемый объект в документе (НЕ КОПИЯ) </param>
            <param name="newObject"> Указатель на заменяющий объект в куче </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectForChange(CTFObject*)">
            <summary> Зарегистрировать объект в документе и Undo-блоке для дальнейшего изменения </summary>
            <remarks>
Сценарий использования: 
1. Находим в документе объект, который хотим отредактирвоать.
2. Передаём указатель на него в данный метод.
3. В случае успеха - изменяем объект по тому же указателю.
</remarks>
            <param name="objectInDoc"> Указатель на объект в документе (НЕ КОПИЯ) </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectDeletion(System.UInt32,CTFObject**,System.UInt32)">
            <summary> Зарегистрировать удаление объекта в документе и Undo-блоке </summary>
            <remarks>
Удаляет объект из документа, если открыт Undo-блок.
Сценарий использования: 
1. Находим в документе объект, который хотим удалить.
2. Передаём указатель на него в данный метод.
</remarks>
            <param name="objectInDoc"> Указатель на удаляемый объект в документе </param>
            <param name="flags"> Параметры удаления объекта </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectCreationWithCopy(CTFObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Зарегистрировать создание объекта в документе и Undo-блоке </summary>
            <remarks>
Делает копию созданного на стеке объекта.
Сценарий использования: 
1. Создаём объект в стеке.
2. Передаём его в данный метод.
3. В случае успеха можем изменять объект по указателю, который вернул данный метод.
</remarks>
            <param name="objectOnStack"> Cозданный на стеке объект </param>
            <returns> Указатель на объект в документе - в случае успеха, nullptr - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectCreation(CTFObject*)">
            <summary> Зарегистрировать создание объекта в документе и Undo-блоке </summary>
            <remarks>
Ответственность за удаление созданного объекта передаётся документу.
В случае неудачи (например, если Undo-блок не открыт или данный документ не может изменяться) - удаляет созданный объект сразу.
Сценарий использования: 
1. Создаём объект в куче.
2. Передаём указатель на него в данный метод.
3. В случае успеха можем изменять объект по тому же указателю.
</remarks>
            <param name="objectOnHeap"> Указатель на созданный объект в куче </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.IsChanging">
            <summary> Изменяется ли документ в данный момент (открыт ли Undo-блок) </summary>
            <returns> true - документ изменяется, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.CancelChanges(System.Boolean)">
            <summary> Отменить текущие изменения документа и закрыть Undo-блок </summary>
            <remarks>
Отменяет изменения только если открыт Undo-блок. Если Undo-блок вложенный - изменения не отменяет, но закрывает вложенный блок.
Недопустимо нарушение парности вызовов BeginChanges() и EndChanges() или CancelChanges(). Для удобства можно использовать RAII класс UndoBlock.
</remarks>
            <param name="regenerate"> true - выполнить пересчёт документа </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.EndChanges(System.Boolean,System.Boolean)">
            <summary> Закончить изменение документа с регистрацией в Undo </summary>
            <remarks>
Здесь регистрируется блок Undo, после его регистрации уже нельзя воспользоваться методом CancelChanges().
Недопустимо нарушение парности вызовов BeginChanges() и EndChanges() или CancelChanges(). Для удобства можно использовать RAII класс UndoBlock.
</remarks>
            <param name="regenerate"> true - выполнить пересчёт документа </param>
            <param name="merge"> Объединить текущий Undo-блок с верхним Undo-блоком </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.BeginChanges(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Начать изменение документа с регистрацией в undo </summary>
            <remarks>
Блоки могут быть вложенными (с точки зрения вызовов BeginChanges() EndChanges() CancelChanges()).
В этом случае, при вызове последнего EndChanges() будет сформирован один общий Undo-блок, а при последнем вызове CancelChanges() будет произведена отмена всех вложенных блоков.
Недопустимо нарушение парности вызовов BeginChanges() и EndChanges() или CancelChanges(). Для удобства можно использовать RAII класс UndoBlock.
</remarks>
            <param name="undoBlockName"> Название блока undo </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RedrawViews(TFlex.FlagSet&lt;&lt;unknown type&gt;&gt;)">
            <summary> Перерисовать все виды документа </summary>
            <param name="params"> Параметры перерисовки </param>
        </member>
        <member name="T:CTfw32Doc.RedrawViewFlags">
            <summary> Параметры перерисовки видов </summary>
        </member>
        <member name="M:AllElementsOptions.EditForWhat">
Редактировать список типов родителей, которые запрашиваются
</member>
        <member name="M:AllElementsOptions.GetForWhat">
Получить список типов родителей, которые запрашиваются
</member>
        <member name="M:AllElementsOptions.IsUpdateStyleUsage">
Проверить режим обновления информации об использовании стилей
</member>
        <member name="M:AllElementsOptions.SetUpdateStyleUsage(System.Boolean)">
Установить режим обновления информации об использовании стилей
</member>
        <member name="F:STATUS._solvers">
Решатель ограничений
</member>
        <member name="D:DimensionVector">
Множество размеров
</member>
        <member name="D:SketchConstraintVector">
Множество ограничений
</member>
        <member name="D:SketchSolverVector">
Множество объектов пересчета
</member>
        <member name="T:SketchSolver">
Временный модельный объект, который используется для вычислений в дереве пересчета модели
</member>
        <member name="D:Constraints2D.EqualCurvePropertyPtr">
Разделяемая ссылка на совпадение свойств двух кривых в точке
</member>
        <member name="T:Constraints2D.EqualCurveProperty">
Совпадение свойств двух кривых в точке
</member>
        <member name="D:Constraints2D.CurvePtr">
Разделяемая ссылка на кривую
</member>
        <member name="T:Constraints2D.Curve">
Кривая
</member>
        <member name="D:Constraints2D.OffsetCurvePtr">
Разделяемая ссылка на смещение
</member>
        <member name="T:Constraints2D.OffsetCurve">
Смещение
</member>
        <member name="D:Constraints2D.ParametricCurvePtr">
Разделяемая ссылка на параметрическую кривую
</member>
        <member name="D:Constraints2D.CurveLengthPtr">
Разделяемая ссылка на ограничение типа длина кривой
</member>
        <member name="T:Constraints2D.ProcessMonitorData">
Функция мониторинга процесса выполнения методов решателя с возможностью прерывания
</member>
        <member name="D:Constraints2D.RigidLinearEquationPtr">
Разделяемая ссылка на линейное уравнение

Разделяемая ссылка на линейное уравнение
</member>
        <member name="D:Constraints2D.LinearEquationPtr">
Разделяемая ссылка на линейное уравнение
</member>
        <member name="D:Constraints2D.EquationMediatorPtr">
Разделяемая ссылка на уравнение
</member>
        <member name="D:Constraints2D.EquationSet">
Множество уравнений
</member>
        <member name="D:Constraints2D.EquationPtr">
Разделяемая ссылка на уравнение
</member>
        <member name="D:Constraints2D.VariableVector">
Упорядоченное множество переменных
</member>
        <member name="D:Constraints2D.VariableSet">
Множество переменных
</member>
        <member name="D:Constraints2D.VariableMediatorVector">
Множество посредников переменных
</member>
        <member name="D:Constraints2D.VariableMediatorPtr">
Разделяемая ссылка на посредник переменной
</member>
        <member name="D:Constraints2D.VariablePtr">
Разделяемая ссылка на переменную
</member>
        <member name="D:Constraints2D.ConstraintTypeVector">
Множество типов ограничений
</member>
        <member name="T:Constraints2D.ConstraintType">
Тип ограничения
</member>
        <member name="D:Constraints2D.InstancePtr">
Разделяемая ссылка на копию
</member>
        <member name="T:Constraints2D.Instance">
Копия
</member>
        <member name="D:Constraints2D.FixParameterPtr">
Разделяемая ссылка на фиксированный параметр в ограничении
</member>
        <member name="T:Constraints2D.FixParameter">
Фиксация параметра в ограничении
</member>
        <member name="D:Constraints2D.NormalPtr">
Разделяемая ссылка на перпендикулярность касательных в точке пересечения кривых
</member>
        <member name="T:Constraints2D.Normal">
Перпендикулярность касательных в точке пересечения кривых
</member>
        <member name="D:Constraints2D.EqualDistancePtr">
Разделяемая ссылка на равенство расстояний
</member>
        <member name="T:Constraints2D.EqualDistance">
Равенство расстояний
</member>
        <member name="D:Constraints2D.MidPointPtr">
Разделяемая ссылка на среднюю точку
</member>
        <member name="T:Constraints2D.MidPoint">
Средняя точка
</member>
        <member name="D:Constraints2D.AnglePtr">
Разделяемая ссылка на угол
</member>
        <member name="T:Constraints2D.Angle">
Угол
</member>
        <member name="D:Constraints2D.ArcLengthPtr">
Разделяемая ссылка на длину дуги
</member>
        <member name="T:Constraints2D.ArcLength">
Длина дуги
</member>
        <member name="D:Constraints2D.TangentPtr">
Разделяемая ссылка на касание
</member>
        <member name="T:Constraints2D.Tangent">
Касание
</member>
        <member name="T:Constraints2D.FixType">
Фиксация геометрии
</member>
        <member name="D:Constraints2D.SymmetricPtr">
Разделяемая ссылка на симметрию
</member>
        <member name="T:Constraints2D.Symmetric">
Симметрия
</member>
        <member name="D:Constraints2D.RadiusPtr">
Разделяемая ссылка на радиус
</member>
        <member name="T:Constraints2D.Radius">
Радиус
</member>
        <member name="D:Constraints2D.EqualRadiusPtr">
Разделяемая ссылка на равные радиусы
</member>
        <member name="T:Constraints2D.EqualRadius">
Равные радиусы
</member>
        <member name="D:Constraints2D.ConcentricPtr">
Разделяемая ссылка на соосность
</member>
        <member name="T:Constraints2D.Concentric">
Соосность
</member>
        <member name="D:Constraints2D.DistancePtr">
Разделяемая ссылка на расстояние
</member>
        <member name="T:Constraints2D.Distance">
Расстояние
</member>
        <member name="D:Constraints2D.DimensionPtr">
Разделяемая ссылка на размер
</member>
        <member name="T:Constraints2D.Dimension">
Размер
</member>
        <member name="D:Constraints2D.LockGeometryVector">
Массив блокировок
</member>
        <member name="D:Constraints2D.LockGeometryPtr">
Разделяемая ссылка на блокировку
</member>
        <member name="T:Constraints2D.LockGeometry">
Блокировка
</member>
        <member name="D:Constraints2D.CoincidentPtr">
Разделяемая ссылка на совпадение
</member>
        <member name="T:Constraints2D.Coincident">
Совпадение
</member>
        <member name="D:Constraints2D.PerpendicularPtr">
Разделяемая ссылка на перпендикулярность
</member>
        <member name="T:Constraints2D.Perpendicular">
Перпендикулярность
</member>
        <member name="D:Constraints2D.ParallelPtr">
Разделяемая ссылка на параллельность
</member>
        <member name="T:Constraints2D.Parallel">
Параллельность
</member>
        <member name="D:Constraints2D.ConstraintMediatorPtr">
Разделяемая ссылка на посредника для взаимодействия ограничения с конкретным решателем
</member>
        <member name="T:Constraints2D.ConstraintMediator">
Посредник для взаимодействия ограничения с конкретным решателем
</member>
        <member name="D:Constraints2D.ConstraintVector">
Множество ограничений
</member>
        <member name="D:Constraints2D.ConstraintSet">
Множество ограничений
</member>
        <member name="D:Constraints2D.ConstraintPtr">
Разделяемая ссылка на ограничение
</member>
        <member name="T:Constraints2D.Constraint">
Базовый класс ограничения
</member>
        <member name="D:Constraints2D.PatternPtr">
Разделяемая ссылка на копирование по образцу
</member>
        <member name="D:Constraints2D.SplinePtr">
Разделяемая ссылка на сплайн
</member>
        <member name="D:Constraints2D.EllipsePtr">
Разделяемая ссылка на эллипс
</member>
        <member name="D:Constraints2D.CirclePtr">
Разделяемая ссылка на окружность
</member>
        <member name="D:Constraints2D.LinePtr">
Разделяемая ссылка на линию
</member>
        <member name="D:Constraints2D.PointVector">
Массив разделяемых ссылок на точку
</member>
        <member name="D:Constraints2D.PointPtr">
Разделяемая ссылка на точку
</member>
        <member name="T:Constraints2D.Pattern">
Копирование по образцу
</member>
        <member name="T:Constraints2D.Spline">
Сплайн
</member>
        <member name="T:Constraints2D.Ellipse">
Эллипс
</member>
        <member name="T:Constraints2D.Circle">
Окружность
</member>
        <member name="T:Constraints2D.Line">
Линия
</member>
        <member name="T:Constraints2D.Point">
Точка
</member>
        <member name="D:Constraints2D.SolverPtr">
Разделяемая ссылка на решатель системы ограничений
</member>
        <member name="T:Constraints2D.Solver">
Решатель системы ограничений
</member>
        <member name="D:Constraints2D.DimensionSystemPtr">
Разделяемая ссылка на систему ограничений
</member>
        <member name="T:Constraints2D.DimensionSystem">
Система ограничений
</member>
        <member name="D:Constraints2D.GeometryMediatorVector">
Массив разделяемых ссылок на посредников для взаимодействия геометрии с конкретным решателем
</member>
        <member name="D:Constraints2D.GeometryMediatorPtr">
Разделяемая ссылка на посредника для взаимодействия геометрии с конкретным решателем
</member>
        <member name="T:Constraints2D.GeometryMediator">
Посредник для взаимодействия геометрии с конкретным решателем
</member>
        <member name="D:Constraints2D.MediatorSet">
Множество посредников
</member>
        <member name="D:Constraints2D.MediatorPtr">
Разделяемая ссылка на базовый класс посредника для взаимодействия с конкретным решателем
</member>
        <member name="T:Constraints2D.Mediator">
Базовый класс посредника для взаимодействия с конкретным решателем
</member>
        <member name="D:Constraints2D.GeometryVector">
Множество геометрических данных
</member>
        <member name="D:Constraints2D.GeometrySet">
Множество геометрических данных
</member>
        <member name="D:Constraints2D.GeometryPtr">
Разделяемая ссылка на геометрические данные
</member>
        <member name="T:Constraints2D.Geometry">
Геометрические данные для решателя ограничений
</member>
        <member name="M:KNOT.HasConstraints">
Данные для решателя ограничений
</member>
        <member name="M:KNOT.IsFixedForConstraint">
Линия фиксирована в решателе ограничений
</member>
        <member name="M:DRAW.HasConstraints">
Данные для решателя ограничений
</member>
        <member name="M:FlatObject.IsFixedForConstraint">
Объект фиксирован в решателе ограничений
</member>
        <member name="M:FlatObject.TypedRegenerateSketch(FlatObject.RegenerateSketchOptions!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Функция, непосредственно осуществляющая регенерацию объекта на эскизе после решения системы ограничений
</member>
        <member name="T:FlatObject.RegenerateSketchOptions">
Эскизы с ограничениями и управляющими размерами
</member>
        <member name="M:CompiledExpression.#ctor">
Конструктор
</member>
        <member name="M:ExpressionItem.BeginAt">
            <summary>Возвращает начальную позицию лексемы в заданном выражении, необходимо для раскраски</summary>
        </member>
        <member name="M:ExpressionItem.Length">
            <summary>Возвращает длину символов в начальном выражении, необходимо для раскраски</summary>
        </member>
        <member name="M:ExpressionItem.GetType">
            <summary>Возвращает тип лексемы</summary>
        </member>
        <member name="M:ExpressionItem.Dispose">
Деструктор
</member>
        <member name="M:ExpressionItem.#ctor">
Конструктор
</member>
        <member name="F:FunctionParameter">
            <remarks>Параметр пользовательской функции</remarks>
        </member>
        <member name="F:UserFunction">
            <remarks>пользовательская функция</remarks>
        </member>
        <member name="F:StartFunction">
            <remarks>начало списка параметров функции</remarks>
        </member>
        <member name="F:DatabaseField">
            <remarks>поле базы данных</remarks>
        </member>
        <member name="F:Comment">
            <remarks>комментарий</remarks>
        </member>
        <member name="F:Colon">
            <remarks>оператор двоеточие (используется в семантике тернарного оператора)</remarks>
        </member>
        <member name="F:Comma">
            <remarks>оператор запятая (используется в функциях с несколькими переменными)</remarks>
            <summary>Запятая</summary>
        </member>
        <member name="F:PowerOperation">
Операции возведения в степень
</member>
        <member name="F:LogicalOr">
            <remarks>логическое ИЛИ: '|'</remarks>
        </member>
        <member name="F:LogicalAnd">
            <remarks>логическое И: '&amp;'</remarks>
        </member>
        <member name="F:LogicalGreatedEqual">
            <remarks>логическое больше-равно: '&gt;='</remarks>
        </member>
        <member name="F:LogicalLessEqual">
            <remarks>логическое меньше-равно: '&lt;='</remarks>
        </member>
        <member name="F:LogicalNotEqual">
            <remarks>логическое неравенство: '!='</remarks>
        </member>
        <member name="F:LogicalEqual">
            <remarks>логическое равенство: '=='</remarks>
        </member>
        <member name="F:LogicalGreater">
            <remarks>логическое больше: '&gt;'</remarks>
        </member>
        <member name="F:LogicalLess">
            <remarks>логическое меньше: '&lt;'</remarks>
        </member>
        <member name="F:Mod">
Бинарный оператор получения остатка от деления: '%'
</member>
        <member name="F:Divide">
Бинарный оператор деления: '/'
</member>
        <member name="F:Multiply">
Бинарный оператор умножения: '*'
</member>
        <member name="F:Add">
Бинарный оператор плюс: '+'
</member>
        <member name="F:Subtract">
Бинарный оператор минус: '-'
</member>
        <member name="F:LogicalNot">
Унарный оператор НЕ: '!'
</member>
        <member name="F:UnaryMinus">
Унарный оператор минус: '-'
</member>
        <member name="F:TernarySeparatorOperation">
Тернарный оператор: '?', разделитель группы
</member>
        <member name="F:EndTernaryOperation">
Тернарный оператор: '?', конец группы
</member>
        <member name="F:BeginTernaryOperation">
Тернарный оператор: '?', начало группы
</member>
        <member name="F:TernaryOperation">
Тернарный оператор: '?'
</member>
        <member name="F:CloseScope">
Закрывающий оператор приоритета ")"
</member>
        <member name="F:OpenScope">
Открывающий оператор приоритета "("
</member>
        <member name="F:FunctionCall">
Функция	
</member>
        <member name="F:StringConstant">
Константа
</member>
        <member name="F:RealConstant">
Константа
</member>
        <member name="F:InexistingVariableReference">
Несуществующая переменная
</member>
        <member name="F:VariableReference">
Переменная
</member>
        <member name="F:Unknown">
Неизвестный тип
</member>
        <member name="M:ExpressionCompilerError.Length">
            <summary>Длина ошибки, выраженная в количестве символов(необходимо для подсветки ошибки)</summary>
            <returns>Возвращает длину ошибочной части строки выражения, тип std::size_t</returns>
        </member>
        <member name="M:ExpressionCompilerError.StartAt">
            <summary>Возвращает исходную позицию, с которой начинается ошибка, в переданном выражении(необходимо для подсветки ошибки)</summary>
            <returns>Возвращает начальную позицию ошибки, тип std::size_t</returns>
        </member>
        <member name="M:ExpressionCompilerError.What">
            <summary>Возвращает строку с описанием ошибки компиляции выражения</summary>
            <returns>Возвращает текст ошибки, тип std::wstring</returns>
        </member>
        <member name="M:ExpressionCompilerError.HasError">
            <summary>Возвращает флаг наличия ошибки</summary>
            <returns>Возвращает true при наличии ошибки, false - при отсутствии</returns>
        </member>
        <member name="M:ExpressionCompilerError.Clear">
            <summary>Сбрасывает информацию об ошибках</summary>
        </member>
        <member name="M:ExpressionCompilerError.#ctor">
Конструктор
</member>
        <member name="T:ExpressionCompilerError">
Класс, хранящий ошибку компиляции выражения
</member>
        <member name="M:PlineHandler.Instance">
            <summary> Хэндлер полилинии для локального трэда </summary>
            <remarks>
Общая схема:
Есть пул полилиний. Хэндлер для работы с полилинией объявлен как thread_local, что означает,
что при первом обращении к нему в текущем трэде у него вызывается конструктор по умолчанию, а при завершении трэда - вызывается деструктор.
В конструкторе хэндлер получает полилинию из пула, а в деструкторе - возвращает ее.
</remarks>
        </member>
        <member name="T:PlineHandler">
            <summary> Класс, обеспечивающий доступ к полилинии </summary>
        </member>
        <member name="M:PlineData.GetRawX">
            <summary> Интерфейс для использования старых алгоритмов </summary>
        </member>
        <member name="M:PlineData.AddPolyline(RGPlatform.Geometry.Polyline2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Добавить полилинию из источника.</summary>
        </member>
        <member name="M:PlineData.Fill(RGPlatform.Geometry.Polyline2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Заполнить полилинию из источника </summary>
        </member>
        <member name="M:PlineData.GetContour(System.UInt64)">
            <summary> Получить контур поиндексу </summary>
        </member>
        <member name="M:PlineData.CountContours">
            <summary> Получить количество контуров </summary>
        </member>
        <member name="M:PlineData.GetPoint(System.UInt64)">
            <summary> Получить координаты точки по индексу </summary>
        </member>
        <member name="M:PlineData.CountPoints">
            <summary> Получить количество точек </summary>
        </member>
        <member name="T:PlineData.Contour">
            <summary> Контур </summary>
        </member>
        <member name="T:PlineData">
Legacy end
<summary> Структура данных полилинии </summary></member>
        <member name="M:LockPline">
Legacy
</member>
        <member name="M:SelectableObject.ReplaceCharacteristicDataReferences(CharacteristicDataToReplace!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Заменить ссылки на характерные данные других объектов </summary>
            <remarks> Если входящие данные не находят соответствия какой-либо ссылке, то эта ссылка просто пропускается. </remarks>
            <param name="iData"> Входящие данные для замены ссылок </param>
            <returns> false, если хотя бы одна ссылка была удалена, true - иначе </returns>
        </member>
        <member name="M:SelectableObject.GetCharacteristicDataCount">
Характерные данные объекта: габаритные точки, центры симметрии, концы или середина кривой, очерк. Пока поддерживаются только точки
</member>
        <member name="M:CharacteristicDataToReplace.#ctor(CharacteristicDataToReplace!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="T:CharacteristicDataToReplace">
Параметры замены характерных данных родителей
</member>
        <member name="T:CharacteristicDataReference">
Ссылка на характерные данные объекта
</member>
        <member name="M:CharacteristicDataChanges.GetGeometry">
Новая геометрия, если харакетристика задаётся произвольной геометрией
</member>
        <member name="M:CharacteristicDataChanges.GetPoint">
Новые координаты, если харакетристика задаётся точкой
</member>
        <member name="M:CharacteristicDataChanges.GetID">
Идентификатор узла
</member>
        <member name="M:CharacteristicDataChanges.#ctor(CharacteristicDataChanges!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="T:CharacteristicDataChanges">
Параметры изменения характерных данных, если они являются управляющими
</member>
        <member name="M:CharacteristicDataReport.GetGeometry">
Харакетристика задаётся произвольной геометрией
</member>
        <member name="M:CharacteristicDataReport.GetPoint">
Харакетристика задаётся точкой
</member>
        <member name="T:CharacteristicDataReport.FixType">
Параметр на кривой фиксирован, если характеристика является точкой
</member>
        <member name="M:CharacteristicDataReport.GetParameter">
Параметр на кривой, если характеристика является точкой
</member>
        <member name="T:CharacteristicDataReport.RelationType">
Тип характеристики по отношению к геометрии объекта
</member>
        <member name="T:CharacteristicDataReport.ParameterType">
Тип характеристики как параметра объекта
</member>
        <member name="T:CharacteristicDataReport.CharacteristicType">
Тип характеристики
</member>
        <member name="M:CharacteristicDataReport.#ctor(CharacteristicDataReport!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="T:CharacteristicDataReport">
Результаты запроса информации о характеристике
</member>
        <member name="M:CharacteristicDataQuery.GetCheckError">
Идентификатор характеристики
</member>
        <member name="M:CharacteristicDataQuery.GetID">
Идентификатор характеристики
</member>
        <member name="M:CharacteristicDataQuery.#ctor(CharacteristicDataQuery!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="T:CharacteristicDataQuery">
Параметры запроса информации о характеристике
</member>
        <member name="M:CTFObject.DoActionLikeAfterRegenerateOptions.IsNestedRegeneration">
Проверить режим вложенного пересчета(например, параметрические копии)
</member>
        <member name="M:CTFObject.DoActionLikeAfterRegenerateOptions.SetNestedRegeneration(System.Boolean)">
Установить режим вложенного пересчета(например, параметрические копии)
</member>
        <member name="M:CTFObject.DoActionLikeAfterRegenerateOptions.IsOnly2D">
Проверить режим 2D пересчета
</member>
        <member name="M:CTFObject.DoActionLikeAfterRegenerateOptions.SetOnly2D(System.Boolean)">
Установить режим 2D пересчета
</member>
        <member name="M:op_OnesComplement(&lt;unknown type&gt;)">
Класс только для наследования от него
</member>
        <member name="M:CTFObject.GetToModelSpaceScale">
Методы для вычислений на точной геометрии
</member>
        <member name="M:CTFObject.ChangeWhenChildrenAreDeleted(DeleteElementsContext*)">
Изменение родителя, при удалении потомка
</member>
        <member name="M:CTFObject.GetParentsThatChangeWhenDelete(CParentsArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,DeleteElementsContext*)">
Получить родителей, которые меняются при удалении
</member>
        <member name="M:CTFObject.GetDeletingParents(CParentsArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,DeleteElementsContext*)">
Функция возвращает список родителей, которые нужно удалять вместе с объектом.
В процессе построения дерева удаления объектов функция может вызываться много раз.
</member>
        <member name="F:IS_ELEVABLE">
не используется в 2D
</member>
        <member name="F:REFER_CLONE_MOVE">
не используется в 2D
</member>
        <member name="F:ref_ScreenObjectToFragmentProjectionReference">
Тела в списке проецирования соритуются по этим идентификаторам
</member>
        <member name="F:pfwReallyChanged">
Альтернатива рекурсивному вызову IsReallyChanged
</member>
        <member name="F:pfwDistance">
Порядок расположения объектов в дереве модели
</member>
        <member name="F:pfwTestRecursion">
Проверка рекурсии. Используется для специальной обработки случаев, когда формально существующая по связам рекурсия, на самом деле таковой не является.
Например, 3D фрагмент задаётся 2D фрагментом, который берёт значения переменных с 3D коннектора (система координат). При это система кординат и 3D фрагмент связаны сопряжениями
</member>
        <member name="F:ptFORMULA_Variable">
Переделан метод IsAuxiliary
</member>
        <member name="F:ptLockType_Remove_Container">
ptLockType_Import								= 12508,
</member>
        <member name="F:ptPoint2Dto3D_Mesh">
Точка на сетке
</member>
        <member name="F:ptCViewData_Next">
Следующий идентификатор для проекций
</member>
        <member name="F:ptCViewData_ScreenObjects">
Тела в списке проецирования соритуются по этим идентификаторам
</member>
        <member name="F:ptPath3D_FromProjectionOnFace_Direction">
5414 используется
</member>
        <member name="T:FormHeaderButton">
%%COMMENT
</member>
        <member name="T:TopKindID">
%%COMMENT
</member>
        <member name="T:ExpandClassID">
%%COMMENT
</member>
        <member name="P:TFlex.Model.Model2D.BOMObject.LinkedFragment">
            <summary>Связанный фрагмент</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.GetUserFieldValue(System.String)">
            <summary>Получить значение пользовательского поля</summary>
            <param name="fieldName">Пользовательское поле</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.GetStandardFieldValue(TFlex.Model.Model2D.BOMObject.StandardField)">
            <summary>Получить значение стандартного поля</summary>
            <param name="field">Стандартное поле</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.GetBOMGroups">
            <summary>Получить массив всех разделов спецификации</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.NewGroupUseMaxPosition">
            <summary>Начинать нумерацию в разделе после максимального значения в предыдущем разделе</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.SortByPosition">
            <summary>Сортировка по позициям</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.IsUsedForSetupPositions">
            <summary>Используется для простановки позиций</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.FriendlyName">
            <summary>Название спецификации</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.ReportID">
            <summary>Идентификатор связаного объекта в документе спецификации</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.ReportFileLink">
            <summary>Ссылка на документ спецификации</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.SetVersions(TFlex.Model.Model2D.BOMObject.Version[])">
            <summary>Установить исполнения</summary>
            <param name="versions">Массив исполнений</param>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.Version.Order">
            <summary>Порядковый номер исполнения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.Version.ID">
            <summary>Идентификатор исполнения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.Version.Name">
            <summary>Имя исполнения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.BOMObject.Version">
            <summary>Исполнение</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.CreateCustomColumn(System.String,TFlex.Model.Model2D.BOMObject.ColumnSettings)">
            <summary>Создать колонку пользовательского типа</summary>
            <param name="name">Имя колонки</param>
            <param name="settings">Параметры колонки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.CreateVariableColumn(System.String,System.String,TFlex.Model.Model2D.BOMObject.ColumnSettings)">
            <summary>Создать колонку переменного типа</summary>
            <param name="name">Название</param>
            <param name="variableName">Имя переменной, значение которой будет заносится в создаваемую колонку</param>
            <param name="settings">Параметры колонки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.CreateStandardColumn(System.String,TFlex.Model.Model2D.BOMObject.StandardField,TFlex.Model.Model2D.BOMObject.ColumnSettings)">
            <summary>Создать колонку стандартного типа</summary>
            <param name="name">Название</param>
            <param name="type">Тип</param>
            <param name="settings">Параметры колонки</param>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.ColumnSettings.Visible">
            <summary>Свойство видимости колонки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.ColumnSettings.ShowGroupName">
            <summary>Свойство "Отображать название раздела"</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.ColumnSettings.IgnoreCase">
            <summary>Свойство "Игнорировать при сравнении"</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.ColumnSettings.Sum">
            <summary>Свойство "Суммировать при объединении"</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.ColumnSettings.DataType">
            <summary>Тип данных колонки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.ColumnSettings.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.BOMObject.ColumnSettings">
            <summary>Параметры колонки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.CreateField(System.String,TFlex.Model.Model2D.BOMObject.FieldType)">
            <summary>Создать поле</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.FieldType.Binary">
            <summary>Двоичное</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.FieldType.Memo">
            <summary>Строковое без ограничения длины</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.FieldType.StringField">
            <summary>Строковое</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.FieldType.Double">
            <summary>Вещественное</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.FieldType.DWord">
            <summary>32-битное целое</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.FieldType.Bool">
            <summary>Булевый</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.FieldType.Unknown">
            <summary>Неизвестный</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.BOMObject.FieldType">
            <summary>Типы полей записи</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.GetVisibleFields">
            <summary>Получить имена видимых полей в порядке отображения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.GetAllFields">
            <summary>Получить имена всех полей</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.UpdateUserFieldValue(System.String,System.String)">
            <summary>Установить значение пользовательского поля</summary>
            <param name="fieldName">Имя пользовательского поля</param>
            <param name="value">Значение</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.UpdateStandardFieldValue(TFlex.Model.Model2D.BOMObject.StandardField,System.String)">
            <summary>Установить значение стандартного поля</summary>
            <param name="field">Стандартное поле</param>
            <param name="value">Значение</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.SetFieldGuidValueIndirect(System.UInt32,System.Guid)">
            <summary>Установить значение поля в виде GUID</summary>
            <param name="fieldIndex">Индекс поля</param>
            <param name="value">GUID</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.GetFieldGuidValueIndirect(System.UInt32)">
            <summary>Получить значение поля в виде GUID</summary>
            <param name="fieldIndex">Индекс поля</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.SetFieldIntValueIndirect(System.UInt32,System.Int32)">
            <summary>Установить целое значение поля</summary>
            <param name="fieldIndex">Индекс поля</param>
            <param name="value">Значение поля</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.GetFieldIntValueIndirect(System.UInt32)">
            <summary>Получить целое значение поля</summary>
            <param name="fieldIndex">Индекс поля</param>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Version">
            <summary>Номер исполнения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.CageCode">
            <summary>Коммерческий код</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.FragmentID">
            <summary>Последовательность ID связанного фрагмента</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Order">
            <summary>Порядковый номер при ручной сортировке записей</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Format">
            <summary>Формат</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Zone">
            <summary>Зона</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Position">
            <summary>Номер позиции</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Amount">
            <summary>Количество</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Snap">
            <summary>ID предыдущей записи при привязке к ней</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Remarks">
            <summary>Комментарии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Price">
            <summary>Цена</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Mass">
            <summary>Масса</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Material">
            <summary>Материал</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Number">
            <summary>Обозначение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Desc">
            <summary>Наименование</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Flags">
            <summary>Флаги записи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Group">
            <summary>Номер раздела спецификации</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.RowNumber">
            <summary>Номер строки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Fragment">
            <summary>Имя связанного фрагмента</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.TableID">
            <summary>Идентификатор записи в таблице вложенной спецификации</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.Table">
            <summary>Идентификатор таблицы вложенной спецификации</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.StandardField.ID">
            <summary>Идентификатор записи</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.BOMObject.StandardField">
            <summary>Идентификаторы стандартных полей</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.RecordPosition">
            <summary>Номер позиции текущей записи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.RecordGroupFullName">
            <summary>Полное имя раздела текущей записи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.RecordGroup">
            <summary>Номер раздела текущей записи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.RecordVersion">
            <summary>Номер исполнения текущей записи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.RecordSpaceAfter">
            <summary>Пропуск строк после текущей записи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.RecordSpaceBefore">
            <summary>Пропуск строк перед текущей записью</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.RecordFlags">
            <summary>Флаги состояния текущей записи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.RecordID">
            <summary>ID текущей записи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.RecordFlag.Merged">
            <summary>Объединенная</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.RecordFlag.Invisible">
            <summary>Невидимая</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.RecordFlag.Automatic">
            <summary>Автоматическая</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.RecordFlag.Temporary">
            <summary>Временная</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.RecordFlag.Hidden">
            <summary>Запись является скрытой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.RecordFlag.SkipPosition">
            <summary>Пропустить номер позиции</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.BOMObject.RecordFlag.FixedPosition">
            <summary>Зафиксирован номер позиции</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.BOMObject.RecordFlag">
            <summary>Флаги состояния записи</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.DeleteAllRecords">
            <summary>Удалить все записи</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.DeleteRecord">
            <summary>Удалить текущую запись</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.UpdateRecord">
            <summary>Обновить текущую запись</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.AddRecord">
            <summary>Добавить запись</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.EditRecord">
            <summary>Редактировать текущую запись</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.SeekToRecordID(System.UInt32)">
            <summary>Перевести курсор на запись спецификации с заданным ID</summary>
            <param name="id">Идентификатор записи спецификации</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.MoveToNextRecord">
            <summary>Перевести курсор на следующую запись спецификации</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.MoveToFrontRecord">
            <summary>Перевести курсор на первую запись спецификации</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.Refresh(System.Boolean)">
            <summary>Обновить данные спецификации и спецификацию</summary>
            <param name="refreshData">Обновить данные спецификации</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.Refresh">
            <summary>Обновить спецификацию</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.EndEdit">
            <summary>Завершить изменение спецификации</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BOMObject.BeginEdit">
            <summary>Начать изменение спецификации</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BOMObject.SubType">
            <summary>Подтип спецификации</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.BOMObject">
            <summary>Класс спецификации</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BomGroup.ParentID">
            <summary>Идентификатор родительского раздела</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BomGroup.Name">
            <summary>Наименование раздела</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BomGroup.ID">
            <summary>Идентификатор</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.BomGroup">
            <summary>Раздел спецификации</summary>
        </member>
        <member name="P:TFlex.Model.Structure.ElementLink.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="P:TFlex.Model.Structure.LinkDescriptor.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="P:TFlex.Model.Structure.Element.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="P:TFlex.Model.Structure.ElementType.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="T:TFlex.Configuration.I3DManagedFuncImpl">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructureReportSupport.CopyReportTemplateIntoDocument(TFlex.Model.Document,TFlex.Model.Document)">
            <summary>Copies pages from report template document into sepcified document</summary>
        </member>
        <member name="T:TFlex.Model.ProductStructureReportSupport">
            <summary>Auxiliary class for product structure report generation</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.CreateChangesScope">
            <summary>Создать область изменений. Структура изделия не будет автоматически пересчитываться при изменениях. Вместо этого она пересчитается когда будет вызван Dispose.</summary>
            <remarks>Для использования в using.</remarks>
        </member>
        <member name="M:TFlex.Model.ProductStructure.UpdateReports(System.Collections.Generic.IEnumerable`1{TFlex.Model.Model2D.RichText})">
            <summary>Обновить выбранные отчёты структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.UpdateReports">
            <summary>Обновить все отчёты структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.ExportToExcel(TFlex.Model.ProductStructureExcelExportOptions)">
            <summary>Экспортировать структуру изделия в Excel</summary>
            <param name="options">Параметры экспорта</param>
        </member>
        <member name="M:TFlex.Model.ProductStructure.ExportToXml(TFlex.Model.ProductStructureXmlExportOptions)">
            <summary>Экспортировать структуру изделия в xml</summary>
            <param name="options">Параметры экспорта</param>
        </member>
        <member name="M:TFlex.Model.ProductStructure.RunReportGeneration(System.Guid,TFlex.Model.ProductStructureReportOptions)">
            <summary>Запустить генерацию отчета структуры изделия</summary>
            <param name="reportID">Идентификатор отчета. Можно получить из схемы структуры изделия.</param>
            <param name="options">Параметры генерации</param>
        </member>
        <member name="P:TFlex.Model.ProductStructure.IsShownInProductStructureWindow">
            <summary>Структура изделия показана в окне "Структура изделия"</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.ShowInProductStructureWindow">
            <summary>Показать структуру изделия в окне "Структура изделия"</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.RemoveExternalReport(TFlex.Model.FileLink)">
            <summary>Удалить ссылку на внешний отчёт</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.AddExternalReport(TFlex.Model.FileLink)">
            <summary>Добавить ссылку на внешний отчёт</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.GetExternalReports">
            <summary>Получить коллекцию ссылок на внешние отчёты структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.GetRowElementGroups(System.Int32)">
            <summary>Получить группы элементов структуры изделия</summary>
            <param name="groupingIndex">Индекс представления, используемого для группировки и объединения элементов</param>
        </member>
        <member name="M:TFlex.Model.ProductStructure.GetRowElementGroups(System.Guid)">
            <summary>Получить группы элементов структуры изделия</summary>
            <param name="groupingID">Идентификатор представления, используемого для группировки и объединения элементов</param>
        </member>
        <member name="M:TFlex.Model.ProductStructure.GetRowElementGroups">
            <summary>Получить группы элементов структуры изделия</summary>
            <remarks>Для группировки и объединения используется представление по умолчанию</remarks>
        </member>
        <member name="M:TFlex.Model.ProductStructure.AddElement">
            <summary>Добавить элемент в структуру изделия</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.GetAllRowElements">
            <summary>Получить все элементы структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.SetScheme(TFlex.Model.Data.ProductStructure.Scheme)">
            <summary>Изменить тип структуры изделия</summary>
            <param name="scheme">Тип структуры изделия</param>
        </member>
        <member name="P:TFlex.Model.ProductStructure.SchemeId">
            <summary>Идентификатор типа структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.GetScheme">
            <summary>Получить тип структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.UpdateStructure">
            <summary>Обновить структуру изделия</summary>
        </member>
        <member name="M:TFlex.Model.ProductStructure.InitializeByPrototype(System.String)">
            <summary>Инициалихация структуры изделия по прототипу</summary>
            <param name="prototypeName">Имя прототипа</param>
        </member>
        <member name="M:TFlex.Model.ProductStructure.CreateProductStructure(TFlex.Model.Document,TFlex.Model.FileLink)">
            <summary>Создать новую структуру изделия</summary>
            <param name="doc">Документ, в котором создаётся новая структура</param>
            <param name="schemeFileLink">Файл с типом структуры изделия</param>
        </member>
        <member name="M:TFlex.Model.ProductStructure.CreateProductStructure(TFlex.Model.Document,TFlex.Model.Data.ProductStructure.Scheme)">
            <summary>Создать новую структуру изделия</summary>
            <param name="doc">Документ, в котором создаётся новая структура</param>
            <param name="scheme">Тип структуры изделия</param>
        </member>
        <member name="T:TFlex.Model.ProductStructure">
            <summary>Класс структуры изделия</summary>
        </member>
        <member name="P:TFlex.Model.RowElementGroup.RowElements">
            <summary>Коллекция всех элементов группы</summary>
        </member>
        <member name="P:TFlex.Model.RowElementGroup.Items">
            <summary>Коллекция записей группы</summary>
        </member>
        <member name="P:TFlex.Model.RowElementGroup.Name">
            <summary>Имя группы</summary>
        </member>
        <member name="P:TFlex.Model.RowElementGroup.Item.ChildGroups">
            <summary>Коллекция дочерних групп элементов.</summary>
            <remarks>Заполняется только, если используется представление с учётом иерархии</remarks>
        </member>
        <member name="P:TFlex.Model.RowElementGroup.Item.MergedCells">
            <summary>Значения, полученные суммированием при объединении элементов. Ключ - идентификатор колонки.</summary>
        </member>
        <member name="P:TFlex.Model.RowElementGroup.Item.MergedElements">
            <summary>Коллекция объединенных записью элементов.</summary>
            <remarks>Первый элемент главный</remarks>
        </member>
        <member name="T:TFlex.Model.RowElementGroup.Item">
            <summary>Запись группы элементов структуры изделия</summary>
            <remarks>Каждая запись представляет 1 или более элементов структуры изделия</remarks>
        </member>
        <member name="T:TFlex.Model.RowElementGroup.MergedCellValue">
            <summary>Объединенные значения ячеек структуры изделия</summary>
        </member>
        <member name="T:TFlex.Model.RowElementGroup">
            <summary>Класс группы элементов структуры изделия.</summary>
        </member>
        <member name="P:TFlex.Model.RowElementCell.Unit">
            <summary>Единица измерения ячейки</summary>
        </member>
        <member name="P:TFlex.Model.RowElementCell.Variable">
            <summary>Переменная, с которой связана ячейки</summary>
        </member>
        <member name="P:TFlex.Model.RowElementCell.Text">
            <summary>Значение исходного текста ячейки</summary>
            <remarks>Имеет смысл только для строковых колонок</remarks>
        </member>
        <member name="P:TFlex.Model.RowElementCell.ValueAsString">
            <summary>Значение ячейки сконвертированное в строку</summary>
        </member>
        <member name="P:TFlex.Model.RowElementCell.Value">
            <summary>Значение</summary>
        </member>
        <member name="P:TFlex.Model.RowElementCell.IsGenerated">
            <summary>Влючен ли для ячейка генератор колонки</summary>
        </member>
        <member name="P:TFlex.Model.RowElementCell.IsUserDefined">
            <summary>Задана ли ячейка элемента пользователем</summary>
        </member>
        <member name="P:TFlex.Model.RowElementCell.RowElement">
            <summary>Элемент структуры изделия, которому принадлежит ячейка</summary>
        </member>
        <member name="T:TFlex.Model.RowElementCell">
            <summary>Класс ячейки элемента структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.RowElement.CreateChangesScope">
            <summary>Создать область изменений. Запись не будет автоматически пересчитываться при изменениях в ячейках. Вместо этого она пересчитается когда будет вызван Dispose.</summary>
            <remarks>Для использования в using.</remarks>
        </member>
        <member name="P:TFlex.Model.RowElement.Position">
            <summary>Получить ячейку "Включать при вставке в сборку"</summary>
        </member>
        <member name="P:TFlex.Model.RowElement.IncludeInAssembly">
            <summary>Получить ячейку "Включать в отчёты/спецификации текущего документа"</summary>
        </member>
        <member name="P:TFlex.Model.RowElement.IncludeInDoc">
            <summary>Получить ячейку "Включать в отчёты/спецификации текущего документа"</summary>
        </member>
        <member name="P:TFlex.Model.RowElement.default(System.Guid)">
            <summary>Получить ячейку элемента для колонки структуры изделия</summary>
            <param name="parameterId">Идентификатор колонки структуры изделия</param>
        </member>
        <member name="P:TFlex.Model.RowElement.default(TFlex.Model.Data.ProductStructure.ParameterDescriptor)">
            <summary>Получить ячейку элемента для колонки структуры изделия</summary>
            <param name="parameter">Колонка структуры изделия</param>
        </member>
        <member name="M:TFlex.Model.RowElement.GetCell(System.Guid)">
            <summary>Получить ячейку элемента для колонки структуры изделия</summary>
            <param name="parameterId">Идентификатор колонки структуры изделия</param>
        </member>
        <member name="P:TFlex.Model.RowElement.LinkedObjects">
            <summary>Модельные объекты, связанные с элементом структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.RowElement.GetCell(TFlex.Model.Data.ProductStructure.ParameterDescriptor)">
            <summary>Получить ячейку элемента для колонки структуры изделия</summary>
            <param name="parameter">Колонка структуры изделия</param>
        </member>
        <member name="P:TFlex.Model.RowElement.SourceRowElementUIDFirstLevel">
            <summary>Уникальный идентификатор элемента, по которому создан этот элемент (первого уровня вложенности). Если элемент не поднят из фрагмента, то возвращается System.Guid.Empty</summary>
        </member>
        <member name="P:TFlex.Model.RowElement.SourceRowElementUID">
            <summary>Уникальный идентификатор элемента, по которому создан этот элемент. Если элемент не поднят из фрагмента, то возвращается System.Guid.Empty</summary>
        </member>
        <member name="P:TFlex.Model.RowElement.SourceFragmentFirstLevel">
            <summary>Фрагмент, из которого поднят элемент. Если элемент не поднят из фрагмента, то возвращается null.</summary>
        </member>
        <member name="M:TFlex.Model.RowElement.GetSourceFragmentIdChain(System.Boolean)">
            <summary>Список идентификаторов фрагментов, из которых поднят элемент. Если элемент не поднят из фрагмента, то возвращается пустой перечислитель.</summary>
            <param name="fragment3d">Возвращать идентификаторы для 3D фрагментов</param>
        </member>
        <member name="P:TFlex.Model.RowElement.SourceFragmentPath">
            <summary>Путь к фрагменту, из которого поднят элемент. Если элемент не поднят из фрагмента, то возвращается null.</summary>
        </member>
        <member name="P:TFlex.Model.RowElement.ParentRowElement">
            <summary>Родительский элемент</summary>
        </member>
        <member name="P:TFlex.Model.RowElement.ProductStructure">
            <summary>Структура изделия, которой принадлежит элемент</summary>
        </member>
        <member name="P:TFlex.Model.RowElement.UID">
            <summary>Уникальный идентификатор элемента</summary>
        </member>
        <member name="T:TFlex.Model.RowElement">
            <summary>Класс элемента структуры изделия</summary>
        </member>
        <member name="M:TFlex.RibbonButton.Remove">
            <summary>Удаляет эту кнопку из содержащего её контейнера (группы ленты или другой кнопки)</summary>
        </member>
        <member name="M:TFlex.RibbonButton.AddChildButton(System.Int32,System.String,TFlex.Plugin,TFlex.RibbonButtonStyle)">
            <summary>Добавляет кнопку в список кнопок, вложенных в эту</summary>
        </member>
        <member name="M:TFlex.RibbonButton.AddChildButton(System.Int32,System.String,TFlex.Plugin)">
            <summary>Добавляет кнопку в список кнопок, вложенных в эту</summary>
        </member>
        <member name="M:TFlex.RibbonButton.AddChildButton(System.Int32,TFlex.Plugin,TFlex.RibbonButtonStyle)">
            <summary>Добавляет кнопку в список кнопок, вложенных в эту</summary>
        </member>
        <member name="M:TFlex.RibbonButton.AddChildButton(System.Int32,TFlex.Plugin)">
            <summary>Добавляет кнопку в список кнопок, вложенных в эту</summary>
        </member>
        <member name="M:TFlex.RibbonButton.AddChildButton(System.Int32,System.String,TFlex.RibbonButtonStyle)">
            <summary>Добавляет кнопку в список кнопок, вложенных в эту</summary>
        </member>
        <member name="M:TFlex.RibbonButton.AddChildButton(System.Int32,System.String)">
            <summary>Добавляет кнопку в список кнопок, вложенных в эту</summary>
        </member>
        <member name="M:TFlex.RibbonButton.AddChildButton(System.Int32,TFlex.RibbonButtonStyle)">
            <summary>Добавляет кнопку в список кнопок, вложенных в эту</summary>
        </member>
        <member name="M:TFlex.RibbonButton.AddChildButton(System.Int32)">
            <summary>Добавляет кнопку в список кнопок, вложенных в эту</summary>
        </member>
        <member name="P:TFlex.RibbonButton.ChildButtons">
            <summary>Кнопки, вложенные в эту</summary>
        </member>
        <member name="P:TFlex.RibbonButton.ChildButton(System.Int32)">
            <summary>i-ая кнопка, вложенная в эту</summary>
        </member>
        <member name="P:TFlex.RibbonButton.ChildButtonCount">
            <summary>Количество кнопок, вложенных в эту</summary>
        </member>
        <member name="P:TFlex.RibbonButton.ToolTip">
            <summary>Текст подсказки, отображаемой при наведении курсора на эту кнопку</summary>
        </member>
        <member name="P:TFlex.RibbonButton.Description">
            <summary>Описание команды, выполняемой при нажатии на эту кнопку</summary>
        </member>
        <member name="P:TFlex.RibbonButton.Caption">
            <summary>Отображаемый на кнопке текст</summary>
        </member>
        <member name="P:TFlex.RibbonButton.ID">
            <summary>Идентификатор этой кнопки</summary>
        </member>
        <member name="T:TFlex.RibbonButton">
            <summary>Кнопка на ленте T-FLEX CAD</summary>
        </member>
        <member name="M:BuildModelTreeOptions.GetSubTreeObjects">
Получить список объектов, для которых создаётся поддерево
</member>
        <member name="M:BuildModelTreeOptions.EditSubTreeObjects">
Редактировать список объектов, для которых создаётся поддерево
</member>
        <member name="M:BuildModelTreeOptions.GetModelTreeType">
Получить состав дерева модели
</member>
        <member name="M:BuildModelTreeOptions.SetModelTreeType(BuildModelTreeOptions.ModelTreeType)">
Установить состав дерева модели
</member>
        <member name="M:BuildModelTreeOptions.GetAddObjects">
Получить список дополнительных объектов, которые будут добавлены в дерево
</member>
        <member name="M:BuildModelTreeOptions.EditAddObjects">
Редактировать список дополнительных объектов, которые будут добавлены в дерево
</member>
        <member name="T:BuildModelTreeOptions.ModelTreeType">
Состав дерева модели
</member>
        <member name="T:BuildModelTreeOptions">
Параметры построения дерева
</member>
        <member name="M:RegenerateModelTreeOptions.IsNestedRegeneration">
Проверить режим вложенного пересчета(например, параметрические копии)
</member>
        <member name="M:RegenerateModelTreeOptions.SetNestedRegeneration(System.Boolean)">
Установить режим вложенного пересчета(например, параметрические копии)
</member>
        <member name="M:RegenerateModelTreeOptions.IsOnly2D">
Проверить режим 2D пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.SetOnly2D(System.Boolean)">
Установить режим 2D пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.IsCompress">
Проверить режим компактизации представления 3D данных
</member>
        <member name="M:RegenerateModelTreeOptions.SetCompress(System.Boolean)">
Установить режим компактизации представления 3D данных
</member>
        <member name="M:RegenerateModelTreeOptions.IsShowGauge">
Проверить режим мониторинга процесса пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.SetShowGauge(System.Boolean)">
Установить режим мониторинга процесса пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.IsFullRegeneration">
Проверить режим полного пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.SetFullRegeneration(System.Boolean)">
Установить режим полного пересчета
</member>
        <member name="T:RegenerateModelTreeOptions">
Параметры пересчета дерева
</member>
        <member name="T:TFlex.Model.Circuits.Bus">
            <summary>Объект "Шина"</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinkSymbol.GetConnectors">
            <summary>Получить коннекторы</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinkSymbol.GetLinks">
            <summary>Получить линии связи, к которым привязан символ</summary>
        </member>
        <member name="P:TFlex.Model.Circuits.LinkSymbol.Page">
            <summary>Страница, на которой размещается элемент</summary>
        </member>
        <member name="P:TFlex.Model.Circuits.LinkSymbol.CanDraw">
            <summary>Управление отрисовкой</summary>
        </member>
        <member name="T:TFlex.Model.Circuits.LinkSymbol">
            <summary>Объект "Условное обозначение на линии связи"</summary>
        </member>
        <member name="T:TFlex.Model.Circuits.MultiLinksGroup">
            <summary>Объект "Групповая линия связи с разрывом"</summary>
        </member>
        <member name="T:TFlex.Model.Circuits.MultiLink">
            <summary>Объект "Линия связи с разрывом"</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinksGroup.Create(System.Collections.Generic.List`1{TFlex.Model.Circuits.Link})">
            <summary>Создание по линиям связи</summary>
        </member>
        <member name="T:TFlex.Model.Circuits.LinksGroup">
            <summary>Объект "Групповая линия связи"</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.IGroupLink.Collapse(System.Collections.Generic.IEnumerable`1{TFlex.Model.Model2D.FixingVector},TFlex.Model.Model2D.FixingVector)">
            <summary>Свернуть в точке подключения</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.IGroupLink.Expand(TFlex.Model.Model2D.FixingVector,System.Collections.Generic.IEnumerable`1{TFlex.Model.Model2D.FixingVector})">
            <summary>Развернуть в точке подключения</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.IGroupLink.GetAllLinks">
            <summary>Линии связи</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.GetSymbols">
            <summary>Получить все графические обозначения на ЛС</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.GetFreePoints">
            <summary>Координаты точек, которые ни к чему не подключены</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.GetMultiLink">
            <summary>Получить линию связи с разрывом</summary>
        </member>
        <member name="P:TFlex.Model.Circuits.Link.Coaxial">
            <summary>Атрибуты линии связи</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.OnEndEdit">
            <summary>Событие на завершение редактирования</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.OnBeginEdit">
            <summary>Событие на начало редактирования</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.Insert(TFlex.Model.Model2D.FixingVector,TFlex.Model.Model2D.FixingVector)">
            <summary>вставка point1 и point2 в линию связи</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.Insert(TFlex.Model.Model2D.FixingVector)">
            <summary>вставка point1 в линию связи</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.CanInsert(TFlex.Model.Model2D.FixingVector,TFlex.Model.Model2D.FixingVector)">
            <summary>Проверка, можно ли вставить point1 и point2 в линию</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.Link.CanInsert(TFlex.Model.Model2D.FixingVector)">
            <summary>Проверка, можно ли вставить point в линию</summary>
        </member>
        <member name="P:TFlex.Model.Circuits.Link.Page">
            <summary>Страница, на которой размещается элемент</summary>
        </member>
        <member name="T:TFlex.Model.Circuits.Link">
            <summary>Объект "линия связи"</summary>
        </member>
        <member name="P:TFlex.Model.Circuits.LinkBase.CanDraw">
            <summary>Управление отрисовкой</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinkBase.MarkPath(TFlex.Drawing.Graphics,TFlex.Model.Model2D.FixingVector,TFlex.Model.Model2D.FixingVector)">
            <summary>Подсветить связь между коннекторами</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinkBase.GetGroups">
            <summary>Групповые линии связи</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinkBase.SetTextHorizontalAlignment(TFlex.Model.Model2D.TextExtension.HorizontalAlignment)">
            <summary>Надписи</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinkBase.HasDesignation">
            <summary>Обозначения</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinkBase.Remove(TFlex.Model.Model2D.FixingVector)">
            <summary>Отсоединение коннектора от линии связи</summary>
        </member>
        <member name="M:TFlex.Model.Circuits.LinkBase.GetAllLinkedObjects">
            <summary>Все коннекторы</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroupContainer.Enumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroupContainer.Enumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroupContainer.Enumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroupContainer.FindGroup(System.String)">
            <summary>Найти группу по имени</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroupContainer.Remove(TFlex.Model.ModelObjectGroup)">
            <summary>Удалить группу</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroupContainer.AddEmptyGroup(System.String)">
            <summary>Добавить новую пустую группу</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroupContainer.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.ModelObjectGroupContainer">
            <summary>Массив групп объектов</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.IsOnTopLevel">
            <summary>Возвращает true, если группа не входит в другую группу</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.Count">
            <summary>Количество элементов в группе</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroup.FindItem(TFlex.Model.ModelObjectGroup)">
            <summary>Найти элемент группы - вложенную группу</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroup.FindItem(TFlex.Model.ModelObject)">
            <summary>Найти элемент группы - объект модели</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroup.RemoveAllItems">
            <summary>Удаление всех элементов группы</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroup.Remove(TFlex.Model.ModelObjectGroup)">
            <summary>Удаление вложенной группы объектов из данной группы</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroup.Remove(TFlex.Model.ModelObject)">
            <summary>Удаление объекта из группы</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroup.Add(TFlex.Model.ModelObjectGroup)">
            <summary>Добавление другой группы в данную группу</summary>
            <param name="group">Группа, добавляемая в данную группу</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroup.Add(TFlex.Model.ModelObject)">
            <summary>Добавление объекта в группу</summary>
            <param name="object">Добавляемый в группу объект</param>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.GroupItems">
            <summary>Коллекция элементов, входящих в группу</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.Name">
            <summary>Имя группы</summary>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.Document">
            <summary>Документ, являющийся родительским для данной группы</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectGroup.#ctor(TFlex.Model.Document,System.String)">
            <summary>Конструктор</summary>
            <param name="Doc">Документ объекта</param>
            <param name="Name">Имя группы. Если имя уже существует или значение параметра равно null, имя подбирается автоматически</param>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.GroupItem.Object">
            <summary>Объект модели, представляемый данным элементом. Если элемент является вложенной группой, возвращает null</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.GroupItem.IsObject">
            <summary>Возвращает true, если элемент является объектом</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.GroupItem.Group">
            <summary>Вложенная группа, представляемая данным элементом. Если элемент является объектом модели, возвращает null</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectGroup.GroupItem.IsGroup">
            <summary>Возвращает true, если элемент является вложенной группой</summary>
        </member>
        <member name="T:TFlex.Model.ModelObjectGroup.GroupItem">
            <summary>Класс элемента группы объектов.</summary>
        </member>
        <member name="T:TFlex.Model.ModelObjectGroup">
            <summary>Класс группы объектов модели, вспомогательного объекта документа T-FLEX.</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.FontStyle">
            <summary>Стиль шрифта текста для получения или установки его параметров</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.OldStyle">
            <summary>Флаг рисования шероховатости без учёта изменений №3 ГОСТ 2.309-73</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.DrawExtLine">
            <summary>Параметр рисования выносной линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.ArrowSize">
            <summary>Размер стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.ArrowType">
            <summary>Тип стрелки</summary>
            <remarks>При установки типа (-1) надпись будет рисоваться без стрелки</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.UnsetType">
            <summary>Вид неуказываемой шероховатости</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.SymbolType">
            <summary>Вид значка шероховатости</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.TextInstruction">
            <summary>Установить строку текста - указание</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.TextDirection">
            <summary>Строка текста - направление неровностей</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.TextAfter">
            <summary>Строка текста после знака шероховатости</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.TextBefore">
            <summary>Строка текста перед знаком шероховатости</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetLeaderOffset(System.Double,System.Double)">
            <summary>Установка смещения выносной полки шероховатости</summary>
            <param name="dX">Смещение относительно точки привязки в направлении касательной к линии привязки</param>
            <param name="dY">Смещение относительно точки привязки в направлении перпендикулярном линии привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.LeaderDirection">
            <summary>Направление выносной полки шероховатости</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.SignOrientation">
            <summary>Положение знака шероховатости</summary>
            <remarks>Если значение равно 1, то знак рисуется под линией привязки</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.RelativeLengthParameter">
            <summary>Параметры относительной опорной длины</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetRelativeLength(TFlex.Model.Model2D.RoughnessRelativeLengthType,System.String,System.String,System.String,System.String)">
            <summary>Установка типа и строк относительной опорной длины</summary>
            <param name="parameterType">Тип относительной опорной длины</param>
            <param name="minimum">Минимум</param>
            <param name="maximumOrNominal">Максимум или номинал</param>
            <param name="deviation">Отклонения</param>
            <param name="p">Параметр "p"</param>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.StepParameter">
            <summary>Шаговый параметр шероховатости</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetStepParameter(TFlex.Model.Model2D.RoughnessStepParameterType,System.String,System.String,System.String,System.String)">
            <summary>Установка типа и строк шагового параметра</summary>
            <param name="parameterType">Тип шагового параметра</param>
            <param name="minimum">Минимум</param>
            <param name="maximumOrNominal">Максимум или номинал</param>
            <param name="deviation">Отклонение</param>
            <param name="basicLength">Базовая длина</param>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.HeightParameter">
            <summary>Высотный параметр шероховатости</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetHeightParameter(TFlex.Model.Model2D.RoughnessHeightParameterType,System.String,System.String,System.String,System.String)">
            <summary>Установка типа и строк высотного параметра</summary>
            <param name="parameterType">Тип высотного параметра</param>
            <param name="minimum">Минимум</param>
            <param name="maximumOrNominal">Максимум или номинал</param>
            <param name="deviation">Отклонение</param>
            <param name="basicLength">Базовая длина</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetLeaderNote(TFlex.Model.Model2D.LeaderNote,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к надписи</summary>
            <param name="note">Надпись для привязки</param>
            <param name="offset">Смещение положения точки привязки от стрелки надписи</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetCircularDimension(TFlex.Model.Model2D.CircularDimension,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к размеру на окружности</summary>
            <param name="dim">Размер для привязки</param>
            <param name="offset">Смещение положения точки привязки от окружности</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetLinearDimension(TFlex.Model.Model2D.LinearDimension,System.Boolean,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к линейному размеру</summary>
            <param name="dim">Размер для привязки</param>
            <param name="onSecondLine">Параметр, к какой из линий размера осуществлять привязку</param>
            <param name="offset">Смещение положения точки привязки от размерной линии</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetPolyline(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к полилинии</summary>
            <param name="polyline">Полилиния привязки</param>
            <param name="parameter">Параметр положения точки привязки на полилинии</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetEllipse(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к эллипсу</summary>
            <param name="ellipse">Эллипс привязки</param>
            <param name="parameter">Параметр положения точки привязки на эллипсе</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetCircle(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к окружности</summary>
            <param name="circle">Окружность привязки</param>
            <param name="cosAngle">Косинус угла, на котором находится точка привязки</param>
            <param name="sinAngle">Синус угла, на котором находится точка привязки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetOutlineLine(TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к отрезку</summary>
            <param name="line">Отрезок привязки</param>
            <param name="isOnEnd">Указывает на то, что привязка происходит к концу отрезка (иначе - к началу)</param>
            <param name="offset">Смещение точки привязки по отрезку относительно выбранного конца отрезка</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetConstructionLine(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к прямой</summary>
            <param name="line">Прямая привязки</param>
            <param name="nod">Узел привязки (на прямой)</param>
            <param name="offset">Смещение точки привязки по прямой относительно узла</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetNode(TFlex.Model.Model2D.Node,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки к узлу</summary>
            <param name="nod">Узел привязки</param>
            <param name="dX">Смещение относительно узла привязки по оси X</param>
            <param name="dY">Смещение относительно узла привязки по оси Y</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.SetAbsolute(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки  к абсолютным координатам</summary>
            <param name="x">Абцисса привязки</param>
            <param name="y">Ордината привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.AttachmentType">
            <summary>Тип привязки шероховатости</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RoughnessSymbol.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RoughnessSymbol.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.RelativeLengthParameters.p">
            <summary>Параметр "p"</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.RelativeLengthParameters.Deviation">
            <summary>Отклонение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.RelativeLengthParameters.MaximumOrNominal">
            <summary>Максимум или номинал</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.RelativeLengthParameters.Minimum">
            <summary>Минимум</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.RelativeLengthParameters.ParameterType">
            <summary>Тип относительной опорной длины</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessSymbol.RelativeLengthParameters">
            <summary>Параметры относительной опорной длины</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.StepParameters.BasicLength">
            <summary>Базовая длина</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.StepParameters.Deviation">
            <summary>Отклонение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.StepParameters.MaximumOrNominal">
            <summary>Максимум или номинал</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.StepParameters.Minimum">
            <summary>Минимум</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.StepParameters.ParameterType">
            <summary>Тип шагового параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessSymbol.StepParameters">
            <summary>Шаговый параметр обозначения шероховатости</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.HeightParameters.BasicLength">
            <summary>Базовая длина</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.HeightParameters.Deviation">
            <summary>Отклонение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.HeightParameters.MaximumOrNominal">
            <summary>Максимум или номинал</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.HeightParameters.Minimum">
            <summary>Минимум</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbol.HeightParameters.ParameterType">
            <summary>Тип высотного параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessSymbol.HeightParameters">
            <summary>Высотный параметр обозначения шероховатости</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessSymbol">
            <summary>Класс символа шероховатости</summary>
            <example>
                <code name="Шероховатость">
public static void RoughnessSymbol()//Шероховатость (с заданием дополнительных специфических параметров)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Шероховатость");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 100, 640);		 	
   RoughnessSymbol roughnessSymbol = new RoughnessSymbol(document);
   roughnessSymbol.SetNode(fn1, 0, 0);
   roughnessSymbol.SignOrientation = 1;

   //Шаговый параметр шероховатости
   roughnessSymbol.SetStepParameter(RoughnessStepParameterType.S, "1", "5", "1.2", "3");
   roughnessSymbol.SymbolType = RoughnessSymbolViewType.Simple;//Вид значка шероховатости
   roughnessSymbol.TextAfter = "после знака";//Строка текста после знака шероховатости
   roughnessSymbol.TextBefore = "перед знаком";//Строка текста перед знаком шероховатости
   roughnessSymbol.TextDirection = "направление неровностей";//Строка текста - направление неровностей
   roughnessSymbol.TextInstruction = "указание";//Установить строку текста - указание

   //Вид неуказываемой шероховатости (Неуказываемая шероховатость со значком без скобок)
   roughnessSymbol.UnsetType = RoughnessUnsetViewType.SimpleUnset;

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessUnsetViewType">
            <summary>Типы значков неуказываемой шероховатости</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessUnsetViewType.UnsetWithParenthesis">
            <summary>Неуказываемая шероховатость со значком в скобках</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessUnsetViewType.SimpleUnset">
            <summary>Неуказываемая шероховатость со значком без скобок</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessUnsetViewType.None">
            <summary>Неуказываемая шероховатость отсутствует</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessSymbolViewType">
            <summary>Типы значков шероховатости</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessRelativeLengthType">
            <summary>Типы относительной опорной длины</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessStepParameterType">
            <summary>Типы шагового параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessHeightParameterType">
            <summary>Типы высотного параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessSymbolLeaderType">
            <summary>Типы направления полки шероховатости</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolLeaderType.ToRight">
            <summary>Полка вправо</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolLeaderType.ToLeft">
            <summary>Полка влево</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolLeaderType.None">
            <summary>Полка отсутствует</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RoughnessSymbolAttachmentType">
            <summary>Типы привязок шероховатости</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.CircularDimension">
            <summary>К размеру на окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.LinearDimension">
            <summary>К линейному размеру</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.LeaderNote">
            <summary>К надписи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.Polyline">
            <summary>К полилинии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.Ellipse">
            <summary>К эллипсу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.Circle">
            <summary>К окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.OutlineLine">
            <summary>К отрезку</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.ConstructionLine">
            <summary>К прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.Node">
            <summary>К узлу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RoughnessSymbolAttachmentType.Absolute">
            <summary>По абсолютным координатам</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ParentWeld">
            <summary>Родительский сварной шов</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetDefaults">
            <summary>Установка параметров надписи в соответствии с параметрами по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.FontStyle">
            <summary>Стиль шрифта текста для получения или установки его параметров</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.Page">
            <summary>Cтраница, на которой размещается объект</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.GetObjectKnotLists">
            <summary>Получить списки узлов объекта (стрелки)</summary>
            <returns>Списки узлов объекта</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.RemoveMultipleLeaderString(System.Int32)">
            <summary>Удаление дополнительной полки надписи</summary>
            <param name="index">Индекс удаляемой полки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.AddMultipleLeaderString(System.String)">
            <summary>Добавление новой дополнительной полки надписи</summary>
            <param name="text">Строка на добавляемой полке</param>
            <returns>Индекс добавленной полки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.ClearMultipleLeader">
            <summary>Удаление всех дополнительных полок надписи</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.GetMultipleLeaderString(System.Int32)">
            <summary>Получение строки на дополнительной полке надписи</summary>
            <param name="index">Индекс дополнительной полки (начиная с 0)</param>
            <returns>Строка, на дополнительной полке надписи</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.GetLeaderDOCsLinks(System.Int32)">
            <summary>Получение позиций полках надписи</summary>
            <param name="StringIndex">Индекс дополнительной полки (начиная с 0). "-1" для основной полки.</param>
            <returns>Список позиций</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderDOCsLinks(System.Int32,System.Collections.Generic.List`1{System.Guid})">
            <summary>Установка позиций полках надписи</summary>
            <param name="StringIndex">Индекс дополнительной полки (начиная с 0). "-1" для основной полки.</param>
            <param name="guids">Список позиций</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetMultipleLeaderString(System.Int32,System.String)">
            <summary>Установка строки на дополнительной полке надписи</summary>
            <param name="index">Индекс дополнительной полки (начиная с 0)</param>
            <param name="text">Устанавливаемая строка</param>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.MultipleLeaderCount">
            <summary>Количество дополнительных полок надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.StringsAlignment">
            <summary>Параметр выравнивания дополнительных полок по длине наибольшей из полок</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.StartAtBottom">
            <summary>Расположение дополнительных полок: true - добавлять снизу вверх, false - сверху вниз</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.StringsHeight">
            <summary>Высота строк</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.CornerThickness">
            <summary>Толщина линии уголка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowThickness">
            <summary>Толщина линии стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.CornerSize">
            <summary>Размер уголка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowOwnHeight">
            <summary>Высота прямоугольника стрелки. Eсли данное значение больше 0 - используется соответствующее значение из статуса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowHeight">
            <summary>Высота прямоугольника прямоугольной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowOwnSize">
            <summary>Размер стрелки. Eсли данное значение меньше 0 - используется соответствующее значение из статуса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowSize">
            <summary>Размер стрелки, радиус стрелки-окружности или ширина стрелки-прямоугольника</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.Standard">
            <summary>Стандарт изображения надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.SymbolType">
            <summary>Тип символа на стрелке</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.CornerType">
            <summary>Тип уголка надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.Direction">
            <summary>Направление полки надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowType">
            <summary>Тип стрелки. При установки типа (-1) надпись будет рисоваться без стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.TextUnderArrow">
            <summary>Текст под стрелкой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.TextUnderLeader">
            <summary>Текст под полкой надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.TextOnArrow">
            <summary>Текст на стрелке</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.TextOnLeader">
            <summary>Текст на полке надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.LeaderOffsetY">
            <summary>Смещение надписи относительно узла привязки или (значение LeaderOffsetY) по линии привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.LeaderOffsetX">
            <summary>Смещение надписи относительно узла привязки или (значение LeaderOffsetX) по линии привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowOffsetY">
            <summary>Смещение стрелки относительно узла привязки или (значение ArrowOffsetY) по линии привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowOffsetX">
            <summary>Смещение стрелки относительно узла привязки или (значение ArrowOffsetX) по линии привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.LeaderIsAttchedFromEnd">
            <summary>Привязка надписи выполняется с конца объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.LeaderAttachmentObject">
            <summary>Объект, к которому привязана надпись</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowIsAttchedFromEnd">
            <summary>Привязка стрелки выполняется с конца объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowAttachmentObject">
            <summary>Объект, к которому привязана стрелка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.LeaderPoint">
            <summary>Положение надписи в абсолютных координатах</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowPoint">
            <summary>Положение стрелки в абсолютных координатах</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderMultiPoints(System.Collections.Generic.IList`1{TFlex.Drawing.Point})">
            <summary>Построить выносную линию в соответствии с заданной последовательностью точек</summary>
            <param name="points">Коллекция точек для построения выносной линии</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderFirstPoint(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки полки относительно положения стрелки</summary>
            <param name="dX">Смещение оси X</param>
            <param name="dY">Смещение оси Y</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderPolyline(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки полки к полилинии</summary>
            <param name="polyline">Полилиния привязки</param>
            <param name="parameter">Параметр положения точки привязки на полилинии</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderEllipse(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки полки к эллипсу</summary>
            <param name="ellipse">Эллипс привязки</param>
            <param name="parameter">Параметр положения точки привязки на эллипсе</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderCircle(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки полки к окружности</summary>
            <param name="circle">Окружность привязки</param>
            <param name="cosAngle">Косинус угла, на котором находится точка привязки</param>
            <param name="sinAngle">Синус угла, на котором находится точка привязки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderOutlineLine(TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки полки к отрезку</summary>
            <param name="line">Отрезок привязки</param>
            <param name="isOnEnd">Указывает на то, что привязка происходит к концу отрезка (иначе - к началу)</param>
            <param name="offset">Смещение точки привязки по отрезку относительно выбранного конца отрезка</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderConstructionLine(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки полки к прямой</summary>
            <param name="line">Прямая привязки</param>
            <param name="nod">Узел привязки (на прямой)</param>
            <param name="offset">Смещение точки привязки по прямой относительно узла</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderNode(TFlex.Model.Model2D.Node,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки полки к узлу</summary>
            <param name="nod">Узел привязки</param>
            <param name="dX">Смещение относительно узла привязки по оси X</param>
            <param name="dY">Смещение относительно узла привязки по оси Y</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetLeaderAbsolute(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка позиции текста по абсолютным координатам</summary>
            <param name="x">Координата X</param>
            <param name="y">Координата Y</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetArrowPolyline(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки стрелки к полилинии</summary>
            <param name="polyline">Полилиния привязки</param>
            <param name="parameter">Параметр положения точки привязки на полилинии</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetArrowEllipse(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки стрелки к эллипсу</summary>
            <param name="ellipse">Эллипс привязки</param>
            <param name="parameter">Параметр положения точки привязки на эллипсе</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetArrowCircle(TFlex.Model.Model2D.Object2D,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки стрелки к окружности</summary>
            <param name="circle">Окружность привязки</param>
            <param name="cosAngle">Косинус угла, на котором находится точка привязки</param>
            <param name="sinAngle">Синус угла, на котором находится точка привязки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetArrowOutlineLine(TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки стрелки к отрезку</summary>
            <param name="line">Отрезок привязки</param>
            <param name="isOnEnd">Указывает на то, что привязка происходит к концу отрезка (иначе - к началу)</param>
            <param name="offset">Смещение точки привязки по отрезку относительно выбранного конца отрезка</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetArrowConstructionLine(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки стрелки к прямой</summary>
            <param name="line">Прямая привязки</param>
            <param name="nod">Узел привязки (на прямой)</param>
            <param name="offset">Смещение точки привязки по прямой относительно узла</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetArrowNode(TFlex.Model.Model2D.Node,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка привязки стрелки к узлу</summary>
            <param name="nod">Узел привязки</param>
            <param name="dX">Смещение по X от узла привязки</param>
            <param name="dY">Смещение по Y от узла привязки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.SetArrowAbsolute(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров привязки стрелки к абсолютным координатам</summary>
            <param name="x">Абцисса привязки</param>
            <param name="y">Ордината привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.ArrowAttachmentType">
            <summary>Тип привязки стрелки надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.LeaderAttachmentType">
            <summary>Тип привязки надписи</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LeaderNote.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LeaderNote.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ объекта</param>
        </member>
        <member name="T:TFlex.Model.Model2D.LeaderNote">
            <summary>Надпись</summary>
            <example>
                <code name="Надпись">
public static void LeaderNote()//Надпись (с заданием дополнительных специфических параметров)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Надпись");//Открытие блока изменений документа

   LeaderNote leaderNote = new LeaderNote(document); 
   leaderNote.SetArrowAbsolute(-100, 50);
   leaderNote.TextOnArrow = "Текст на стрелке";
   leaderNote.TextOnLeader = "Текст на полке надписи";
   leaderNote.TextUnderArrow = "Текст под стрелкой";
   leaderNote.TextUnderLeader = "Текст под полкой надписи";
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.LeaderNoteSymbolType">
            <summary>Тип символа на стрелке надписи</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LeaderNoteCornerType">
            <summary>Типы уголка надписи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteCornerType.UnderlineCircle">
            <summary>Подчеркнутый в окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteCornerType.Triangle">
            <summary>Треугольник</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteCornerType.Circle">
            <summary>Окружность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteCornerType.Weld">
            <summary>Сварка</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteCornerType.Rounded">
            <summary>По контуру (с кружком)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteCornerType.Simple">
            <summary>Обычный</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LeaderNoteStandard">
            <summary>Типы стандартов изображения надписи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteStandard.ISO">
            <summary>ЕСКД</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteStandard.ANSI">
            <summary>ANSI</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteStandard.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LeaderNoteDirection">
            <summary>Типы направления полок надписи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteDirection.ToDown">
            <summary>Вниз</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteDirection.ToRight">
            <summary>Вправо</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteDirection.ToUp">
            <summary>Вверх</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteDirection.ToLeft">
            <summary>Влево</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LeaderNoteAttachmentType">
            <summary>Типы привязок точек надписи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteAttachmentType.FirstPoint">
            <summary>К концу стрелки надписи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteAttachmentType.Polyline">
            <summary>К полилинии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteAttachmentType.Ellipse">
            <summary>К эллипсу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteAttachmentType.Circle">
            <summary>К окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteAttachmentType.OutlineLine">
            <summary>К отрезку</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteAttachmentType.ConstructionLine">
            <summary>К прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteAttachmentType.Node">
            <summary>К узлу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LeaderNoteAttachmentType.Absolute">
            <summary>По абсолютным координатам</summary>
        </member>
        <member name="T:TFReference.CTFBoolPropertyAuto">
Класс для автоматической переменной для установки нового значения флага и восстановления старого значения флага при завершении
</member>
        <member name="M:TFlex.RibbonGroup.Remove">
            <summary>Удаляет эту группу из содержащей её вкладки</summary>
        </member>
        <member name="M:TFlex.RibbonGroup.AddButton(System.Int32,System.String,TFlex.Plugin,TFlex.RibbonButtonStyle)">
            <summary>Добавляет кнопку в эту группу</summary>
        </member>
        <member name="M:TFlex.RibbonGroup.AddButton(System.Int32,System.String,TFlex.Plugin)">
            <summary>Добавляет кнопку в эту группу</summary>
        </member>
        <member name="M:TFlex.RibbonGroup.AddButton(System.Int32,TFlex.Plugin,TFlex.RibbonButtonStyle)">
            <summary>Добавляет кнопку в эту группу</summary>
        </member>
        <member name="M:TFlex.RibbonGroup.AddButton(System.Int32,TFlex.Plugin)">
            <summary>Добавляет кнопку в эту группу</summary>
        </member>
        <member name="M:TFlex.RibbonGroup.AddButton(System.Int32,System.String,TFlex.RibbonButtonStyle)">
            <summary>Добавляет кнопку в эту группу</summary>
        </member>
        <member name="M:TFlex.RibbonGroup.AddButton(System.Int32,System.String)">
            <summary>Добавляет кнопку в эту группу</summary>
        </member>
        <member name="M:TFlex.RibbonGroup.AddButton(System.Int32,TFlex.RibbonButtonStyle)">
            <summary>Добавляет кнопку в эту группу</summary>
        </member>
        <member name="M:TFlex.RibbonGroup.AddButton(System.Int32)">
            <summary>Добавляет кнопку в эту группу</summary>
        </member>
        <member name="P:TFlex.RibbonGroup.Buttons">
            <summary>Кнопки этой группы</summary>
        </member>
        <member name="P:TFlex.RibbonGroup.Button(System.Int32)">
            <summary>i-ая кнопка в этой группе</summary>
        </member>
        <member name="P:TFlex.RibbonGroup.ButtonCount">
            <summary>Количество кнопок в этой группе</summary>
        </member>
        <member name="P:TFlex.RibbonGroup.Visible">
            <summary>Видимость группы</summary>
        </member>
        <member name="P:TFlex.RibbonGroup.Caption">
            <summary>Текст, отображаемый в группе</summary>
        </member>
        <member name="P:TFlex.RibbonGroup.ID">
            <summary>Идентификатор этой группы</summary>
        </member>
        <member name="T:TFlex.RibbonGroup">
            <summary>Группа элементов управления во вкладке ленты</summary>
        </member>
        <member name="M:TFlex.RibbonTab.Remove">
            <summary>Удаляет вкладку из ленты</summary>
        </member>
        <member name="M:TFlex.RibbonTab.AddGroup(System.String,System.Int32)">
            <summary>Добавляет новую группу в эту вкладку</summary>
        </member>
        <member name="M:TFlex.RibbonTab.AddGroup(System.String)">
            <summary>Добавляет новую группу в эту вкладку</summary>
        </member>
        <member name="P:TFlex.RibbonTab.Groups">
            <summary>Группы этой вкладки</summary>
        </member>
        <member name="P:TFlex.RibbonTab.Group(System.Int32)">
            <summary>i-ая группа этой вкладки</summary>
        </member>
        <member name="P:TFlex.RibbonTab.GroupCount">
            <summary>Количество групп в этой вкладке</summary>
        </member>
        <member name="P:TFlex.RibbonTab.Caption">
            <summary>Отображаемый на вкладке текст</summary>
        </member>
        <member name="P:TFlex.RibbonTab.GUID">
            <summary>Идентификатор вкладки</summary>
        </member>
        <member name="P:TFlex.RibbonTab.ID">
            <summary>Идентификатор вкладки</summary>
        </member>
        <member name="M:TFlex.RibbonTab.#ctor(System.String,System.Guid,TFlex.Plugin,System.Guid,System.Boolean)">
            <summary>Конструктор</summary>
        </member>
        <member name="M:TFlex.RibbonTab.#ctor(System.String,System.Guid,TFlex.Plugin,System.Guid)">
            <summary>Конструктор</summary>
        </member>
        <member name="M:TFlex.RibbonTab.#ctor(System.String,System.Guid,TFlex.Plugin)">
            <summary>Конструктор</summary>
        </member>
        <member name="M:TFlex.RibbonTab.#ctor(System.String)">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.RibbonTab">
            <summary>Вкладка ленты T-FLEX CAD</summary>
        </member>
        <member name="M:TFlex.Control.OnPaint(System.Windows.Forms.PaintEventArgs)">
            <summary>Событие, происходящее при перерисовке визуального элемента управления</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Control.OnMouseDoubleClick(System.Windows.Forms.MouseEventArgs)">
            <summary>Событие, происходящее, когда визуальный элемент управления дважды щелкается мышью</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Control.OnMouseUp(System.Windows.Forms.MouseEventArgs)">
            <summary>Cобытие, происходящее при отпускании кнопки мыши, когда указатель мыши находится на визуальном элементе управления</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Control.OnMouseMove(System.Windows.Forms.MouseEventArgs)">
            <summary>Событие, происходящее при перемещении указателя мыши по визуальному элементу управления</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Control.OnMouseDown(System.Windows.Forms.MouseEventArgs)">
            <summary>Cобытие, происходящеe при нажатии кнопки мыши, если указатель мыши находится на визуальном элементе управления</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Control.OnMouseWheel(System.Windows.Forms.MouseEventArgs)">
            <summary>Событие, происходящее при прокрутке колеса мыши в поле визуального элемента управления</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Control.OnResize(System.EventArgs)">
            <summary>Событие, происходящее при изменении размеров визуального элемента управления</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="E:TFlex.Control.ObjectChanged">
            <summary>Событие, происходящее при изменении объекта</summary>
        </member>
        <member name="E:TFlex.Control.PageChanged">
            <summary>Событие, происходящее при изменении активной страницы</summary>
        </member>
        <member name="E:TFlex.Control.ContextMenu">
            <summary>Событие, происходящее при вызове контекстного меню</summary>
        </member>
        <member name="E:TFlex.Control.MouseMoved">
            <summary>Событие, происходящее при перемещении указателя мыши по визуальному элементу управления.</summary>
        </member>
        <member name="E:TFlex.Control.RMouseUp">
            <summary>Событие, происходящее при отпускании правой кнопки мыши, когда указатель мыши находится на визуальном элементе управления.</summary>
        </member>
        <member name="E:TFlex.Control.RMouseDown">
            <summary>Событие, происходящеe при нажатии правой кнопки мыши, если указатель мыши находится на визуальном элементе управления.</summary>
        </member>
        <member name="E:TFlex.Control.MouseDblClick">
            <summary>Событие, происходящее, когда визуальный элемент управления дважды щелкается мышью.</summary>
        </member>
        <member name="E:TFlex.Control.MouseUp">
            <summary>Cобытие, происходящее при отпускании кнопки мыши, когда указатель мыши находится на визуальном элементе управления.</summary>
        </member>
        <member name="E:TFlex.Control.MouseDown">
            <summary>Cобытие, происходящеe при нажатии кнопки мыши, если указатель мыши находится на визуальном элементе управления.</summary>
        </member>
        <member name="M:TFlex.Control.Print">
            <summary>Печатать содержимое окна элемента управления</summary>
        </member>
        <member name="M:TFlex.Control.GetModelPoint(System.Drawing.Point)">
            <summary>Получить точку в системе координат модели</summary>
        </member>
        <member name="P:TFlex.Control.EnableFragmentEditing">
            <summary>Разрешить редактирование фрагментов</summary>
        </member>
        <member name="P:TFlex.Control.ShowVariablesButton">
            <summary>Показать кнопку "Переменные"</summary>
        </member>
        <member name="P:TFlex.Control.EnablePrintButton">
            <summary>Параметр "Разрешить печатать"</summary>
        </member>
        <member name="M:TFlex.Control.LoadImageFile(System.String)">
            <summary>Загрузить изображение</summary>
            <param name="fileName">Имя файла</param>
        </member>
        <member name="P:TFlex.Control.Image">
            <summary>Параметр "изображение"</summary>
        </member>
        <member name="M:TFlex.Control.Redraw">
            <summary>Перерисовать окно</summary>
        </member>
        <member name="M:TFlex.Control.SetPageTypeVisibility(TFlex.Model.PageType,System.Boolean)">
            <summary>Управление видимостью страницы</summary>
        </member>
        <member name="M:TFlex.Control.IsPageTypeVisible(TFlex.Model.PageType)">
            <summary>Возвращает видимость страницы с заданным типом</summary>
        </member>
        <member name="P:TFlex.Control.ShowAllPages">
            <summary>Параметр "Показывать все страницы"</summary>
        </member>
        <member name="P:TFlex.Control.TabAlignment">
            <summary>Параметр "Показывать закладки страниц снизу"</summary>
        </member>
        <member name="P:TFlex.Control.ShowPageTabs">
            <summary>Параметр "Показывать закладки страниц"</summary>
        </member>
        <member name="P:TFlex.Control.ShowView3D">
            <summary>Параметр "Показывать 3D вид"</summary>
        </member>
        <member name="P:TFlex.Control.ShowControlButtons">
            <summary>Параметр "Показывать кнопки управления видом"</summary>
        </member>
        <member name="M:TFlex.Control.Select(System.Drawing.Point,TFlex.Model.SelectionFilter)">
            <summary>Выбор элемента модели, ближайшего к заданной точке</summary>
            <param name="point">Точка на экране</param>
            <param name="filter">Фильтр выбора объектов</param>
        </member>
        <member name="M:TFlex.Control.Select(System.Int32,System.Int32,TFlex.Model.SelectionFilter)">
            <summary>Выбор элемента модели, ближайшего к точке с заданными координатами</summary>
            <param name="x">Координата X в экранной системе координат</param>
            <param name="y">Координата Y в экранной системе координат</param>
            <param name="filter">Фильтр выбора объектов</param>
        </member>
        <member name="M:TFlex.Control.SetViewPoint(TFlex.Control.ViewPoint)">
            <summary>Установка точки взгляда</summary>
            <param name="point">Точка взгляда</param>
        </member>
        <member name="F:TFlex.Control.ViewPoint.Isometric">
            <summary>Изометрическая</summary>
        </member>
        <member name="F:TFlex.Control.ViewPoint.Bottom">
            <summary>Снизу</summary>
        </member>
        <member name="F:TFlex.Control.ViewPoint.Top">
            <summary>Сверху</summary>
        </member>
        <member name="F:TFlex.Control.ViewPoint.Right">
            <summary>Справа</summary>
        </member>
        <member name="F:TFlex.Control.ViewPoint.Left">
            <summary>Слева</summary>
        </member>
        <member name="F:TFlex.Control.ViewPoint.Back">
            <summary>Сзади</summary>
        </member>
        <member name="F:TFlex.Control.ViewPoint.Front">
            <summary>Спереди</summary>
        </member>
        <member name="T:TFlex.Control.ViewPoint">
            <summary>Перечислитель точек взгляда (3D)</summary>
        </member>
        <member name="P:TFlex.Control.ExplodeMode">
            <summary>Параметр "Режим разборки (3D)"</summary>
        </member>
        <member name="P:TFlex.Control.ViewStyle">
            <summary>Параметр "Стиль отображения (3D)"</summary>
        </member>
        <member name="F:TFlex.Control.ViewStyleMode.PreciseHidden">
            <summary>Точное удаление невидимых линий</summary>
        </member>
        <member name="F:TFlex.Control.ViewStyleMode.Rendering">
            <summary>Тоновая закраска с материалами</summary>
        </member>
        <member name="F:TFlex.Control.ViewStyleMode.QuickHidden">
            <summary>Быстрое удаление невидимых линий</summary>
        </member>
        <member name="F:TFlex.Control.ViewStyleMode.Wireframe">
            <summary>Проволочная модель</summary>
        </member>
        <member name="F:TFlex.Control.ViewStyleMode.Shading">
            <summary>Тоновая закраска</summary>
        </member>
        <member name="T:TFlex.Control.ViewStyleMode">
            <summary>Перечислитель стилей отображения в 3D окне</summary>
        </member>
        <member name="P:TFlex.Control.GlobalLcsVisible">
            <summary>Показать или скрыть глобальную систему координат</summary>
        </member>
        <member name="P:TFlex.Control.Hide3DAnnotations">
            <summary>Параметр "Скрыть элементы оформления"</summary>
        </member>
        <member name="P:TFlex.Control.HideConstructions">
            <summary>Параметр "Скрыть линии построения"</summary>
        </member>
        <member name="P:TFlex.Control.ZoomRectangle">
            <summary>Прямоугольник, который отображается в данном виде (только для 2D)</summary>
        </member>
        <member name="M:TFlex.Control.ZoomLimits">
            <summary>Показать всё изображение</summary>
        </member>
        <member name="M:TFlex.Control.SetZoomRectangle(TFlex.Drawing.Rectangle)">
            <summary>Установить текущее окно вывода (только 2D)</summary>
            <param name="rect">Прямоугольник окна вывода</param>
        </member>
        <member name="P:TFlex.Control.Graphics">
            <summary>Получение текущего графического контекста (только 2D)</summary>
        </member>
        <member name="P:TFlex.Control.AutoZoom">
            <summary>Режим автоматического масштабирования</summary>
        </member>
        <member name="P:TFlex.Control.ViewType">
            <summary>Получить тип текущего вида: false - 2D, true - 3D</summary>
        </member>
        <member name="P:TFlex.Control.AutoSelectViewType">
            <summary>Выбирать тип вида (2D/3D) по умолчанию</summary>
        </member>
        <member name="P:TFlex.Control.DefaultWindowsBackground">
            <summary>Использовать цвет фона Windows по умолчанию</summary>
        </member>
        <member name="P:TFlex.Control.DrawAnnotations">
            <summary>Выводить аннотации</summary>
        </member>
        <member name="P:TFlex.Control.DrawPaperBorder">
            <summary>Рисовать рамку страницы</summary>
        </member>
        <member name="P:TFlex.Control.Border">
            <summary>Рамка</summary>
        </member>
        <member name="P:TFlex.Control.ProductVersion">
            <summary>Версия визульного элемента управления</summary>
        </member>
        <member name="P:TFlex.Control.ProductName">
            <summary>Название визуального элемента управления</summary>
        </member>
        <member name="P:TFlex.Control.Page">
            <summary>Текущая страница</summary>
        </member>
        <member name="M:TFlex.Control.RefreshTabs">
            <summary>Обновить закладки текущего документа</summary>
        </member>
        <member name="P:TFlex.Control.Document">
            <summary>Текущий документ</summary>
        </member>
        <member name="M:TFlex.Control.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Control.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Control">
            <summary>Класс визуального элемент управления, позволяющего отображать документы T-FLEX CAD в окне приложения</summary>
        </member>
        <member name="T:TFlex.ControlPageChanged">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, происходящее при изменении активной страницы в визуальном элементе управления</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.ControlContextMenu">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, происходящее при вызове контекстного меню на визуальном элементе управления</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.ControlMouseMoved">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, происходящее при перемещении указателя мыши по визуальному элементу управления.</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.ControlRMouseUp">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, происходящее при отпускании правой кнопки мыши, когда указатель мыши находится на визуальном элементе управления.</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.ControlRMouseDown">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, происходящеe при нажатии правой кнопки мыши, если указатель мыши находится на визуальном элементе управления.</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.ControlMouseDblClick">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, происходящее, когда визуальный элемент управления дважды щелкается мышью.</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.ControlMouseUp">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, происходящее при отпускании кнопки мыши, когда указатель мыши находится на визуальном элементе управления.</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.ControlMouseDown">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, происходящеe при нажатии кнопки мыши, если указатель мыши находится на визуальном элементе управления.</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="P:TFlex.ControlEventArgs.ModelY">
            <summary>Координата Y положения курсора мыши на момент возникновения события(в единицах измерения чертежа)</summary>
        </member>
        <member name="P:TFlex.ControlEventArgs.ModelX">
            <summary>Координата X положения курсора мыши на момент возникновения события(в единицах измерения чертежа)</summary>
        </member>
        <member name="P:TFlex.ControlEventArgs.Cancel">
            <summary>Вызывать обработку базового метода</summary>
        </member>
        <member name="P:TFlex.ControlEventArgs.y">
            <summary>Координата Y положения курсора мыши на момент возникновения события(в пикселях)</summary>
        </member>
        <member name="P:TFlex.ControlEventArgs.x">
            <summary>Координата X положения курсора мыши на момент возникновения события(в пикселях)</summary>
        </member>
        <member name="M:TFlex.ControlEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>Конструктор</summary>
            <param name="_x">Координата X положения курсора мыши на момент возникновения события</param>
            <param name="_y">Координата Y положения курсора мыши на момент возникновения события</param>
        </member>
        <member name="T:TFlex.ControlEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем в визуальном элементе управления</summary>
        </member>
        <member name="F:TFlex.PageTabAlignment.Bottom">
            <summary>Снизу</summary>
        </member>
        <member name="F:TFlex.PageTabAlignment.Top">
            <summary>Сверху</summary>
        </member>
        <member name="P:TFlex.Command.PropetiesWindowHeaderButtonPressedEventArgs.Button">
            <summary>Кнопка служебного окна свойств, которая была нажата</summary>
        </member>
        <member name="T:TFlex.Command.PropetiesWindowHeaderButtonPressedEventArgs">
            <summary>Класс аргументов события, возникающего при нажатии одной из кнопок служебного окна свойств объекта</summary>
        </member>
        <member name="P:TFlex.Command.SelectEventArgs.Result">
            <summary>Результат выбора</summary>
        </member>
        <member name="P:TFlex.Command.SelectEventArgs.OwnerObject">
            <summary>Выбранный составной элемент объекта</summary>
        </member>
        <member name="P:TFlex.Command.SelectEventArgs.Object">
            <summary>Выбранный объект</summary>
        </member>
        <member name="P:TFlex.Command.SelectEventArgs.GroupType">
            <summary>Тип выбранного объекта</summary>
        </member>
        <member name="P:TFlex.Command.SelectEventArgs.Mode">
            <summary>Режим выбора объектов</summary>
        </member>
        <member name="F:TFlex.Command.SelectEventArgs.SelectMode.SelectObjectElements">
            <summary>Выбирать составные элементы объектов</summary>
        </member>
        <member name="F:TFlex.Command.SelectEventArgs.SelectMode.SelectObject">
            <summary>Выбирать все объекты</summary>
        </member>
        <member name="F:TFlex.Command.SelectEventArgs.SelectMode.SelectType">
            <summary>Выбирать объекты одного типа</summary>
        </member>
        <member name="F:TFlex.Command.SelectEventArgs.SelectMode.SelectNone">
            <summary>Не выбирать объекты</summary>
        </member>
        <member name="T:TFlex.Command.SelectEventArgs.SelectMode">
            <summary>Перечислитель режимов выбора объектов</summary>
        </member>
        <member name="T:TFlex.Command.SelectEventArgs">
            <summary>Класс аргументов события, возникающего при выборе объекта</summary>
        </member>
        <member name="P:TFlex.Command.ContinueEventArgs.PreviousCommand">
            <summary>Вложенная команда, которая завершилась</summary>
        </member>
        <member name="P:TFlex.Command.ContinueEventArgs.Result">
            <summary>Объект, который был передан из вложенной команды</summary>
        </member>
        <member name="T:TFlex.Command.ContinueEventArgs">
            <summary>Класс аргументов события завершения выполнения вложенной команды приложения</summary>
            <remarks>Вложенной командой называется команда, функция <c>TFlex.Command.PluginCommand.Run(TFlex.Model.View, bool)</c>
которой вызвана внутри обработчика выполнения другой (вызывающей) команды</remarks>
        </member>
        <member name="P:TFlex.Command.MouseEventArgs.CursorAction">
            <summary>Режим динамической прорисовки курсора</summary>
        </member>
        <member name="T:TFlex.Command.MouseEventArgs">
            <summary>Класс аргументов событий, возникающих при перемещении мыши</summary>
        </member>
        <member name="P:TFlex.Command.KeyEventArgs.Handled">
            <summary>Обработка события завершена</summary>
        </member>
        <member name="P:TFlex.Command.KeyEventArgs.State">
            <summary>Состояние клавиши</summary>
        </member>
        <member name="P:TFlex.Command.KeyEventArgs.Code">
            <summary>Код клавиатуры нажатой клавиши</summary>
        </member>
        <member name="T:TFlex.Command.KeyEventArgs">
            <summary>Класс аргументов события, возникающего при нажатии на клавишу клавиатуры или кнопку автоменю</summary>
        </member>
        <member name="P:TFlex.Command.CursorEventArgs.SelectedObject">
            <summary>Выбранный объект</summary>
        </member>
        <member name="P:TFlex.Command.CursorEventArgs.GY">
            <summary>Координата Y курсора в координатах графического контекста с учётом сетки</summary>
        </member>
        <member name="P:TFlex.Command.CursorEventArgs.GX">
            <summary>Координата X курсора в координатах графического контекста с учётом сетки</summary>
        </member>
        <member name="P:TFlex.Command.CursorEventArgs.DY">
            <summary>Координата Y курсора в координатах графического контекста</summary>
        </member>
        <member name="P:TFlex.Command.CursorEventArgs.DX">
            <summary>Координата X курсора в координатах графического контекста</summary>
        </member>
        <member name="P:TFlex.Command.CursorEventArgs.Y">
            <summary>Координата Y курсора в пикселях</summary>
        </member>
        <member name="P:TFlex.Command.CursorEventArgs.X">
            <summary>Координата X курсора в пикселях</summary>
        </member>
        <member name="T:TFlex.Command.CursorEventArgs">
            <summary>Базовый класс аргументов событий, возникающих при манипуляциях с курсором</summary>
        </member>
        <member name="P:TFlex.Command.ExitEventArgs.Result">
            <summary>Объект, который необходимо передать из вложенной команды в вызывающую</summary>
            <remarks>Применяется только для вложенных команд приложения. Вложенной командой называется команда, функция
<c>TFlex.Command.PluginCommand.Run(TFlex.Model.View, bool)</c> которой вызвана внутри обработчика выполнения другой
(вызывающей) команды</remarks>
        </member>
        <member name="T:TFlex.Command.ExitEventArgs">
            <summary>Класс аргументов события, возникающего при завершении выполнения команды приложения</summary>
        </member>
        <member name="T:TFlex.Command.InitializeEventArgs">
            <summary>Класс аргументов события, возникающего при инициализации команды приложения</summary>
        </member>
        <member name="P:TFlex.Command.CommandEventArgs.Graphics">
            <summary>Графический контекст</summary>
        </member>
        <member name="P:TFlex.Command.CommandEventArgs.Document">
            <summary>Документ, в котором произошло событие</summary>
        </member>
        <member name="P:TFlex.Command.CommandEventArgs.Window">
            <summary>Вид документа (окно), в котором произошло событие</summary>
        </member>
        <member name="T:TFlex.Command.CommandEventArgs">
            <summary>Базовый класс аргументов событий, возникающих при манипуляциях с командами приложения</summary>
        </member>
        <member name="T:TFlex.Command.CursorDrawAction">
            <summary>Перечислитель режимов динамической прорисовки курсора</summary>
        </member>
        <member name="F:TFlex.Command.CursorDrawAction.Show">
            <summary>Прорисовывать</summary>
        </member>
        <member name="F:TFlex.Command.CursorDrawAction.None">
            <summary>Не прорисовывать</summary>
        </member>
        <member name="E:TFlex.Command.PropertiesWindow.HeaderButtonPressed">
            <summary>Событие, возникающее при нажатии одной из кнопок служебного окна свойств</summary>
        </member>
        <member name="M:TFlex.Command.PropertiesWindow.AppendWpfForm(TFlex.Command.PropertiesWindowWpfForm)">
            <summary>Добавить WPF вкладку к служебному окну свойств</summary>
            <param name="form">Вкладка служебного окна</param>
        </member>
        <member name="M:TFlex.Command.PropertiesWindow.AppendForm(TFlex.Command.PropertiesWindowForm)">
            <summary>Добавить вкладку к служебному окну свойств</summary>
            <param name="form">Вкладка служебного окна</param>
        </member>
        <member name="M:TFlex.Command.PropertiesWindow.AppendForm(TFlex.Command.PropertiesWindowFormBase)">
            <summary>Добавить вкладку к служебному окну свойств</summary>
            <param name="form">Вкладка служебного окна</param>
        </member>
        <member name="M:TFlex.Command.PropertiesWindow.AppendBaseForm(TFlex.Command.PropertiesWindowFormBase)">
            <summary>Добавить вкладку к служебному окну свойств</summary>
            <param name="form">Вкладка служебного окна</param>
        </member>
        <member name="M:TFlex.Command.PropertiesWindow.EnableHeaderButton(TFlex.Command.PropertiesWindowHeaderButton,System.Boolean)">
            <summary>Доступность кнопки служебного окна свойств</summary>
            <param name="button">Кнопка окна свойств</param>
            <param name="enable">true - кнопка доступна, false - кнопка заблокирована</param>
        </member>
        <member name="M:TFlex.Command.PropertiesWindow.HeaderButtonEnabled(TFlex.Command.PropertiesWindowHeaderButton)">
            <summary>Доступность кнопки служебного окна свойств</summary>
            <param name="button">Кнопка окна свойств</param>
        </member>
        <member name="P:TFlex.Command.PropertiesWindow.PropertiesHeaderType">
            <summary>Набор кнопок служебного окна свойств</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindow.HeaderType.OkApplyCancel">
            <summary>Завершить редактирование, применить изменения, отменить редактирование</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindow.HeaderType.OkRefreshPreviewCancel">
            <summary>Завершить редактирование, обновить, просмотреть изменения, отменить редактирование</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindow.HeaderType.OkPreviewCancel">
            <summary>Завершить редактирование, просмотреть изменения, отменить редактирование</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindow.HeaderType.None">
            <summary>Нет кнопок</summary>
        </member>
        <member name="T:TFlex.Command.PropertiesWindow.HeaderType">
            <summary>Перечислитель наборов кнопок служебного окна свойств</summary>
        </member>
        <member name="P:TFlex.Command.PropertiesWindow.Caption">
            <summary>Заголовок служебного окна свойств</summary>
        </member>
        <member name="M:TFlex.Command.PropertiesWindow.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Command.PropertiesWindow.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Command.PropertiesWindow">
            <summary>Класс, представляющий служебное окно свойств объекта</summary>
        </member>
        <member name="T:TFlex.Command.PropetiesWindowHeaderButtonPressedEventHandler">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, возникающее при нажатии одной из кнопок служебного окна свойств</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.Command.PropertiesWindowHeaderButton">
            <summary>Перечислитель типов кнопок служебного окна свойств</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindowHeaderButton.Apply">
            <summary>Применить изменения</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindowHeaderButton.Refresh">
            <summary>Обновить</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindowHeaderButton.Preview">
            <summary>Просмотреть изменения</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindowHeaderButton.Cancel">
            <summary>Отменить редактирование</summary>
        </member>
        <member name="F:TFlex.Command.PropertiesWindowHeaderButton.OK">
            <summary>Завершить редактирование</summary>
        </member>
        <member name="P:TFlex.Command.PropertiesWindowWpfForm.Element">
            <summary>Элемент управления, который отображается на вкладке служебного окна свойств</summary>
        </member>
        <member name="P:TFlex.Command.PropertiesWindowWpfForm.Caption">
            <summary>Заголовок вкладки</summary>
        </member>
        <member name="M:TFlex.Command.PropertiesWindowWpfForm.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Command.PropertiesWindowWpfForm.#ctor(System.Windows.UIElement)">
            <summary>Конструктор</summary>
            <param name="element">Элемент управления, который будет отображаться на вкладке служебного окна свойств</param>
        </member>
        <member name="T:TFlex.Command.PropertiesWindowWpfForm">
            <summary>Класс вкладки служебного окна для использования с контролами WPF</summary>
        </member>
        <member name="P:TFlex.Command.PropertiesWindowForm.Control">
            <summary>Элемент управления, который отображается на вкладке служебного окна свойств</summary>
        </member>
        <member name="P:TFlex.Command.PropertiesWindowForm.Caption">
            <summary>Заголовок вкладки</summary>
        </member>
        <member name="M:TFlex.Command.PropertiesWindowForm.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Command.PropertiesWindowForm.#ctor(System.Windows.Forms.Control)">
            <summary>Конструктор</summary>
            <param name="control">Элемент управления, который будет отображаться на вкладке служебного окна свойств</param>
        </member>
        <member name="M:TFlex.Command.PropertiesWindowForm.#ctor">
            <summary>Конструктор по умолчанию (создает развернутую видимую вкладку)</summary>
        </member>
        <member name="T:TFlex.Command.PropertiesWindowForm">
            <summary>Класс вкладки служебного окна</summary>
        </member>
        <member name="P:TFlex.Command.PropertiesWindowFormBase.AutoSize">
            <summary>Автоматически изменять размер окна</summary>
        </member>
        <member name="P:TFlex.Command.PropertiesWindowFormBase.Visible">
            <summary>Свойство видимости вкладки служебного окна свойств</summary>
        </member>
        <member name="P:TFlex.Command.PropertiesWindowFormBase.Expanded">
            <summary>Свойство отображения вкладки служебного окна свойств (развернуто или свернуто)</summary>
        </member>
        <member name="T:TFlex.Command.PropertiesWindowFormBase">
            <summary>Базовый класс для вкладки служебного окна свойств</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.View2D.BasePage">
            <summary>Страница, которая отображается в данном виде, без учёта активированных DrawingView</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.View2D.HasActivatedDrawingViews">
            <summary>Есть ли активированный чертёжный вид хотя бы на одной странице вида</summary>
            <remarks>Активированный DrawingView может подменять результат свойства Page</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.View2D.ZoomRectangle">
            <summary>Прямоугольник, который отображается в данном виде</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.View2D">
            <summary>Данный класс представляет собой 2D вид документа.</summary>
        </member>
        <member name="M:TFlex.Model.View.SetCursor(System.IntPtr)">
            <summary>Установить курсор</summary>
        </member>
        <member name="M:TFlex.Model.View.Split(TFlex.Model.ViewType,TFlex.Model.ViewType,TFlex.Model.ViewType,TFlex.Model.ViewType)">
            <summary>Разделить вид</summary>
        </member>
        <member name="M:TFlex.Model.View.SplitHorizontally(TFlex.Model.ViewType,TFlex.Model.ViewType)">
            <summary>Разделить по горизонтали</summary>
        </member>
        <member name="M:TFlex.Model.View.SplitVertically(TFlex.Model.ViewType,TFlex.Model.ViewType)">
            <summary>Разделить по вертикали</summary>
        </member>
        <member name="M:TFlex.Model.View.Activate">
            <summary>Активизировать вид</summary>
        </member>
        <member name="P:TFlex.Model.View.Page">
            <summary>Страница, которая отображается в данном виде</summary>
        </member>
        <member name="M:TFlex.Model.View.Search(System.Double,System.Double,TFlex.Model.SelectionFilter,System.Double)">
            <summary>Поиск элемента модели</summary>
            <param name="x">Координата X в модельных координатах</param>
            <param name="y">Координата Y в модельных координатах</param>
            <param name="filter">Фильтр выбираемых объектов</param>
            <param name="maxdist">Расстояние до объекта, пикселей</param>
        </member>
        <member name="M:TFlex.Model.View.Search(TFlex.Drawing.Point,TFlex.Model.SelectionFilter,System.Double)">
            <summary>Поиск элемента модели</summary>
            <param name="point">Точка в координатах модели</param>
            <param name="filter">Фильтр выбираемых объектов</param>
            <param name="maxdist">Расстояние до объекта, пикселей</param>
        </member>
        <member name="M:TFlex.Model.View.Select(TFlex.Drawing.Point,TFlex.Model.SelectionFilter,System.Double)">
            <summary>Выбор элемента модели</summary>
            <param name="point">Точка в координатах модели</param>
            <param name="filter">Фильтр выбираемых объектов</param>
            <param name="maxdist">Расстояние до объекта, пикселей</param>
        </member>
        <member name="M:TFlex.Model.View.Select(System.Double,System.Double,TFlex.Model.SelectionFilter,System.Double)">
            <summary>Выбор элемента модели</summary>
            <param name="x">Координата X в модельных координатах</param>
            <param name="y">Координата Y в модельных координатах</param>
            <param name="filter">Фильтр выбираемых объектов</param>
            <param name="maxdist">Расстояние до объекта, пикселей</param>
        </member>
        <member name="M:TFlex.Model.View.Select(System.Drawing.Point,TFlex.Model.SelectionFilter)">
            <summary>Выбор элемента модели</summary>
            <param name="point">Точка в координатах экрана</param>
            <param name="filter">Фильтр выбираемых объектов</param>
        </member>
        <member name="M:TFlex.Model.View.Select(System.Int32,System.Int32,TFlex.Model.SelectionFilter)">
            <summary>Выбор элемента модели</summary>
            <param name="x">Координата X курсора</param>
            <param name="y">Координата Y курсора</param>
            <param name="filter">Фильтр выбираемых объектов</param>
        </member>
        <member name="M:TFlex.Model.View.PointToModel(System.Drawing.Point)">
            <summary>Преобразование точки из экранных координат в модельные</summary>
            <param name="screenPoint">Точка в экранных координатах</param>
        </member>
        <member name="M:TFlex.Model.View.PointToClient(System.Drawing.Point)">
            <summary>Преобразование точки из экранных координат в оконные</summary>
            <param name="screenPoint">Точка в экранных координатах</param>
        </member>
        <member name="M:TFlex.Model.View.PointToScreen(System.Drawing.Point)">
            <summary>Преобразование точки из оконных координат в экранные</summary>
            <param name="clientPoint">Точка в оконных координатах</param>
        </member>
        <member name="P:TFlex.Model.View.HideConstructions">
            <summary>Параметр "Скрыть линии построения"</summary>
        </member>
        <member name="M:TFlex.Model.View.Close">
            <summary>Закрыть вид</summary>
            <returns>true, если операция завершилась успешно</returns>
        </member>
        <member name="P:TFlex.Model.View.HWnd">
            <summary>Дескриптор окна вида</summary>
        </member>
        <member name="P:TFlex.Model.View.Graphics">
            <summary>Объект графического контекста для вывода графического изображения в данный вид</summary>
        </member>
        <member name="P:TFlex.Model.View.Document">
            <summary>Документ, видом которого является данный объект</summary>
        </member>
        <member name="T:TFlex.Model.View">
            <summary>Данный класс реализует функциональность вида документа</summary>
            <remarks>Класс является базовым классом для классов <see cref="T:TFlex.Model.Model2D.View2D" /> и <see cref="T:TFlex.Model.Model3D.View3D" />,
являющимися 2D и 3D видами соответственно</remarks>
        </member>
        <member name="P:TFlex.Command.PluginCommand.DisplayNameForError">
            <summary>Название команды для отображения в сообщениях об ошибке</summary>
        </member>
        <member name="P:TFlex.Command.PluginCommand.SupportedBehavior">
            <summary>Поддерживаемое командой поведение</summary>
        </member>
        <member name="M:TFlex.Command.PluginCommand.OnSelect(TFlex.Command.SelectEventArgs)">
            <summary>Фильтр выбираемых объектов</summary>
            <param name="e">Аргументы события</param>
            <remarks>В обработчике этого события надо отбрасывать неподходящие объекты</remarks>
        </member>
        <member name="M:TFlex.Command.PluginCommand.OnShowCursor(TFlex.Command.MouseEventArgs)">
            <summary>Динамическая отрисовка курсора</summary>
            <param name="e">Аргументы события</param>
            <remarks>Данная функция вызывается в тот момент, когда требуется прорисовка динамического курсора при перемещении мыши</remarks>
        </member>
        <member name="M:TFlex.Command.PluginCommand.OnMouseMove(TFlex.Command.MouseEventArgs)">
            <summary>Обработчик перемещения курсора мыши</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Command.PluginCommand.OnKeyPressed(TFlex.Command.KeyEventArgs)">
            <summary>Обработчик нажатия клавиши на клавиатуре или кнопки автоменю</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Command.PluginCommand.OnContinue(TFlex.Command.ContinueEventArgs)">
            <summary>Обработчик завершения выполнения вложенной команды</summary>
            <param name="e">Аргументы события</param>
            <remarks>Данную функцию необходимо переопределить для того, чтобы получить управление при завершении вложенной команды и код её завершения</remarks>
        </member>
        <member name="M:TFlex.Command.PluginCommand.OnExit(TFlex.Command.ExitEventArgs)">
            <summary>Обработчик выхода из команды</summary>
            <param name="e">Аргументы события</param>
            <remarks>Данную функцию необходимо переопределить для того, чтобы получить управление в момент завершения выполнения команды.
Это сообщение приходит последним в процессе выполнения команды</remarks>
        </member>
        <member name="M:TFlex.Command.PluginCommand.OnInitialize(TFlex.Command.InitializeEventArgs)">
            <summary>Обработчик инициализации команды</summary>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.Command.PluginCommand.ResetSelectedObject">
            <summary>Отменить выбор последнего объекта</summary>
        </member>
        <member name="M:TFlex.Command.PluginCommand.PassSelected">
            <summary>Передать ранее выбранный с помощью метода <see cref="M:TFlex.Command.PluginCommand.SelectByEvent(TFlex.Command.CursorEventArgs,System.Boolean)" /> объект системе.</summary>
            <remarks>Вызов данного метода имитирует выбор объекта в режиме ожидания.</remarks>
        </member>
        <member name="M:TFlex.Command.PluginCommand.SelectByEvent(TFlex.Command.CursorEventArgs,System.Boolean)">
            <summary>Функция выбора объекта</summary>
            <remarks>Этим методом можно пользоваться в обработчике щелчка мыши или нажатия на Enter. Изнутри метода вызывается
обработчик Select, выбранный объект помещается в контейнер (см. <see cref="T:TFlex.Model.SelectionContainer" />).</remarks>
            <param name="ev">Аргументы события, возникающие при манипуляциях с курсором</param>
            <param name="mark">Подсвечивать выбираемые объекты</param>
        </member>
        <member name="E:TFlex.Command.PluginCommand.Select">
            <summary>Событие, возникающее при выборе объекта</summary>
            <remarks>В обработчике этого события надо отбрасывать неподходящие объекты</remarks>
        </member>
        <member name="E:TFlex.Command.PluginCommand.ShowCursor">
            <summary>Событие, возникающее при прорисовке динамического курсора при перемещении мыши</summary>
            <remarks>Данное событие необходимо реализовать в тот момент, когда требуется прорисовка динамического курсора при перемещении мыши</remarks>
        </member>
        <member name="E:TFlex.Command.PluginCommand.MouseMove">
            <summary>Событие, возникающее при перемещении курсора</summary>
        </member>
        <member name="E:TFlex.Command.PluginCommand.KeyPressed">
            <summary>Событие, возникающее при нажатии клавиши клавиатуры или кнопки автоменю</summary>
        </member>
        <member name="E:TFlex.Command.PluginCommand.Exit">
            <summary>Событие завершения выполнения команды</summary>
            <remarks>Данное событие необходимо реализовать для того, чтобы получить управление в момент завершения выполнения команды.
Это сообщение приходит последним в процессе выполнения команды</remarks>
        </member>
        <member name="E:TFlex.Command.PluginCommand.Continue">
            <summary>Событие завершения выполнения вложенной команды</summary>
            <remarks>Данное событие необходимо реализовать для того, чтобы получить управление при завершении вложенной команды и код её завершения</remarks>
        </member>
        <member name="E:TFlex.Command.PluginCommand.Initialize">
            <summary>Событие инициализации команды</summary>
        </member>
        <member name="P:TFlex.Command.PluginCommand.PropertiesWindow">
            <summary>Окно свойств команды</summary>
        </member>
        <member name="P:TFlex.Command.PluginCommand.Automenu">
            <summary>Автоменю команды</summary>
        </member>
        <member name="P:TFlex.Command.PluginCommand.IsTransparentChangesEnabled">
            <summary>Разрешает блоку отмены действий оставаться открытым между событиями команды</summary>
        </member>
        <member name="P:TFlex.Command.PluginCommand.ID">
            <summary>Возвращает зарегестрированный идентификатор команды</summary>
        </member>
        <member name="M:TFlex.Command.PluginCommand.Terminate">
            <summary>Завершить выполнение команды</summary>
        </member>
        <member name="M:TFlex.Command.PluginCommand.Run(TFlex.Model.View,System.Boolean)">
            <summary>Запустить команду на выполнение</summary>
            <param name="subCommand">Указание, должна ли текущая команда быть остановлена (false; старое поведение)
перед запуском этой или нет (true)</param>
        </member>
        <member name="M:TFlex.Command.PluginCommand.Run(TFlex.Model.View)">
            <summary>Запустить команду на выполнение</summary>
        </member>
        <member name="P:TFlex.Command.PluginCommand.Owner">
            <summary>Получить приложение команды</summary>
        </member>
        <member name="M:TFlex.Command.PluginCommand.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Command.PluginCommand.#ctor(TFlex.Plugin)">
            <summary>Конструктор команды</summary>
            <param name="OwnerPlugin">Объект приложения в котором произошел вызов команды</param>
        </member>
        <member name="T:TFlex.Command.PluginCommand">
            <summary>Реализация функциональности команды приложения</summary>
            <remarks>При получении сообщения через функцию <see cref="!:TFlex::Plugin::OnCommand(TFlex.Model.Document, System.UInt32)" />
приложение конструирует объект данного класса и запускает его на выполнение при помощи функции <c>Run</c>.
После этого до завершения данной команды или запуска другой команды сообщения Windows транслируются в вызовы функция данного класса.</remarks>
        </member>
        <member name="M:TFlex.Command.FilterOwnerExtensions.ShowSelectionFilterSet(TFlex.Command.IFilterOwner,TFlex.Command.SelectorSetType)">
            <summary>Показать конфигурацию селектора</summary>
            <param name="setType">Набор для селекции</param>
        </member>
        <member name="M:TFlex.Command.FilterOwnerExtensions.ShowSelectionFilterButton(TFlex.Command.IFilterOwner,TFlex.Model.ObjectType,System.Boolean)">
            <summary>Показать кнопку фильтра селекции</summary>
            <param name="objectType">Тип модельного объекта для которого требуется включить селекцию</param>
            <param name="show">Добавить фильтр</param>
        </member>
        <member name="M:TFlex.Command.FilterOwnerExtensions.HideAllSelectionFilterButtons(TFlex.Command.IFilterOwner)">
            <summary>Скрыть все фильтры селекции</summary>
        </member>
        <member name="M:TFlex.Command.FilterOwnerExtensions.SetSelectionFilterButtonToolTip(TFlex.Command.IFilterOwner,TFlex.Model.ObjectType,System.String)">
            <summary>Установить подсказку у кнопки селектора</summary>
            <param name="objectType">Тип модельного объекта для которого требуется включить селекцию</param>
            <param name="toolTip">Подсказка для кнопки</param>
        </member>
        <member name="M:TFlex.Command.FilterOwnerExtensions.GetSelectionFilterButtonState(TFlex.Command.IFilterOwner,TFlex.Model.ObjectType,System.Boolean@,System.Boolean@)">
            <summary>Получить состояние кнопки селекции</summary>
            <param name="objectType">Тип модельного объекта для которого требуется включить селекцию</param>
            <param name="checked">Кнопка селектера активирована</param>
            <param name="disabled">Кнопка селектора недоступна для изменения</param>
        </member>
        <member name="M:TFlex.Command.FilterOwnerExtensions.SetSelectionFilterButtonState(TFlex.Command.IFilterOwner,TFlex.Model.ObjectType,System.Boolean,System.Boolean)">
            <summary>Установить состояние кнопки селекции</summary>
            <param name="objectType">Тип модельного объекта для которого требуется включить селекцию</param>
            <param name="checked">Активировать фильтр</param>
            <param name="disabled">Сделать недоступным для изменения</param>
        </member>
        <member name="M:TFlex.Command.FilterOwnerExtensions.ResumeSelectionFilterNotifications(TFlex.Command.IFilterOwner)">
            <summary>Закончить настройку панели фильтров</summary>
            <remarks>Возобновляет перерисовку панели</remarks>
        </member>
        <member name="M:TFlex.Command.FilterOwnerExtensions.SuspendSelectionFilterNotifications(TFlex.Command.IFilterOwner)">
            <summary>Начать настройку панели фильтров</summary>
            <remarks>Приостанавливает на время настройки перерисовку панели.
После настройки панели необходимо вызвать метод:
<see cref="!:TFlex::Command::FilterOwnerExtensions::EndSelectionFilterConfiguration()" /></remarks>
        </member>
        <member name="M:TFlex.Command.FilterOwner.OnSelectionFilterButtonClick(TFlex.Command.SelectionFilterButtonClickEventArgs)">
            <summary>Вызывает событие <see cref="E:TFlex.Command.FilterOwner.SelectionFilterButtonClick" /></summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Command.FilterOwner.RemoveOwnSelectionFilterButtons">
            <summary>Удалить все созданные этим объектом кнопки селекции</summary>
        </member>
        <member name="M:TFlex.Command.FilterOwner.CreateSelectionFilterButton(System.Guid,System.String,TFlex.Command.SelectionFilterButton)">
            <summary>Создать кнопку селекции</summary>
            <param name="iconId">Идентификатор, использованный для регистрации иконки при помощи
<see cref="!:TFlex::Command::CustomCommand::RegisterAutomenuIcon" /></param>
            <param name="toolTip">Подсказка для кнопки</param>
            <param name="neighbor">Существующая кнопка селекции, которая должна предшествовать новой</param>
            <returns>Созданная кнопка либо <c>null</c> в случае ошибки</returns>
            <remarks>Добавляет кнопку в конец панели, если <c>neighbor</c> не является существующей кнопкой селекции</remarks>
        </member>
        <member name="M:TFlex.Command.FilterOwner.CreateSelectionFilterButton(System.Guid,System.String,TFlex.Model.ObjectType)">
            <summary>Создать кнопку селекции</summary>
            <param name="iconId">Идентификатор, использованный для регистрации иконки при помощи
<see cref="!:TFlex::Command::CustomCommand::RegisterAutomenuIcon" /></param>
            <param name="toolTip">Подсказка для кнопки</param>
            <param name="neighbor">Тип модельного объекта, соответствующий существующей кнопке селекции, которая должна
предшествовать новой</param>
            <returns>Созданная кнопка либо <c>null</c> в случае ошибки</returns>
            <remarks>Добавляет кнопку в конец панели, если <c>neighbor</c> не соответствует ни одной из существующих
кнопок</remarks>
        </member>
        <member name="M:TFlex.Command.FilterOwner.CreateSelectionFilterButton(System.Guid,System.String)">
            <summary>Создать кнопку селекции</summary>
            <param name="iconId">Идентификатор, использованный для регистрации иконки при помощи
<see cref="!:TFlex::Command::CustomCommand::RegisterAutomenuIcon" /></param>
            <param name="toolTip">Подсказка для кнопки</param>
            <returns>Созданная кнопка либо <c>null</c> в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Command.FilterOwner.OnSelectionFilterButtonClick(System.Int32)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="T:TFlex.Command.SelectorSetType">
            <summary>Конфигурация селектора</summary>
        </member>
        <member name="F:TFlex.Command.SelectorSetType.BasicSetFor3D">
            <summary>3D элементы</summary>
        </member>
        <member name="F:TFlex.Command.SelectorSetType.BasicSetFor2D">
            <summary>2D элементы</summary>
        </member>
        <member name="T:TFlex.Command.CommandBehavior">
            <summary>Поведение команды</summary>
        </member>
        <member name="F:TFlex.Command.CommandBehavior.DisableAutomenuIn3DView">
            <summary>Automenu commands will be disabled when 3d view is active</summary>
        </member>
        <member name="F:TFlex.Command.CommandBehavior.MouseButtonsPressedIn2dView">
            <summary>Key pressed event for mouse buttons will fire for 2D view</summary>
        </member>
        <member name="F:TFlex.Command.CommandBehavior.MouseButtonsUpEvents">
            <summary>Command expects events to fire when mouse buttons come up</summary>
        </member>
        <member name="T:TFlex.Command.SelectEventHandler">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, возникающее при выборе объекта</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.Command.MouseEventHandler">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, возникающее при перемещении курсора</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.Command.KeyEventHandler">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, возникающее при нажатии клавиши клавиатуры или кнопки автоменю</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.Command.ContinueEventHandler">
            <summary>Делегат представляющий метод, который будет обрабатывать событие завершения выполнения вложенной команды</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.Command.ExitEventHandler">
            <summary>Делегат представляющий метод, который будет обрабатывать событие завершения выполнения команды</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="T:TFlex.Command.InitializeEventHandler">
            <summary>Делегат представляющий метод, который будет обрабатывать событие инициализации команды приложения</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:PROJECTION_KNOT.GetVariant">
Номер пересечения в случае пересечения с кривой
</member>
        <member name="M:PROJECTION_KNOT.SetPointMethod(System.UInt32)">
Метод получения коодрнат проецируемой 3D точки 
</member>
        <member name="T:CTfw32Doc">
#include "tfname.h"
</member>
        <member name="M:DRAW_SPLINE.PreprocessTangentsLegacy">
            <summary>  Метод для создания производных по узлам на краях, применяется при конверитации страх данных в новые </summary>
        </member>
        <member name="M:DRAW_SPLINE.PreprocessOldVersions">
            <summary>  Обработать старую версию сплайна </summary>
        </member>
        <member name="M:DRAW_SPLINE.GetData">
            <summary>  Получить указатель на данные для построения DRAW_SPLINE </summary>
        </member>
        <member name="F:CBitmapRenderTarget.m_pBitmapRenderTarget">
            <summary>
A pointer to an ID2D1BitmapRenderTarget object.
</summary>
        </member>
        <member name="M:CBitmapRenderTarget.GetBitmap(CD2DBitmap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. </summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="bitmap">When this method returns, contains the valid bitmap for this render target. This bitmap can be used for drawing operations.</param>
        </member>
        <member name="M:CBitmapRenderTarget.op_Implicit~ID2D1BitmapRenderTarget*">
            <summary>
Returns ID2D1BitmapRenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1BitmapRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CBitmapRenderTarget.GetBitmapRenderTarget">
            <summary>
Returns ID2D1BitmapRenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1BitmapRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CBitmapRenderTarget.Detach">
            <summary>
Detaches render target interface from the object</summary>
            <returns> 
Pointer to detached render target interface.</returns>
        </member>
        <member name="M:CBitmapRenderTarget.Attach(ID2D1BitmapRenderTarget*)">
            <summary>
Attaches existing render target interface to the object</summary>
            <param name="pTarget">Existing render target interface. Cannot be NULL</param>
        </member>
        <member name="M:CBitmapRenderTarget.#ctor">
            <summary>
Constructs a CBitmapRenderTarget object.</summary>
        </member>
        <member name="F:CDCRenderTarget.m_pDCRenderTarget">
            <summary>
A pointer to an ID2D1DCRenderTarget object.
</summary>
        </member>
        <member name="M:CDCRenderTarget.op_Implicit~ID2D1DCRenderTarget*">
            <summary>
Returns ID2D1DCRenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1DCRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CDCRenderTarget.GetDCRenderTarget">
            <summary>
Returns ID2D1DCRenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1DCRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CDCRenderTarget.BindDC(CDC!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Binds the render target to the device context to which it issues drawing commands</summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="dc">The device context to which the render target issues drawing commands</param>
            <param name="rect">The dimensions of the handle to a device context (HDC) to which the render target is bound</param>
        </member>
        <member name="M:CDCRenderTarget.Create(D2D1_RENDER_TARGET_PROPERTIES!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a CDCRenderTarget.</summary>
            <returns>
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="props">The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering.</param>
        </member>
        <member name="M:CDCRenderTarget.Detach">
            <summary>
Detaches render target interface from the object</summary>
            <returns> 
Pointer to detached render target interface.</returns>
        </member>
        <member name="M:CDCRenderTarget.Attach(ID2D1DCRenderTarget*)">
            <summary>
Attaches existing render target interface to the object</summary>
            <param name="pTarget">Existing render target interface. Cannot be NULL</param>
        </member>
        <member name="M:CDCRenderTarget.#ctor">
            <summary>
Constructs a CDCRenderTarget object.</summary>
        </member>
        <member name="T:CDCRenderTarget">
            <summary>
ID2D1DCRenderTarget wrapper.
</summary>
        </member>
        <member name="F:CHwndRenderTarget.m_pHwndRenderTarget">
            <summary>
A pointer to an ID2D1HwndRenderTarget object.
</summary>
        </member>
        <member name="M:CHwndRenderTarget.Resize(CD2DSizeU!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Changes the size of the render target to the specified pixel size</summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="size">The new size of the render target in device pixels</param>
        </member>
        <member name="M:CHwndRenderTarget.CheckWindowState">
            <summary>
Indicates whether the HWND associated with this render target is occluded.</summary>
            <returns>
A value that indicates whether the HWND associated with this render target is occluded.</returns>
        </member>
        <member name="M:CHwndRenderTarget.GetHwnd">
            <summary>
Returns the HWND associated with this render target.</summary>
            <returns>
The HWND associated with this render target.</returns>
        </member>
        <member name="M:CHwndRenderTarget.op_Implicit~ID2D1HwndRenderTarget*">
            <summary>
Returns ID2D1HwndRenderTarget interface.</summary>
            <returns>
Pointer to an ID2D1HwndRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CHwndRenderTarget.GetHwndRenderTarget">
            <summary>
Returns ID2D1HwndRenderTarget interface.</summary>
            <returns>
Pointer to an ID2D1HwndRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CHwndRenderTarget.ReCreate(HWND__*)">
            <summary>
Re-creates a render target associated with the window</summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="hWnd">The HWND associated with this render target</param>
        </member>
        <member name="M:CHwndRenderTarget.Create(HWND__*)">
            <summary>
Creates a render target associated with the window </summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE</returns>
            <param name="hWnd">The HWND associated with this render target</param>
        </member>
        <member name="M:CHwndRenderTarget.Detach">
            <summary>
Detaches render target interface from the object</summary>
            <returns> 
Pointer to detached render target interface.</returns>
        </member>
        <member name="M:CHwndRenderTarget.Attach(ID2D1HwndRenderTarget*)">
            <summary>
Attaches existing render target interface to the object</summary>
            <param name="pTarget">Existing render target interface. Cannot be NULL</param>
        </member>
        <member name="M:CHwndRenderTarget.#ctor(HWND__*)">
            <summary>
Constructs a CHwndRenderTarget object from HWND.</summary>
            <param name="hwnd">The HWND associated with this render target</param>
        </member>
        <member name="T:CHwndRenderTarget">
            <summary>
ID2D1HwndRenderTarget wrapper.
</summary>
        </member>
        <member name="F:CRenderTarget.m_pTextFormatDefault">
            <summary>
A pointer to CD2DTextFormat object that contains a default text format.
</summary>
        </member>
        <member name="F:CRenderTarget.m_lstResources">
            <summary>
A list of pointers to CD2DResource objects.
</summary>
        </member>
        <member name="F:CRenderTarget.m_pRenderTarget">
            <summary>
A pointer to an ID2D1RenderTarget object.
</summary>
        </member>
        <member name="M:CRenderTarget.VerifyResource(CD2DResource*)">
            <summary>
Verifies CD2DResource object validity; creates the object if it didn't already exist.</summary>
            <param name="pResource">Pointer to CD2DResource object.</param>
            <returns> 
TRUE is object if valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CRenderTarget.PopAxisAlignedClip">
            <summary>
Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations.</summary>
        </member>
        <member name="M:CRenderTarget.PushAxisAlignedClip(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,D2D1_ANTIALIAS_MODE)">
            <summary>
Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations.</summary>
            <param name="rectClip">The size and position of the clipping area, in device-independent pixels.</param>
            <param name="mode">The antialiasing mode that is used to draw the edges of clip rects that have subpixel boundaries, and to blend the clip with the scene contents. The blending is performed once when the PopAxisAlignedClip method is called, and does not apply to each primitive within the layer.</param>
        </member>
        <member name="M:CRenderTarget.RestoreDrawingState(ID2D1DrawingStateBlock*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets the render target's drawing state to that of the specified ID2D1DrawingStateBlock.</summary>
            <param name="drawingStateBlock">The new drawing state of the render target.</param>
        </member>
        <member name="M:CRenderTarget.SaveDrawingState(ID2D1DrawingStateBlock*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Saves the current drawing state to the specified ID2D1DrawingStateBlock.</summary>
            <param name="drawingStateBlock">When this method returns, contains the current drawing state of the render target. This parameter must be initialized before passing it to the method.</param>
        </member>
        <member name="M:CRenderTarget.Flush(System.UInt64*,System.UInt64*)">
            <summary>
Executes all pending drawing commands.</summary>
            <param name="tag1">Contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</param>
            <param name="tag2">Contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</param>
        </member>
        <member name="M:CRenderTarget.PopLayer">
            <summary>
Stops redirecting drawing operations to the layer that is specified by the last PushLayer call.</summary>
        </member>
        <member name="M:CRenderTarget.PushLayer(D2D1_LAYER_PARAMETERS!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DLayer*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Adds the specified layer to the render target so that it receives all subsequent drawing operations until PopLayer is called.</summary>
            <param name="layerParameters">The content bounds, geometric mask, opacity, opacity mask, and antialiasing options for the layer.</param>
            <param name="layer">The layer that receives subsequent drawing operations.</param>
        </member>
        <member name="M:CRenderTarget.CreateCompatibleRenderTarget(CBitmapRenderTarget*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DSizeF,CD2DSizeU,D2D1_PIXEL_FORMAT*,D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS)">
            <summary>
Creates a new bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target .</summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="bitmapTarget">When this method returns, contains the address of a pointer to a new bitmap render target. This parameter is passed uninitialized.</param>
            <param name="sizeDesired">The desired size of the new render target in device-independent pixels if it should be different from the original render target, or NULL. For more information, see the Remarks section.</param>
            <param name="sizePixelDesired">The desired size of the new render target in pixels if it should be different from the original render target, or NULL. For more information, see the Remarks section.</param>
            <param name="desiredFormat">The desired pixel format and alpha mode of the new render target, or NULL. If the pixel format is set to DXGI_FORMAT_UNKNOWN or if this parameter is null, the new render target uses the same pixel format as the original render target. If the alpha mode is D2D1_ALPHA_MODE_UNKNOWN or this parameter is NULL, the alpha mode of the new render target defaults to D2D1_ALPHA_MODE_PREMULTIPLIED. For information about supported pixel formats, see Supported Pixel Formats and Alpha Modes.</param>
            <param name="options">A value that specifies whether the new render target must be compatible with GDI.</param>
        </member>
        <member name="M:CRenderTarget.GetTransform(D2D_MATRIX_3X2_F*)">
            <summary>
Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.</summary>
            <param name="transform">The transform to apply to the render target.</param>
        </member>
        <member name="M:CRenderTarget.SetTransform(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.</summary>
            <param name="transform">The transform to apply to the render target.</param>
        </member>
        <member name="M:CRenderTarget.SetTransform(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.</summary>
            <param name="transform">The transform to apply to the render target.</param>
        </member>
        <member name="M:CRenderTarget.GetTextRenderingParams(IDWriteRenderingParams**)">
            <summary>
Retrieves the render target's current text rendering options.</summary>
            <param name="textRenderingParams">When this method returns, textRenderingParamscontains the address of a pointer to the render target's current text rendering options.</param>
        </member>
        <member name="M:CRenderTarget.SetTextRenderingParams(IDWriteRenderingParams*)">
            <summary>
Specifies text rendering options to be applied to all subsequent text and glyph drawing operations.</summary>
            <param name="textRenderingParams">The text rendering options to be applied to all subsequent text and glyph drawing operations; NULL to clear current text rendering options.</param>
        </member>
        <member name="M:CRenderTarget.GetTextAntialiasMode">
            <summary>
Gets the current antialiasing mode for text and glyph drawing operations.</summary>
            <returns>
Current antialiasing mode for text and glyph drawing operations.</returns>
        </member>
        <member name="M:CRenderTarget.SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE)">
            <summary>
Specifies the antialiasing mode to use for subsequent text and glyph drawing operations.</summary>
            <param name="textAntialiasMode">The antialiasing mode to use for subsequent text and glyph drawing operations.</param>
        </member>
        <member name="M:CRenderTarget.GetAntialiasMode">
            <summary>
Retrieves the current antialiasing mode for nontext drawing operations.</summary>
            <returns>
Current antialiasing mode for nontext drawing operations.</returns>
        </member>
        <member name="M:CRenderTarget.SetAntialiasMode(D2D1_ANTIALIAS_MODE)">
            <summary>
Sets the antialiasing mode of the render target. The antialiasing mode applies to all subsequent drawing operations, excluding text and glyph drawing operations.</summary>
            <param name="antialiasMode">The antialiasing mode for future drawing operations.</param>
        </member>
        <member name="M:CRenderTarget.FillMesh(CD2DMesh*,CD2DBrush*)">
            <summary>
Paints the interior of the specified mesh.</summary>
            <param name="pMesh">The mesh to paint.</param>
            <param name="pBrush">The brush used to paint the mesh.</param>
        </member>
        <member name="M:CRenderTarget.DrawGlyphRun(CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,DWRITE_GLYPH_RUN!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,DWRITE_MEASURING_MODE)">
            <summary>
Draws the specified glyphs.</summary>
            <param name="ptBaseLineOrigin">The origin, in device-independent pixels, of the glyphs' baseline.</param>
            <param name="glyphRun">The glyphs to render.</param>
            <param name="pForegroundBrush">The brush used to paint the specified glyphs.</param>
            <param name="measuringMode">A value that indicates how glyph metrics are used to measure text when it is formatted. The default value is DWRITE_MEASURING_MODE_NATURAL.</param>
        </member>
        <member name="M:CRenderTarget.FillGeometry(CD2DGeometry*,CD2DBrush*,CD2DBrush*)">
            <summary>
Paints the interior of the specified geometry.</summary>
            <param name="pGeometry">The geometry to paint.</param>
            <param name="pBrush">The brush used to paint the geometry's interior.</param>
            <param name="pOpacityBrush">The opacity mask to apply to the geometry;NULL for no opacity mask. If an opacity mask (the opacityBrush parameter) is specified, brush must be an ID2D1BitmapBrush that has its x- and y-extend modes set to D2D1_EXTEND_MODE_CLAMP. For more information, see the Remarks section.</param>
        </member>
        <member name="M:CRenderTarget.DrawGeometry(CD2DGeometry*,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws the outline of the specified geometry using the specified stroke style.</summary>
            <param name="pGeometry">The geometry to draw.</param>
            <param name="pBrush">The brush used to paint the geometry's stroke.</param>
            <param name="fStrokeWidth">The thickness of the geometry's stroke. The stroke is centered on the geometry's outline.</param>
            <param name="strokeStyle">The style of stroke to apply to the geometry's outline, or NULL to paint a solid stroke.</param>
        </member>
        <member name="M:CRenderTarget.DrawBitmap(CD2DBitmap*,CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,D2D1_BITMAP_INTERPOLATION_MODE,CD2DRectF!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Draws the formatted text described by the specified IDWriteTextLayout object.</summary>
            <param name="pBitmap">The bitmap to render.</param>
            <param name="rectDest">The size and position, in device-independent pixels in the render target's coordinate space, of the area to which the bitmap is drawn. If the rectangle is not well-ordered, nothing is drawn, but the render target does not enter an error state.</param>
            <param name="fOpacity">A value between 0.0f and 1.0f, inclusive, that specifies an opacity value to apply to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.</param>
            <param name="interpolationMode">The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation.</param>
            <param name="pRectSrc">The size and position, in device-independent pixels in the bitmap's coordinate space, of the area within the bitmap to draw.</param>
        </member>
        <member name="M:CRenderTarget.DrawTextLayout(CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DTextLayout*,CD2DBrush*,D2D1_DRAW_TEXT_OPTIONS)">
            <summary>
Draws the formatted text described by the specified IDWriteTextLayout object.</summary>
            <param name="ptOrigin">The point, described in device-independent pixels, at which the upper-left corner of the text described by textLayout is drawn.</param>
            <param name="textLayout">The formatted text to draw. Any drawing effects that do not inherit from ID2D1Resource are ignored. If there are drawing effects that inherit from ID2D1Resource that are not brushes, this method fails and the render target is put in an error state.</param>
            <param name="pBrushForeground">The brush used to paint any text in textLayout that does not already have a brush associated with it as a drawing effect (specified by the IDWriteTextLayout::SetDrawingEffect method).</param>
            <param name="options">A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle. The default value is D2D1_DRAW_TEXT_OPTIONS_NONE, which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle.</param>
        </member>
        <member name="M:CRenderTarget.DrawTextW(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,CD2DTextFormat*,D2D1_DRAW_TEXT_OPTIONS,DWRITE_MEASURING_MODE)">
            <summary>
Draws the specified text using the format information provided by an IDWriteTextFormat object.</summary>
            <param name="strText">A pointer to an array of Unicode characters to draw.</param>
            <param name="rect">The size and position of the area in which the text is drawn.</param>
            <param name="pForegroundBrush">The brush used to paint the text.</param>
            <param name="textFormat">An object that describes formatting details of the text to draw, such as the font, the font size, and flow direction.</param>
            <param name="options">A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle. The default value is D2D1_DRAW_TEXT_OPTIONS_NONE, which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle.</param>
            <param name="measuringMode">A value that indicates how glyph metrics are used to measure text when it is formatted. The default value is DWRITE_MEASURING_MODE_NATURAL.</param>
        </member>
        <member name="M:CRenderTarget.FillOpacityMask(CD2DBitmap*,CD2DBrush*,D2D1_OPACITY_MASK_CONTENT,CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Applies the opacity mask described by the specified bitmap to a brush and uses that brush to paint a region of the render target.</summary>
            <param name="pOpacityMask">The position and radius, in device-independent pixels, of the ellipse to paint.</param>
            <param name="pBrush">The brush used to paint the region of the render target specified by destinationRectangle.</param>
            <param name="content">The type of content the opacity mask contains. The value is used to determine the color space in which the opacity mask is blended.</param>
            <param name="rectDest">The region of the render target to paint, in device-independent pixels.</param>
            <param name="rectSrc">The region of the bitmap to use as the opacity mask, in device-independent pixels.</param>
        </member>
        <member name="M:CRenderTarget.DrawLine(CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws a line between the specified points using the specified stroke style.</summary>
            <param name="ptFrom">The start point of the line, in device-independent pixels.</param>
            <param name="ptTo">The end point of the line, in device-independent pixels.</param>
            <param name="pBrush">The brush used to paint the line's stroke.</param>
            <param name="fStrokeWidth">A value greater than or equal to 0.0f that specifies the width of the stroke. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</param>
            <param name="strokeStyle">The style of stroke to paint, or NULL to paint a solid line.</param>
        </member>
        <member name="M:CRenderTarget.FillEllipse(CD2DEllipse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*)">
            <summary>
Paints the interior of the specified ellipse.</summary>
            <param name="ellipse">The position and radius, in device-independent pixels, of the ellipse to paint.</param>
            <param name="pBrush">The brush used to paint the interior of the ellipse.</param>
        </member>
        <member name="M:CRenderTarget.DrawEllipse(CD2DEllipse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws the outline of the specified ellipse using the specified stroke style.</summary>
            <param name="ellipse">The position and radius of the ellipse to draw, in device-independent pixels.</param>
            <param name="pBrush">The brush used to paint the ellipse's outline.</param>
            <param name="fStrokeWidth">The thickness of the ellipse's stroke. The stroke is centered on the ellipse's outline.</param>
            <param name="strokeStyle">The style of stroke to apply to the ellipse's outline, or NULL to paint a solid stroke.</param>
        </member>
        <member name="M:CRenderTarget.FillRoundedRectangle(CD2DRoundedRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*)">
            <summary>
Paints the interior of the specified rounded rectangle.</summary>
            <param name="rectRounded">The dimensions of the rounded rectangle to paint, in device independent pixels.</param>
            <param name="pBrush">The brush used to paint the interior of the rounded rectangle.</param>
        </member>
        <member name="M:CRenderTarget.DrawRoundedRectangle(CD2DRoundedRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws the outline of the specified rounded rectangle using the specified stroke style.</summary>
            <param name="rectRounded">The dimensions of the rounded rectangle to draw, in device-independent pixels.</param>
            <param name="pBrush">The brush used to paint the rounded rectangle's outline.</param>
            <param name="fStrokeWidth">The width of the rounded rectangle's stroke. The stroke is centered on the rounded rectangle's outline. The default value is 1.0f.</param>
            <param name="strokeStyle">The style of the rounded rectangle's stroke, or NULL to paint a solid stroke. The default value is NULL.</param>
        </member>
        <member name="M:CRenderTarget.FillRectangle(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*)">
            <summary>
Paints the interior of the specified rectangle.</summary>
            <param name="rect">The dimension of the rectangle to paint, in device-independent pixels.</param>
            <param name="pBrush">The brush used to paint the rectangle's interior.</param>
        </member>
        <member name="M:CRenderTarget.DrawRectangle(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws the outline of a rectangle that has the specified dimensions and stroke style.</summary>
            <param name="rect">The dimensions of the rectangle to draw, in device-independent pixels</param>
            <param name="pBrush">The brush used to paint the rectangle's stroke</param>
            <param name="fStrokeWidth">A value greater than or equal to 0.0f that specifies the width of the rectangle's stroke. The stroke is centered on the rectangle's outline.</param>
            <param name="strokeStyle">The style of stroke to paint, or NULL to paint a solid stroke.</param>
        </member>
        <member name="M:CRenderTarget.Clear(_D3DCOLORVALUE)">
            <summary>
Clears the drawing area to the specified color.</summary>
            <param name="color">The color to which the drawing area is cleared.</param>
        </member>
        <member name="M:CRenderTarget.COLORREF_TO_D2DCOLOR(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>
Converts GDI color and alpha values to the D2D1_COLOR_F object.</summary>
            <param name="color">RGB value.</param>
            <param name="nAlpha">Alpha value.</param>
            <returns>
D2D1_COLOR_F value.</returns>
        </member>
        <member name="M:CRenderTarget.EndDraw">
            <summary>
Ends drawing operations on the render target and indicates the current error state and associated tags.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:CRenderTarget.BeginDraw">
            <summary>
Initiates drawing on this render target.</summary>
        </member>
        <member name="M:CRenderTarget.Detach">
            <summary>
Detaches render target interface from the object</summary>
            <returns> 
Pointer to detached render target interface.</returns>
        </member>
        <member name="M:CRenderTarget.Attach(ID2D1RenderTarget*)">
            <summary>
Attaches existing render target interface to the object</summary>
            <param name="pRenderTarget">Existing render target interface. Cannot be NULL</param>
        </member>
        <member name="M:CRenderTarget.GetMaximumBitmapSize">
            <summary>
Gets the maximum size, in device-dependent units (pixels), of any one bitmap dimension supported by the render target</summary>
            <returns> 
The maximum size, in pixels, of any one bitmap dimension supported by the render target</returns>
        </member>
        <member name="M:CRenderTarget.IsSupported(D2D1_RENDER_TARGET_PROPERTIES!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Indicates whether the render target supports the specified properties</summary>
            <returns> 
TRUE if the specified render target properties are supported by this render target; otherwise, FALSE</returns>
            <param name="renderTargetProperties">The render target properties to test</param>
        </member>
        <member name="M:CRenderTarget.SetTags(System.UInt64,System.UInt64)">
            <summary>
Specifies a label for subsequent drawing operations.</summary>
            <param name="tag1">A label to apply to subsequent drawing operations.</param>
            <param name="tag2">A label to apply to subsequent drawing operations.</param>
        </member>
        <member name="M:CRenderTarget.GetTags(System.UInt64*,System.UInt64*)">
            <summary>
Gets the label for subsequent drawing operations.</summary>
            <param name="tag1">Contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If NULL is specified, no value is retrieved for this parameter.</param>
            <param name="tag2">Contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If NULL is specified, no value is retrieved for this parameter.</param>
        </member>
        <member name="M:CRenderTarget.GetPixelSize">
            <summary>
Returns the size of the render target in device pixels</summary>
            <returns> 
The size of the render target in device pixels</returns>
        </member>
        <member name="M:CRenderTarget.GetPixelFormat">
            <summary>
Retrieves the pixel format and alpha mode of the render target</summary>
            <returns> 
The pixel format and alpha mode of the render target</returns>
        </member>
        <member name="M:CRenderTarget.GetDpi">
            <summary>
Returns the render target's dots per inch (DPI)</summary>
            <returns> 
The render target's dots per inch (DPI).</returns>
        </member>
        <member name="M:CRenderTarget.SetDpi(CD2DSizeF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets the dots per inch (DPI) of the render target.</summary>
            <param name="sizeDPI">A value greater than or equal to zero that specifies the horizontal/verticalDPI of the render target.</param>
        </member>
        <member name="M:CRenderTarget.GetSize">
            <summary>
Returns the size of the render target in device-independent pixels</summary>
            <returns> 
The current size of the render target in device-independent pixels</returns>
        </member>
        <member name="M:CRenderTarget.op_Implicit~ID2D1RenderTarget*">
            <summary>
Returns ID2D1RenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1RenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CRenderTarget.GetRenderTarget">
            <summary>
Returns ID2D1RenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1RenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CRenderTarget.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CRenderTarget.Destroy(System.Int32)">
            <summary>
Deletes one or more resources</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE</returns>
            <param name="bDeleteResources">If bDeleteResources is TRUE, all resources located in m_lstResources will be automatically destroyed.</param>
        </member>
        <member name="M:CRenderTarget.Dispose">
            <summary>
The destructor. Called when a render target object is being destroyed.
</summary>
        </member>
        <member name="M:CRenderTarget.#ctor">
            <summary>
Constructs a CRenderTarget object.</summary>
        </member>
        <member name="T:CRenderTarget">
            <summary>
ID2D1RenderTarget wrapper.
</summary>
        </member>
        <member name="F:CD2DMesh.m_pMesh">
            <summary>
A pointer to an ID2D1Mesh.
</summary>
        </member>
        <member name="M:CD2DMesh.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DMesh.Destroy">
            <summary>
Destroys a CD2DMesh object.</summary>
        </member>
        <member name="M:CD2DMesh.Create(CRenderTarget*)">
            <summary>
Creates a CD2DMesh.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DMesh.Open">
            <summary>
Opens the mesh for population.</summary>
            <returns>
A pointer to an ID2D1TessellationSink that is used to populate the mesh.</returns>
        </member>
        <member name="M:CD2DMesh.op_Implicit~ID2D1Mesh*">
            <summary>
Returns ID2D1Mesh interface</summary>
            <returns> 
Pointer to an ID2D1Mesh interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DMesh.Get">
            <summary>
Returns ID2D1Mesh interface</summary>
            <returns> 
Pointer to an ID2D1Mesh interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DMesh.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DMesh.Attach(ID2D1Mesh*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DMesh.Dispose">
            <summary>
The destructor. Called when a D2D mesh object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DMesh.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DMesh object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DMesh">
            <summary>
ID2D1Mesh wrapper.
</summary>
        </member>
        <member name="F:CD2DGeometrySink.m_pSink">
            <summary>
A pointer to an ID2D1GeometrySink.
</summary>
        </member>
        <member name="M:CD2DGeometrySink.SetSegmentFlags(D2D1_PATH_SEGMENT)">
            <summary>
Specifies stroke and join options to be applied to new segments added to the geometry sink.</summary>
            <param name="vertexFlags">Stroke and join options to be applied to new segments added to the geometry sink.</param>
        </member>
        <member name="M:CD2DGeometrySink.SetFillMode(D2D1_FILL_MODE)">
            <summary>
Specifies the method used to determine which points are inside the geometry described by this geometry sink and which points are outside.</summary>
            <param name="fillMode">The method used to determine whether a given point is part of the geometry.</param>
        </member>
        <member name="M:CD2DGeometrySink.Close">
            <summary>
Closes the geometry sink</summary>
            <returns> 
Nonzero if successful; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DGeometrySink.AddLines(CArray&lt;CD2DPointF,CD2DPointF&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a sequence of lines using the specified points and adds them to the geometry sink.</summary>
            <param name="points">An array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by BeginFigure) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on. An array of a sequence of the end points of the lines to draw.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddLine(CD2DPointF)">
            <summary>
Creates a line segment between the current point and the specified end point and adds it to the geometry sink.</summary>
            <param name="point">The end point of the line to draw.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddQuadraticBeziers(CArray&lt;D2D1_QUADRATIC_BEZIER_SEGMENT,D2D1_QUADRATIC_BEZIER_SEGMENT&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Adds a sequence of quadratic Bezier segments as an array in a single call.</summary>
            <param name="beziers">An array of a sequence of quadratic Bezier segments.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddQuadraticBezier(D2D1_QUADRATIC_BEZIER_SEGMENT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a quadratic Bezier curve between the current point and the specified end point.</summary>
            <param name="bezier">A structure that describes the control point and the end point of the quadratic Bezier curve to add.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddBeziers(CArray&lt;D2D1_BEZIER_SEGMENT,D2D1_BEZIER_SEGMENT&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a sequence of cubic Bezier curves and adds them to the geometry sink.</summary>
            <param name="beziers">An array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by BeginFigure) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddBezier(D2D1_BEZIER_SEGMENT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a cubic Bezier curve between the current point and the specified end point.</summary>
            <param name="bezier">A structure that describes the control points and end point of the Bezier curve to add.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddArc(D2D1_ARC_SEGMENT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Adds a single arc to the path geometry</summary>
            <param name="arc">The arc segment to add to the figure</param>
        </member>
        <member name="M:CD2DGeometrySink.EndFigure(D2D1_FIGURE_END)">
            <summary>
Ends the current figure; optionally, closes it.</summary>
            <param name="figureEnd">A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by BeginFigure.</param>
        </member>
        <member name="M:CD2DGeometrySink.BeginFigure(CD2DPointF,D2D1_FIGURE_BEGIN)">
            <summary>
Starts a new figure at the specified point.</summary>
            <param name="startPoint">The point at which to begin the new figure.</param>
            <param name="figureBegin">Whether the new figure should be hollow or filled.</param>
        </member>
        <member name="M:CD2DGeometrySink.op_Implicit~ID2D1GeometrySink*">
            <summary>
Returns ID2D1GeometrySink interface</summary>
            <returns> 
Pointer to an ID2D1GeometrySink interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DGeometrySink.Get">
            <summary>
Returns ID2D1GeometrySink interface</summary>
            <returns> 
Pointer to an ID2D1GeometrySink interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DGeometrySink.IsValid">
            <summary>
Checks geometry sink validity</summary>
            <returns> 
TRUE if geometry sink is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DGeometrySink.Dispose">
            <summary>
The destructor. Called when a D2D geometry sink object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DGeometrySink.#ctor(CD2DPathGeometry*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DGeometrySink object from CD2DPathGeometry object.</summary>
            <param name="pathGeometry">An existing CD2DPathGeometry object.</param>
        </member>
        <member name="T:CD2DGeometrySink">
            <summary>
ID2D1GeometrySink wrapper.
</summary>
        </member>
        <member name="F:CD2DPathGeometry.m_pPathGeometry">
            <summary>
A pointer to an ID2D1PathGeometry.
</summary>
        </member>
        <member name="M:CD2DPathGeometry.GetFigureCount">
            <summary>
Retrieves tthe number of figures in the path geometry.</summary>
            <returns> 
Returns the number of figures in the path geometry.</returns>
        </member>
        <member name="M:CD2DPathGeometry.GetSegmentCount">
            <summary>
Retrieves the number of segments in the path geometry.</summary>
            <returns> 
Returns the number of segments in the path geometry.</returns>
        </member>
        <member name="M:CD2DPathGeometry.Stream(ID2D1GeometrySink*)">
            <summary>
Copies the contents of the path geometry to the specified ID2D1GeometrySink.</summary>
            <returns>
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="geometrySink">The sink to which the path geometry's contents are copied. Modifying this sink does not change the contents of this path geometry.</param>
        </member>
        <member name="M:CD2DPathGeometry.Open">
            <summary>
Retrieves the geometry sink that is used to populate the path geometry with figures and segments.</summary>
            <returns>
A pointer to the ID2D1GeometrySink that is used to populate the path geometry with figures and segments.</returns>
        </member>
        <member name="M:CD2DPathGeometry.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DPathGeometry.Attach(ID2D1PathGeometry*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DPathGeometry.Destroy">
            <summary>
Destroys a CD2DPathGeometry object.</summary>
        </member>
        <member name="M:CD2DPathGeometry.Create(CRenderTarget*)">
            <summary>
Creates a CD2DPathGeometry.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DPathGeometry.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DPathGeometry object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DPathGeometry">
            <summary>
ID2D1PathGeometry wrapper.
</summary>
        </member>
        <member name="F:CD2DGeometry.m_pGeometry">
            <summary>
A pointer to an ID2D1Geometry.
</summary>
        </member>
        <member name="M:CD2DGeometry.Widen(System.Single,ID2D1StrokeStyle*,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1SimplifiedGeometrySink*,System.Single)">
            <summary>
Widens the geometry by the specified stroke and writes the result to an ID2D1SimplifiedGeometrySink after it has been transformed by the specified matrix and flattened using the specified tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="strokeWidth">The amount by which to widen the geometry.</param>
            <param name="strokeStyle">The style of stroke to apply to the geometry, or NULL.</param>
            <param name="worldTransform">The transform to apply to the geometry after widening it.</param>
            <param name="geometrySink">The ID2D1SimplifiedGeometrySink to which the widened geometry is appended.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.Tessellate(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1TessellationSink*,System.Single)">
            <summary>
Creates a set of clockwise-wound triangles that cover the geometry after it has been transformed using the specified matrix and flattened using the specified tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to this geometry, or NULL.</param>
            <param name="tessellationSink">The ID2D1TessellationSink to which the tessellated is appended.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.Simplify(D2D1_GEOMETRY_SIMPLIFICATION_OPTION,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1SimplifiedGeometrySink*,System.Single)">
            <summary>
Creates a simplified version of the geometry that contains only lines and (optionally) cubic Bezier curves and writes the result to an ID2D1SimplifiedGeometrySink.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="simplificationOption">A value that specifies whether the simplified geometry should contain curves.</param>
            <param name="worldTransform">The transform to apply to the simplified geometry.</param>
            <param name="geometrySink">The ID2D1SimplifiedGeometrySink to which the simplified geometry is appended.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.Outline(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1SimplifiedGeometrySink*,System.Single)">
            <summary>
Computes the outline of the geometry and writes the result to an ID2D1SimplifiedGeometrySink.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to the geometry outline.</param>
            <param name="geometrySink">The ID2D1SimplifiedGeometrySink to which the geometry transformed outline is appended.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.StrokeContainsPoint(CD2DPointF,System.Single,ID2D1StrokeStyle*,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Single)">
            <summary>
Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="point">The point to test for containment.</param>
            <param name="strokeWidth">The thickness of the stroke to apply.</param>
            <param name="strokeStyle">The style of the stroke to apply.</param>
            <param name="worldTransform">The transform to apply to the stroked geometry.</param>
            <param name="contains">When this method returns, contains a boolean value set to TRUE if the geometry's stroke contains the specified point; otherwise, FALSE. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the stroke by less than the tolerance are still considered inside. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.FillContainsPoint(CD2DPointF,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Single)">
            <summary>
Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="point">The point to test.</param>
            <param name="worldTransform">The transform to apply to the geometry prior to testing for containment.</param>
            <param name="contains">When this method returns, contains a bool value that is TRUE if the area filled by the geometry contains point; otherwise, FALSE. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.GetWidenedBounds(System.Single,ID2D1StrokeStyle*,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DRectF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="strokeWidth">The amount by which to widen the geometry by stroking its outline.</param>
            <param name="strokeStyle">The style of the stroke that widens the geometry.</param>
            <param name="worldTransform">A transform to apply to the geometry after the geometry is transformed and after the geometry has been stroked.</param>
            <param name="bounds">When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.GetBounds(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DRectF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieves the bounds of the geometry.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to this geometry before calculating its bounds.</param>
            <param name="bounds">When this method returns, contains the bounds of this geometry. If the bounds are empty, this will be a rect where bounds.left is greater than bounds.right. You must allocate storage for this parameter.</param>
        </member>
        <member name="M:CD2DGeometry.ComputePointAtLength(System.Single,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DPointF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DPointF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Calculates the point and tangent vector at the specified distance along the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="length">The distance along the geometry of the point and tangent to find. If this distance is less then 0, this method calculates the first point in the geometry. If this distance is greater than the length of the geometry, this method calculates the last point in the geometry.</param>
            <param name="worldTransform">The transform to apply to the geometry before calculating the specified point and tangent.</param>
            <param name="point">The location at the specified distance along the geometry. If the geometry is empty, this point contains NaN as its x and y values.</param>
            <param name="unitTangentVector">When this method returns, contains a pointer to the tangent vector at the specified distance along the geometry. If the geometry is empty, this vector contains NaN as its x and y values. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.ComputeLength(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Calculates the length of the geometry as though each segment were unrolled into a line.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to the geometry before calculating its length.</param>
            <param name="length">When this method returns, contains a pointer to the length of the geometry. For closed geometries, the length includes an implicit closing segment. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.ComputeArea(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Computes the area of the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to this geometry before computing its area.</param>
            <param name="area">When this method returns, contains a pointer to the area of the transformed, flattened version of this geometry. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.CompareWithGeometry(CD2DGeometry*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Describes the intersection between this geometry and the specified geometry. The comparison is performed using the specified flattening tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="inputGeometry">The geometry to test.</param>
            <param name="inputGeometryTransform">The transform to apply to inputGeometry.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. </param>
        </member>
        <member name="M:CD2DGeometry.CombineWithGeometry(CD2DGeometry*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,D2D1_COMBINE_MODE,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1SimplifiedGeometrySink*,System.Single)">
            <summary>
Combines this geometry with the specified geometry and stores the result in an ID2D1SimplifiedGeometrySink.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="inputGeometry">The geometry to combine with this instance.</param>
            <param name="combineMode">The type of combine operation to perform.</param>
            <param name="inputGeometryTransform">The transform to apply to inputGeometry before combining.</param>
            <param name="geometrySink">The result of the combine operation.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DGeometry.Destroy">
            <summary>
Destroys a CD2DGeometry object.</summary>
        </member>
        <member name="M:CD2DGeometry.op_Implicit~ID2D1Geometry*">
            <summary>
Returns ID2D1Geometry interface</summary>
            <returns> 
Pointer to an ID2D1Geometry interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DGeometry.Get">
            <summary>
Returns ID2D1Geometry interface</summary>
            <returns> 
Pointer to an ID2D1Geometry interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DGeometry.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DGeometry.Attach(ID2D1Geometry*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DGeometry.Dispose">
            <summary>
The destructor. Called when a D2D geometry object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DGeometry.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DGeometry object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DGeometry">
            <summary>
ID2D1Geometry wrapper.
</summary>
        </member>
        <member name="F:CD2DTextLayout.m_pTextLayout">
            <summary>
A pointer to an IDWriteTextLayout.
</summary>
        </member>
        <member name="M:CD2DTextLayout.GetLocaleName(System.UInt32,DWRITE_TEXT_RANGE*)">
            <summary>
Gets the locale name of the text at the specified position.</summary>
            <returns>
CString object that contains the current locale name.</returns>
            <param name="currentPosition">The position of the text to inspect.</param>
            <param name="textRange">The range of text that has the same formatting as the text at the position specified by currentPosition. This means the run has the exact formatting as the position specified, including but not limited to the locale name.</param>
        </member>
        <member name="M:CD2DTextLayout.GetFontFamilyName(System.UInt32,DWRITE_TEXT_RANGE*)">
            <summary>
Copies the font family name of the text at the specified position.</summary>
            <returns>
CString object that contains the current font family name.</returns>
            <param name="currentPosition">The position of the text to examine.</param>
            <param name="textRange">The range of text that has the same formatting as the text at the position specified by currentPosition. This means the run has the exact formatting as the position specified, including but not limited to the font family name.</param>
        </member>
        <member name="M:CD2DTextLayout.SetLocaleName(System.Char!System.Runtime.CompilerServices.IsConst*,DWRITE_TEXT_RANGE)">
            <summary>
Sets the locale name for text within a specified text range</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE</returns>
            <param name="pwzLocaleName">A null-terminated locale name string</param>
            <param name="textRange">Text range to which this change applies</param>
        </member>
        <member name="M:CD2DTextLayout.SetFontFamilyName(System.Char!System.Runtime.CompilerServices.IsConst*,DWRITE_TEXT_RANGE)">
            <summary>
Sets null-terminated font family name for text within a specified text range</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE</returns>
            <param name="pwzFontFamilyName">The font family name that applies to the entire text string within the range specified by textRange</param>
            <param name="textRange">Text range to which this change applies</param>
        </member>
        <member name="M:CD2DTextLayout.op_Implicit~IDWriteTextLayout*">
            <summary>
Returns IDWriteTextLayout interface</summary>
            <returns>
Pointer to an IDWriteTextLayout interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DTextLayout.Get">
            <summary>
Returns IDWriteTextLayout interface</summary>
            <returns>
Pointer to an IDWriteTextLayout interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DTextLayout.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DTextLayout.Destroy">
            <summary>
Destroys a CD2DTextLayout object.</summary>
        </member>
        <member name="M:CD2DTextLayout.Create(CRenderTarget*)">
            <summary>
Creates a CD2DTextLayout.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DTextLayout.ReCreate(CRenderTarget*)">
            <summary>
Re-creates a CD2DTextLayout.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DTextLayout.Dispose">
            <summary>
The destructor. Called when a D2D text layout object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DTextLayout.#ctor(CRenderTarget*,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DTextFormat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DSizeF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
            <summary>
Constructs a CD2DTextLayout object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="strText">A CString object that contains the string to create a new CD2DTextLayout object from.</param>
            <param name="textFormat">A CString object that contains the format to apply to the string.</param>
            <param name="sizeMax">The size of the layout box.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DTextLayout">
            <summary>
IDWriteTextLayout wrapper.
</summary>
        </member>
        <member name="F:CD2DTextFormat.m_pTextFormat">
            <summary>
A pointer to an IDWriteTextFormat.
</summary>
        </member>
        <member name="M:CD2DTextFormat.GetLocaleName">
            <summary>
Gets a copy of the locale name.</summary>
            <returns>
CString object that contains the current locale name.</returns>
        </member>
        <member name="M:CD2DTextFormat.GetFontFamilyName">
            <summary>
Gets a copy of the font family name.</summary>
            <returns>
CString object that contains the current font family name.</returns>
        </member>
        <member name="M:CD2DTextFormat.op_Implicit~IDWriteTextFormat*">
            <summary>
Returns IDWriteTextFormat interface</summary>
            <returns>
Pointer to an IDWriteTextFormat interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DTextFormat.Get">
            <summary>
Returns IDWriteTextFormat interface</summary>
            <returns> 
Pointer to an IDWriteTextFormat interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DTextFormat.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DTextFormat.Destroy">
            <summary>
Destroys a CD2DTextFormat object.</summary>
        </member>
        <member name="M:CD2DTextFormat.Create(CRenderTarget*)">
            <summary>
Creates a CD2DTextFormat.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DTextFormat.ReCreate(CRenderTarget*)">
            <summary>
Re-creates a CD2DTextFormat.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DTextFormat.Dispose">
            <summary>
The destructor. Called when a D2D text format object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DTextFormat.#ctor(CRenderTarget*,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,DWRITE_FONT_WEIGHT,DWRITE_FONT_STYLE,DWRITE_FONT_STRETCH,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,IDWriteFontCollection*,System.Int32)">
            <summary>
Constructs a CD2DTextFormat object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="strFontFamilyName">A CString object that contains the name of the font family.</param>
            <param name="fontSize">The logical size of the font in DIP ("device-independent pixel") units. A DIPequals 1/96 inch.</param>
            <param name="fontWeight">A value that indicates the font weight for the text object.</param>
            <param name="fontStyle">A value that indicates the font style for the text object.</param>
            <param name="fontStretch">A value that indicates the font stretch for the text object.</param>
            <param name="strFontLocale">A CString object that contains the locale name.</param>
            <param name="pFontCollection">A pointer to a font collection object. When this is NULL, indicates the system font collection.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DTextFormat">
            <summary>
IDWriteTextFormat wrapper.
</summary>
        </member>
        <member name="F:CD2DRadialGradientBrush.m_pRadialGradientBrush">
            <summary>
A pointer to an ID2D1RadialGradientBrush.
</summary>
        </member>
        <member name="F:CD2DRadialGradientBrush.m_RadialGradientBrushProperties">
            <summary>
The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.
</summary>
        </member>
        <member name="M:CD2DRadialGradientBrush.GetRadiusY">
            <summary>
Retrieves the y-radius of the gradient ellipse</summary>
            <returns> 
The y-radius of the gradient ellipse. This value is expressed in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.GetRadiusX">
            <summary>
Retrieves the x-radius of the gradient ellipse</summary>
            <returns> 
The x-radius of the gradient ellipse. This value is expressed in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.GetGradientOriginOffset">
            <summary>
Retrieves the offset of the gradient origin relative to the gradient ellipse's center</summary>
            <returns> 
The offset of the gradient origin from the center of the gradient ellipse. This value is expressed in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.GetCenter">
            <summary>
Retrieves the center of the gradient ellipse</summary>
            <returns> 
The center of the gradient ellipse. This value is expressed in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.SetRadiusY(System.Single)">
            <summary>
Specifies the y-radius of the gradient ellipse, in the brush's coordinate space</summary>
            <param name="radiusY">The y-radius of the gradient ellipse. This value is in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.SetRadiusX(System.Single)">
            <summary>
Specifies the x-radius of the gradient ellipse, in the brush's coordinate space</summary>
            <param name="radiusX">The x-radius of the gradient ellipse. This value is in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.SetGradientOriginOffset(CD2DPointF)">
            <summary>
Specifies the offset of the gradient origin relative to the gradient ellipse's center</summary>
            <param name="gradientOriginOffset">The offset of the gradient origin from the center of the gradient ellipse</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.SetCenter(CD2DPointF)">
            <summary>
Specifies the center of the gradient ellipse in the brush's coordinate space</summary>
            <param name="point">The center of the gradient ellipse, in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.op_Implicit~ID2D1RadialGradientBrush*">
            <summary>
Returns ID2D1RadialGradientBrush interface</summary>
            <returns> 
Pointer to an ID2D1RadialGradientBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.Get">
            <summary>
Returns ID2D1RadialGradientBrush interface</summary>
            <returns> 
Pointer to an ID2D1RadialGradientBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.Attach(ID2D1RadialGradientBrush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.Destroy">
            <summary>
Destroys a CD2DRadialGradientBrush object.</summary>
        </member>
        <member name="M:CD2DRadialGradientBrush.Create(CRenderTarget*)">
            <summary>
Creates a CD2DRadialGradientBrush.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.Dispose">
            <summary>
The destructor. Called when a D2D radial gradient brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DRadialGradientBrush.#ctor(CRenderTarget*,D2D1_GRADIENT_STOP!System.Runtime.CompilerServices.IsConst*,System.UInt32,D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES,D2D1_GAMMA,D2D1_EXTEND_MODE,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DLinearGradientBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="gradientStopsCount">A value greater than or equal to 1 that specifies the number of gradient stops in the gradientStops array.</param>
            <param name="RadialGradientBrushProperties">The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.</param>
            <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
            <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DRadialGradientBrush">
            <summary>
ID2D1RadialGradientBrush wrapper.
</summary>
        </member>
        <member name="F:CD2DLinearGradientBrush.m_pLinearGradientBrush">
            <summary>
A pointer to an ID2D1LinearGradientBrush.
</summary>
        </member>
        <member name="F:CD2DLinearGradientBrush.m_LinearGradientBrushProperties">
            <summary>
The start and end points of the gradient.
</summary>
        </member>
        <member name="M:CD2DLinearGradientBrush.GetEndPoint">
            <summary>
Retrieves the ending coordinates of the linear gradient</summary>
            <returns> 
The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.GetStartPoint">
            <summary>
Retrieves the starting coordinates of the linear gradient</summary>
            <returns> 
The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.SetEndPoint(CD2DPointF)">
            <summary>
Sets the ending coordinates of the linear gradient in the brush's coordinate space</summary>
            <param name="point">The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DLinearGradientBrush.SetStartPoint(CD2DPointF)">
            <summary>
Sets the starting coordinates of the linear gradient in the brush's coordinate space</summary>
            <param name="point">The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DLinearGradientBrush.op_Implicit~ID2D1LinearGradientBrush*">
            <summary>
Returns ID2D1LinearGradientBrush interface</summary>
            <returns> 
Pointer to an ID2D1LinearGradientBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.Get">
            <summary>
Returns ID2D1LinearGradientBrush interface</summary>
            <returns> 
Pointer to an ID2D1LinearGradientBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.Attach(ID2D1LinearGradientBrush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DLinearGradientBrush.Destroy">
            <summary>
Destroys a CD2DLinearGradientBrush object.</summary>
        </member>
        <member name="M:CD2DLinearGradientBrush.Create(CRenderTarget*)">
            <summary>
Creates a CD2DLinearGradientBrush.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DLinearGradientBrush.Dispose">
            <summary>
The destructor. Called when a D2D linear gradient brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DLinearGradientBrush.#ctor(CRenderTarget*,D2D1_GRADIENT_STOP!System.Runtime.CompilerServices.IsConst*,System.UInt32,D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES,D2D1_GAMMA,D2D1_EXTEND_MODE,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DLinearGradientBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="gradientStopsCount">A value greater than or equal to 1 that specifies the number of gradient stops in the gradientStops array.</param>
            <param name="LinearGradientBrushProperties">The start and end points of the gradient.</param>
            <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
            <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DLinearGradientBrush">
            <summary>
ID2D1LinearGradientBrush wrapper.
</summary>
        </member>
        <member name="F:CD2DGradientBrush.m_pGradientStops">
            <summary>
A pointer to an array of D2D1_GRADIENT_STOP structures.
</summary>
        </member>
        <member name="F:CD2DGradientBrush.m_extendMode">
            <summary>
The behavior of the gradient outside the [0,1] normalized range.
</summary>
        </member>
        <member name="F:CD2DGradientBrush.m_colorInterpolationGamma">
            <summary>
The space in which color interpolation between the gradient stops is performed.
</summary>
        </member>
        <member name="F:CD2DGradientBrush.m_arGradientStops">
            <summary>
Array of the D2D1_GRADIENT_STOP structures.
</summary>
        </member>
        <member name="M:CD2DGradientBrush.Destroy">
            <summary>
Destroys a CD2DGradientBrush object.</summary>
        </member>
        <member name="M:CD2DGradientBrush.Dispose">
            <summary>
The destructor. Called when a D2D gradient brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DGradientBrush.#ctor(CRenderTarget*,D2D1_GRADIENT_STOP!System.Runtime.CompilerServices.IsConst*,System.UInt32,D2D1_GAMMA,D2D1_EXTEND_MODE,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DGradientBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="gradientStopsCount">A value greater than or equal to 1 that specifies the number of gradient stops in the gradientStops array.</param>
            <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
            <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DGradientBrush">
            <summary>
The base class of CD2DLinearGradientBrush and CD2DRadialGradientBrush classes.
</summary>
        </member>
        <member name="F:CD2DBitmapBrush.m_pBitmapBrushProperties">
            <summary>
Bitmap brush properties.
</summary>
        </member>
        <member name="F:CD2DBitmapBrush.m_pBitmapBrush">
            <summary>
Stores a pointer to an ID2D1BitmapBrush object.
</summary>
        </member>
        <member name="F:CD2DBitmapBrush.m_pBitmap">
            <summary>
Stores a pointer to a CD2DBitmap object.
</summary>
        </member>
        <member name="M:CD2DBitmapBrush.CommonInit(D2D1_BITMAP_BRUSH_PROPERTIES*)">
            <summary>
Initializes the object</summary>
            <param name="pBitmapBrushProperties">A pointer to the bitmap brush properties.</param>
        </member>
        <member name="M:CD2DBitmapBrush.Destroy">
            <summary>
Destroys a CD2DBitmapBrush object.</summary>
        </member>
        <member name="M:CD2DBitmapBrush.Create(CRenderTarget*)">
            <summary>
Creates a CD2DBitmapBrush.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DBitmapBrush.GetInterpolationMode">
            <summary>
Gets the interpolation method used when the brush bitmap is scaled or rotated</summary>
            <returns> 
The interpolation method used when the brush bitmap is scaled or rotated</returns>
        </member>
        <member name="M:CD2DBitmapBrush.GetExtendModeY">
            <summary>
Gets the method by which the brush vertically tiles those areas that extend past its bitmap</summary>
            <returns> 
A value that specifies how the brush vertically tiles those areas that extend past its bitmap</returns>
        </member>
        <member name="M:CD2DBitmapBrush.GetExtendModeX">
            <summary>
Gets the method by which the brush horizontally tiles those areas that extend past its bitmap</summary>
            <returns> 
A value that specifies how the brush horizontally tiles those areas that extend past its bitmap</returns>
        </member>
        <member name="M:CD2DBitmapBrush.SetBitmap(CD2DBitmap*)">
            <summary>
Specifies the bitmap source that this brush uses to paint</summary>
            <param name="pBitmap">The bitmap source used by the brush</param>
        </member>
        <member name="M:CD2DBitmapBrush.SetInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE)">
            <summary>
Specifies the interpolation mode used when the brush bitmap is scaled or rotated</summary>
            <param name="interpolationMode">The interpolation mode used when the brush bitmap is scaled or rotated</param>
        </member>
        <member name="M:CD2DBitmapBrush.SetExtendModeY(D2D1_EXTEND_MODE)">
            <summary>
Specifies how the brush vertically tiles those areas that extend past its bitmap</summary>
            <param name="extendModeY">A value that specifies how the brush vertically tiles those areas that extend past its bitmap</param>
        </member>
        <member name="M:CD2DBitmapBrush.SetExtendModeX(D2D1_EXTEND_MODE)">
            <summary>
Specifies how the brush horizontally tiles those areas that extend past its bitmap</summary>
            <param name="extendModeX">A value that specifies how the brush horizontally tiles those areas that extend past its bitmap</param>
        </member>
        <member name="M:CD2DBitmapBrush.GetBitmap">
            <summary>
Gets the bitmap source that this brush uses to paint</summary>
            <returns> 
Pointer to an CD2DBitmap object or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmapBrush.op_Implicit~ID2D1BitmapBrush*">
            <summary>
Returns ID2D1BitmapBrush interface</summary>
            <returns> 
Pointer to an ID2D1BitmapBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmapBrush.Get">
            <summary>
Returns ID2D1BitmapBrush interface</summary>
            <returns> 
Pointer to an ID2D1BitmapBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmapBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DBitmapBrush.Attach(ID2D1BitmapBrush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DBitmapBrush.Dispose">
            <summary>
The destructor. Called when a D2D bitmap brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DBitmapBrush.#ctor(CRenderTarget*,System.Char!System.Runtime.CompilerServices.IsConst*,CD2DSizeU,D2D1_BITMAP_BRUSH_PROPERTIES*,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DBitmapBrush object from file.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="lpszImagePath">Pointer to a null-terminated string that contains the name of file.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="pBitmapBrushProperties">A pointer to the extend modes and the interpolation mode of a bitmap brush.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmapBrush.#ctor(CRenderTarget*,System.UInt32,System.Char!System.Runtime.CompilerServices.IsConst*,CD2DSizeU,D2D1_BITMAP_BRUSH_PROPERTIES*,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DBitmapBrush object from resource.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="uiResID">The resource ID number of the resource.</param>
            <param name="lpszType">Pointer to a null-terminated string that contains the resource type.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="pBitmapBrushProperties">A pointer to the extend modes and the interpolation mode of a bitmap brush.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmapBrush.#ctor(CRenderTarget*,D2D1_BITMAP_BRUSH_PROPERTIES*,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DBitmapBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="pBitmapBrushProperties">A pointer to the extend modes and the interpolation mode of a bitmap brush.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DBitmapBrush">
            <summary>
ID2D1BitmapBrush wrapper.
</summary>
        </member>
        <member name="F:CD2DSolidColorBrush.m_colorSolid">
            <summary>
Brush solid color.
</summary>
        </member>
        <member name="F:CD2DSolidColorBrush.m_pSolidColorBrush">
            <summary>
Stores a pointer to an ID2D1SolidColorBrush object.
</summary>
        </member>
        <member name="M:CD2DSolidColorBrush.Destroy">
            <summary>
Destroys a CD2DSolidColorBrush object.</summary>
        </member>
        <member name="M:CD2DSolidColorBrush.Create(CRenderTarget*)">
            <summary>
Creates a CD2DSolidColorBrush.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DSolidColorBrush.GetColor">
            <summary>
Retrieves the color of the solid color brush</summary>
            <returns> 
The color of this solid color brush</returns>
        </member>
        <member name="M:CD2DSolidColorBrush.SetColor(_D3DCOLORVALUE)">
            <summary>
Specifies the color of this solid color brush</summary>
            <param name="color">The color of this solid color brush</param>
        </member>
        <member name="M:CD2DSolidColorBrush.op_Implicit~ID2D1SolidColorBrush*">
            <summary>
Returns ID2D1SolidColorBrush interface</summary>
            <returns> 
Pointer to an ID2D1SolidColorBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DSolidColorBrush.Get">
            <summary>
Returns ID2D1SolidColorBrush interface</summary>
            <returns> 
Pointer to an ID2D1SolidColorBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DSolidColorBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DSolidColorBrush.Attach(ID2D1SolidColorBrush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DSolidColorBrush.Dispose">
            <summary>
The destructor. Called when a D2D solid brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DSolidColorBrush.#ctor(CRenderTarget*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DSolidColorBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="color">The red, green, and blue values of the brush's color.</param>
            <param name="nAlpha">The opacity of the brush's color.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DSolidColorBrush.#ctor(CRenderTarget*,_D3DCOLORVALUE,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DSolidColorBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="color">The red, green, blue, and alpha values of the brush's color.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DSolidColorBrush">
            <summary>
ID2D1SolidColorBrush wrapper.
</summary>
        </member>
        <member name="F:CD2DBrush.m_pBrushProperties">
            <summary>
Brush properties.
</summary>
        </member>
        <member name="F:CD2DBrush.m_pBrush">
            <summary>
Stores a pointer to an ID2D1Brush object.
</summary>
        </member>
        <member name="M:CD2DBrush.GetTransform(D2D_MATRIX_3X2_F*)">
            <summary>
Gets the current transform of the render target</summary>
            <param name="transform">When this returns, contains the current transform of the render target. This parameter is passed uninitialized</param>
        </member>
        <member name="M:CD2DBrush.SetTransform(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space</summary>
            <param name="transform">The transform to apply to the render target</param>
        </member>
        <member name="M:CD2DBrush.GetOpacity">
            <summary>
Gets the degree of opacity of this brush</summary>
            <returns> 
A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0 to 1 before they are multiplied together</returns>
        </member>
        <member name="M:CD2DBrush.SetOpacity(System.Single)">
            <summary>
Sets the degree of opacity of this brush</summary>
            <param name="opacity">A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0 to 1 before they are multiplied together</param>
        </member>
        <member name="M:CD2DBrush.Destroy">
            <summary>
Destroys a CD2DBrush object.</summary>
        </member>
        <member name="M:CD2DBrush.op_Implicit~ID2D1Brush*">
            <summary>
Returns ID2D1Brush interface</summary>
            <returns> 
Pointer to an ID2D1Brush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBrush.Get">
            <summary>
Returns ID2D1Brush interface</summary>
            <returns> 
Pointer to an ID2D1Brush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBrush.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DBrush.Attach(ID2D1Brush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DBrush.Dispose">
            <summary>
The destructor. Called when a D2D brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DBrush.#ctor(CRenderTarget*,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DBrush">
            <summary>
ID2D1Brush wrapper.
</summary>
        </member>
        <member name="M:CD2DBrushProperties.CommonInit">
            <summary>
Initializes the object</summary>
        </member>
        <member name="M:CD2DBrushProperties.#ctor(D2D_MATRIX_3X2_F,System.Single)">
            <summary>
Creates a CD2D_BRUSH_PROPERTIES structure</summary>
            <param name="_transform">The transformation to apply to the brush</param>
            <param name="_opacity">The base opacity of the brush. The default value is 1.0.</param>
        </member>
        <member name="M:CD2DBrushProperties.#ctor(System.Single)">
            <summary>
Creates a CD2D_BRUSH_PROPERTIES structure</summary>
            <param name="_opacity">The base opacity of the brush. The default value is 1.0.</param>
        </member>
        <member name="M:CD2DBrushProperties.#ctor">
            <summary>
Creates a CD2D_BRUSH_PROPERTIES structure</summary>
        </member>
        <member name="T:CD2DBrushProperties">
            <summary>
D2D1_BRUSH_PROPERTIES wrapper.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_bAutoDestroyHBMP">
            <summary>
TRUE if m_hBmpSrc should be destroyed; otherwise FALSE.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_hBmpSrc">
            <summary>
Source bitmap handle.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_sizeDest">
            <summary>
Bitmap destination size.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_strPath">
            <summary>
Botmap file path.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_lpszType">
            <summary>
Resource type.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_uiResID">
            <summary>
Bitmap resource ID.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_pBitmap">
            <summary>
Stores a pointer to an ID2D1Bitmap object.
</summary>
        </member>
        <member name="M:CD2DBitmap.Destroy">
            <summary>
Destroys a CD2DBitmap object.</summary>
        </member>
        <member name="M:CD2DBitmap.Create(CRenderTarget*)">
            <summary>
Creates a CD2DBitmap.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DBitmap.CommonInit">
            <summary>
Initializes the object</summary>
        </member>
        <member name="M:CD2DBitmap.op_Implicit~ID2D1Bitmap*">
            <summary>
Returns ID2D1Bitmap interface</summary>
            <returns> 
Pointer to an ID2D1Bitmap interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmap.Get">
            <summary>
Returns ID2D1Bitmap interface</summary>
            <returns> 
Pointer to an ID2D1Bitmap interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmap.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DBitmap.CopyFromMemory(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,CD2DRectU!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Copies the specified region from memory into the current bitmap</summary>
            <returns> 
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="srcData">The data to copy</param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding</param>
            <param name="destRect">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied</param>
        </member>
        <member name="M:CD2DBitmap.CopyFromRenderTarget(CRenderTarget!System.Runtime.CompilerServices.IsConst*,CD2DPointU!System.Runtime.CompilerServices.IsConst*,CD2DRectU!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Copies the specified region from the specified render target into the current bitmap</summary>
            <returns> 
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">The render target that contains the region to copy</param>
            <param name="destPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied</param>
            <param name="srcRect">The area of renderTarget to copy</param>
        </member>
        <member name="M:CD2DBitmap.CopyFromBitmap(CD2DBitmap!System.Runtime.CompilerServices.IsConst*,CD2DPointU!System.Runtime.CompilerServices.IsConst*,CD2DRectU!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Copies the specified region from the specified bitmap into the current bitmap</summary>
            <returns> 
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pBitmap">The bitmap to copy from</param>
            <param name="destPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied</param>
            <param name="srcRect">The area of bitmap to copy</param>
        </member>
        <member name="M:CD2DBitmap.GetDPI">
            <summary>
Return the dots per inch (DPI) of the bitmap</summary>
            <returns> 
The horizontal and vertical DPI of the bitmap.</returns>
        </member>
        <member name="M:CD2DBitmap.GetPixelFormat">
            <summary>
Retrieves the pixel format and alpha mode of the bitmap</summary>
            <returns> 
The pixel format and alpha mode of the bitmap.</returns>
        </member>
        <member name="M:CD2DBitmap.GetPixelSize">
            <summary>
Returns the size, in device-dependent units (pixels), of the bitmap</summary>
            <returns> 
The size, in pixels, of the bitmap..</returns>
        </member>
        <member name="M:CD2DBitmap.GetSize">
            <summary>
Returns the size, in device-independent pixels (DIPs), of the bitmap</summary>
            <returns> 
The size, in DIPs, of the bitmap.</returns>
        </member>
        <member name="M:CD2DBitmap.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DBitmap.Attach(ID2D1Bitmap*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DBitmap.Dispose">
            <summary>
The destructor. Called when a D2D bitmap object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DBitmap.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DBitmap object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmap.#ctor(CRenderTarget*,HBITMAP__*,CD2DSizeU,System.Int32)">
            <summary>
Constructs a CD2DBitmap object from HBITMAP.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="hbmpSrc">Handle to the bitmap.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmap.#ctor(CRenderTarget*,System.Char!System.Runtime.CompilerServices.IsConst*,CD2DSizeU,System.Int32)">
            <summary>
Constructs a CD2DBitmap object from file.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="lpszPath">Pointer to a null-terminated string that contains the name of file.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmap.#ctor(CRenderTarget*,System.UInt32,System.Char!System.Runtime.CompilerServices.IsConst*,CD2DSizeU,System.Int32)">
            <summary>
Constructs a CD2DBitmap object from resource.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="uiResID">The resource ID number of the resource.</param>
            <param name="lpszType">Pointer to a null-terminated string that contains the resource type.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DBitmap">
            <summary>
ID2D1Bitmap wrapper.
</summary>
        </member>
        <member name="F:CD2DLayer.m_pLayer">
            <summary>
Stores a pointer to an ID2D1Layer object.
</summary>
        </member>
        <member name="M:CD2DLayer.Destroy">
            <summary>
Destroys a CD2DLayer object.</summary>
        </member>
        <member name="M:CD2DLayer.Create(CRenderTarget*)">
            <summary>
Creates a CD2DLayer.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DLayer.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DLayer.Attach(ID2D1Layer*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DLayer.op_Implicit~ID2D1Layer*">
            <summary>
Returns ID2D1Layer interface</summary>
            <returns> 
Pointer to an ID2D1Layer interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DLayer.Get">
            <summary>
Returns ID2D1Layer interface</summary>
            <returns> 
Pointer to an ID2D1Layer interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DLayer.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DLayer.GetSize">
            <summary>
Returns the size of the render target in device-independent pixels</summary>
            <returns> 
The current size of the render target in device-independent pixels</returns>
        </member>
        <member name="M:CD2DLayer.Dispose">
            <summary>
The destructor. Called when a D2D layer object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DLayer.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DLayer object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DLayer">
            <summary>
ID2D1Layer wrapper.
</summary>
        </member>
        <member name="F:CD2DResource.m_pParentTarget">
            <summary>
Pointer to the parent CRenderTarget)</summary>
        </member>
        <member name="F:CD2DResource.m_bIsAutoDestroy">
            <summary>
Resource will be destoyed by owner (CRenderTarget)</summary>
        </member>
        <member name="M:CD2DResource.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DResource.Destroy">
            <summary>
Destroys a CD2DResource object.</summary>
        </member>
        <member name="M:CD2DResource.Create(CRenderTarget*)">
            <summary>
Creates a CD2DResource.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DResource.ReCreate(CRenderTarget*)">
            <summary>
Re-creates a CD2DResource.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DResource.IsAutoDestroy">
            <summary>
Check auto destroy flag.</summary>
            <returns>
TRUE if the object will be destroyed by its owner; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DResource.Dispose">
            <summary>
The destructor. Called when a D2D resource object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DResource.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DResource object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DResource">
            <summary>
An abstract class, which provides a interface for creating and managing D2D resources such as brushes, layers and texts.
</summary>
        </member>
        <member name="M:CD2DEllipse.#ctor(CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DSizeF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DEllipse from CD2DPointF and CD2DSizeF objects.</summary>
            <param name="ptCenter">The center point of the ellipse.</param>
            <param name="sizeRadius">The X-radius and Y-radius of the ellipse.</param>
        </member>
        <member name="M:CD2DEllipse.#ctor(D2D1_ELLIPSE!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DEllipse object from D2D1_ELLIPSE object.</summary>
            <param name="ellipse">source ellipse</param>
        </member>
        <member name="M:CD2DEllipse.#ctor(D2D1_ELLIPSE!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DEllipse object from D2D1_ELLIPSE object.</summary>
            <param name="ellipse">source ellipse</param>
        </member>
        <member name="M:CD2DEllipse.#ctor(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DEllipse object from CD2DRectF object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="T:CD2DEllipse">
            <summary>
D2D1_ELLIPSE wrapper
</summary>
        </member>
        <member name="M:CD2DRoundedRect.#ctor(D2D1_ROUNDED_RECT!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DRoundedRect object from D2D1_ROUNDED_RECT object.</summary>
            <param name="rectIn">source rectangle</param>
        </member>
        <member name="M:CD2DRoundedRect.#ctor(D2D1_ROUNDED_RECT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRoundedRect object from D2D1_ROUNDED_RECT object.</summary>
            <param name="rectIn">source rectangle</param>
        </member>
        <member name="M:CD2DRoundedRect.#ctor(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DSizeF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRoundedRect object from CD2DRectF object.</summary>
            <param name="rectIn">source rectangle</param>
            <param name="sizeRadius">radius size</param>
        </member>
        <member name="T:CD2DRoundedRect">
            <summary>
D2D1_ROUNDED_RECT wrapper
</summary>
        </member>
        <member name="M:CD2DRectU.op_Implicit~CRect">
            <summary>
Converts CD2DRectU to CRect object.</summary>
            <returns>
Current value of D2D rectangle.
</returns>
        </member>
        <member name="M:CD2DRectU.IsNull">
            <summary>
Returns a Boolean value that indicates whether an expression contains no valid data (Null).</summary>
            <returns>
TRUE if rectangle's top, left, bottom, and right values are all equal to 0; otherwise FALSE.
</returns>
        </member>
        <member name="M:CD2DRectU.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
Constructs a CD2DRectU object from four UINT32 values.</summary>
            <param name="uLeft">source left coordinate</param>
            <param name="uTop">source top coordinate</param>
            <param name="uRight">source right coordinate</param>
            <param name="uBottom">source bottom coordinate</param>
        </member>
        <member name="M:CD2DRectU.#ctor(D2D_RECT_U!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DRectU object from D2D1_RECT_U object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="M:CD2DRectU.#ctor(D2D_RECT_U!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRectU object from D2D1_RECT_U object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="M:CD2DRectU.#ctor(CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRectU object from CRect object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="T:CD2DRectU">
            <summary>
D2D1_RECT_U wrapper
</summary>
        </member>
        <member name="M:CD2DRectF.op_Implicit~CRect">
            <summary>
Converts CD2DRectF to CRect object.</summary>
            <returns>
Current value of D2D rectangle.
</returns>
        </member>
        <member name="M:CD2DRectF.IsNull">
            <summary>
Returns a Boolean value that indicates whether an expression contains no valid data (Null).</summary>
            <returns>
TRUE if rectangle's top, left, bottom, and right values are all equal to 0; otherwise FALSE.
</returns>
        </member>
        <member name="M:CD2DRectF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs a CD2DRectF object from four FLOAT values.</summary>
            <param name="fLeft">source left coordinate</param>
            <param name="fTop">source top coordinate</param>
            <param name="fRight">source right coordinate</param>
            <param name="fBottom">source bottom coordinate</param>
        </member>
        <member name="M:CD2DRectF.#ctor(D2D_RECT_F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DRectF object from D2D1_RECT_F object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="M:CD2DRectF.#ctor(D2D_RECT_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRectF object from D2D1_RECT_F object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="M:CD2DRectF.#ctor(CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRectF object from CRect object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="T:CD2DRectF">
            <summary>
D2D1_RECT_F wrapper
</summary>
        </member>
        <member name="M:CD2DSizeU.op_Implicit~CSize">
            <summary>
Converts CD2DSizeU to CSize object.</summary>
            <returns>
Current value of D2D size.
</returns>
        </member>
        <member name="M:CD2DSizeU.IsNull">
            <summary>
Returns a Boolean value that indicates whether an expression contains no valid data (Null).</summary>
            <returns>
TRUE if width and height are empty; otherwise FALSE.
</returns>
        </member>
        <member name="M:CD2DSizeU.#ctor(System.UInt32,System.UInt32)">
            <summary>
Constructs a CD2DSizeU object from two UINT32 values.</summary>
            <param name="cx">source width</param>
            <param name="cy">source height</param>
        </member>
        <member name="M:CD2DSizeU.#ctor(D2D_SIZE_U!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DSizeU object from D2D1_SIZE_U object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="M:CD2DSizeU.#ctor(D2D_SIZE_U!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DSizeU object from D2D1_SIZE_U object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="M:CD2DSizeU.#ctor(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DSizeU object from CSize object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="T:CD2DSizeU">
            <summary>
D2D1_SIZE_U wrapper
</summary>
        </member>
        <member name="M:CD2DSizeF.op_Implicit~CSize">
            <summary>
Converts CD2DSizeF to CSize object.</summary>
            <returns>
Current value of D2D size.
</returns>
        </member>
        <member name="M:CD2DSizeF.IsNull">
            <summary>
Returns a Boolean value that indicates whether an expression contains no valid data (Null).</summary>
            <returns>
TRUE if width and height are empty; otherwise FALSE.
</returns>
        </member>
        <member name="M:CD2DSizeF.#ctor(System.Single,System.Single)">
            <summary>
Constructs a CD2DSizeF object from two FLOAT values.</summary>
            <param name="cx">source width</param>
            <param name="cy">source height</param>
        </member>
        <member name="M:CD2DSizeF.#ctor(D2D_SIZE_F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DSizeF object from D2D1_SIZE_F object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="M:CD2DSizeF.#ctor(D2D_SIZE_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DSizeF object from D2D1_SIZE_F object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="M:CD2DSizeF.#ctor(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DSizeF object from CSize object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="T:CD2DSizeF">
            <summary>
D2D1_SIZE_F wrapper
</summary>
        </member>
        <member name="M:CD2DPointU.op_Implicit~CPoint">
            <summary>
Converts CD2DPointU to CPoint object.</summary>
            <returns>
Current value of D2D point.
</returns>
        </member>
        <member name="M:CD2DPointU.#ctor(System.UInt32,System.UInt32)">
            <summary>
Constructs a CD2DPointU object from two UINT32 values.</summary>
            <param name="uX">source X</param>
            <param name="uY">source Y</param>
        </member>
        <member name="M:CD2DPointU.#ctor(D2D_POINT_2U!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DPointU from object D2D1_POINT_2U object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="M:CD2DPointU.#ctor(D2D_POINT_2U!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DPointU from object D2D1_POINT_2U object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="M:CD2DPointU.#ctor(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DPointU object from CPoint object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="T:CD2DPointU">
            <summary>
D2D1_POINT_2U wrapper
</summary>
        </member>
        <member name="M:CD2DPointF.op_Implicit~CPoint">
            <summary>
Converts CD2DPointF to CPoint object.</summary>
            <returns>
Current value of D2D point.
</returns>
        </member>
        <member name="M:CD2DPointF.#ctor(System.Single,System.Single)">
            <summary>
Constructs a CD2DPointF object from two FLOAT values.</summary>
            <param name="fX">source X</param>
            <param name="fY">source Y</param>
        </member>
        <member name="M:CD2DPointF.#ctor(D2D_POINT_2F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DPointF object from D2D1_POINT_2F object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="M:CD2DPointF.#ctor(D2D_POINT_2F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DPointF object from D2D1_POINT_2F object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="M:CD2DPointF.#ctor(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DPointF object from CPoint object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="T:CD2DPointF">
            <summary>
D2D1_POINT_2F wrapper
</summary>
        </member>
        <member name="M:CCustomTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <remarks>
This method also can set initial value and initial velocity to be applied to an animation variable, which is
associated with this transition. For this purpose you have to call SetInitialValue and SetInitialVelocity before
the framework creates the encapsulated transition COM object (it happens when you call CAnimationController::AnimateGroup).
</remarks>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="M:CCustomTransition.SetInitialVelocity(System.Double)">
            <summary>
Sets an initial velocity, which will be applied to an animation variable associated with this transition.
</summary>
        </member>
        <member name="M:CCustomTransition.SetInitialValue(System.Double)">
            <summary>
Sets an initial value, which will be applied to an animation variable associated with this transition.
</summary>
        </member>
        <member name="M:CCustomTransition.#ctor(CCustomInterpolator*)">
            <summary>
Constructs a custom transition object.
</summary>
            <param name="pInterpolator">A pointer to custom interpolator.</param>
        </member>
        <member name="F:CCustomTransition.m_initialVelocity">
            <summary>
Stores the initial velocity.
</summary>
        </member>
        <member name="F:CCustomTransition.m_initialValue">
            <summary>
Stores the initial value.
</summary>
        </member>
        <member name="F:CCustomTransition.m_bInitialVelocitySpecified">
            <summary>
Specifies whether the initial velocity was specified with SetInitialVelocity.
</summary>
        </member>
        <member name="F:CCustomTransition.m_bInitialValueSpecified">
            <summary>
Specifies whether the initial value was specified with SetInitialValue.
</summary>
        </member>
        <member name="F:CCustomTransition.m_pInterpolator">
            <summary>
Stores a pointer to a custom interpolator.
</summary>
        </member>
        <member name="T:CCustomTransition">
            <summary>
Implements custom transition.
</summary>
            <remarks>
The CCustomTransitions class allows developers to implement custom transitions. It's created and used
as a standard transition, but its constructor accepts as parameter a pointer to a custom interpolator.
Perform the following steps to use custom transitions:
1. Derive a class from CCustomInterpolator and implement at least InterpolateValue method.
2. Ensure that the lifetime of custom interpolator object must be longer than duration of animation where it's used.
3. Instantiate (using operator new) a CCustomTransition object and pass a pointer to custom interpolator in the constructor.
4. Call CCustomTransition::SetInitialValue and CCustomTransition::SetInitialVelocity if these parameters are required for custom interpolation.
5. Pass the pointer to custom transition to AddTransition method of animation object, whose value should be animated with the custom algorithm.
6. When the value of animation object should change Windows Animation API will call InterpolateValue (and other relevant methods) in CCustomInterpolator.
</remarks>
        </member>
        <member name="M:CInterpolatorBase.GetDependencies(__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*,__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*,__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*)">
            <summary>
Gets the interpolator's dependencies.
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the GetDependencies method.
</returns>
            <param name="initialValueDependencies">Output. Aspects of the interpolator that depend on the initial value passed to SetInitialValueAndVelocity.</param>
            <param name="initialVelocityDependencies">Output. Aspects of the interpolator that depend on the initial velocity passed to SetInitialValueAndVelocity.</param>
            <param name="durationDependencies">Output. Aspects of the interpolator that depend on the duration passed to SetDuration.</param>
        </member>
        <member name="M:CInterpolatorBase.InterpolateVelocity(System.Double,System.Double*)">
            <summary>
Interpolates the velocity at a given offset
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the InterpolateVelocity method.
</returns>
            <param name="offset">The offset from the start of the transition.
The offset is always greater than or equal to zero and less than or equal to the duration of the transition.
This method is not called if the duration of the transition is zero. </param>
            <param name="velocity">Output. The velocity of the variable at the offset.</param>
        </member>
        <member name="M:CInterpolatorBase.InterpolateValue(System.Double,System.Double*)">
            <summary>
Interpolates the value at a given offset
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the InterpolateValue method.
</returns>
            <param name="offset">The offset from the start of the transition.
The offset is always greater than or equal to zero and less than the duration of the transition.
This method is not called if the duration of the transition is zero.</param>
            <param name="value">Output. The interpolated value.</param>
        </member>
        <member name="M:CInterpolatorBase.GetFinalValue(System.Double*)">
            <summary>
Gets the final value to which the interpolator leads.
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the GetFinalValue method.
</returns>
            <param name="value">Output. The final value of a variable at the end of the transition.</param>
        </member>
        <member name="M:CInterpolatorBase.GetDuration(System.Double*)">
            <summary>
Gets the interpolator's duration.
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the GetDuration method.
</returns>
            <param name="duration">Output. The duration of the transition, in seconds.</param>
        </member>
        <member name="M:CInterpolatorBase.SetDuration(System.Double)">
            <summary>
Sets the interpolator's duration
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the SetDuration method.
</returns>
            <param name="duration">The duration of the transition.</param>
        </member>
        <member name="M:CInterpolatorBase.SetInitialValueAndVelocity(System.Double,System.Double)">
            <summary>
Sets the interpolator's initial value and velocity.
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the SetInitialValueAndVelocity method.
</returns>
            <param name="initialValue">The value of the variable at the start of the transition.</param>
            <param name="initialVelocity">The velocity of the variable at the start of the transition.</param>
        </member>
        <member name="M:CInterpolatorBase.CreateInstance(CCustomInterpolator*,IUIAnimationInterpolator**)">
            <summary>
Creates an instance of CInterpolatorBase and stores a pointer to custom interpolator, which will be handling events.
</summary>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
<param name="pInterpolator">A pointer to custom interpolator.</param><param name="ppHandler">Output. Contains a pointer to instance of CInterpolatorBase when the function returns.</param></member>
        <member name="M:CInterpolatorBase.SetCustomInterpolator(CCustomInterpolator*)">
            <summary>
Stores  a pointer to custom interpolator, which will be handling events.
</summary>
            <param name="pInterpolator">A pointer to custom interpolator.</param>
        </member>
        <member name="M:CInterpolatorBase.#ctor">
            <summary>
Constructs the CInterpolatorBase object.
</summary>
        </member>
        <member name="T:CInterpolatorBase">
            <summary>
Implements a callback, which is called by Animation API when it needs to calculate a new value of animation variable.
</summary>
            <remarks>
This handler is created and passed to IUIAnimationTransitionFactory::CreateTransition when a CCustomTransition
object is being created as a part of animation initialization process (started by CAnimationController::AnimateGroup).
Usually you don't need to use this class directly, it just routs all events to a CCustomInterpolator-derived class, whose
pointer is passed to constructor of CCustomTransition.
</remarks>
        </member>
        <member name="M:CCustomInterpolator.GetDependencies(__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*,__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*,__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*)">
            <summary>
Gets the interpolator's dependencies.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="initialValueDependencies">Output. Aspects of the interpolator that depend on the initial value passed to SetInitialValueAndVelocity.</param>
            <param name="initialVelocityDependencies">Output. Aspects of the interpolator that depend on the initial velocity passed to SetInitialValueAndVelocity.</param>
            <param name="durationDependencies">Output. Aspects of the interpolator that depend on the duration passed to SetDuration.</param>
        </member>
        <member name="M:CCustomInterpolator.InterpolateVelocity(System.Double,System.Double*)">
            <summary>
Interpolates the velocity at a given offset
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="offset">The offset from the start of the transition.
The offset is always greater than or equal to zero and less than or equal to the duration of the transition.
This method is not called if the duration of the transition is zero. </param>
            <param name="velocity">Output. The velocity of the variable at the offset.</param>
        </member>
        <member name="M:CCustomInterpolator.InterpolateValue(System.Double,System.Double*)">
            <summary>
Interpolates the value at a given offset.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="offset">The offset from the start of the transition.
The offset is always greater than or equal to zero and less than the duration of the transition.
This method is not called if the duration of the transition is zero.</param>
            <param name="value">Output. The interpolated value.</param>
        </member>
        <member name="M:CCustomInterpolator.GetFinalValue(System.Double*)">
            <summary>
Gets the final value to which the interpolator leads.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="value">Output. The final value of a variable at the end of the transition.</param>
        </member>
        <member name="M:CCustomInterpolator.GetDuration(System.Double*)">
            <summary>
Gets the interpolator's duration.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="duration">Output. The duration of the transition, in seconds.</param>
        </member>
        <member name="M:CCustomInterpolator.SetDuration(System.Double)">
            <summary>
Sets the interpolator's duration.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="duration">The duration of the transition.</param>
        </member>
        <member name="M:CCustomInterpolator.SetInitialValueAndVelocity(System.Double,System.Double)">
            <summary>
Sets the interpolator's initial value and velocity.
</summary>
            <returns>
The basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="initialValue">The value of the variable at the start of the transition.</param>
            <param name="initialVelocity">The velocity of the variable at the start of the transition.</param>
        </member>
        <member name="M:CCustomInterpolator.Init(System.Double,System.Double)">
            <summary>
Initializes duration and final value.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="finalValue">The final value of a variable at the end of the transition.</param>
        </member>
        <member name="M:CCustomInterpolator.#ctor(System.Double,System.Double)">
            <summary>
Constructs a custom interpolator object and initializes duration and velocity to specified values.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="finalValue" />
        </member>
        <member name="M:CCustomInterpolator.#ctor">
            <summary>
Constructs a custom interpolator object and sets all values to default 0.
</summary>
            <remarks>
Use CCustomInterpolator::Init to initialize duration and final value later in the code.
</remarks>
        </member>
        <member name="F:CCustomInterpolator.m_currentVelocity">
            <summary>
The interpolated velocity.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_currentValue">
            <summary>
The interpolated value.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_initialVelocity">
            <summary>
The velocity of the variable at the start of the transition.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_initialValue">
            <summary>
The value of the variable at the start of the transition.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_finalValue">
            <summary>
The final value of a variable at the end of the transition.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="T:CCustomInterpolator">
            <summary>
Implements a basic interpolator.
</summary>
            <remarks>
Derive a class from CCustomInterpolator and override all necessary methods in order to implement a custom
interpolation algorithm. A pointer to this class should be passed as a parameter to CCustomTransition.
</remarks>
        </member>
        <member name="M:CSinusoidalTransitionFromVelocity.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CSinusoidalTransitionFromVelocity.m_period">
            <summary>
The period of oscillation of the sinusoidal wave in seconds.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromVelocity.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CSinusoidalTransitionFromVelocity.#ctor(System.Double,System.Double)">
            <summary>
Constructs a transition object.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="period">The period of oscillation of the sinusoidal wave in seconds. </param>
        </member>
        <member name="T:CSinusoidalTransitionFromVelocity">
            <summary>
Encapsulates a sinusoidal-velocity transition, with an amplitude determined by the animation variable's initial velocity..
</summary>
            <remarks>
The value of the animation variable oscillates around the initial value over the entire duration of a
sinusoidal-range transition. The amplitude of the oscillation is determined by the animation variable's velocity
when the transition begins.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CSinusoidalTransitionFromRange.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_slope">
            <summary>
The slope at the start of the transition.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_period">
            <summary>
The period of oscillation of the sinusoidal wave in seconds.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_dblMaximumValue">
            <summary>
The value of the animation variable at a peak of the sinusoidal wave.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_dblMinimumValue">
            <summary>
The value of the animation variable at a trough of the sinusoidal wave.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CSinusoidalTransitionFromRange.#ctor(System.Double,System.Double,System.Double,System.Double,__MIDL___MIDL_itf_UIAnimation_0000_0009_0001)">
            <summary>
Constructs a transition object.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="dblMinimumValue">The value of the animation variable at a trough of the sinusoidal wave.</param>
            <param name="dblMaximumValue">The value of the animation variable at a peak of the sinusoidal wave.</param>
            <param name="period">The period of oscillation of the sinusoidal wave in seconds. </param>
            <param name="slope">The slope at the start of the transition. </param>
        </member>
        <member name="T:CSinusoidalTransitionFromRange">
            <summary>
Encapsulates a sinusoidal-range transition, with a given range of oscillation.
</summary>
            <remarks>
The value of the animation variable fluctuates between the specified minimum and maximum values over the entire
duration of a sinusoidal-range transition. The slope parameter is used to disambiguate between the two possible
sine waves specified by the other parameters.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CReversalTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CReversalTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CReversalTransition.#ctor(System.Double)">
            <summary>
Constructs a reversal transition object and initializes its duration.
</summary>
            <param name="duration">The duration of the transition. </param>
        </member>
        <member name="T:CReversalTransition">
            <summary>
Encapsulates a reversal transition.
</summary>
            <remarks>
A reversal transition smoothly changes direction over a given duration.
The final value will be the same as the initial value and the final velocity will be the negative of the initial velocity.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CParabolicTransitionFromAcceleration.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CParabolicTransitionFromAcceleration.m_dblAcceleration">
            <summary>
The acceleration of the animation variable during the transition.
</summary>
        </member>
        <member name="F:CParabolicTransitionFromAcceleration.m_dblFinalVelocity">
            <summary>
The velocity of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CParabolicTransitionFromAcceleration.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="M:CParabolicTransitionFromAcceleration.#ctor(System.Double,System.Double,System.Double)">
            <summary>
Constructs a parabolic-acceleration transition and initializes it with specified parameters.
</summary>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition. </param>
            <param name="dblFinalVelocity">The velocity of the animation variable at the end of the transition. </param>
            <param name="dblAcceleration">The acceleration of the animation variable during the transition.</param>
        </member>
        <member name="T:CParabolicTransitionFromAcceleration">
            <summary>
Encapsulates a parabolic-acceleration transition.
</summary>
            <remarks>
During a parabolic-acceleration transition, the value of the animation variable changes from the initial value
to the final value ending at a specified velocity. You can control how quickly the variable reaches the final
value by specifying the rate of acceleration.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CSmoothStopTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CSmoothStopTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CSmoothStopTransition.m_maximumDuration">
            <summary>
The maximum duration of the transition.
</summary>
        </member>
        <member name="M:CSmoothStopTransition.#ctor(System.Double,System.Double)">
            <summary>
Constructs a smooth-stop transition and initializes its maximum duration and final value.
</summary>
            <param name="maximumDuration">The maximum duration of the transition.</param>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition.</param>
        </member>
        <member name="T:CSmoothStopTransition">
            <summary>
Encapsulates a smooth-stop transition.
</summary>
            <remarks>
A smooth-stop transition slows down as it approaches a given final value, and reaches it with a velocity of zero.
The duration of the transition is determined by the initial velocity, the difference between the initial and final values,
and the specified maximum duration. If there is no solution consisting of a single parabolic arc,
this method creates a cubic transition.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CLinearTransitionFromSpeed.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CLinearTransitionFromSpeed.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CLinearTransitionFromSpeed.m_dblSpeed">
            <summary>
The absolute value of the variable's velocity.
</summary>
        </member>
        <member name="M:CLinearTransitionFromSpeed.#ctor(System.Double,System.Double)">
            <summary>
Constructs a linear-speed transition object and initializes it with speed and final value.
</summary>
            <param name="dblSpeed">The absolute value of the variable's velocity.</param>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition.</param>
        </member>
        <member name="T:CLinearTransitionFromSpeed">
            <summary>
Encapsulates a linear-speed transition.
</summary>
            <remarks>
During a linear-speed transition, the value of the animation variable changes at a specified rate.
The duration of the transition is determined by the difference between the initial value and the specified final value.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CLinearTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CLinearTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CLinearTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CLinearTransition.#ctor(System.Double,System.Double)">
            <summary>
Constructs a linear transition object and initializes it with duration and final value.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition.</param>
        </member>
        <member name="T:CLinearTransition">
            <summary>
Encapsulates a linear transition.
</summary>
            <remarks>
During a linear transition, the value of the animation variable transitions linearly from its initial value to a specified final value.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CInstantaneousTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CInstantaneousTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="M:CInstantaneousTransition.#ctor(System.Double)">
            <summary>
Constructs a transition object and initializes its final value.
</summary>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition.</param>
        </member>
        <member name="T:CInstantaneousTransition">
            <summary>
Encapsulates an instantaneous transition.
</summary>
            <remarks>
During an instantaneous transition, the value of the animation variable changes instantly from its current
value to a specified final value. The duration of this transition is always zero.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CDiscreteTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CDiscreteTransition.m_hold">
            <summary>
The amount of time by which to hold the variable at its final value.
</summary>
        </member>
        <member name="F:CDiscreteTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CDiscreteTransition.m_delay">
            <summary>
The amount of time by which to delay the instantaneous switch to the final value.
</summary>
        </member>
        <member name="M:CDiscreteTransition.#ctor(System.Double,System.Double,System.Double)">
            <summary>
Constructs a discrete transition object and initializes its parameters.
</summary>
            <param name="delay">The amount of time by which to delay the instantaneous switch to the final value.</param>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition. </param>
            <param name="hold">The amount of time by which to hold the variable at its final value.</param>
        </member>
        <member name="T:CDiscreteTransition">
            <summary>
Encapsulates a discrete transition.
</summary>
            <remarks>
During a discrete transition, the animation variable remains at the initial value for a specified delay time,
then switches instantaneously to a specified final value and remains at that value for a given hold time.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CCubicTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CCubicTransition.m_dblFinalVelocity">
            <summary>
The velocity of the variable at the end of the transition.
</summary>
        </member>
        <member name="F:CCubicTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CCubicTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CCubicTransition.#ctor(System.Double,System.Double,System.Double)">
            <summary>
Constructs a transition object and initializes its parameters.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="finalValue">The value of the animation variable at the end of the transition.</param>
            <param name="finalVelocity">The velocity of the variable at the end of the transition.</param>
        </member>
        <member name="T:CCubicTransition">
            <summary>
Encapsulates a cubic transition.
</summary>
            <remarks>
During a cubic transition, the value of the animation variable changes from its initial value to a specified
final value over the duration of the transition, ending at a specified velocity.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CConstantTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CConstantTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CConstantTransition.#ctor(System.Double)">
            <summary>
Constructs a transition object and initializes its duration.
</summary>
            <param name="duration">The duration of the transition. </param>
        </member>
        <member name="T:CConstantTransition">
            <summary>
Encapsulates a constant transition.
</summary>
            <remarks>
During a constant transition, the value of an animation variable remains at the initial value over the duration
of the transition.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CAccelerateDecelerateTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CAccelerateDecelerateTransition.m_decelerationRatio">
            <summary>
The ratio of the time spent decelerating to the duration.
</summary>
        </member>
        <member name="F:CAccelerateDecelerateTransition.m_accelerationRatio">
            <summary>
The ratio of the time spent accelerating to the duration.
</summary>
        </member>
        <member name="F:CAccelerateDecelerateTransition.m_finalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CAccelerateDecelerateTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CAccelerateDecelerateTransition.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
Constructs a transition object.
</summary>
            <param name="duration">The duration of the transition. </param>
            <param name="finalValue">The value of the animation variable at the end of the transition. </param>
            <param name="accelerationRatio">The ratio of the time spent accelerating to the duration.</param>
            <param name="decelerationRatio">The ratio of the time spent decelerating to the duration. </param>
        </member>
        <member name="T:CAccelerateDecelerateTransition">
            <summary>
Implements an accelerate-decelerate transition.
</summary>
            <remarks>
During an accelerate-decelerate transition, the animation variable speeds up and then slows down over the
duration of the transition, ending at a specified value. You can control how quickly the variable accelerates and
decelerates independently, by specifying different acceleration and deceleration ratios.
When the initial velocity is zero, the acceleration ratio is the fraction of the duration that the variable will
spend accelerating; likewise with the deceleration ratio. If the initial velocity is non-zero, it is the
fraction of the time between the velocity reaching zero and the end of transition. The acceleration ratio and
the deceleration ratio should sum to a maximum of 1.0.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CAnimationTimerEventHandler.OnRenderingTooSlow(System.UInt32)">
            <summary>
Handles events that occur when the rendering frame rate for an animation falls below the minimum desirable frame rate.
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
        </member>
        <member name="M:CAnimationTimerEventHandler.OnPostUpdate">
            <summary>
Handles events that occur after an animation update is finished.
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
        </member>
        <member name="M:CAnimationTimerEventHandler.OnPreUpdate">
            <summary>
Handles events that occur before an animation update begins.
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
        </member>
        <member name="M:CAnimationTimerEventHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationTimerEventHandler.CreateInstance(CAnimationController*,IUIAnimationTimerEventHandler**)">
            <summary>
Creates an instance of CAnimationTimerEventHandler callback.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppTimerEventHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
animation timer events.</param>
        </member>
        <member name="T:CAnimationTimerEventHandler">
            <summary>
Implements a call back, which is called by Animation API when timing events occur.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationTimer::SetTimerEventHandler when you call
CAnimationController::EnableAnimationTimerEventHandler.
</remarks>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.OnStoryboardUpdated(IUIAnimationStoryboard*)">
            <summary>
Handles OnStoryboardUpdated events, which occur when a storyboard is updated
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
            <param name="storyboard">A pointer to storyboard, which was updated.</param>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.OnStoryboardStatusChanged(IUIAnimationStoryboard*,__MIDL___MIDL_itf_UIAnimation_0000_0002_0001,__MIDL___MIDL_itf_UIAnimation_0000_0002_0001)">
            <summary>
Handles OnStoryboardStatusChanged events, which occur when a storyboard's status changes
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
            <param name="storyboard">A pointer to storyboard whose status has changed.</param>
            <param name="newStatus">Specifies new storyboard status.</param>
            <param name="previousStatus">Specifies previous storyboard status.</param>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.CreateInstance(CAnimationController*,IUIAnimationStoryboardEventHandler**)">
            <summary>
Creates an instance of CAnimationStoryboardEventHandler callback.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
storyboard events.</param>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.#ctor">
            <summary>
Constructs a CAnimationStoryboardEventHandler object.
</summary>
        </member>
        <member name="T:CAnimationStoryboardEventHandler">
            <summary>
Implements a callback, which is called by Animation API when storyboard's status is changed or storyboard is updated.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationStoryboard::SetStoryboardEventHandler method,
when you call CAnimationController::EnableStoryboardEventHandler.
</remarks>
        </member>
        <member name="M:CAnimationVariableIntegerChangeHandler.OnIntegerValueChanged(IUIAnimationStoryboard*,IUIAnimationVariable*,System.Int32,System.Int32)">
            <summary>
Called when a value of an animation variable has changed.
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
            <param name="storyboard">The storyboard that is animating the variable.</param>
            <param name="variable">The animation variable that was updated.</param>
            <param name="newValue">The new rounded value.</param>
            <param name="previousValue">The previous rounded value.</param>
        </member>
        <member name="M:CAnimationVariableIntegerChangeHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationVariableIntegerChangeHandler.CreateInstance(CAnimationController*,IUIAnimationVariableIntegerChangeHandler**)">
            <summary>
Creates an instance of CAnimationVariableIntegerChangeHandler callback.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
variable integer change events.</param>
        </member>
        <member name="M:CAnimationVariableIntegerChangeHandler.#ctor">
            <summary>
Constructs a CAnimationVariableIntegerChangeHandler object.
</summary>
        </member>
        <member name="T:CAnimationVariableIntegerChangeHandler">
            <summary>
Implements a call back, which is called by Animation API when the value of an animation variable changes.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationVariable::SetVariableIntegerChangeHandler method,
when you call CAnimationVariable::EnableIntegerValueChangedEvent or CAnimationBaseObject::EnableIntegerValueChangedEvent
(which enables this event for all animation variables encapsulated in an animation object).
</remarks>
        </member>
        <member name="M:CAnimationVariableChangeHandler.OnValueChanged(IUIAnimationStoryboard*,IUIAnimationVariable*,System.Double,System.Double)">
            <summary>
Called when a value of an animation variable has changed.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="storyboard">The storyboard that is animating the variable.</param>
            <param name="variable">The animation variable that was updated.</param>
            <param name="newValue">The new value.</param>
            <param name="previousValue">The previous value.</param>
        </member>
        <member name="M:CAnimationVariableChangeHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationVariableChangeHandler.CreateInstance(CAnimationController*,IUIAnimationVariableChangeHandler**)">
            <summary>
Creates an instance of CAnimationVariableChangeHandler object.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
variable change events.</param>
        </member>
        <member name="M:CAnimationVariableChangeHandler.#ctor">
            <summary>
Constructs a CAnimationVariableChangeHandler object.
</summary>
        </member>
        <member name="T:CAnimationVariableChangeHandler">
            <summary>
Implements a call back, which is called by Animation API when the value of an animation variable changes.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationVariable::SetVariableChangeHandler method,
when you call CAnimationVariable::EnableValueChangedEvent or CAnimationBaseObject::EnableValueChangedEvent
(which enables this event for all animation variables encapsulated in an animation object).
</remarks>
        </member>
        <member name="M:CAnimationManagerEventHandler.OnManagerStatusChanged(__MIDL___MIDL_itf_UIAnimation_0000_0000_0002,__MIDL___MIDL_itf_UIAnimation_0000_0000_0002)">
            <summary>
Called when a status of animation manager has changed.
</summary>
            <returns>
Current implementation always returns S_OK;
</returns>
            <param name="newStatus">New status.</param>
            <param name="previousStatus">Previous status.</param>
        </member>
        <member name="M:CAnimationManagerEventHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationManagerEventHandler.CreateInstance(CAnimationController*,IUIAnimationManagerEventHandler**)">
            <summary>
Creates an instance of CAnimationManagerEventHandler object.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppManagerEventHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
status updates to an animation manager.</param>
        </member>
        <member name="M:CAnimationManagerEventHandler.#ctor">
            <summary>
Constructs a CAnimationManagerEventHandler object.
</summary>
        </member>
        <member name="T:CAnimationManagerEventHandler">
            <summary>
Implements a callback, which is called by Animation API when a status of animation manager changed.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationManager::SetManagerEventHandler method,
when you call CAnimationController::EnableAnimationManagerEvent.
</remarks>
        </member>
        <member name="M:CAnimationController.CleanUpGroup(CAnimationGroup*)">
            <summary>
A helper that cleans up the group.
</summary>
            <remarks>
This method removes all transitions and keyframes from the specified group.
</remarks>
            <param name="pGroup">A pointer to animation group to clean.</param>
        </member>
        <member name="M:CAnimationController.OnAfterSchedule(CAnimationGroup*)">
            <summary>
Called by the framework when an animation for the specified group has just been scheduled.
</summary>
            <remarks>
The default implementation removes keyframes from the specified group and transitions from animation variables that
belong to the specified group. Can be overridden in a derived class to take any additional actions upon animation schedule.
</remarks>
            <param name="pGroup">A pointer to an animation group, which has been scheduled.</param>
        </member>
        <member name="M:CAnimationController.OnAnimationTimerRenderingTooSlow(System.UInt32)">
            <summary>
Called by the framework when the rendering frame rate for an animation falls below a minimum desirable frame rate.
</summary>
            <remarks>
This method is called if you enable timer event handlers using EnableAnimationTimerEventHandler.
It can be overridden in a derived class to take application-specific actions.
The minimum desirable frame rate is specified by calling IUIAnimationTimer::SetFrameRateThreshold.
</remarks>
            <param name="fps">The current frame rate in frames per second. </param>
        </member>
        <member name="M:CAnimationController.OnAnimationTimerPostUpdate">
            <summary>
Called by the framework after an animation update is finished.
</summary>
            <remarks>
This method is called if you enable timer event handlers using EnableAnimationTimerEventHandler.
It can be overridden in a derived class to take application-specific actions.
</remarks>
        </member>
        <member name="M:CAnimationController.OnAnimationTimerPreUpdate">
            <summary>
Called by the framework before an animation update begins.
</summary>
            <remarks>
This method is called if you enable timer event handlers using EnableAnimationTimerEventHandler.
It can be overridden in a derived class to take application-specific actions.
</remarks>
        </member>
        <member name="M:CAnimationController.OnHasPriorityCompress(CAnimationGroup*,CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0008_0001)">
            <summary>
Called by the framework to resolve scheduling conflicts.
</summary>
            <returns>
Should return TRUE if storyboard owned by pGroupNew has priority. Should return FALSE if storyboard owned by
pGroupScheduled has priority.
</returns>
            <remarks>
This method is called if you enable priority comparison events using CAnimationController::EnablePriorityComparisonHandler
and specify UI_ANIMATION_PHT_COMPRESS.
It can be overridden in a derived class to take application-specific actions.
Read Windows Animation API documentation for more information about Conflict Management (http://msdn.microsoft.com/en-us/library/dd371759(VS.85).aspx).
</remarks>
            <param name="pGroupScheduled">The group that owns the currently scheduled storyboard.</param>
            <param name="pGroupNew">The group that owns the new storyboard that is in scheduling conflict with the scheduled storyboard owned by pGroupScheduled.</param>
            <param name="priorityEffect">The potential effect on pGroupNew if pGroupScheduled has a higher priority.</param>
        </member>
        <member name="M:CAnimationController.OnHasPriorityTrim(CAnimationGroup*,CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0008_0001)">
            <summary>
Called by the framework to resolve scheduling conflicts.
</summary>
            <returns>
Should return TRUE if storyboard owned by pGroupNew has priority. Should return FALSE if storyboard owned by
pGroupScheduled has priority.
</returns>
            <remarks>
This method is called if you enable priority comparison events using CAnimationController::EnablePriorityComparisonHandler
and specify UI_ANIMATION_PHT_TRIM.
It can be overridden in a derived class to take application-specific actions.
Read Windows Animation API documentation for more information about Conflict Management (http://msdn.microsoft.com/en-us/library/dd371759(VS.85).aspx).
</remarks>
            <param name="pGroupScheduled">The group that owns the currently scheduled storyboard.</param>
            <param name="pGroupNew">The group that owns the new storyboard that is in scheduling conflict with the scheduled storyboard owned by pGroupScheduled.</param>
            <param name="priorityEffect">The potential effect on pGroupNew if pGroupScheduled has a higher priority.</param>
        </member>
        <member name="M:CAnimationController.OnHasPriorityConclude(CAnimationGroup*,CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0008_0001)">
            <summary>
Called by the framework to resolve scheduling conflicts.
</summary>
            <returns>
Should return TRUE if storyboard owned by pGroupNew has priority. Should return FALSE if storyboard owned by
pGroupScheduled has priority.
</returns>
            <remarks>
This method is called if you enable priority comparison events using CAnimationController::EnablePriorityComparisonHandler
and specify UI_ANIMATION_PHT_CONCLUDE.
It can be overridden in a derived class to take application-specific actions.
Read Windows Animation API documentation for more information about Conflict Management (http://msdn.microsoft.com/en-us/library/dd371759(VS.85).aspx).
</remarks>
            <param name="pGroupScheduled">The group that owns the currently scheduled storyboard.</param>
            <param name="pGroupNew">The group that owns the new storyboard that is in scheduling conflict with the scheduled storyboard owned by pGroupScheduled.</param>
            <param name="priorityEffect">The potential effect on pGroupNew if pGroupScheduled has a higher priority.</param>
        </member>
        <member name="M:CAnimationController.OnHasPriorityCancel(CAnimationGroup*,CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0008_0001)">
            <summary>
Called by the framework to resolve scheduling conflicts.
</summary>
            <returns>
Should return TRUE if storyboard owned by pGroupNew has priority. Should return FALSE if storyboard owned by
pGroupScheduled has priority.
</returns>
            <remarks>
This method is called if you enable priority comparison events using CAnimationController::EnablePriorityComparisonHandler
and specify UI_ANIMATION_PHT_CANCEL.
It can be overridden in a derived class to take application-specific actions.
Read Windows Animation API documentation for more information about Conflict Management (http://msdn.microsoft.com/en-us/library/dd371759(VS.85).aspx).
</remarks>
            <param name="pGroupScheduled">The group that owns the currently scheduled storyboard.</param>
            <param name="pGroupNew">The group that owns the new storyboard that is in scheduling conflict with the scheduled storyboard owned by pGroupScheduled.</param>
            <param name="priorityEffect">The potential effect on pGroupNew if pGroupScheduled has a higher priority.</param>
        </member>
        <member name="M:CAnimationController.OnStoryboardUpdated(CAnimationGroup*)">
            <summary>
Called by the framework when storyboard has been updated.
</summary>
            <remarks>
This method is called if you enable storyboard events using CAnimationController::EnableStoryboardEventHandler.
It can be overridden in a derived class to take application-specific actions.
</remarks>
            <param name="pGroup">A pointer to a group that owns the storyboard.</param>
        </member>
        <member name="M:CAnimationController.OnStoryboardStatusChanged(CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0002_0001,__MIDL___MIDL_itf_UIAnimation_0000_0002_0001)">
            <summary>
Called by the framework when storyboard status has changed.
</summary>
            <remarks>
This method is called if you enable storyboard events using CAnimationController::EnableStoryboardEventHandler.
It can be overridden in a derived class to take application-specific actions.
</remarks>
            <param name="pGroup">A pointer to an animation group that owns the storyboard whose status has changed.</param>
            <param name="newStatus">Specifies the new status.</param>
            <param name="previousStatus">Specifies the previous status.</param>
        </member>
        <member name="M:CAnimationController.OnAnimationIntegerValueChanged(CAnimationGroup*,CAnimationBaseObject*,IUIAnimationVariable*,System.Int32,System.Int32)">
            <summary>
Called by the framework when integer value of animation variable has changed.
</summary>
            <remarks>
This method is called if you enable animation variable events with EnableIntegerValueChangedEvent called for a specific
animation variable or animation object.
It can be overridden in a derived class to take application-specific actions.
</remarks>
            <param name="pGroup">A pointer to an animation group that holds an animation object whose value has changed.</param>
            <param name="pObject">A pointer to an animation object that contains an animation variable whose value has changed.</param>
            <param name="variable">A pointer to an animation variable.</param>
            <param name="newValue">Specifies new value.</param>
            <param name="prevValue">Specifies previous value.</param>
        </member>
        <member name="M:CAnimationController.OnAnimationValueChanged(CAnimationGroup*,CAnimationBaseObject*,IUIAnimationVariable*,System.Double,System.Double)">
            <summary>
Called by the framework when value of animation variable has changed.
</summary>
            <remarks>
This method is called if you enable animation variable events with EnableValueChangedEvent called for a specific
animation variable or animation object.
It can be overridden in a derived class to take application-specific actions.
</remarks>
            <param name="pGroup">A pointer to an animation group that holds an animation object whose value has changed.</param>
            <param name="pObject">A pointer to an animation object that contains an animation variable whose value has changed.</param>
            <param name="variable">A pointer to an animation variable.</param>
            <param name="newValue">Specifies new value.</param>
            <param name="prevValue">Specifies previous value.</param>
        </member>
        <member name="M:CAnimationController.OnAnimationManagerStatusChanged(__MIDL___MIDL_itf_UIAnimation_0000_0000_0002,__MIDL___MIDL_itf_UIAnimation_0000_0000_0002)">
            <summary>
Called by the framework in response to StatusChanged event from animation manager.
</summary>
            <remarks>
This method is called if you enable animation manager events with EnableAnimationManagerEvent.
It can be overridden in a derived class to take application-specific actions. The default implementation
updates a related window if it has been set with SetRelatedWnd.
</remarks>
            <param name="newStatus">New animation manager status.</param>
            <param name="previousStatus">Previous animation manager status.</param>
        </member>
        <member name="M:CAnimationController.OnBeforeAnimationStart(CAnimationGroup*)">
            <summary>
Called by the framework right before the animation is scheduled.
</summary>
            <remarks>
This call is routed to related CWnd and can be overridden in a derived class to perform any
additional actions before the animation starts for the specified group.
</remarks>
            <param name="pGroup">A pointer to an animation group whose animation is about to start.</param>
        </member>
        <member name="M:CAnimationController.CleanUpGroup(System.UInt32)">
            <summary>
Called by the framework to clean up the group when animation has been scheduled.
</summary>
            <remarks>
This method removes all transitions and keyframes from the specified group, because they are not relevant
after an animation has been scheduled.
</remarks>
            <param name="nGroupID">Specifies GroupID.</param>
        </member>
        <member name="M:CAnimationController.ScheduleGroup(System.UInt32,System.Double)">
            <summary>
Schedules an animation.
</summary>
            <returns>
TRUE if animation was scheduled successfully. FALSE if storyboard has not been created, or other error occurs.
</returns>
            <remarks>
You must call AnimateGroup with parameter bScheduleNow set to FALSE prior ScheduleGroup. You can specify the
desired animation time obtained from IUIAnimationTimer::GetTime. If the time parameter is 0.0, the animation is scheduled for the
current time.
</remarks>
            <param name="nGroupID">Specifies animation Group ID to schedule.</param>
            <param name="time">Specifies time to schedule.</param>
        </member>
        <member name="M:CAnimationController.AnimateGroup(System.UInt32,System.Int32)">
            <summary>
Prepares a group to run animation and optionally schedules it.
</summary>
            <returns>
TRUE if animation was successfully scheduled and run.
</returns>
            <remarks>
This method does the actual work creating storyboard, adding animation variables, applying transitions and setting keyframes.
It's possible to delay scheduling if you set bScheduleNow to FALSE. In this case the specified group
will hold a storyboard that has been set up for animation. At that point you can setup events for the storyboard and
animation variables. When you actually need to run the animation call CAnimationController::ScheduleGroup.
</remarks>
            <param name="nGroupID">Specifies GroupID.</param>
            <param name="bScheduleNow">Specifies whether to run animation right away.</param>
        </member>
        <member name="M:CAnimationController.FindAnimationObject(IUIAnimationVariable*,CAnimationBaseObject**,CAnimationGroup**)">
            <summary>
Finds animation object containing a specified animation variable.
</summary>
            <returns>
TRUE if object was found; otherwise FALSE.
</returns>
            <remarks>
Called from event handlers when it's required to find an animation object from incoming animation variable.
</remarks>
            <param name="pVariable">A pointer to animation variable.</param>
            <param name="ppObject">Output. Contains a pointer to animation object or NULL. </param>
            <param name="ppGroup">Output. Contains a pointer to animation group that holds the animation object, or NULL.</param>
        </member>
        <member name="M:CAnimationController.FindAnimationGroup(IUIAnimationStoryboard*)">
            <summary>
Finds an animation group by its storyboard.
</summary>
            <returns>
A pointer to animation group if succeeds, or NULL if no group plays the specified storyboard.
</returns>
            <remarks>
This method is usually called from event handlers to find a group by pointer to storyboard that comes as a parameter to an event handler.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
        </member>
        <member name="M:CAnimationController.FindAnimationGroup(System.UInt32)">
            <summary>
Finds an animation group by its Group ID.
</summary>
            <returns>
A pointer to animation group or NULL if the group with specified ID is not found.
</returns>
            <remarks>
Use this method to find an animation group at runtime. A group is created and added to the internal list of animation groups
when a first animation object with particular GroupID is being added to animation controller.
</remarks>
            <param name="nGroupID">Specifies a GroupID.</param>
        </member>
        <member name="M:CAnimationController.AddKeyframeToGroup(System.UInt32,CBaseKeyFrame*)">
            <summary>
Adds a keyframe to group.
</summary>
            <returns>
TRUE if the function succeeds; otherwise FALSE.
</returns>
            <remarks>
Usually you don't need to call this method, use CAnimationController::CreateKeyframe instead, which creates
and adds the created keyframe to a group automatically.
</remarks>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="pKeyframe">A pointer to a keyframe.</param>
        </member>
        <member name="M:CAnimationController.CreateKeyframe(System.UInt32,CBaseKeyFrame*,System.Double)">
            <summary>
Creates a keyframe that depends on other keyframe with optional offset in seconds and adds it to the specified group.
</summary>
            <returns>
A pointer to newly created keyframe if the function succeeds.
</returns>
            <remarks>
You can store the returned pointer and base other keyframes on the newly created keyframe (see the second overload).
It's possible to begin transitions at keyframes - see CBaseTransition::SetKeyframes.
You don't need to delete keyframes created in this way, because they are deleted automatically by animation groups.
Be careful when creating keyframes based on other keyframes and transitions and avoid circular references.
</remarks>
            <param name="nGroupID">Specifies Group ID for which keyframe is created.</param>
            <param name="pKeyframe">A  pointer to base keyframe for this keyframe.</param>
            <param name="offset">Offset in seconds from the base keyframe specified by pKeyframe.</param>
        </member>
        <member name="M:CAnimationController.CreateKeyframe(System.UInt32,CBaseTransition*)">
            <summary>
Creates a keyframe that depends on transition and adds it to the specified group.
</summary>
            <returns>
A pointer to newly created keyframe if the function succeeds.
</returns>
            <remarks>
You can store the returned pointer and base other keyframes on the newly created keyframe (see the second overload).
It's possible to begin transitions at keyframes - see CBaseTransition::SetKeyframes.
You don't need to delete keyframes created in this way, because they are deleted automatically by animation groups.
Be careful when creating keyframes based on other keyframes and transitions and avoid circular references.
</remarks>
            <param name="nGroupID">Specifies Group ID for which keyframe is created.</param>
            <param name="pTransition">A pointer to transition. Keyframe will be inserted to storyboard after this transition.</param>
        </member>
        <member name="M:CAnimationController.RemoveTransitions(System.UInt32)">
            <summary>
Removes transitions from animation objects that belong to the specified group.
</summary>
            <remarks>
The group loops over its animation objects and calls ClearTransitions(FALSE) for each animation object.
This method is called by the framework after animation has been scheduled.
</remarks>
            <param name="nGroupID">Specifies Group ID.</param>
        </member>
        <member name="M:CAnimationController.RemoveAllAnimationGroups">
            <summary>
Removes all animation groups from animation controller.
</summary>
            <remarks>
All groups will be deleted, their pointer, if stored at the application level, must be invalidated.
If CAnimationGroup::m_bAutodestroyAnimationObjects for a group being deleted is TRUE,
all animation objects that belong to that group will be deleted; otherwise their references to parent animation
controller will be set to NULL and they can be added to another controller.
</remarks>
        </member>
        <member name="M:CAnimationController.RemoveAnimationGroup(System.UInt32)">
            <summary>
Removes an animation group with specified ID from animation controller.
</summary>
            <remarks>
This method removes an animation group from the internal list of groups and deletes it, therefore if you stored
a pointer to that animation group, it must be invalidated. If CAnimationGroup::m_bAutodestroyAnimationObjects is TRUE,
all animation objects that belong to that group will be deleted; otherwise their references to parent animation
controller will be set to NULL and they can be added to another controller.
</remarks>
            <param name="nGroupID">Specifies animation group ID.</param>
        </member>
        <member name="M:CAnimationController.RemoveAnimationObject(CAnimationBaseObject*,System.Int32)">
            <summary>
Remove an animation object from animation controller.
</summary>
            <remarks>
Removes an animation object from animation controller and animation group. Call this function if
a particular object should not be animated anymore, or if you need to move the object to another animation controller.
In the last case bNoDelete must be TRUE.
</remarks>
            <param name="pObject">A pointer to an animation object.</param>
            <param name="bNoDelete">If this parameter is TRUE the object will not be deleted upon remove.</param>
        </member>
        <member name="M:CAnimationController.AddAnimationObject(CAnimationBaseObject*)">
            <summary>
Adds an animation object to a group that belongs to the animation controller.
</summary>
            <returns>
A pointer to existing or new animation group where pObject has been added if function succeeds; NULL if
pObject has already been added to a group that belongs to another animation controller.
</returns>
            <remarks>
Call this method to add an animation object to the animation controller. An object will be added to a group
according to object's GroupID (see CAnimationBaseObject::SetID). The animation controller will create a new
group if it's the first object being added with the specified GroupID. An animation object can be added to
one animation controller only. If you need to add an object to another controller, call RemoveAnimationObject first.
If you call SetID with new GroupID for an object that has been already added to a group, the object will be removed
from the old group and added to another group with specified ID.
</remarks>
            <param name="pObject">A pointer to an animation object.</param>
        </member>
        <member name="M:CAnimationController.SetRelatedWnd(CWnd*)">
            <summary>
Establishes a relationship between animation controller and a window.
</summary>
            <remarks>
If a related CWnd object is set, the animation controller can automatically update it (send WM_PAINT message) when
the status of animation manager has changed or timer post update event has occurred.
</remarks>
            <param name="pWnd">A pointer to window object to set.</param>
        </member>
        <member name="M:CAnimationController.IsAnimationInProgress">
            <summary>
Tells whether at least one group is playing animation.
</summary>
            <returns>
TRUE if there is an animation in progress for this animation controller; otherwise FALSE.
</returns>
            <remarks>
Checks status of animation manager and returns TRUE if the status is UI_ANIMATION_MANAGER_BUSY.
</remarks>
        </member>
        <member name="M:CAnimationController.UpdateAnimationManager">
            <summary>
Directs the animation manager to update the values of all animation variables.
</summary>
            <remarks>
Calling this method advances the animation manager to current time, changing statuses of storyboards as necessary
and updating any animation variables to appropriate interpolated values. Internally this method calls
IUIAnimationTimer::GetTime(timeNow) and IUIAnimationManager::Update(timeNow). Override this method in a derived
class to customize this behavior.
</remarks>
        </member>
        <member name="M:CAnimationController.EnableAnimationTimerEventHandler(System.Int32,__MIDL___MIDL_itf_UIAnimation_0000_0012_0001)">
            <summary>
Sets or releases a handler for timing events and handler for timing updates.
</summary>
            <returns>
TRUE if handlers were successfully set or released; FALSE if this method is called for a second time without
releasing the handlers first, or if any other error occurs.
</returns>
            <remarks>
When the handlers are set (enabled) Windows Animation API calls OnAnimationTimerPreUpdate, OnAnimationTimerPostUpdate,
OnRenderingTooSlow methods.
You need to enable animation timers to allow Windows Animation API update storyboards. Otherwise you'll need to
call CAnimationController::UpdateAnimationManager in order to direct the animation manager to update the values
of all animation variables.
</remarks>
            <param name="bEnable">Specifies whether to set or release the handlers.</param>
            <param name="idleBehavior">Specifies idle behavior for timer update handler.</param>
        </member>
        <member name="M:CAnimationController.EnableStoryboardEventHandler(System.UInt32,System.Int32)">
            <summary>
Sets or releases a handler for storyboard status and update events.
</summary>
            <returns>
TRUE if the handler was successfully set or released; FALSE if the specified animation group is now found or
animation for the specified group has not been initiated and its internal storyboard is NULL.
</returns>
            <remarks>
When a handler is set (enabled) Windows Animation API calls OnStoryboardStatusChanges and OnStoryboardUpdated virtual methods.
A handler must be set after CAnimationController::Animate has been called for the specified animation group, because
it creates encapsulated IUIAnimationStoryboard object.
</remarks>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="bEnable">Specifies whether to set or release a handler.</param>
        </member>
        <member name="M:CAnimationController.EnablePriorityComparisonHandler(System.UInt64)">
            <summary>
Sets or releases the priority comparison handler to call to determine whether a scheduled storyboard can be cancelled,
concluded, trimmed or compressed.
</summary>
            <returns>
TRUE if the handler was successfully set or released.
</returns>
            <remarks>
When a handler is set (enabled) Windows Animation calls the following virtual methods depending on dwHandlerType:
OnHasPriorityCancel, OnHasPriorityConclude, OnHasPriorityTrim, OnHasPriorityCompress.
dwHandler can be a combination of the following flags:
UI_ANIMATION_PHT_NONE - release all handlers
UI_ANIMATION_PHT_CANCEL - set Cancel comparison handler
UI_ANIMATION_PHT_CONCLUDE - set Conclude comparison handler
UI_ANIMATION_PHT_COMPRESS - set Compress comparison handler
UI_ANIMATION_PHT_TRIM - set Trim comparison handler
UI_ANIMATION_PHT_CANCEL_REMOVE - remove Cancel comparison handler
UI_ANIMATION_PHT_CONCLUDE_REMOVE - remove Conclude comparison handler
UI_ANIMATION_PHT_COMPRESS_REMOVE - remove Compress comparison handler
UI_ANIMATION_PHT_TRIM_REMOVE - remove Trim comparison handler
</remarks>
            <param name="dwHandlerType">A combination of UI_ANIMATION_PHT_ flags (see remarks), which specifies what handlers to set or release.</param>
        </member>
        <member name="M:CAnimationController.EnableAnimationManagerEvent(System.Int32)">
            <summary>
Sets or releases a handler to call when animation manager's status changes.
</summary>
            <returns>
TRUE if the handler was successfully set or released.
</returns>
            <remarks>
When a handler is set (enabled) Windows Animation calls OnAnimationManagerStatusChanged when animation manager's status changes.
</remarks>
            <param name="bEnable">Specifies whether to set or release a handler.</param>
        </member>
        <member name="M:CAnimationController.GetKeyframeStoryboardStart">
            <summary>
Returns a keyframe that identifies start of storyboard.
</summary>
            <returns>
A pointer to base keyframe, which identifies start of storyboard.
</returns>
            <remarks>
Obtain this keyframe to base any other keyframes or transitions on the moment in time when a storyboard starts.
</remarks>
        </member>
        <member name="M:CAnimationController.IsValid">
            <summary>
Tells whether animation controller is valid.
</summary>
            <returns>
TRUE if animation controller is valid; otherwise FALSE.
</returns>
            <remarks>
This method returns FALSE only if Windows Animation API is not supported on the current OS and creation of
animation manager failed because it's not registered. You need to call GetUIAnimationManager at least once after initialization of
COM libraries to cause setting of this flag.
</remarks>
        </member>
        <member name="M:CAnimationController.GetUITransitionFactory">
            <summary>
A pointer to IUIAnimationTransitionFactory interface or NULL, if creation of transition library failed.
</summary>
            <returns>
A pointer to IUIAnimationTransitionFactory or NULL, if creation of transition factory failed.
</returns>
            <remarks>
If current OS does not support Windows Animation API, this method returns NULL and after that all subsequent calls
on CAnimationController::IsValid return FALSE.
</remarks>
        </member>
        <member name="M:CAnimationController.GetUIAnimationTimer">
            <summary>
Provides access to encapsulated IUIAnimationTimer object.
</summary>
            <returns>
A pointer to IUIAnimationTimer interface or NULL, if creation of animation timer failed.
</returns>
            <remarks>
If current OS does not support Windows Animation API, this method returns NULL and after that all subsequent calls
on CAnimationController::IsValid return FALSE.
</remarks>
        </member>
        <member name="M:CAnimationController.GetUITransitionLibrary">
            <summary>
Provides access to encapsulated IUIAnimationTransitionLibrary object.
</summary>
            <returns>
A pointer to IUIAnimationTransitionLibrary interface or NULL, if creation of transition library failed.
</returns>
            <remarks>
If current OS does not support Windows Animation API, this method returns NULL and after that all subsequent calls
on CAnimationController::IsValid return FALSE.
</remarks>
        </member>
        <member name="M:CAnimationController.GetUIAnimationManager">
            <summary>
Provides access to encapsulated IUIAnimationManager object.
</summary>
            <returns>
A pointer to IUIAnimationManager interface or NULL, if creation of animation manager failed.
</returns>
            <remarks>
If current OS does not support Windows Animation API, this method returns NULL and after that all subsequent calls
on CAnimationController::IsValid return FALSE.
You may need to access IUIAnimationManager in order to call its interface methods, which are not wrapped by
animation controller.
</remarks>
        </member>
        <member name="M:CAnimationController.Dispose">
            <summary>
The destructor. Called when animation controller object is being destroyed.
</summary>
        </member>
        <member name="M:CAnimationController.#ctor">
            <summary>
Constructs an animation controller.
</summary>
        </member>
        <member name="F:CAnimationController.g_KeyframeStoryboardStart">
            <summary>
A keyframe that represents start of storyboard.
</summary>
        </member>
        <member name="F:CAnimationController.m_lstAnimationGroups">
            <summary>
A list of animation groups that belong to this animation controller.
</summary>
        </member>
        <member name="F:CAnimationController.m_pRelatedWnd">
            <summary>
A pointer to a related CWnd object, which can be automatically redrawn when
the status of animation manager has changed, or post update event has occurred. Can be NULL.
</summary>
        </member>
        <member name="F:CAnimationController.m_pTransitionFactory">
            <summary>
Stores a pointer to Transition Factory COM object.
</summary>
        </member>
        <member name="F:CAnimationController.m_pAnimationTimer">
            <summary>
Stores a pointer to Animation Timer COM object.
</summary>
        </member>
        <member name="F:CAnimationController.m_pTransitionLibrary">
            <summary>
Stores a pointer to Transition Library COM object.
</summary>
        </member>
        <member name="F:CAnimationController.m_pAnimationManager">
            <summary>
Stores a pointer to Animation Manager COM object.
</summary>
        </member>
        <member name="F:CAnimationController.m_bIsValid">
            <summary>
Specifies whether an animation controller is valid or not.
This member is set to FALSE if current OS does not support Windows Animation API.
</summary>
        </member>
        <member name="T:CAnimationController">
            <summary>
Implements the animation controller, which provides a central interface for creating and managing UI animations.
</summary>
            <remarks>
The CAnimationController class is the key class that manages animations.
You may create one or more instances of animation controller in an application and, optionally, connect an instance of
animation controller to a CWnd object using CAnimationController::SetRelatedWnd. This connection is required to send WM_PAINT messages
to the related window automatically when animation manager status has changed or animation timer has been updated.
If you do not enable this relation, you must redraw a window that displays an animation manually. For this purpose you can derive a class
from CAnimationController and override OnAnimationManagerStatusChanged and/or OnAnimationTimerPostUpdate and invalidate one or
more windows when necessary.
</remarks>
        </member>
        <member name="F:CAnimationGroup.m_bAutodestroyAnimationObjects">
            <summary>
Specifies how to destroy animation objects. If this parameter is TRUE, animation objects will be destroyed automatically
when the group is destroyed. Otherwise animation objects must be destroyed manually. The default value is FALSE.
Set this value to TRUE only if all animation objects that belong to group are allocated dynamically with operator new.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_bAutoclearTransitions">
            <summary>
Specifies how to clear transitions from animation objects that belong to group. If this member is TRUE,
transitions are removed automatically when an animation has been scheduled. Otherwise you need to remove
transitions manually.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_bAutodestroyKeyframes">
            <summary>
Specifies how to destroy keyframes. If this value is TRUE, all keyframes are removed and destroyed;
otherwise they are removed from the list only. The default value is TRUE.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_pStoryboard">
            <summary>
Points to animation storyboard. This pointer is valid only after call on Animate.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_lstKeyFrames">
            <summary>
Contains a list of keyframes.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_lstAnimationObjects">
            <summary>
Contains a list of animation objects.
</summary>
        </member>
        <member name="M:CAnimationGroup.SetAutodestroyTransitions(System.Int32)">
            <summary>
Directs all animation objects that belong to group automatically destroy transitions.
</summary>
            <remarks>
Set this value to FALSE only if you allocate transitions on the stack. The default value is TRUE, therefore
it's highly recommended to allocate transition objects using operator new.
</remarks>
            <param name="bAutoDestroy">Specifies how to destroy transitions.</param>
        </member>
        <member name="M:CAnimationGroup.Schedule(IUIAnimationTimer*,System.Double)">
            <summary>
Schedules an animation at the specified time.
</summary>
            <returns>
TRUE if the method succeeds; FALSE if the method fails or if Animate has not been called with bScheduleNow set to FALSE.
</returns>
            <remarks>
Call this function to schedule an animation at the specified time. You must call Animate with bScheduleNow set to FALSE first.
</remarks>
            <param name="pTimer">A pointer to animation timer.</param>
            <param name="time">Specifies time to schedule the animation.</param>
        </member>
        <member name="M:CAnimationGroup.Animate(IUIAnimationManager*,IUIAnimationTimer*,System.Int32)">
            <summary>
Animates a group.
</summary>
            <returns>
TRUE if the method succeeds; otherwise FALSE.
</returns>
            <remarks>
This method creates an internal storyboard, creates and applies transitions and schedules an animation
if bScheduleNow is TRUE. If bScheduleNow is FALSE, you need to call Schedule to start animation at the
specified time.
</remarks>
            <param name="pManager" />
            <param name="pTimer" />
            <param name="bScheduleNow" />
        </member>
        <member name="M:CAnimationGroup.FindAnimationObject(IUIAnimationVariable*)">
            <summary>
Finds an animation object that contains the specified animation variable.
</summary>
            <returns>
A pointer to animation object, or NULL if animation object is not found.
</returns>
            <param name="pVariable">A pointer to animation variable.</param>
        </member>
        <member name="M:CAnimationGroup.RemoveKeyframes">
            <summary>
Removes and optionally destroys all keyframes that belong to an animation group.
</summary>
            <remarks>
If m_bAutodestroyKeyframes member is TRUE then keyframes are removed and destroyed, otherwise keyframes are
just removed from the internal list of keyframes.
</remarks>
        </member>
        <member name="M:CAnimationGroup.RemoveTransitions">
            <summary>
Removes transitions from animation objects that belong to an animation group.
</summary>
            <remarks>
If m_bAutoclearTransitions flag is set to TRUE, this method loops over all animation objects that belong to the group
and calls CAnimationObject::ClearTransitions(FALSE).
</remarks>
        </member>
        <member name="M:CAnimationGroup.ApplyTransitions">
            <summary>
Applies transitions to animation objects.
</summary>
            <remarks>
This method ASSERTS in debug mode if storyboard has not been created.
It creates all transitions first, then adds "static" keyframes (keyframes that depend on offsets),
adds transitions that do not depend on keyframes, adds keyframes depending on transitions and other keyframes,
and at last adds transitions that depend on keyframes.
</remarks>
        </member>
        <member name="M:CAnimationGroup.GetGroupID">
            <summary>
Returns GroupID.
</summary>
            <returns>
A group identifier.
</returns>
        </member>
        <member name="M:CAnimationGroup.Dispose">
            <summary>
The destructor. Called when an animation group is being destroyed.
</summary>
        </member>
        <member name="M:CAnimationGroup.#ctor(CAnimationController*,System.UInt32)">
            <summary>
Constructs an animation group.
</summary>
            <param name="pParentController">A pointer to animation controller that creates a group.</param>
            <param name="nGroupID">Specifies GroupID.</param>
        </member>
        <member name="M:CAnimationGroup.CreateTransitions">
            <summary>
A helper that creates COM transition objects.
</summary>
            <returns>
TRUE is the method succeeds, otherwise FALSE.
</returns>
        </member>
        <member name="M:CAnimationGroup.AddTransitions(IUIAnimationStoryboard*,System.Int32)">
            <summary>
A helper that adds transitions to a storyboard.
</summary>
            <param name="pStoryboard">A pointer to a storyboard COM object.</param>
            <param name="bDependOnKeyframes">Specifies whether this method should add to the storyboard transitions that depend on other keyframes.</param>
        </member>
        <member name="M:CAnimationGroup.AddKeyframes(IUIAnimationStoryboard*,System.Int32)">
            <summary>
A helper that adds keyframes to a storyboard.
</summary>
            <param name="pStoryboard">A pointer to a storyboard COM object.</param>
            <param name="bAddDeep">Specifies whether this method should add to the storyboard keyframes that depend on other keyframes.</param>
        </member>
        <member name="F:CAnimationGroup.m_pParentController">
            <summary>
A pointer to animation controller this group belongs to.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_nGroupID">
            <summary>
A unique identifier of animation group.
</summary>
        </member>
        <member name="T:CAnimationGroup">
            <summary>
Implements an animation group, which combines an animation storyboard, animation objects and transitions
to define an animation.
</summary>
            <remarks>
Animation groups are created automatically by animation controller (CAnimationController) when you add animation
objects using CAnimationController::AddAnimationObject.
An animation group is identified by GroupID, which is usually taken as a parameter to manipulate animation groups.
The GroupID is taken from the first animation object being added to a new animation group.
An encapsulated animation storyboard is created after you call CAnimationController::AnimateGroup and can be
accessed via public member m_pStoryboard.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variables into a list.
</summary>
            <param name="lst">When the function returns, it contains pointers to four CAnimationVariable objects
representing coordinates of rectangle.</param>
        </member>
        <member name="F:CAnimationRect.m_bFixedSize">
            <summary>
Specifies whether the rectangle has fixed size.
</summary>
            <remarks>
If this member is true, then the size of rectangle is fixed and right and bottom values
are recalculated each time the top-left corner is  moved according to the fixed size.
Set this value to TRUE to easily move the rectangle around the screen. In this case transitions applied to
right and bottom coordinates are ignored. The size is stored internally when you construct the object and/or
call SetDefaultValue. By default this member is set to FALSE.
</remarks>
        </member>
        <member name="M:CAnimationRect.AddTransition(CBaseTransition*,CBaseTransition*,CBaseTransition*,CBaseTransition*)">
            <summary>
Adds transitions for left, top, right and bottom coordinates.
</summary>
            <remarks>
Call this function to add the specified transitions to the internal list of transitions to be applied to animation variables for each rectangle sides.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
If you don't need to apply a transition to one of the rectangle sides, you can pass NULL.
</remarks>
            <param name="pLeftTransition">Specifies transition for the left side.</param>
            <param name="pTopTransition">Specifies transition for the top side.</param>
            <param name="pRightTransition">Specifies transition for the right side.</param>
            <param name="pBottomTransition">Specifies transition for the bottom side.</param>
        </member>
        <member name="M:CAnimationRect.op_Implicit~tagRECT">
            <summary>
Converts a CAnimationRect to RECT.
</summary>
            <returns>
Current value of animation rectangle as RECT.
</returns>
            <remarks>
This function internally calls GetValue. If GetValue for some reason fails, the returned RECT will contain default values for all rectangle coordinates.
</remarks>
        </member>
        <member name="M:CAnimationRect.op_Assign(tagRECT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Assigns rect to CAnimationRect.
</summary>
            <remarks>
It's recommended to do that before animation start, because this operator calls
SetDefaultValue, which recreates the underlying COM objects for color components if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="rect">The new value of animation rectangle.</param>
        </member>
        <member name="M:CAnimationRect.GetBottom">
            <summary>
Provides access to CAnimationVariable representing bottom coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing bottom coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing the bottom coordinate.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetRight">
            <summary>
Provides access to CAnimationVariable representing right coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing right coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing the right coordinate.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetTop">
            <summary>
Provides access to CAnimationVariable representing top coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing top coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing the top coordinate.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetLeft">
            <summary>
Provides access to CAnimationVariable representing left coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing left coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing the left coordinate.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetValue(CRect*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns current value.
</summary>
            <returns>
TRUE, if the current value was successfully retrieved; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value of animation rectangle. If this method fails or underlying COM objects for
left, top, right and bottom have not been initialized, rect contains default value, which was previously set in constructor or by SetDefaultValue.
</remarks>
            <param name="rect">Output. Contains the current value when this method returns.</param>
        </member>
        <member name="M:CAnimationRect.GetDefaultValue">
            <summary>
Returns the default values for rectangle's bounds.
</summary>
            <returns>
A CRect value containing defaults for left, right, top and bottom.
</returns>
            <remarks>
Call this function to retrieve default value, which was previously set by constructor or SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationRect.SetDefaultValue(CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this function to set a default value to animation object. This methods assigns default values to rectangle's bounds.
It also recreates underlying COM objects if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="rect">Specifies new default values for left, top, right and bottom.</param>
        </member>
        <member name="M:CAnimationRect.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation rect object.
</summary>
            <remarks>
The object is constructed with specified coordinates of each side, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="nLeft">Specifies coordinate of left bound.</param>
            <param name="nTop">Specifies coordinate of top bound.</param>
            <param name="nRight">Specifies coordinate of right bound.</param>
            <param name="nBottom">Specifies coordinate of bottom bound.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationRect.#ctor(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation rect object.
</summary>
            <remarks>
The object is constructed with specified top-left corner coordinates and size of rectangle, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="pt">Coordinate of top-left corner.</param>
            <param name="sz">Size of rectangle.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationRect.#ctor(CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation rect object.
</summary>
            <remarks>
The object is constructed with specified rect coordinates, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="rect">Specifies default rectangle.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationRect.#ctor">
            <summary>
Constructs a CAnimationRect object.
</summary>
            <remarks>
The object is constructed with default values for left, top, right and bottom, Object ID and Group ID, which will be set to 0. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
        </member>
        <member name="F:CAnimationRect.m_szInitial">
            <summary>
Specifies initial size of animation rectangle.
</summary>
        </member>
        <member name="F:CAnimationRect.m_bottomValue">
            <summary>
The encapsulated animation variable that represents Bottom bound of animation rectangle.
</summary>
        </member>
        <member name="F:CAnimationRect.m_rightValue">
            <summary>
The encapsulated animation variable that represents Right bound of animation rectangle.
</summary>
        </member>
        <member name="F:CAnimationRect.m_topValue">
            <summary>
The encapsulated animation variable that represents Top bound of animation rectangle.
</summary>
        </member>
        <member name="F:CAnimationRect.m_leftValue">
            <summary>
The encapsulated animation variable that represents Left bound of animation rectangle.
</summary>
        </member>
        <member name="T:CAnimationRect">
            <summary>
Implements the functionality of a rectangle whose top, left, right and bottom sides can be animated.
</summary>
            <remarks>
The CAnimationRect class encapsulates four CAnimationVariable objects and can represent in applications
a rectangle.
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to left, right top and bottom coordinates.
</remarks>
        </member>
        <member name="M:CAnimationColor.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variables into a list.
</summary>
            <param name="lst">When the function returns, it contains pointers to three CAnimationVariable objects
representing red, green and blue components.</param>
        </member>
        <member name="M:CAnimationColor.AddTransition(CBaseTransition*,CBaseTransition*,CBaseTransition*)">
            <summary>
Adds transitions for Red, Green and Blue components.
</summary>
            <remarks>
Call this function to add the specified transitions to the internal list of transitions to be applied to animation variables representing color components.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
If you don't need to apply a transition to one of the color components, you can pass NULL.
</remarks>
            <param name="pRTransition">Transition for Red component.</param>
            <param name="pGTransition">Transition for Green component.</param>
            <param name="pBTransition">Transition for Blue component.</param>
        </member>
        <member name="M:CAnimationColor.op_Implicit~System.UInt32!System.Runtime.CompilerServices.IsLong">
            <summary>
Converts a CAnimationColor to COLORREF.
</summary>
            <returns>
Current value of animation color object as COLORREF.
</returns>
            <remarks>
This function internally calls GetValue. If GetValue for some reason fails, the returned COLORREF will contain default values for all color components.
</remarks>
        </member>
        <member name="M:CAnimationColor.op_Assign(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Assigns color to CAnimationColor.
</summary>
            <remarks>
It's recommended to do that before animation start, because this operator calls
SetDefaultValue, which recreates the underlying COM objects for color components if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="color">Specifies new value Animation Color.</param>
        </member>
        <member name="M:CAnimationColor.GetB">
            <summary>
Provides access to CAnimationVariable representing Blue component.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Blue component.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Blue component.
</remarks>
        </member>
        <member name="M:CAnimationColor.GetG">
            <summary>
Provides access to CAnimationVariable representing Green component.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Green component.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Green component.
</remarks>
        </member>
        <member name="M:CAnimationColor.GetR">
            <summary>
Provides access to CAnimationVariable representing Red component.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Red component.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Red component.
</remarks>
        </member>
        <member name="M:CAnimationColor.GetValue(System.UInt32!System.Runtime.CompilerServices.IsLong*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns current value.
</summary>
            <returns>
TRUE, if the current value was successfully retrieved; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value of animation color. If this method fails or underlying COM objects for
color components have not been initialized, color contains default value, which was previously set in constructor or by SetDefaultValue.
</remarks>
            <param name="color">Output. Contains the current value when this method returns.</param>
        </member>
        <member name="M:CAnimationColor.GetDefaultValue">
            <summary>
Returns the default values for color components.
</summary>
            <returns>
A COLORREF value containing defaults for RGB components.
</returns>
            <remarks>
Call this function to retrieve default value, which was previously set by constructor or SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationColor.SetDefaultValue(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this function to set a default value to animation object. This methods assigns default values to color components
of animation color. It also recreates underlying COM objects if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="color">Specifies new default values for red, green and blue components.</param>
        </member>
        <member name="M:CAnimationColor.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation color object.
</summary>
            <remarks>
The object is constructed with specified values for RGB components, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="color">Specifies default color.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationColor.#ctor">
            <summary>
Constructs a CAnimationColor object.
</summary>
            <remarks>
The object is constructed with default values for red, green, blue, Object ID and Group ID, which will be set to 0. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
        </member>
        <member name="F:CAnimationColor.m_bValue">
            <summary>
The encapsulated animation variable that represents Blue component of animation color.
</summary>
        </member>
        <member name="F:CAnimationColor.m_gValue">
            <summary>
The encapsulated animation variable that represents Green component of animation color.
</summary>
        </member>
        <member name="F:CAnimationColor.m_rValue">
            <summary>
The encapsulated animation variable that represents Red component of animation color.
</summary>
        </member>
        <member name="T:CAnimationColor">
            <summary>
Implements the functionality of a color whose red, green and blue components can be animated.
</summary>
            <remarks>
The CAnimationColor class encapsulates three CAnimationVariable objects and can represent in applications
a color. For example, you can use this class to animate colors of any object on the screen (like text color, background color etc).
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to Red, Green and Blue components.
</remarks>
        </member>
        <member name="M:CAnimationSize.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variables into a list.
</summary>
            <param name="lst">When the function returns, it contains pointers to two CAnimationVariable objects
representing the width and height.</param>
        </member>
        <member name="M:CAnimationSize.AddTransition(CBaseTransition*,CBaseTransition*)">
            <summary>
Adds transitions for Width and Height.
</summary>
            <remarks>
Call this function to add the specified transitions to the internal list of transitions to be applied to animation variables for Width and Height.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
If you don't need to apply a transition to one of dimensions, you can pass NULL.
</remarks>
            <param name="pCXTransition">A pointer to transition for Width.</param>
            <param name="pCYTransition">A pointer to transition for Height.</param>
        </member>
        <member name="M:CAnimationSize.op_Implicit~CSize">
            <summary>
Converts a CAnimationSize to a CSize.
</summary>
            <returns>
Current value of animation size as CSize.
</returns>
            <remarks>
This function internally calls GetValue. If GetValue for some reason fails, the returned size will contain default values for Width and Height.
</remarks>
        </member>
        <member name="M:CAnimationSize.op_Assign(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Assigns szSrc to CAnimationSize.
</summary>
            <remarks>
Assigns szSrc to CAnimationSize. It's recommended to do that before animation start, because this operator calls
SetDefaultValue, which recreates the underlying COM objects for Width and Height if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="szSrc">Refers to CSize or SIZE.</param>
        </member>
        <member name="M:CAnimationSize.GetCY">
            <summary>
Provides access to CAnimationVariable representing Height.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Height.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Height.
</remarks>
        </member>
        <member name="M:CAnimationSize.GetCX">
            <summary>
Provides access to CAnimationVariable representing Width.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Width.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Width.
</remarks>
        </member>
        <member name="M:CAnimationSize.GetValue(CSize*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns current value.
</summary>
            <returns>
TRUE, if the current value was successfully retrieved; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value of animation size. If this method fails or underlying COM objects for
Width and Size have not been initialized, szValue contains default value, which was previously set in constructor or by SetDefaultValue.
</remarks>
            <param name="szValue">Output. Contains the current value when this method returns.</param>
        </member>
        <member name="M:CAnimationSize.GetDefaultValue">
            <summary>
Returns the default values for Width and Height.
</summary>
            <returns>
A CSize object containing default values.
</returns>
            <remarks>
Call this function to retrieve default value, which was previously set by constructor or SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationSize.SetDefaultValue(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this function to set a default value to animation object. This methods assigns default values to Width and Height
of animation size. It also recreates underlying COM objects if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="szDefault">Specifies new default size.</param>
        </member>
        <member name="M:CAnimationSize.#ctor(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation size object.
</summary>
            <remarks>
The object is constructed with specified values for width, height, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="szDefault">Specifies default size.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationSize.#ctor">
            <summary>
Constructs an animation size object.
</summary>
            <remarks>
The object is constructed with default values for width, height, Object ID and Group ID, which will be set to 0. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
        </member>
        <member name="F:CAnimationSize.m_cyValue">
            <summary>
The encapsulated animation variable that represents height of animation size.
</summary>
        </member>
        <member name="F:CAnimationSize.m_cxValue">
            <summary>
The encapsulated animation variable that represents width of animation size.
</summary>
        </member>
        <member name="T:CAnimationSize">
            <summary>
Implements the functionality of a size object whose dimensions can be animated.
</summary>
            <remarks>
The CAnimationSize class encapsulates two CAnimationVariable objects and can represent in applications
a size. For example, you can use this class to animate a size of any two dimensional object on the screen (like rectangle, control etc).
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to Width and/or Height.
</remarks>
        </member>
        <member name="M:CAnimationPoint.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variables into a list.
</summary>
            <param name="lst">When the function returns, it contains pointers to two CAnimationVariable objects
representing the X and Y coordinates.</param>
        </member>
        <member name="M:CAnimationPoint.AddTransition(CBaseTransition*,CBaseTransition*)">
            <summary>
Adds transitions for X and Y coordinates.
</summary>
            <remarks>
Call this function to add the specified transitions to the internal list of transitions to be applied to animation variables for X and Y coordinates.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
If you don't need to apply a transition to one of coordinates, you can pass NULL.
</remarks>
            <param name="pXTransition">A pointer to transition for X coordinates.</param>
            <param name="pYTransition">A pointer to transition for Y coordinate.</param>
        </member>
        <member name="M:CAnimationPoint.GetY">
            <summary>
Provides access to CAnimationVariable for Y coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Y coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Y coordinate.
</remarks>
        </member>
        <member name="M:CAnimationPoint.GetX">
            <summary>
Provides access to CAnimationVariable for X coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing X coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing X coordinate.
</remarks>
        </member>
        <member name="M:CAnimationPoint.op_Implicit~CPoint">
            <summary>
Converts a CAnimationPoint to a CPoint.
</summary>
            <returns>
Current value of CAnimationPoint as CPoint.
</returns>
            <remarks>
This function internally calls GetValue. If GetValue for some reason fails, the returned point will contain default values for X and Y coordinates.
</remarks>
        </member>
        <member name="M:CAnimationPoint.op_Assign(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Assigns ptSrc to CAnimationPoint.
</summary>
            <remarks>
Assigns ptSrc to CAnimationPoint. It's recommended to do that before animation start, because this operator calls
SetDefaultValue, which recreates the underlying COM objects for X and Y coordinates if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="ptSrc">Refers to CPoint or POINT.</param>
        </member>
        <member name="M:CAnimationPoint.GetValue(CPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns current value.
</summary>
            <returns>
TRUE, if the current value was successfully retrieved; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value of animation point. If this method fails or underlying COM objects for
X and Y coordinates have not been initialized, ptValue contains default
value, which was previously set in constructor or by SetDefaultValue.
</remarks>
            <param name="ptValue">Output. Contains the current value when this method returns.</param>
        </member>
        <member name="M:CAnimationPoint.GetDefaultValue">
            <summary>
Returns the default values for X and Y coordinates.
</summary>
            <returns>
A point containing default value.
</returns>
            <remarks>
Call this function to retrieve default value, which was previously set by constructor or SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationPoint.SetDefaultValue(tagPOINT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this function to set a default value to animation object. This methods assigns default values to X and Y
coordinates of animation point. It also recreates underlying COM objects if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="ptDefault">Specifies the default point value.</param>
        </member>
        <member name="M:CAnimationPoint.#ctor(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs CAnimationPoint object.
</summary>
            <remarks>
Constructs CAnimationPoint object with specified properties.
</remarks>
            <param name="ptDefault">Specifies default point coordinates.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationPoint.#ctor">
            <summary>
Constructs CAnimationPoint object.
</summary>
            <remarks>
Constructs CAnimationPoint object with default properties: default point coordinates, Group ID and Object ID are set to 0.
</remarks>
        </member>
        <member name="F:CAnimationPoint.m_yValue">
            <summary>
The encapsulated animation variable that represents Y coordinate of animation point.
</summary>
        </member>
        <member name="F:CAnimationPoint.m_xValue">
            <summary>
The encapsulated animation variable that represents X coordinate of animation point.
</summary>
        </member>
        <member name="T:CAnimationPoint">
            <summary>
Implements the functionality of a point whose coordinates can be animated.
</summary>
            <remarks>
The CAnimationPoint class encapsulates two CAnimationVariable objects and can represent in applications
a point. For example, you can use this class to animate a position of any object on the screen (like text string, circle, point etc).
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to X and/or Y coordinates.
</remarks>
        </member>
        <member name="M:CAnimationValue.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variable into a list.
</summary>
            <param name="lst">When the function returns, it contains a pointer to CAnimationVariable representing the animated value.</param>
        </member>
        <member name="M:CAnimationValue.AddTransition(CBaseTransition*)">
            <summary>
Adds a transition to be applied to a value.
</summary>
            <remarks>
Call this function to add a transition to internal list of transitions to be applied to an animation variable.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
</remarks>
            <param name="pTransition">A pointer to transition object.</param>
        </member>
        <member name="M:CAnimationValue.GetVariable">
            <summary>
Provides access to encapsulated animation variable.
</summary>
            <returns>
A reference to encapsulated animation variable.
</returns>
            <remarks>
Use this method to access the encapsulated animation variable. From CAnimationVariable you get access
to underlying IUIAnimationVariable object, whose pointer can be NULL if animation variable has not been created.
</remarks>
        </member>
        <member name="M:CAnimationValue.op_Assign(System.Int32)">
            <summary>
Assigns an INT32 value to CAnimationValue.
</summary>
            <remarks>
Assigns an INT32 value to CAnimationValue. This value is set as a default value for encapsulated animation variable.
If you subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="nVal">Specifies the value to be assigned to Animation Value.</param>
        </member>
        <member name="M:CAnimationValue.op_Assign(System.Double)">
            <summary>
Assigns a DOUBLE value to CAnimationValue.
</summary>
            <remarks>
Assigns a DOUBLE value to CAnimationValue. This value is set as a default value for encapsulated animation variable.
If you subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="dblVal">Specifies the value to be assigned to Animation Value.</param>
        </member>
        <member name="M:CAnimationValue.op_Implicit~System.Int32">
            <summary>
Provides conversion between CAnimationValue and INT32.
</summary>
            <returns>
Current value of Animation Value as integer.
</returns>
            <remarks>
Provides conversion between CAnimationValue and INT32. This method internally calls GetValue and doesn't check for
errors. If GetValue fails, the returned value will contain a default value previously set in constructor or with SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationValue.op_Implicit~System.Double">
            <summary>
Provides conversion between CAnimationValue and DOUBLE.
</summary>
            <returns>
Current value of Animation Value.
</returns>
            <remarks>
Provides conversion between CAnimationValue and DOUBLE. This method internally calls GetValue and doesn't check for
errors. If GetValue fails, the returned value will contain a default value previously set in constructor or with SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationValue.GetValue(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieves the current value.
</summary>
            <returns>
TRUE if the current value was retrieved successfully; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value. This implementation calls the encapsulated COM object, and if
the call fails, this method returns the default value that was previously set in constructor or with SetDefaultValue.
</remarks>
            <param name="nValue">Output. When the function returns it contains a current value of animation variable.</param>
        </member>
        <member name="M:CAnimationValue.GetValue(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieves the current value.
</summary>
            <returns>
TRUE if the current value was retrieved successfully; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value. This implementation calls the encapsulated COM object, and if
the call fails, this method returns the default value that was previously set in constructor or with SetDefaultValue.
</remarks>
            <param name="dblValue">Output. When the function returns it contains a current value of animation variable.</param>
        </member>
        <member name="M:CAnimationValue.SetDefaultValue(System.Double)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this method to set a default value. A default value is returned to application when animation has not been started
and/or underlying COM object has not been created. If the underlying COM object encapsulated in CAnimationVarible
was already created, this method recreates it, therefore you might need to call EnableValueChanged/EnableIntegerValueChanged
methods again.
</remarks>
            <param name="dblDefaultValue">Specifies the default value.</param>
        </member>
        <member name="M:CAnimationValue.#ctor(System.Double,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs a CAnimationValue object.
</summary>
            <remarks>
Constructs CAnimationValue object with specified properties.
</remarks>
            <param name="dblDefaultValue">Specifies default value.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationValue.#ctor">
            <summary>
Constructs a CAnimationValue object.
</summary>
            <remarks>
Constructs CAnimationValue object with default properties: default value, Group ID and Object ID are set to 0.
</remarks>
        </member>
        <member name="F:CAnimationValue.m_value">
            <summary>
The encapsulated animation variable that represents animation value.
</summary>
        </member>
        <member name="T:CAnimationValue">
            <summary>
Implements the functionality of animation object with one value.
</summary>
            <remarks>
The CAnimationValue class encapsulates a single CAnimationVariable object and can represent in applications
a single animated value. For example, you can use this class for animated transparency (fade effect), angle (to rotate objects),
or for any other case when you need to create an animation depending on a single animated value.
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to the value.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.SetParentAnimationObjects">
            <summary>
Establishes relationship between animation variables, contained in an animation object, and their container.
</summary>
            <remarks>
This is a helper that can be used to establish relationship between animation variables, contained in an animation object,
and their container. It loops over animation variables and sets a back pointer to a parent animation object
to each animation variable.
In the current implementation the actual relationship is established in CAnimationBaseObject::ApplyTransitions, therefore
back pointers are not set until you call CAnimationGroup::Animate.
Knowing the relationship may be helpful when you processing events and need to get a parent animation object
from CAnimationVariable (use CAnimationVariable::GetParentAnimationObject).
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Collects pointers to contained animation variables.
</summary>
            <remarks>
This is a pure virtual method that must be overridden in a derived class.
An animation object, depending on its type, contains one or more animation variables. For example, CAnimationPoint
contains two variables, for X and Y coordinates respectively. The base class CAnimationBaseObject implements
some generic methods, which act on a list of animation variables: ApplyTransitions, ClearTransitions,
EnableValueChangedEvent, EnableIntegerValueChangedEvent. These methods call GetAnimationVariableList, which is filled
in a derived class with actual animation variables contained in a particular animation object, then loop over the
list and perform necessary actions.
If you create a custom animation object, you must add to lst all animation variables contained in that object.
</remarks>
            <param name="lst">A list that must be filled with animation variables contained in an animation object.</param>
        </member>
        <member name="M:CAnimationBaseObject.ContainsVariable(IUIAnimationVariable*)">
            <summary>
Determines whether an animation object contains a particular animation variable.
</summary>
            <returns>
TRUE if the animation variable is contained in the animation object; otherwise FALSE.
</returns>
            <remarks>
This method can be used to determine whether an animation variable specified by pVariable is contained
within an animation object. An animation object, depending on its type, may contain several animation variables.
For example, CAnimationColor contains three variables, one for each color component (red, green and blue). When a
value of animation variable has changed, Windows Animation API sends ValueChanged or IntegerValueChanged events (if enabled),
and the parameter of this event is a pointer to interface IUIAnimationVariable of animation variable.
This method helps to obtain a pointer to animation from a pointer to contained COM object.
</remarks>
            <param name="pVariable">A pointer to animation variable.</param>
        </member>
        <member name="M:CAnimationBaseObject.EnableIntegerValueChangedEvent(CAnimationController*,System.Int32)">
            <summary>
Sets up Integer Value Changed event handler.
</summary>
            <remarks>
If the Integer Value Changed event handler is enabled, you can handle this event in CAnimationController::OnAnimationIntegerValueChanged method,
which should be overridden in a CAnimationController-derived class. This method is called every time the animation integer value has changed.
</remarks>
            <param name="pController">A pointer to a parent controller.</param>
            <param name="bEnable">Specifies whether to enable, or disable Integer Value Changed event.</param>
        </member>
        <member name="M:CAnimationBaseObject.EnableValueChangedEvent(CAnimationController*,System.Int32)">
            <summary>
Sets up Value Changed event handler.
</summary>
            <remarks>
If the Value Changed event handler is enabled, you can handle this event in CAnimationController::OnAnimationValueChanged method,
which should be overridden in a CAnimationController-derived class. This method is called every time the animation value has changed.
</remarks>
            <param name="pController">A pointer to a parent controller.</param>
            <param name="bEnable">Specifies whether to enable, or disable Value Changed event.</param>
        </member>
        <member name="M:CAnimationBaseObject.ClearTransitions(System.Int32)">
            <summary>
Removes all related transitions.
</summary>
            <remarks>
Removes all related transitions and destroys them if bAutodestroy or m_bAutodestroyTransitions flag is TRUE.
Transitions should be destroyed automatically only if they are not allocated on the stack.
If the above flags are FALSE, transitions are just removed from the internal list of related transitions.
</remarks>
            <param name="bAutodestroy">Specifies whether to destroy transition objects automatically, or just remove them from the related list.</param>
        </member>
        <member name="M:CAnimationBaseObject.ApplyTransitions(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds transitions to storyboard with encapsulated animation variable.
</summary>
            <returns>
TRUE if transitions were added successfully.
</returns>
            <remarks>
Adds related transitions, that have been added with AddTransition (overloaded methods in derived classes), to storyboard.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDependOnKeyframes">With FALSE this method adds only those transitions that do not depend on keyframes.</param>
        </member>
        <member name="M:CAnimationBaseObject.GetAutodestroyTransitions">
            <summary>
Tells whether related transition are destroyed automatically.
</summary>
            <returns>
If TRUE, related transitions are destroyed automatically; if FALSE, transition objects should be deallocated by calling application.
</returns>
            <remarks>
By default this flag is TRUE. Set this flag only if you allocated transition on the stack and/or transitions should be deallocated by
the calling application.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.SetAutodestroyTransitions(System.Int32)">
            <summary>
Sets a flag that orders to automatically destroy transitions.
</summary>
            <remarks>
Set this flag only if you allocated transition objects using operator new. If for some reason transition
objects are allocated on the stack, the auto destroy flag should be FALSE. By default this flag is TRUE.
</remarks>
            <param name="bValue">Specifies the auto destroy flag.</param>
        </member>
        <member name="M:CAnimationBaseObject.GetUserData">
            <summary>
Returns user defined data.
</summary>
            <returns>
A value of custom data.
</returns>
            <remarks>
Call this method to retrieve the custom data at runtime. The returned value will be 0 if it was not explicitly initialized in constructor or with SetUserData.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.GetGroupID">
            <summary>
Returns current Group ID.
</summary>
            <returns>
Current Group ID.
</returns>
            <remarks>
Use this method to retrieve Group ID. It's 0 if Group ID has not been set explicitly in constructor or with SetID.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.GetObjectID">
            <summary>
Returns current Object ID.
</summary>
            <returns>
Current Object ID.
</returns>
            <remarks>
Use this method to retrieve Object ID. It's 0 if Object ID has not been set explicitly in constructor or with SetID.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.DetachFromController">
            <summary>
Detaches an animation object from parent animation controller.
</summary>
            <remarks>
This method is used internally.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.SetUserData(System.UInt64)">
            <summary>
Sets user-defined data.
</summary>
            <remarks>
Use this method to associate a custom data with an animation object. This data may be retrieved later at runtime by GetUserData.
</remarks>
            <param name="dwUserData">Specifies the custom data.</param>
        </member>
        <member name="M:CAnimationBaseObject.SetID(System.UInt32,System.UInt32)">
            <summary>
Sets new IDs.
</summary>
            <remarks>
Allows to change Object ID and Group ID. If the new Group ID differs from the current ID, an animation object
is moved to another group (a new group will be created, if necessary).
</remarks>
            <param name="nObjectID">Specifies new Object ID.</param>
            <param name="nGroupID">Specifies new Group ID.</param>
        </member>
        <member name="M:CAnimationBaseObject.CreateTransitions">
            <summary>
Creates transitions associated with an animation object.
</summary>
            <returns>
TRUE if transitions were created successfully; otherwise FALSE.
</returns>
            <remarks>
Loops over list of animation variables encapsulated in a derived animation object and creates transitions
associated with each animation variable.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.Dispose">
            <summary>
The destructor. Called when an animation object is being destroyed.
</summary>
        </member>
        <member name="M:CAnimationBaseObject.#ctor(System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation object.
</summary>
            <remarks>
Constructs an animation object with specified Object ID and Group ID.
</remarks>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">User-defined data, which can be associated with animation object and retrieved later at runtime.</param>
        </member>
        <member name="M:CAnimationBaseObject.#ctor">
            <summary>
Constructs an animation object.
</summary>
            <remarks>
Constructs an animation objects and assigns default Object ID (0) and Group ID (0).
</remarks>
        </member>
        <member name="F:CAnimationBaseObject.m_pParentController">
            <summary>
A pointer to the parent animation controller.
</summary>
        </member>
        <member name="F:CAnimationBaseObject.m_bAutodestroyTransitions">
            <summary>
Specifies whether related transitions should be automatically destroyed.
</summary>
        </member>
        <member name="F:CAnimationBaseObject.m_dwUserData">
            <summary>
Stores user-defined data.
</summary>
        </member>
        <member name="F:CAnimationBaseObject.m_nObjectID">
            <summary>
Specifes the Object ID of the animation object.
</summary>
        </member>
        <member name="F:CAnimationBaseObject.m_nGroupID">
            <summary>
Specifies the Group ID of the animation object.
</summary>
        </member>
        <member name="T:CAnimationBaseObject">
            <summary>
The base class for all animation objects.
</summary>
            <remarks>
This class implements basic methods for all animation objects. An animation object can represent a value, point,
size, rectangle or color in an application, as well as any custom entity. Animation objects are stored in animation groups
(see CAnimationGroup). Each group can be animated separately and can be treated as an analogue of storyboard.
An animation object encapsulates one or more animation variables (see CAnimationVariable), depending on its logical
representation. For example, CAnimationRect contains four animation variables - one variable for each side of rectangle.
Each animation object class exposes overloaded AddTransition method, which should be used to apply transitions to
encapsulated animation variables.
An animation object can be identified by Object ID (optionally) and by Group ID. A Group ID is necessary in order
to place an animation object to correct group, but if a Group ID is not specified, an object is placed in the default group with ID 0.
If you call SetID with different GroupID, an animation object will be moved to another group (a new group is created if necessary).
</remarks>
        </member>
        <member name="F:CAnimationVariable.m_bAutodestroyTransitions">
            <summary>
Specifies whether related transition objects should be deleted.
</summary>
            <remarks>
Set this value to TRUE to force deletion of transition objects when they are being removed from the internal list
of transitions. If this value is FALSE the transitions should be deleted by calling application.
The list of transitions is always cleared after an animation has been scheduled. The default value is FALSE.
</remarks>
        </member>
        <member name="M:CAnimationVariable.GetDefaultValue">
            <summary>
Returns default value.
</summary>
            <returns>
The default value.
</returns>
            <remarks>
Use this function to obtain default value of animation variable. The default value can be set in constructor or by
SetDefaultValue method.
</remarks>
        </member>
        <member name="M:CAnimationVariable.EnableIntegerValueChangedEvent(CAnimationController*,System.Int32)">
            <summary>
Enables or disables the IntegerValueChanged event.
</summary>
            <remarks>
When ValueChanged event is enabled, the framework calls virtual method CAnimationController::OnAnimationIntegerValueChanged.
You need to override it in a class derived from CAnimationController in order to process this event. This method is called every time
the integer value of animation variable is changed.
</remarks>
            <param name="pController">A pointer to parent controller.</param>
            <param name="bEnable">TRUE - enable event, FALSE - disable event.</param>
        </member>
        <member name="M:CAnimationVariable.EnableValueChangedEvent(CAnimationController*,System.Int32)">
            <summary>
Enables or disables the ValueChanged event.
</summary>
            <remarks>
When ValueChanged event is enabled, the framework calls virtual method CAnimationController::OnAnimationValueChanged.
You need to override it in a class derived from CAnimationController in order to process this event. This method is called every time
the value of animation variable is changed.
</remarks>
            <param name="pController">A pointer to parent controller.</param>
            <param name="bEnable">TRUE - enable event, FALSE - disable event.</param>
        </member>
        <member name="M:CAnimationVariable.ApplyTransitions(CAnimationController*,IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds transitions from the internal list to storyboard.
</summary>
            <remarks>
This method adds transitions from the internal list to storyboard. It's called from the
top level code several times to add transitions that do not depend on keyframes and add
transitions that depend on keyframes. If the underlying animation variable
COM object has not been created, this method creates it at this stage.
</remarks>
            <param name="pController">A pointer to parent animation controller.</param>
            <param name="pStoryboard">A pointer to storyboard.</param>
            <param name="bDependOnKeyframes">TRUE, if this method should add transitions that depend on keyframes.</param>
        </member>
        <member name="M:CAnimationVariable.ClearTransitions(System.Int32)">
            <summary>
Clears transitions.
</summary>
            <remarks>
This method removes all transitions from the internal list of transitions. If bAutodestroy is TRUE, or
m_bAutodestroyTransitions is TRUE, then transitions are deleted. Otherwise the caller should deallocate
the transition objects.
</remarks>
            <param name="bAutodestroy">Specifies whether this method should delete transition objects.</param>
        </member>
        <member name="M:CAnimationVariable.AddTransition(CBaseTransition*)">
            <summary>
Adds a transition.
</summary>
            <remarks>
This method is called to add a transition to the internal list of transitions to be applied to the animation variable.
This list should be cleared when an animation has been scheduled.
</remarks>
            <param name="pTransition">A pointer to a transition to add.</param>
        </member>
        <member name="M:CAnimationVariable.GetValue(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns the current value of animation variable.
</summary>
            <returns>
S_OK if the value was obtained successfully, or underlying animation variable has not been created. Otherwise
HRESULT error code.
</returns>
            <remarks>
This method can be called to retrieve the current value of animation variable. If the underlying COM object
has not been created, dblValue will contain a default value, when the function returns.
</remarks>
            <param name="nValue">The current value of the animation variable.</param>
        </member>
        <member name="M:CAnimationVariable.GetValue(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns the current value of animation variable.
</summary>
            <returns>
S_OK if the value was obtained successfully, or underlying animation variable has not been created. Otherwise
HRESULT error code.
</returns>
            <remarks>
This method can be called to retrieve the current value of animation variable. If the underlying COM object
has not been created, dblValue will contain a default value, when the function returns.
</remarks>
            <param name="dblValue">The current value of the animation variable.</param>
        </member>
        <member name="M:CAnimationVariable.CreateTransitions(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Creates all transitions to be applied to this animation variable.
</summary>
            <returns>
TRUE if transitions were created successfully; otherwise FALSE.
</returns>
            <remarks>
This method is called by the framework when it needs to create transitions that have been added
to the variable's internal list of transitions.
</remarks>
            <param name="pLibrary">A pointer to transition library.</param>
            <param name="pFactory">A pointer to transition factory.</param>
        </member>
        <member name="M:CAnimationVariable.Create(IUIAnimationManager*)">
            <summary>
Creates the underlying animation variable COM object.
</summary>
            <returns>
TRUE if the animation variable was successfully created; otherwise FALSE.
</returns>
            <remarks>
This method creates the underlying animation variable COM object and sets its default value.
</remarks>
            <param name="pManager">A pointer to animation manager.</param>
        </member>
        <member name="M:CAnimationVariable.SetDefaultValue(System.Double)">
            <summary>
Sets default value and releases IUIAnimationVariable COM object.
</summary>
            <remarks>
Use this method to reset the default value. This method releases the internal IUIAnimationVariable COM object,
therefore when animation variable is recreated, the underlying COM object gets the new default value.
The default value is returned by GetValue if the COM object representing the animation variable is not created,
or if the variable has not been animated.
</remarks>
            <param name="dblDefaultValue">Specifies the new default value.</param>
        </member>
        <member name="M:CAnimationVariable.GetVariable">
            <summary>
Returns a pointer to IUIAnimationVariable COM object.
</summary>
            <returns>
A valid pointer to IUIAnimationVariable COM object, or NULL if animation variable was not created, or can't be created.
</returns>
            <remarks>
Use this function to access the underlying IUIAnimationVariable COM object and call its methods directly if needed.
</remarks>
        </member>
        <member name="M:CAnimationVariable.GetParentAnimationObject">
            <summary>
Returns the parent animation object.
</summary>
            <returns>
A pointer to parent animation object, if relationship was established, otherwise NULL.
</returns>
            <remarks>
This method can be called to retrieve a pointer to a parent animation object (a container).
</remarks>
        </member>
        <member name="M:CAnimationVariable.Dispose">
            <summary>
The destructor. Called when a CAnimationVariable object is being destroyed.
</summary>
        </member>
        <member name="M:CAnimationVariable.#ctor(System.Double)">
            <summary>
Constructs an animation variable object.
</summary>
            <remarks>
Constructs an animation variable object and sets its default value. A default value is used when
a variable is not animated, or can't be animated.
</remarks>
            <param name="dblDefaultValue">Specifies the default value.</param>
        </member>
        <member name="M:CAnimationVariable.SetParentAnimationObject(CAnimationBaseObject*)">
            <summary>
Sets the relationship between an animation variable and an animation object.
</summary>
            <remarks>
This method is called internally to establish one-to-one relationship between an animation variable and an animation object that encapsulates it.
</remarks>
            <param name="pParentObject">A pointer to an animation object that contains this variable.</param>
        </member>
        <member name="F:CAnimationVariable.m_pParentObject">
            <summary>
A pointer to an animation object that encapsulates this animation variable.
</summary>
        </member>
        <member name="F:CAnimationVariable.m_lstTransitions">
            <summary>
Contains a list of transitions that animate this animation variable.
</summary>
        </member>
        <member name="F:CAnimationVariable.m_dblDefaultValue">
            <summary>
Specifies the default value, which is propagated to IUIAnimationVariable.
</summary>
        </member>
        <member name="F:CAnimationVariable.m_variable">
            <summary>
Stores a pointer to IUIAnimationVariable COM object. NULL if the COM object has not been created yet, or if creation failed.
</summary>
        </member>
        <member name="T:CAnimationVariable">
            <summary>
Represents an animation variable.
</summary>
            <remarks>
The CAnimationVariable class encapsulates IUIAnimationVariable COM object. It also holds a list of transitions
to be applied to the animation variable in a storyboard. CAnimationVariable objects are embedded to
animation objects, which can represent in an application an animated value, point, size, color and rectangle.
</remarks>
        </member>
        <member name="M:CKeyFrame.AddToStoryboardAtOffset(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds a keyframe to storyboard at offset.
</summary>
            <returns>
TRUE, if keyframe was added successfully.
</returns>
            <remarks>
This function is called by the framework to add a keyframe to storyboard at offset.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDeepAdd">Specifies whether to add a keyframe this keyframe depend on recursively.</param>
        </member>
        <member name="M:CKeyFrame.AddToStoryboardAfterTransition(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds a keyframe to storyboard after transition.
</summary>
            <returns>
TRUE, if keyframe was added successfully.
</returns>
            <remarks>
This function is called by the framework to add a keyframe to storyboard after transition.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDeepAdd">Specifies whether to add a transition recursively.</param>
        </member>
        <member name="M:CKeyFrame.AddToStoryboard(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds a keyframe to a storyboard.
</summary>
            <returns>
TRUE, if keyframe was added successfully.
</returns>
            <remarks>
This method adds a keyframe to storyboard. If it depends on other keyframe or transition and bDeepAdd is TRUE,
this method tries to add them recursively.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDeepAdd">Specifies whether to add keyframe or transition recursively.</param>
        </member>
        <member name="M:CKeyFrame.GetOffset">
            <summary>
Returns an offset from other keyframe.
</summary>
            <returns>
An offset in seconds from other keyframe.
</returns>
            <remarks>
This method should be called to determine an offset in seconds from other keyframe.
</remarks>
        </member>
        <member name="M:CKeyFrame.GetExistingKeyframe">
            <summary>
Returns a pointer to a keyframe this keyframe depends on.
</summary>
            <returns>
A valid pointer to keyframe, or NULL if this keyframe does not depend on other keyframe.
</returns>
            <remarks>
This is an accessor to a keyframe this keyframe depends on.
</remarks>
        </member>
        <member name="M:CKeyFrame.GetTransition">
            <summary>
Returns a pointer to a transition this keyframe depends on.
</summary>
            <returns>
A valid pointer to transition, or NULL if this keyframe does not depend on transition.
</returns>
            <remarks>
This is an accessor to a transition this keyframe depends on.
</remarks>
        </member>
        <member name="M:CKeyFrame.#ctor(CBaseKeyFrame*,System.Double)">
            <summary>
Constructs a keyframe that depends on other keyframe.
</summary>
            <remarks>
The constructed keyframe will represent a moment in time within a storyboard, which has a specified offset from pKeyframe.
</remarks>
            <param name="pKeyframe">A pointer to keyframe.</param>
            <param name="offset">Offset, in seconds, from keyframe specified by pKeyframe.</param>
        </member>
        <member name="M:CKeyFrame.#ctor(CBaseTransition*)">
            <summary>
Constructs a keyframe that depends on a transition.
</summary>
            <remarks>
The constructed keyframe will represent a moment in time within a storyboard when the specified transition ends.
</remarks>
            <param name="pTransition">A pointer to a transition.</param>
        </member>
        <member name="F:CKeyFrame.m_pExistingKeyFrame">
            <summary>
Stores a pointer to an existing keframe. This keyframe is added to storyboard with m_offset to the existing keyframe.
</summary>
        </member>
        <member name="F:CKeyFrame.m_offset">
            <summary>
Specifies offset of this keyframe from a keyframe stored in m_pExistingKeyFrame.
</summary>
        </member>
        <member name="F:CKeyFrame.m_pTransition">
            <summary>
Stores a pointer to transtion that begins at this keyframe.
</summary>
        </member>
        <member name="T:CKeyFrame">
            <summary>
Represents an animation keyframe.
</summary>
            <remarks>
This class implements an animation keyframe. A keyframe represents a moment in time within a
storyboard and can be used to specify the start and end times of transitions.
A keyframe may be based on other keyframe and have an offset (in seconds) from it, or may be based on a transition and
represent a moment in time when this transition ends.
</remarks>
        </member>
        <member name="M:CBaseKeyFrame.AddToStoryboard(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds a keyframe to storyboard.
</summary>
            <returns>
TRUE if keyframe was added to storyboard successfully; otherwise FALSE.
</returns>
            <remarks>
This method is called to add a keyframe to storyboard.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDeepAdd">If this parameter is TRUE and the keyframe being added depends on some other keyframe or transition, this method tries
to add this keyframe or transition to storyboard first.</param>
        </member>
        <member name="M:CBaseKeyFrame.IsKeyframeAtOffset">
            <summary>
Specifies whether the keyframe should be added to storyboard at offset, or after transition.
</summary>
            <returns>
TRUE if the keyframe should be added to storyboard at some specified offset.
FALSE if the keyframe should be added to storyboard after some transition.
</returns>
            <remarks>
Specifies whether the keyframe should be added to storyboard at offset.
The offset or transition must be specified in a derived class.
</remarks>
        </member>
        <member name="M:CBaseKeyFrame.IsAdded">
            <summary>
Tells whether a keyframe has been added to storyboard.
</summary>
            <returns>
TRUE if a keyframe is added to a storyboard; otehrwise FALSE.
</returns>
            <remarks>
In the base class IsAdded always returns TRUE, but it's overridden in derived classes.
</remarks>
        </member>
        <member name="M:CBaseKeyFrame.GetAnimationKeyframe">
            <summary>
Returns the underlying keyframe value.
</summary>
            <returns>
A current keyframe. The default value is UI_ANIMATION_KEYFRAME_STORYBOARD_START.
</returns>
            <remarks>
This is an accessor to the underlying keyframe value.
</remarks>
        </member>
        <member name="M:CBaseKeyFrame.#ctor">
            <summary>
Constructs a keyframe object.
</summary>
        </member>
        <member name="F:CBaseKeyFrame.m_bIsKeyframeAtOffset">
            <summary>
Specifies whether this keyframe should be added to storyboard at an offset from
another existing keyframe, or at the end of some transition.
</summary>
        </member>
        <member name="F:CBaseKeyFrame.m_bAdded">
            <summary>
Specifies whether this keyframe has been added to a storyboard.
</summary>
        </member>
        <member name="F:CBaseKeyFrame.m_keyframe">
            <summary>
Represents a Windows Animation API keyframe. When a keyframe is not initialized
it is set to the predefined value UI_ANIMATION_KEYFRAME_STORYBOARD_START.
</summary>
        </member>
        <member name="T:CBaseKeyFrame">
            <summary>
Implements basic functionality of keyframe.
</summary>
            <remarks>
Encapsulates UI_ANIMATION_KEYFRAME variable. Serves as a base class for any keyframe implementation.
A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions.
There are two types of keyframes - keyframes added to storyboard at the specified offset (in time), or keyframes added
after specified transition. Because durations of some transitions can't be known before animation starts, the actual values
of some keyframes are determined at runtime only.
Because keyframes may depend on transitions, which in their turn depend on keyframes, it's important to prevent
infinite recursions when building keyframe chains.
</remarks>
        </member>
        <member name="F:CBaseTransition.m_bAdded">
            <summary>
Specifies whether a transition has been added to a storyboard.
</summary>
        </member>
        <member name="F:CBaseTransition.m_pRelatedVariable">
            <summary>
A pointer to an animation variable, which is animated with the transition stored in m_transition.
</summary>
        </member>
        <member name="F:CBaseTransition.m_pEndKeyframe">
            <summary>
Stores a pointer to the keyframe that specifies the end of the transition.
</summary>
        </member>
        <member name="F:CBaseTransition.m_pStartKeyframe">
            <summary>
Stores a pointer to the keyframe that specifies the beginning of the transition.
</summary>
        </member>
        <member name="F:CBaseTransition.m_transition">
            <summary>
Stores a pointer to IUIAnimationTransition. NULL if a COM transition object has not been created.
</summary>
        </member>
        <member name="F:CBaseTransition.m_type">
            <summary>
Stores the transition type.
</summary>
        </member>
        <member name="M:CBaseTransition.AddToStoryboardAtKeyframes(IUIAnimationStoryboard*)">
            <summary>
Adds a transition to a storyboard.
</summary>
            <returns>
TRUE, if transition was successfully added to a storyboard.
</returns>
            <remarks>
Applies the transition to the related variable in the storyboard. If the start keyframe was specified, the transition
begins at that keyframe. If the end keyframe was specified, the transition begins at the start keyframe and
and stops at the end keyframe. If the transition was created with a duration parameter specified, that duration is
overwritten with the duration of time between the start and end keyframes.
If no keyframe was specified, the transition is appended to the transition added most recently to the variable.
</remarks>
            <param name="pStoryboard">A pointer to storyboard, which will animate the related variable.</param>
        </member>
        <member name="M:CBaseTransition.AddToStoryboard(IUIAnimationStoryboard*)">
            <summary>
Adds a transition to a storyboard.
</summary>
            <returns>
TRUE, if transition was successfully added to a storyboard.
</returns>
            <remarks>
Applies the transition to the related variable in the storyboard.  If this is the first transition
applied to this variable in this storyboard, the transition begins at the start of the storyboard.
Otherwise, the transition is appended to the transition added most recently to the variable.
</remarks>
            <param name="pStoryboard">A pointer to storyboard, which will animate the related variable.</param>
        </member>
        <member name="M:CBaseTransition.GetRelatedVariable">
            <summary>
Returns a pointer to related variable.
</summary>
            <returns>
A valid pointer to animation variable, or NULL if an animation variable has not been set by SetRelatedVariable.
</returns>
            <remarks>
This is an accessor to related animation variable.
</remarks>
        </member>
        <member name="M:CBaseTransition.SetRelatedVariable(CAnimationVariable*)">
            <summary>
Establishes a relationship between animation variable and transition.
</summary>
            <remarks>
Establishes a relationship between animation variable and transition. A transition can be applied only to one variable.
</remarks>
            <param name="pVariable">A pointer to related animation variable.</param>
        </member>
        <member name="M:CBaseTransition.GetEndKeyframe">
            <summary>
Returns start keyframe.
</summary>
            <returns>
A valid pointer to a keyframe, or NULL if a transition should not be inserted between keyframes.
</returns>
            <remarks>
This method can be used to access a keyframe object that was previously set by SetKeyframes.
It's called by top level code when transitions are being added to storyboard.
</remarks>
        </member>
        <member name="M:CBaseTransition.GetStartKeyframe">
            <summary>
Returns start keyframe.
</summary>
            <returns>
A valid pointer to a keyframe, or NULL if a transition should not start after a keyframe.
</returns>
            <remarks>
This method can be used to access a keyframe object that was previously set by SetKeyframes.
It's called by top level code when transitions are being added to storyboard.
</remarks>
        </member>
        <member name="M:CBaseTransition.IsAdded">
            <summary>
Tells whether a transition has been added to a storyboard.
</summary>
            <returns>
Returns TRUE if a transition has been added to a storyboard, otherwise FALSE.
</returns>
            <remarks>
This flag is set internally when the top level code adds transitions to storyboard.
</remarks>
        </member>
        <member name="M:CBaseTransition.SetKeyframes(CBaseKeyFrame*,CBaseKeyFrame*)">
            <summary>
Sets keyframes for a transition.
</summary>
            <remarks>
This method tells the transition to start after specified keyframe and, optionally, if pEnd is not NULL, end
before the specified keyframe.
If the transition was created with a duration parameter specified, that duration is overwritten with the duration of time between the start and end keyframes.
</remarks>
            <param name="pStart">A keyframe that specifies the beginning of the transition. </param>
            <param name="pEnd">A keyframe that specifies the end of the transition.</param>
        </member>
        <member name="M:CBaseTransition.GetTransition">
            <summary>
Returns a pointer to underlying COM transition object.
</summary>
            <returns>
A valid pointer to IUIAnimationTransition or NULL if underlying transition can't be created.
</returns>
            <remarks>
It's an accessor method to underlying COM transition object. It doesn't instantiates the underlying IUIAnimationTransition COM
object if it wasn't created.
</remarks>
        </member>
        <member name="M:CBaseTransition.GetTransition(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Returns a pointer to underlying COM transition object.
</summary>
            <returns>
A valid pointer to IUIAnimationTransition or NULL if underlying transition can't be created.
</returns>
            <remarks>
This method returns a pointer to underlying COM transition object and creates it if necessary.
</remarks>
            <param name="pLibrary">A pointer to transition library, which creates standard transitions. It can be NULL for custom transitions.</param>
            <param name="pFactory">A pointer to transition factory, which creates custom transitions. It can be NULL for standard transitions.</param>
        </member>
        <member name="M:CBaseTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Creates a COM transition.
</summary>
            <returns>
TRUE if a transition COM object was created successfully; otherwise FALSE.
</returns>
            <remarks>
This is a pure virtual function that must be overridden in a derived class.
It's called by the framework to instantiate the underlying COM transition object.
</remarks>
            <param name="pLibrary">A pointer to transition library, which creates standard transitions. It can be NULL for custom transitions.</param>
            <param name="pFactory">A pointer to transition factory, which creates custom transitions. It can be NULL for standard transitions.</param>
        </member>
        <member name="M:CBaseTransition.GetType">
            <summary>
Returns transition type.
</summary>
            <returns>
One of TRANSITION_TYPE enumerated values.
</returns>
            <remarks>
This method can be used to identify a transition object by its type.
The type is set in a constructor in a derived class.
</remarks>
        </member>
        <member name="M:CBaseTransition.Clear">
            <summary>
Releases encapsulated IUIAnimationTransition COM object.
</summary>
            <remarks>
This method should be called from a derived class's Create method in order to prevent
IUITransition interface leak.
</remarks>
        </member>
        <member name="M:CBaseTransition.Dispose">
            <summary>
The destructor. Called when a transition object is being destroyed.
</summary>
        </member>
        <member name="M:CBaseTransition.#ctor">
            <summary>
Constructs a base transtion object.
</summary>
        </member>
        <member name="T:CBaseTransition.TRANSITION_TYPE">
            <summary>
Defines the transition types currently supported by the MFC implementation of Windows Animation API.
</summary>
            <remarks>
A transition type is set in the constructor of specific transition.
For example, CSinusoidalTransitionFromRange sets its type to SINUSOIDAL_FROM_RANGE.
</remarks>
        </member>
        <member name="T:CBaseTransition">
            <summary>
Represents a basic transition.
</summary>
            <remarks>
This class encapsulates IUIAnimationTransition interface and serves as a base class for all transitions.
</remarks>
        </member>
        <member name="T:TFUnitsS">
            <summary>Structured Units</summary>
        </member>
        <member name="T:TFUnits">
            <summary>Units</summary>
        </member>
        <member name="T:TFUnitTypes">
            <summary>Unit Types</summary>
        </member>
        <member name="T:TFUnitsEnumS">
            <summary>Structured Units Enum</summary>
        </member>
        <member name="T:TFUnitsEnum">
            <summary>Units Enum</summary>
        </member>
        <member name="T:TFUnitTypesEnum">
            <summary>Unit Types Enum</summary>
        </member>
        <member name="M:CTFCom_CContainer3DData.AfterRegenerate2D(TFDocRegenContext*)">
Метод вызывается после 2D пересчета. Используется для обработки 3D объектов, которые участвуют в 2D пересчете
</member>
        <member name="M:CTFCom_CContainer3DData.BeforeRegenerate2D(TFDocRegenContext*)">
Метод вызывается перед 2D пересчетом. Используется для обработки 3D объектов, которые участвуют в 2D пересчете
</member>
        <member name="M:CTFCom_CContainer3DData.GetScreenObjects(std.list&lt;ScreenObject**,std.allocator&lt;ScreenObject**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сформировать список экранных объектов для рисования 3D объектов на 2D.
Сейчас используется для рисования фрагментов проекций с разными приоритетами
</member>
        <member name="T:CTFCom_Is3D.CreateDetailMode">
Полезные фцнкции для деталировки
</member>
        <member name="M:CTFCom_Is3D.CreateUndoManager(CTfw32Doc*)">
Создать менеджер блока отмены действий
</member>
        <member name="M:CTFCom_Is3D.Run2DCommandOn3D(System.UInt64,=FUNC:System.Int64(System.UInt32,System.UInt64,System.Int64,CTFView*),System.UInt64,System.Int64,CTFView*,System.Boolean)">
Создать команду выбора активной рабочей плоскости
</member>
        <member name="M:CTFCom_Is3D.IsObjectVisibileForPS(CTFObject*,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка видимости объекта при обновление структуры изделия. Returns true if handled.
</member>
        <member name="M:CTFCom_Is3D.GetWPForPage(CTfw32Doc!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Получить рабочую плоскость для страницы
</member>
        <member name="M:CTFCom_Is3D.GetWPIntersection(CTFObject*,CTFObject*,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Получить линию пересечения двух РП в системе координат первой РП
</member>
        <member name="M:CTFCom_Is3D.CMarkContainerKey_CMarkContainerKey(SelectableObject!System.Runtime.CompilerServices.IsConst*,TFObjectID*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод возвращает идентификатор, который является ключом в контейнере маркирования
</member>
        <member name="M:CTFCom_Is3D.GetLabelForTheSection(CTFObject!System.Runtime.CompilerServices.IsConst*,CTFSection**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить для проекции типа разрез или сечение, построенным по обозначению вида, собтсвенно это обозначение вида и масштаб проекции.
Во всех остальных случаях метод возвращает false. Значения выходных данных неопределены.
Используется для актуализации обозначения разреза или сечения.
</member>
        <member name="M:TFlex.Model.ModelAttributes.HaveAttribute(System.String)">
            <summary>Проверить существование атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>true, если атрибут с таким именем существует, иначе false </returns>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.DeleteAllAttributes(System.Boolean)">
            <summary>Удалить все атрибуты</summary>
            <param name="change">Изменить значения атрибутов</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.DeleteAllAttributes">
            <summary>Удалить все атрибуты</summary>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.DeleteAttribute(System.String,System.Boolean)">
            <summary>Удалить атрибут</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="change">Изменить значения атрибутов</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.DeleteAttribute(System.String)">
            <summary>Удалить атрибут</summary>
            <param name="attribName">Имя атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.GetAttributeType(System.String)">
            <summary>Получить тип атрибута атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Тип атрибута</returns>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.SetIntAttribute(System.String,System.Int32,System.Boolean)">
            <summary>Установить значение целого атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
            <param name="change">Изменить значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.SetIntAttribute(System.String,System.Int32)">
            <summary>Установить значение целого атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.SetTextAttribute(System.String,System.String,System.Boolean)">
            <summary>Установить значение текстового атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
            <param name="change">Изменить значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.SetTextAttribute(System.String,System.String)">
            <summary>Установить значение текстового атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.SetRealAttribute(System.String,System.Double,System.Boolean)">
            <summary>Установить значение вещественного атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
            <param name="change">Изменить значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.SetRealAttribute(System.String,System.Double)">
            <summary>Установить значение вещественного атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.GetIntAttribute(System.String)">
            <summary>Получить значение целого атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Значение атрибута</returns>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.GetTextAttributeIfExist(System.String)">
            <summary>Получить значение текстового атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Значение атрибута или null, если атрибута не существует</returns>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.GetTextAttribute(System.String)">
            <summary>Получить значение текстового атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Значение атрибута</returns>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.GetRealAttribute(System.String)">
            <summary>Получить значение вещественного атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Значение атрибута</returns>
        </member>
        <member name="M:TFlex.Model.ModelAttributes.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.ModelAttributes">
            <summary>Атрибуты</summary>
        </member>
        <member name="P:TFlex.Model.ModelAttribute.Type">
            <summary>Тип аттрибута</summary>
        </member>
        <member name="P:TFlex.Model.ModelAttribute.Value">
            <summary>Значение аттрибута</summary>
        </member>
        <member name="P:TFlex.Model.ModelAttribute.Name">
            <summary>Имя аттрибута</summary>
        </member>
        <member name="T:TFlex.Model.ModelAttribute">
            <summary>Аттрибут</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.HaveAttribute(System.String)">
            <summary>Проверить существование атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>true, если атрибут с таким именем существует, иначе false </returns>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.DeleteAllAttributes(System.Boolean)">
            <summary>Удалить все атрибуты</summary>
            <param name="change">Удалить значения атрибутов</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.DeleteAllAttributes">
            <summary>Удалить все атрибуты</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.DeleteAttribute(System.String,System.Boolean)">
            <summary>Удалить атрибут</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="change">Удалить значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.DeleteAttribute(System.String)">
            <summary>Удалить атрибут</summary>
            <param name="attribName">Имя атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.GetAttributeType(System.String)">
            <summary>Получить тип атрибута атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Тип атрибута</returns>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.SetIntAttribute(System.String,System.Int32,System.Boolean)">
            <summary>Установить значение целого атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
            <param name="change">Изменить значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.SetIntAttribute(System.String,System.Int32)">
            <summary>Установить значение целого атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.SetTextAttribute(System.String,System.String,System.Boolean)">
            <summary>Установить значение текстового атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
            <param name="change">Изменить значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.SetTextAttribute(System.String,System.String)">
            <summary>Установить значение текстового атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.SetRealAttribute(System.String,System.Double,System.Boolean)">
            <summary>Установить значение вещественного атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
            <param name="change">Изменить значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.SetRealAttribute(System.String,System.Double)">
            <summary>Установить значение вещественного атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <param name="value">Устанавливаемое значение атрибута</param>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.GetIntAttribute(System.String)">
            <summary>Получить значение целого атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Значение атрибута</returns>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.GetTextAttributeIfExist(System.String)">
            <summary>Получить значение текстового атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Значение атрибута или null, если атрибута не существует</returns>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.GetTextAttribute(System.String)">
            <summary>Получить значение текстового атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Значение атрибута</returns>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.GetRealAttribute(System.String)">
            <summary>Получить значение вещественного атрибута</summary>
            <param name="attribName">Имя атрибута</param>
            <returns>Значение атрибута</returns>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectAttributes.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectAttributes.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.AttributeType">
            <summary>Тип атрибута объекта класса <see cref="T:TFlex.Model.ModelObjectAttributes" /></summary>
        </member>
        <member name="F:TFlex.Model.AttributeType.IntAttribute">
            <summary>Целый</summary>
        </member>
        <member name="F:TFlex.Model.AttributeType.TextAttribute">
            <summary>Текстовый</summary>
        </member>
        <member name="F:TFlex.Model.AttributeType.RealAttribute">
            <summary>Вещественный</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.LineWidth">
            <summary>Толщина линий шрифта</summary>
            <remarks>Толщина линий учитывается только при прорисовке шрифтов формата SHX</remarks>
            <example>
                <code name="Установка толщины линии">
public static void SetLineWidth(ModelObject ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка толщины линии");//Открытие блока изменений документа

   ob.LineWidth = 3;	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.Interval">
            <summary>Междустрочный интервал</summary>
            <remarks>Междустрочный интервал задаётся коэффициентом относительно высоты шрифта.
При значении равном 1 междустрочнй интервал равен высоте шрифта</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.Extension">
            <summary>Коэффициент расширения шрифта</summary>
            <remarks>Коэффициент расширения шрифта учитывается только при прорисовке шрифтов типа SHX.
Стандартное значение равно 1</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.Spacing">
            <summary>Дополнитальный интервал между символами</summary>
            <remarks>Интервал между символами измеряется коэффициентом относительно размера шрифта.
Стандартное значение равно 0. При значении 1 интервал между символами равен высоте шрифта.</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.Tilt">
            <summary>Угол наклона шрифта</summary>
            <remarks>Угол измеряется в градусах. Вертикальный шрифт имеет угол наклона, равный значению 90</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.Size">
            <summary>Размер (высота) шрифта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.DefaultTracing">
            <summary>Использовать начертание из статуса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.Italic">
            <summary>Параметр "наклонный шрифт"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.Bold">
            <summary>Параметр "полужирный шрифт"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.Fill">
            <summary>Параметр "заливка шрифта"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.ClearBackground">
            <summary>Параметр "очистка фона"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.FontNameVariable">
            <summary>Переменная, задающая имя шрифта или 0 если имя шрифта является константой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FontStyle.FontName">
            <summary>Имя шрифта</summary>
            <remarks>Шрифты SHX имеют расширение ".shx"</remarks>
        </member>
        <member name="T:TFlex.Model.Model2D.FontStyle">
            <summary>Класс стиля шрифта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.AggregateMultilineTextExtension.GetMultilineTextBounds(TFlex.Model.ModelObject,System.Int32)">
            <summary>Получить габариты аггрегированного многострочного текста</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.AggregateMultilineTextExtension.GetMultilineText(TFlex.Model.ModelObject,System.Int32,System.Boolean)">
            <summary>Получить аггрегированный многострочный текст</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.AggregateMultilineTextExtension.GetMultilineTextsCount(TFlex.Model.ModelObject)">
            <summary>Количество аггрегированных многострочных текстов</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.AggregateMultilineTextExtension.RemoveMultilineText(TFlex.Model.ModelObject,System.Int32)">
            <summary>Удалить многострочный текст по индексу</summary>
            <param>Индекс многострочного текста</param>
        </member>
        <member name="M:TFlex.Model.Model2D.AggregateMultilineTextExtension.AddMultilineText(TFlex.Model.ModelObject)">
            <summary>Аггрегировать новый многострочный текст</summary>
            <returns>Индекс нового многострочного текста</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.ParagraphText.HeightAction">
            <summary>Действие при необходимости увеличить высоту прямоугольника</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitHeightAction.CreateOnCurrentPage">
            <summary>Создать новый прямоугольник на текущей странице</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitHeightAction.CreateOnNextPage">
            <summary>Создать новый прямоугольник на следующей странице</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitHeightAction.CreateOnNewPage">
            <summary>Создать новый прямоугольник на новой странице</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitHeightAction.EnlargeUp">
            <summary>Увеличить прямоугольник вверх</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitHeightAction.EnlargeDown">
            <summary>Увеличить прямоугольник вниз</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitHeightAction.Ignore">
            <summary>Игнорировать</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitHeightAction.AlwaysAsk">
            <summary>Спрашивать пользователя</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParagraphText.FitHeightAction">
            <summary>Действие при необходимости увеличить высоту прямоугольника</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ParagraphText.WidthAction">
            <summary>Действие при необходимости увеличить ширину прямоугольника</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitWidthAction.EnlargeLeft">
            <summary>Увеличить прямоугольник влево</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitWidthAction.EnlargeRight">
            <summary>Увеличить прямоугольник вправо</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitWidthAction.Ignore">
            <summary>Игнорировать</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.FitWidthAction.AlwaysAsk">
            <summary>Спрашивать пользователя</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParagraphText.FitWidthAction">
            <summary>Действие при необходимости увеличить ширину прямоугольника</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ParagraphText.EmptyRectangleAction">
            <summary>Действие с пустым прямоугольником</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.EmptyRectAction.DeleteRectWithPage">
            <summary>Удалять вмете со страницей</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.EmptyRectAction.DeleteRectOnly">
            <summary>Удалять</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.EmptyRectAction.Leave">
            <summary>Оставлять</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.EmptyRectAction.AlwaysAsk">
            <summary>Спрашивать пользователя</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParagraphText.EmptyRectAction">
            <summary>Действие с пустым прямоугольником</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ParagraphText.SetRectangle(System.UInt32,TFlex.Model.Model2D.ParagraphText.TextRectangle)">
            <summary>Установка параметров прямоугольника</summary>
            <param name="index">Порядковый номер прямоугольника</param>
            <param name="rect">Новые параметры прямоугольника</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ParagraphText.GetRectangle(System.UInt32)">
            <summary>Получение параметров прямоугольника</summary>
            <param name="index">Порядковый номер прямоугольника</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ParagraphText.GetRectanglesCount">
            <summary>Получение количества прямоугольников</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ParagraphText.AddRectangle(TFlex.Model.Model2D.ParagraphText.TextRectangle)">
            <summary>Добавление прямоугольника в конец массива прямоугольников</summary>
            <param name="rect">Параметры нового прямоугольника</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ParagraphText.TextRectangle.#ctor(TFlex.Model.Model2D.ParagraphText.TextRectangle.Point,TFlex.Model.Model2D.ParagraphText.TextRectangle.Point,TFlex.Model.Page,System.Double)">
            <summary>Конструктор</summary>
            <param name="left">Левая верхняя точка</param>
            <param name="right">Правая нижняя точка</param>
            <param name="page">Страница</param>
            <param name="angle">Угол поворота</param>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.VAlignment">
            <summary>Вертикальное выравнивание</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.VerticalAlignment.Bottom">
            <summary>По нижней границе текста</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.VerticalAlignment.Center">
            <summary>По центру</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.VerticalAlignment.Top">
            <summary>По верхней границе текста</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.VerticalAlignment.Default">
            <summary>Значение по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParagraphText.TextRectangle.VerticalAlignment">
            <summary>Вертикальное выравнивание</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.Angle">
            <summary>Угол поворота</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.Page">
            <summary>Страница, на которой находится прямоугольник</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.RightPoint">
            <summary>Правая нижняя точка</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.LeftPoint">
            <summary>Левая верхняя точка</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ParagraphText.TextRectangle.Point.#ctor(System.Double,System.Double,TFlex.Model.Model2D.Node)">
            <summary>Конструктор</summary>
            <param name="x">Координата X</param>
            <param name="y">Координата Y</param>
            <param name="node">Узел привязки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ParagraphText.TextRectangle.Point.#ctor(System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="x">Координата X</param>
            <param name="y">Координата Y</param>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.Point.Node">
            <summary>Узел привязки (необязателен)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.Point.Y">
            <summary>Координата Y</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParagraphText.TextRectangle.Point.X">
            <summary>Координата X</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParagraphText.TextRectangle.Point">
            <summary>Точка</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParagraphText.TextRectangle">
            <summary>Параметры прямоугольника</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ParagraphText.Page">
            <summary>Установить страницу</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ParagraphText.SubType">
            <summary>Получение подтипа текста для задания способа его задания</summary>
            <returns>Значение подтипа текста</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.ParagraphText.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового параграф текста</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.ParagraphText">
            <summary>Класс параграф текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MultilineText.VerticalAlignment">
            <summary>Вертикальное выравнивание текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MultilineText.HorizontalAlignment">
            <summary>Горизонтальное выравнивание текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MultilineText.Angle">
            <summary>Угол поворота текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MultilineText.Node">
            <summary>Узел привязки текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MultilineText.Y">
            <summary>Координата Y или смещение Y относительно узла привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MultilineText.X">
            <summary>Координата X или смещение X относительно узла привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MultilineText.SubType">
            <summary>Подтип текста, способ его задания</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.MultilineText.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового многострочного форматированного текста</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.MultilineText">
            <summary>Класс многострочного форматированного текст</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.EditInModalWindow(TFlex.Model.Model2D.RichText.EditData)">
            <summary>Редактировать текст в модальном диалоге</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.EditData.Document">
            <summary>Документ grb для настроек текста по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.EditData.Data">
            <summary>Форматированный текст в виде бинарных данных</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.EditData.Text">
            <summary>Текст для редактирования</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RichText.EditData">
            <summary>Параметры EditInModalWindow</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.ReportPrototypeFile">
            <summary>Ссылка на документ прототип отчета, если текст является отчетом состава изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.ProductStructureFile">
            <summary>Ссылка на документ состава изделия по которому создан текст, если текст является отчетом состава изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.ProductStructureId">
            <summary>ID состава изделия по которому создан текст, если текст является отчетом состава изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.CurrFractionScale">
            <summary>Текущий масштаб высоты шрифта для дробей, используется при вставке новых дробей</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.CurrIndexScale">
            <summary>Текущий масштаб высоты шрифта для индексов, используется при вставке новых индексов</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.TrySetTableOnly(System.Boolean)">
            <summary>Попробовать выставить свойство TableOnly</summary>
            <param name="tableOnly">Таблица</param>
            <remarks>Возвращает true в случае успеха</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.TableOnly">
            <summary>Запретить ввод текста вне таблицы</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.GetTablePosition(TFlex.Model.Model2D.Table)">
            <summary>Получение порядкового номера символа, перед которым находится таблица, относительно начала текста</summary>
            <param name="table">Таблица</param>
            <returns>Порядковый номер символа, перед которым находится таблица, относительно начала текста</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertCopyOfTable(TFlex.Model.Model2D.Table)">
            <summary>Вставка копии таблицы перед символом, на котором находится курсор</summary>
            <param name="table">Таблица, копию которой надо создать</param>
            <returns>Копия таблицы</returns>
            <remarks>После создания таблицы, курсор перемещается в начало первой ячейки</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertCopyOfTable(System.UInt32,TFlex.Model.Model2D.Table)">
            <summary>Вставка копии таблицы перед символом, заданным порядковым номером относительно начала текста</summary>
            <param name="position">Порядковый номер символа, перед которым надо вставить таблицу, относительно начала текста</param>
            <param name="table">Таблица, копию которой надо создать</param>
            <returns>Копия таблицы</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.CreateTable(TFlex.Model.Model2D.Table.CreationSettings)">
            <summary>Создание таблицы перед символом, на котором находится курсор</summary>
            <param name="settings">Параметры создания таблицы</param>
            <returns>Таблица</returns>
            <remarks>После создания таблицы, курсор перемещается в начало первой ячейки</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.CreateTable(System.UInt32,TFlex.Model.Model2D.Table.CreationSettings)">
            <summary>Создание таблицы перед символом, заданным порядковым номером относительно начала текста</summary>
            <param name="position">Порядковый номер символа, перед которым надо вставить таблицу, относительно начала текста</param>
            <param name="settings">Параметры создания таблицы</param>
            <returns>Таблица</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.GetTableByIndex(System.UInt32)">
            <summary>Получение таблицы по её порядковому номеру</summary>
            <param name="index">Порядковый номер таблицы относительно начала текста</param>
            <returns>Таблица</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.DefaultNumberFormat">
            <summary>Формат символов нумерации, используемый по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.DefaultParagraphFormat">
            <summary>Формат абзацев, используемый по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.DefaultCharacterFormat">
            <summary>Формат символов, используемый по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.ParagraphFormat">
            <summary>Формат одного символа, на котором находится курсор, или символов, находящихся в выделенном фрагменте, в зависимости от состояния выделения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.CharacterFormat">
            <summary>Формат одного символа, на котором находится курсор, или символов, находящихся в выделенном фрагменте, в зависимости от состояния выделения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.GetCursorInfo">
            <summary>Получение параметров положения курсора в тексте</summary>
            <returns>Параметры положения курсора</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.SetCursor(TFlex.Model.Model2D.PositionProperties,TFlex.Model.Model2D.Position.TablePosition)">
            <summary>Установка положения курсора в ячейке таблицы</summary>
            <param name="position">Положение курсора в ячейке таблицы</param>
            <param name="table">Положение ячейки</param>
            <remarks>Функция устанавливает курсор в начало(конец) ячейки таблицы</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.SetCursor(TFlex.Model.Model2D.PositionProperties)">
            <summary>Установка положения курсора в тексте</summary>
            <param name="position">Положения курсора в тексте</param>
            <remarks>Функция устанавливает курсор в начало (конец) текста</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.MoveCursor(System.Int32)">
            <summary>Перемещение курсора на несколько символов вперёд или назад</summary>
            <param name="charactersCount">Количество символов</param>
            <remarks>Если значение параметра charactersCount больше 0, то курсор будет перемещён вперёд на charactersCount символов.
Если значение параметра charactersCount меньше 0, то курсор будет перемещён на абсолютное значение charactersCount символов</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.CursorPosition">
            <summary>Положение курсора в тексте</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.SetDefaultFont(System.String,System.Double,System.UInt32,System.Boolean,System.Boolean)">
            <summary>Установка шрифта, используемого по умолчанию</summary>
            <param name="name">Имя шрифта</param>
            <param name="size">Размер символов</param>
            <param name="color">Цвет символов</param>
            <param name="defaultItalic">Курсив по умолчанию</param>
            <param name="defaultBold">Полужирный по умолчанию</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.SetDefaultFont(System.String,System.Double,System.UInt32,System.Boolean)">
            <summary>Установка шрифта, используемого по умолчанию</summary>
            <param name="name">Имя шрифта</param>
            <param name="size">Размер символов</param>
            <param name="color">Цвет символов</param>
            <param name="defaultItalic">Курсив по умолчанию</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.GetDefaultFontSize">
            <summary>Получение размера символов, используемого по умолчанию</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.Deselect">
            <summary>Снятие выделения</summary>
            <remarks>Курсор будет находиться там, где был конец выделенного фрагмента</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.SelectAll">
            <summary>Выделение всего текста</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.GetSelection(TFlex.Model.Model2D.Position*,TFlex.Model.Model2D.Position*)">
            <summary>Получение границ выделенного фрагмента</summary>
            <param name="begining">Начало выделенного фрагмента</param>
            <param name="end">Конец выделенного фрагмента</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.SetSelection(TFlex.Model.Model2D.Position)">
            <summary>Установка выделения фрагмента, находящегося между курсором и заданной позицией</summary>
            <param name="position">Один из краёв выделяемого фрагмента</param>
            <remarks>Курсор устанавливается в конец выделяемого фрагмента</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.SetSelection(TFlex.Model.Model2D.Position,TFlex.Model.Model2D.Position)">
            <summary>Установка выделения фрагмента текста</summary>
            <param name="pos1">Начало выделяемого фрагмента</param>
            <param name="pos2">Конец выделяемого фрагмента</param>
            <remarks>Курсор устанавливается в конец выделяемого фрагмента</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.ClearAll">
            <summary>Очистка содержимого всего текста</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.Delete(System.UInt32)">
            <summary>Удаление нескольких символов, начиная с того, на котором находится курсор</summary>
            <param name="count">Количество удаляемых символов</param>
            <remarks>Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.Delete">
            <summary>Удаление выделенного фрагмента или символа, на котором находится курсор</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.TextLength">
            <summary>Получение длины всего текста с начала до конца без учёта таблиц</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.GetText(TFlex.Model.Model2D.Position,TFlex.Model.Model2D.Position)">
            <summary>Получение текста, находящегося в заданном отрезке</summary>
            <param name="pos1">Начало отрезка</param>
            <param name="pos2">Конец отрезка</param>
            <returns>Текст, находящийся в заданном отрезке</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.TextValue">
            <summary>Получение текста, находящегося в заданном отрезке</summary>
            <returns>Текст документа</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.GetSelectedRtfText">
            <summary>Получение выделенного текста в формате RTF</summary>
            <returns>Выделенный текст в формате RTF</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.GetSelectedText">
            <summary>Получение выделенного текста</summary>
            <returns>Выделенный текст</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.PasteFromClipboard">
            <summary>Вставить текст из буфера обмена</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.CopyToClipboard">
            <summary>Копировать выделенный текст в буфер обмена</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertFraction(System.String,System.String)">
            <summary>Вставка дроби</summary>
            <param name="upper">Строка числителя (может отсутствовать)</param>
            <param name="lower">Строка знаменателя (может отсутствовать)</param>
            <remarks>При создании дроби используется значение масштаба шрифта, указанное в свойстве <see cref="P:TFlex.Model.Model2D.RichText.CurrFractionScale" /></remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertIndex(System.String,System.String)">
            <summary>Вставка индексов</summary>
            <param name="upper">Строка в верхнем индексе (может отсутствовать)</param>
            <param name="lower">Строка в нижнем индексе (может отсутствовать)</param>
            <remarks>При создании индекса используется значение масштаба шрифта, указанное в свойстве <see cref="P:TFlex.Model.Model2D.RichText.CurrIndexScale" /></remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertSymbol(System.UInt32,System.Boolean)">
            <summary>Вставка символа с заданным кодом</summary>
            <param name="code">Код символа</param>
            <param name="fIgnoreFontAngularity">Игнорировать наклон шрифта</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertCommonSymbol(TFlex.Model.Model2D.CommonSymbol)">
            <summary>Вставка символа</summary>
            <param name="symbol">Символ</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertFragment">
            <summary>Вставка фрагмента с указанием ссылки</summary>
            <returns>Добавленый фрагмент</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertFragment(TFlex.Model.FileLink)">
            <summary>Вставка фрагмента с указанием ссылки</summary>
            <param name="link">Используемая ссылка</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertFragment(TFlex.Model.Model2D.Fragment)">
            <summary>Вставка фрагмента</summary>
            <param name="obj">Фрагмент</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertFormLimitsSymbol(TFlex.Model.Model2D.Formlimits)">
            <summary>Вставка обозначения базы или допуска формы или расположения</summary>
            <param name="obj">Обозначение базы или допуска формы или расположения</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertRoughnessSymbol(TFlex.Model.Model2D.RoughnessSymbol)">
            <summary>Вставка обозначения шероховатости</summary>
            <param name="obj">Обозначение шероховатости</param>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.ShowVariableNames">
            <summary>Показать имена переменных</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertVariable(TFlex.Model.Variable,TFlex.Model.VariableProperties)">
            <summary>Вставка переменной</summary>
            <param name="pObj">Переменная</param>
            <param name="varProps">Параметры вставки переменной</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertParagraphs(System.UInt32)">
            <summary>Вставка нескольких абзацев с использованием для разделителя формата символов по умолчанию для разделителя</summary>
            <param name="count">Количество абзацев</param>
            <remarks>Абзацы будет вставлены перед символом, на котором находится курсор.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertParagraphs(System.UInt32,TFlex.Model.Model2D.CharFormat)">
            <summary>Вставка нескольких абзацев с использованием для разделителя заданного формата символов</summary>
            <param name="count">Количество абзацев</param>
            <param name="format">Формат разделителя</param>
            <remarks>Абзацы будет вставлены перед символом, на котором находится курсор.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertParagraph">
            <summary>Вставка абзаца</summary>
            <remarks>Абзац будет вставлен перед символом, на котором находится курсор.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertParagraph(TFlex.Model.Model2D.CharFormat)">
            <summary>Вставка абзаца с использованием заданного формата символов</summary>
            <param name="format">Формат разделителя</param>
            <remarks>Абзац будет вставлен перед символом, на котором находится курсор
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsetRtfText(System.String)">
            <summary>Вставка текста в формате RTF</summary>
            <param name="text">RTF текст</param>
            <remarks>Текст будет вставлен перед символом, на котором находится курсор.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertText(System.String)">
            <summary>Вставка текста с использованием формата символов по умолчанию</summary>
            <param name="rtfText">Текст</param>
            <remarks>Текст будет вставлен перед символом, на котором находится курсор.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.InsertText(System.String,TFlex.Model.Model2D.CharFormat)">
            <summary>Вставка текста с использованием заданного формата символов</summary>
            <param name="text">Текст</param>
            <param name="format">Формат символов</param>
            <remarks>Текст будет вставлен перед символом, на котором находится курсор.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.RichText.AutoUpdate">
            <summary>Автоматический пересчёт текста при открытом блоке изменения текста</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.ReplaceAbsentFontNames(System.String)">
            <summary>Заменяем отсутствующие в системе шрифты во всех элементах текста.</summary>
            <param name="newName">Новое имя шрифта</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.ReplaceFontName(System.String,System.String)">
            <summary>Заменяем выбранный шрифт во всех элементах текста.</summary>
            <param name="oldName">Старое имя шрифта для замены</param>
            <param name="newName">Новое имя шрифта</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.EndEdit">
            <summary>Завершение редактирования текста</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RichText.BeginEdit">
            <summary>Начало редактирования текста</summary>
            <remarks>Функция устанавливает текст в режим редактирования для последующей работы с ним</remarks>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.TextRectangleIndex">
            <summary>Номер прямоугольника текста, где находится курсор</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.Page">
            <summary>Страница</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.Character">
            <summary>Символ</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.Object">
            <summary>Тип объекта, на котором находится курсор</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.Position">
            <summary>Положение курсора в тексте</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.ObjectType.Char">
            <summary>Символ</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.ObjectType.Tab">
            <summary>Табуляция</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.ObjectType.LineBreak">
            <summary>Разделитель линий</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RichText.CursorInfo.ObjectType.ParagraphDelimiter">
            <summary>Разделитель абзацев</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RichText.CursorInfo.ObjectType">
            <summary>Тип объекта </summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RichText.CursorInfo">
            <summary>Параметры положения курсора</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RichText">
            <summary>Базовый класс форматированного текста</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CommonSymbol">
            <summary>Символы для вставки в текст</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CommonSymbol.LineBreak">
            <summary>Перевод строки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CommonSymbol.NotBreakingOffHyphen">
            <summary>Неразрывный дефис</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CommonSymbol.NotBreakingOffSpace">
            <summary>Неразрывный пробел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CommonSymbol.PlusMinus">
            <summary>Значок плюс/минус</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CommonSymbol.Degree">
            <summary>Значок градуса</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CommonSymbol.Diameter">
            <summary>Значок диаметра</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.PositionProperties">
            <summary>Дополнительные параметры положения курсора</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.PositionProperties.End">
            <summary>Расположить вконце</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.PositionProperties.Begining">
            <summary>Расположить вначале</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SetCellData(System.UInt32,System.IntPtr)">
            <summary>Выставление данных ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="data">Данные ячейки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellData(System.UInt32)">
            <summary>Получение данных ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellRectangle(System.UInt32)">
            <summary>Получение прямоугольника ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellText(System.UInt32,System.Boolean)">
            <summary>Получение текста в ячейке</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="useBraces">Указывает, содержит ли строка символы форматирования</param>
            <returns>Строка с текстом</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellText(System.UInt32)">
            <summary>Получение текста в ячейке</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <returns>Строка с текстом</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellTextLength(System.IntPtr)">
            <summary>Получение количества символов в ячейке</summary>
            <param name="cellHandle">Дескриптор ячейки таблицы</param>
            <returns>Количество символов в ячейке</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellTextLength(System.UInt32)">
            <summary>Получение количества символов в ячейке</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <returns>Количество символов в ячейке</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.Delete">
            <summary>Удаление таблицы</summary>
            <remarks>Курсор будет установлен на следующем после таблицы символе.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SetCellHeight(System.UInt32,System.Double,TFlex.Model.Model2D.SizeMode)">
            <summary>Установка высоты ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="height">Новая высота ячейки</param>
            <param name="mode">Режим высоты ячейки</param>
            <remarks>Будет изменена высота всей строки, содержащей данную ячейку</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellHeight(System.UInt32)">
            <summary>Получение высоты ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <returns>Высота ячейки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SetCellWidth(System.UInt32,System.Double,TFlex.Model.Model2D.ColumnSizeMode)">
            <summary>Установка ширины ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="width">Новая ширина ячейки</param>
            <param name="mode">Режим задания ширины ячейки</param>
            <remarks>Будет изменена ширина всего столбца, содержащего данную ячейку</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SetCellWidth(System.UInt32,System.Double)">
            <summary>Установка ширины ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="width">Новая ширина ячейки</param>
            <remarks>Будет изменена ширина всего столбца, содержащего данную ячейку</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellWidth(System.UInt32)">
            <summary>Получение ширины ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <returns>Ширина ячейки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SetCellsProperties(System.UInt32,System.UInt32,TFlex.Model.Model2D.Table.CellProperties)">
            <summary>Установка параметров прямоугольного фрагмента таблицы</summary>
            <param name="cell1">Порядковый номер ячейки таблицы, которая лежит на концах диагонали прямоугольного фрагмента</param>
            <param name="cell2">Порядковый номер ячейки таблицы, которая лежит на концах диагонали прямоугольного фрагмента</param>
            <param name="props">Новые параметры прямоугольного фрагмента таблицы</param>
            <remarks>Курсор будет перемещён в начало левой верхней ячейки таблицы
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellsProperties(System.UInt32,System.UInt32)">
            <summary>Получение параметров прямоугольного фрагмента таблицы</summary>
            <param name="cell1">Порядковый номер ячейки таблицы, которая лежит на концах диагонали прямоугольного фрагмента</param>
            <param name="cell2">Порядковый номер ячейки таблицы, которая лежит на концах диагонали прямоугольного фрагмента</param>
            <returns>Параметры прямоугольного фрагмента таблицы</returns>
            <remarks>Курсор будет перемещён в начало левой верхней ячейки таблицы.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SetCellProperties(System.UInt32,TFlex.Model.Model2D.Table.CellProperties)">
            <summary>Установка параметров ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="props">Новые параметры ячейки таблицы</param>
            <remarks>Курсор будет перемещён в начало заданной ячейки таблицы.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.GetCellProperties(System.UInt32)">
            <summary>Получение параметров ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <returns>Параметры ячейки таблицы</returns>
            <remarks>Курсор будет перемещён в начало заданной ячейки таблицы.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Table.Properties">
            <summary>Параметры таблицы</summary>
            <remarks>При установке курсор будет перемещён в начало левой верхней ячейки таблицы.
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SplitCell(System.UInt32,System.UInt32,System.UInt32)">
            <summary>Разбивка ячейки на строки и столбцы</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="rows">Количество строк</param>
            <param name="columns">Количество столбцов</param>
            <remarks>После разбиения курсор будет перемещён в начало левой верхней ячейки (из образовавшихся), в которую так же будет перенесён весь текст разбиваемой ячейки
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.MergeCells">
            <summary>Объединение выделенных ячеек</summary>
            <remarks>После объединения курсор будет перемещён в начало образовавшейся ячейки
Текст ячеек, находящихся в выделенном фрагменте будет также объединён</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.MergeCells(System.UInt32,System.UInt32)">
            <summary>Объединение ячеек, лежащих в прямоугольном фрагменте, заданном диагональю</summary>
            <param name="cell1">Порядковый номер ячейки таблицы, которая лежит на концах диагонали прямоугольного фрагмента</param>
            <param name="cell2">Порядковый номер ячейки таблицы, которая лежит на концах диагонали прямоугольного фрагмента</param>
            <remarks>После объединения курсор будет перемещён в начало образовавшейся ячейки
Текст ячеек, находящихся во фрагменте будет также объединён
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SelectAll">
            <summary>Выделение всей таблицы</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SetSelection(System.UInt32,System.UInt32)">
            <summary>Выделение прямоугольного фрагмента таблицы по заданной диагонали</summary>
            <param name="cell1">Порядковый номер ячейки таблицы, которая лежат на концах диагонали выделяемого прямоугольного фрагмента</param>
            <param name="cell2">Порядковый номер ячейки таблицы, которая лежат на концах диагонали выделяемого прямоугольного фрагмента</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.Clear(System.UInt32)">
            <summary>Очистка одержимого ячейки</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.InsertText(System.UInt32,System.UInt32,System.String)">
            <summary>Вставка текста с использованием формата символа по умолчанию</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="position">Порядковый номер символа относительно начала ячейки, перед которым надо вставить текст</param>
            <param name="text">Текст</param>
            <remarks>После вставки курсор будет перемещён в конец вставленного текста
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.InsertText(System.UInt32,System.UInt32,System.String,TFlex.Model.Model2D.CharFormat)">
            <summary>Вставка текста с использованием заданного формата символов</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="position">Порядковый номер символа относительно начала ячейки, перед которым надо вставить текст</param>
            <param name="text">Текст</param>
            <param name="format">Формат символов</param>
            <remarks>После вставки курсор будет перемещён в конец вставленного текста
Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.SetCursorPosition(System.UInt32,System.UInt32)">
            <summary>Установка положения курсора</summary>
            <param name="cell">Порядковый номер ячейки таблицы</param>
            <param name="character">Порядковый номер символа относительно начала ячейки</param>
            <remarks>Параметры выделения фрагмента будут потеряны</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.DeleteRow(System.UInt32)">
            <summary>Удаление строки</summary>
            <param name="cell">Порядковый номер ячейки, находящейся в удаляемой строке</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.DeleteColumn(System.UInt32)">
            <summary>Удаление столбца</summary>
            <param name="cell">Порядковый номер ячейки, находящейся в удаляемом столбце</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.InsertRows(System.UInt32,System.UInt32,TFlex.Model.Model2D.Table.InsertProperties)">
            <summary>Вставка строк</summary>
            <param name="count">Количество строк</param>
            <param name="cell">Порядковый номер ячейки таблицы, находящейся в строке, относительно которой надо вставить новые строки</param>
            <param name="props">Параметр вставки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.InsertColumns(System.UInt32,System.UInt32,TFlex.Model.Model2D.Table.InsertProperties)">
            <summary>Вставка столбцов</summary>
            <param name="count">Количество столбцов</param>
            <param name="cell">Порядковый номер ячейки таблицы, находящейся в столбце, относительно которого надо вставить новые столбцы</param>
            <param name="props">Параметр вставки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Table.CellCount">
            <summary>Количество ячеек</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Table.RowCount">
            <summary>Количество строк. Если в таблице есть разбитые или объединённые ячейки возвращает -1</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Table.ColumnCount">
            <summary>Количество столбцов. Если в таблице есть разбитые или объединённые ячейки возвращает -1</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Table.IsRegular">
            <summary>Количество столбцов строк в таблице неизменно. Если в таблице есть разбитые или объединённые ячейки возвращает false</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.InsertProperties.After">
            <summary>Вставить после</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.InsertProperties.Before">
            <summary>Вставить перед</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.InsertProperties">
            <summary>Параметры вставки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.CellProperties.Initialize">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.CellFillColor">
            <summary>Цвет заливки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.FillCell">
            <summary>Заливка</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.Fields">
            <summary>Поля ячейки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.useDefaultFields">
            <summary>Использовать поля по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.TextDirection">
            <summary>Направление текста в ячейке таблицы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.CellTextVAlign">
            <summary>Вертикальное выравнивание текста в ячейке таблицы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.CellWidthMode">
            <summary>Режим высоты строки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.CellWidth">
            <summary>Ширина ячейки таблицы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.RowFromNewRect">
            <summary>Переносить строку в начало следующего прямоугольника</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.RowWrap">
            <summary>Перенос строк</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.RowHeightMode">
            <summary>Режим высоты строки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.RowHeight">
            <summary>Высота строк</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.DefaultBorderWidth">
            <summary>Толщина границ по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.DefaultBorderColor">
            <summary>Цвет границ по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.Borders">
            <summary>Границы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.DefaultFields">
            <summary>Поля ячеек по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.HalfCellSpace">
            <summary>Интервал ячеек</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.TableLeftOffset">
            <summary>Отступ слева</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CellProperties.TableHAlign">
            <summary>Горизонтальное выравнивание таблицы</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.CellProperties">
            <summary>Параметры ячейки таблицы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.Type">
            <summary>Тип</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.Width">
            <summary>Толщина</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.Color">
            <summary>Цвет</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.DefaultColor">
            <summary>Цвет по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.Visible">
            <summary>Видимость</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.BorderType.Right">
            <summary>Правая крайняя</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.BorderType.InternalHorizontal">
            <summary>Внутренняя горизонтальная</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.BorderType.Left">
            <summary>Левая крайняя</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.BorderType.Bottom">
            <summary>Нижняя крайняя</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.BorderType.InternalVertical">
            <summary>Внутренняя вертикальная</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.Border.BorderType.Top">
            <summary>Верхняя крайняя</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.Border.BorderType">
            <summary>Тип границы</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.Border">
            <summary>Границы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TextDirection.Overwinded">
            <summary>Перевёрнутый</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TextDirection.TopToBottom">
            <summary>Сверху вниз</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TextDirection.BottomToTop">
            <summary>Снизу вверх</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TextDirection.Normal">
            <summary>Нормальное (слева направо)</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.TextDirection">
            <summary>Направление текста</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TextVAlign.Bottom">
            <summary>По нижней границе</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TextVAlign.Center">
            <summary>По центру</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TextVAlign.Top">
            <summary>По верхней границе</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.TextVAlign">
            <summary>Вертикальное выравнивание текста в ячейке таблицы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TableHAlign.Right">
            <summary>По правому краю</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TableHAlign.Center">
            <summary>По центру</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.TableHAlign.Left">
            <summary>По левому краю</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.TableHAlign">
            <summary>Горизонтальное выравнивание таблицы</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.CreationSettings.#ctor(System.UInt32,System.UInt32,System.Double)">
            <summary>Конструктор</summary>
            <param name="c">Количество столбцов</param>
            <param name="r">Количество строк</param>
            <param name="w">Ширина столбцов</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Table.CreationSettings.#ctor(System.UInt32,System.UInt32)">
            <summary>Конструктор</summary>
            <param name="c">Количество столбцов</param>
            <param name="r">Количество строк</param>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CreationSettings.ColumnsWidth">
            <summary>Ширина столбцов (учитывается, если заданное значение больше нуля)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CreationSettings.Rows">
            <summary>Количество строк</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.CreationSettings.Columns">
            <summary>Количество столбцов</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.CreationSettings">
            <summary>Параметры создания таблицы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.VertHorParams.Horizontal">
            <summary>Горизонтальное значение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Table.VertHorParams.Vertical">
            <summary>Вертикальное значение</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table.VertHorParams">
            <summary>Значение, задаваемое по вертикали и по горизонтали</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Table">
            <summary>Класс для работы с таблицей</summary>
            <example>
                <code name="Изменение таблицы">
public static void CreateTable()
{
    Document document = TFlex.Application.ActiveDocument;
    document.BeginChanges("_");

    MultilineText mt = new MultilineText(document);
    mt.BeginEdit();
    mt.X = 100;
    mt.Y = 200;

    ParaFormat pt = mt.ParagraphFormat;
    pt.HorJustification =  ParaFormat.Just.Center;
    mt.ParagraphFormat = pt;

    mt.InsertText("Таблица штуцеров");
    mt.InsertCommonSymbol(CommonSymbol.LineBreak);

    Table.CreationSettings sett = new Table.CreationSettings(7, 2);
    Table table = mt.CreateTable(sett);

    Table.CellProperties prop = table.Properties;
    prop.TextDirection = Table.TextDirection.BottomToTop;
    prop.CellWidth = 20;
    prop.RowHeight = 50; 
    prop.RowHeightMode = SizeMode.Auto;
    prop.RowWrap = false;
    prop.CellTextVAlign = Table.TextVAlign.Center;
    prop.TableHAlign = Table.TableHAlign.Center;
    prop.HalfCellSpace.Horizontal = 0;
    prop.HalfCellSpace.Vertical = 0;

    table.SetCellHeight(0, 300, SizeMode.Exact);

    table.SetCellProperties(0, prop);
    table.InsertText(0, 0, "Обозначение");

    prop.TextDirection = Table.TextDirection.Normal;
    prop.CellWidth = 70;
    table.SetCellProperties(1, prop);
    table.InsertText(1, 0, "Назначение штуцеров");

    prop.CellWidth = 15;
    table.SetCellProperties(2, prop);
    table.InsertText(2, 0, "Кол.");

    table.SetCellProperties(3, prop);
    table.InsertText(3, 0, "DN, мм");
    table.InsertText(4, 0, "PN");

    prop.CellWidth = 34;
    table.SetCellProperties(6, prop);
    table.InsertText(6, 0, "Примечание");

    table.MergeCells(4, 5);

    table.MergeCells(0, 6);
    table.MergeCells(1, 6);
    table.MergeCells(2, 6);
    table.MergeCells(3, 6);
		
    prop.CellWidth = 20;
    table.SetCellProperties(6, prop);
    table.InsertText(6, 0, "МПа");

    table.SetCellProperties(7, prop);
    table.InsertText(7, 0, "кгc/с м");

    mt.InsertIndex("2", "");

    CharFormat cf =table.CharFormat;
    cf.VertOffset = 30;
    table.InsertText(7, 0, "2", cf);

    table.MergeCells(5, 8);

    mt.EndEdit();	
    document.EndChanges();
}
public static void GetTable()
{
Document document = TFlex.Application.ActiveDocument;
document.BeginChanges("_");

foreach(var n in document.GetObjects())
   {
       if (n is MultilineText)
       {
           MultilineText mt = (MultilineText)n;
           mt.BeginEdit();

           Table tbl = (Table)mt.GetFirstTable();
           Table.CellProperties prop = tbl.GetCellProperties(1);

		tbl.InsertRows(1, 7, Table.InsertProperties.After); 
		tbl.InsertText(8, 0, "1");

		tbl.InsertText(9, 0, "старый текст");
		mt.EndEdit();
		document.EndChanges();

		document.BeginChanges("_");
		MessageBox.Show("очистка ячейки");

		mt.BeginEdit();
		tbl.Clear(9);
		mt.EndEdit();
				
		document.EndChanges();

		document.BeginChanges("_");
		MessageBox.Show("вставка нового значения в ячейку");

		mt.BeginEdit();
		tbl.InsertText(9, 0, "новый текст");
		mt.EndEdit();
				
		document.EndChanges();
		break;
       }
   }

document.EndChanges();
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.Position.op_Implicit(System.Int32)~TFlex.Model.Model2D.Position">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Position.InTable">
            <summary>Получение информации о положении в таблице</summary>
            <returns>true, если положение в таблице задано</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Position.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Конструктор</summary>
            <param name="ch">Порядковый номер символа</param>
            <param name="tableIndex">Порядковый номер таблицы относительно начала текста</param>
            <param name="cellIndex">Порядковый номер ячейки таблицы</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Position.#ctor(System.Int32)">
            <summary>Конструктор</summary>
            <param name="ch">Порядковый номер символа</param>
        </member>
        <member name="F:TFlex.Model.Model2D.Position.Table">
            <summary>Положение курсора в таблице</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Position.Character">
            <summary>Порядковый номер символа</summary>
            <remarks>Если положение курсора в таблице заданно то рассматривается относительно начала ячейки таблицы. 
В противном случае - относительно начала текста.</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Position.TablePosition.#ctor(System.Int32,System.Int32)">
            <summary>Конструктор</summary>
            <param name="tableIndex">Порядковый номер таблицы относительно начала текста</param>
            <param name="cellIndex">Порядковый номер ячейки таблицы</param>
        </member>
        <member name="F:TFlex.Model.Model2D.Position.TablePosition.Cell">
            <summary>Порядковый номер ячейки таблицы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Position.TablePosition.Index">
            <summary>Порядковый номер таблицы относительно начала текста</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Position.TablePosition">
            <summary>Положение курсора в таблице</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Position">
            <summary>Положение курсора в тексте</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.ReduceExtension">
            <summary>Уменьшать расширение до заданного значения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.FitOneLine">
            <summary>Умещение абзаца в одной строке</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.NumberSuffix">
            <summary>Строка, добавляемая к цифре при нумерации</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.NumberFormat">
            <summary>Формат символов для цифр нумерации</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.NumProps">
            <summary>Параметры нумерации</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.Numbering">
            <summary>Нумерация</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.TabSize">
            <summary>Размер табуляции</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.TabsArray">
            <summary>Массив табуляций</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.LineSpaceMode">
            <summary>Режим размера междустрочного интервала</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.LineSpace">
            <summary>Междустрочный интервал</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.SpaceAfterLast">
            <summary>Интервал после последней строки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.SpaceBeforeFirst">
            <summary>Интервал перед первой строкой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.FirstLineOffset">
            <summary>Отступ первой строки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.RightIndent">
            <summary>Отступ справа </summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.LeftIndent">
            <summary>Отступ слева</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.HorJustification">
            <summary>Выравнивание текста по горизонтали</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.LineSpaceSizeMode.Scale">
            <summary>Множитель</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.LineSpaceSizeMode.Exact">
            <summary>Точно</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.LineSpaceSizeMode.Minimum">
            <summary>Минимум</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.LineSpaceSizeMode.Auto">
            <summary>Автоматически</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParaFormat.LineSpaceSizeMode">
            <summary>Режим размера междустрочного интервала</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.NumberingProps.Skip">
            <summary>Пропустить абзац</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.NumberingProps.Continue">
            <summary>Продолжить нумерацию (номер предыдущего абзаца + 1)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.NumberingProps.Normal">
            <summary>Нумерация начинается с заданного числа</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.NumberingProps.None">
            <summary>Нумерация отсутствует</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParaFormat.NumberingProps">
            <summary>Параметры нумерации</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.Just.Full">
            <summary>По ширине</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.Just.Right">
            <summary>По правому краю</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.Just.Center">
            <summary>По центру</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ParaFormat.Just.Left">
            <summary>По левому краю</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParaFormat.Just">
            <summary>Выравнивание текста по горизонтали</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ParaFormat.Tabs.Count">
            <summary>Количество табуляций</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ParaFormat.Tabs.SetItem(System.Double,System.Int32)">
            <summary>Измененеие значения табуляции</summary>
            <param name="value">Значение</param>
            <param name="idx">Индекс табуляции</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ParaFormat.Tabs.GetItem(System.Int32)">
            <summary>Получение значения табуляции по её порядковому номеру в массиве</summary>
            <param name="idx">Индекс табуляции</param>
            <returns>Значение табуляций</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.ParaFormat.Tabs.Erase">
            <summary>Очистка массива табуляций</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ParaFormat.Tabs.Delete(System.Int32)">
            <summary>Удаление табуляции из массива по индексу</summary>
            <param name="idx">Индекс табуляции</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ParaFormat.Tabs.Add(System.Double)">
            <summary>Добавление новой табуляции</summary>
            <param name="value">Значение</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ParaFormat.Tabs.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParaFormat.Tabs">
            <summary>Массив табуляций</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ParaFormat">
            <summary>Формат абзаца</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ColumnSizeMode">
            <summary>Режим задания ширины столбца</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ColumnSizeMode.Minimum">
            <summary>Минимум</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ColumnSizeMode.Exact">
            <summary>Точно</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.SizeMode">
            <summary>Режим размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SizeMode.Exact">
            <summary>Точно</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SizeMode.Minimum">
            <summary>Минимум</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SizeMode.Auto">
            <summary>Автоматически</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.DefaultExtension">
            <summary>Расширение по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.Extension">
            <summary>Коэффициент расширения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.hasBorder">
            <summary>Рамка</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.VertOffset">
            <summary>Вертикальное смещение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.FontName">
            <summary>Имя шрифта</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.isDefaultItalic">
            <summary>Курсив по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.isDefaultBold">
            <summary>Полужирный по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.DefaultFontSize">
            <summary>Использование размера по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.DefaultColor">
            <summary>Использование цвета по умолчанию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.Color">
            <summary>Цвет</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.Space">
            <summary>Интервал символов</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.FontSize">
            <summary>Размер</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.isStrikeout">
            <summary>Зачеркнутый</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.isUnderline">
            <summary>Подчеркнутый</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.isItalic">
            <summary>Курсив</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CharFormat.isBold">
            <summary>Полужирный</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CharFormat">
            <summary>Формат символа</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyText.Transformation">
            <summary>Преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyText.SourceCopyOperation">
            <summary>Исходный объект-копия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyText.Source">
            <summary>Исходный текст</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyText.SubType">
            <summary>Подтип текста</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CopyText">
            <summary>Класс строчного текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.VerticalAlignment">
            <summary>Вертикальное выравнивание текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.HorizontalAlignment">
            <summary>Горизонтальное выравнивание текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.Symmetric">
            <summary>Признак симметричности текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.Circle">
            <summary>Окружность привязки текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.Line">
            <summary>Прямая привязки текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.Angle">
            <summary>Угол поворота текста в градусах</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.TextValue">
            <summary>Строка (строки) текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.AbsY">
            <summary>Координата Y</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.AbsX">
            <summary>Координата X</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.Node">
            <summary>Узел привязки текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.Y">
            <summary>Координата Y или смещение Y относительно узла привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.X">
            <summary>Координата X или смещение X относительно узла привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineText.SubType">
            <summary>Подтип текста</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LineText.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового строчного текста</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LineText">
            <summary>Класс строчного текста</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.TextVerticalAlignment">
            <summary>Выравнивание текста по вертикали</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextVerticalAlignment.Top">
            <summary>По верхней границе текста</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextVerticalAlignment.UpperLine">
            <summary>По вершине заглавной буквы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextVerticalAlignment.Center">
            <summary>По центру</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextVerticalAlignment.BaseLine">
            <summary>По основанию заглавной буквы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextVerticalAlignment.Bottom">
            <summary>По нижней границе текста</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.TextHorizontalAlignment">
            <summary>Выравнивание текста по горизонтали</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextHorizontalAlignment.Right">
            <summary>По правому краю</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextHorizontalAlignment.Center">
            <summary>По центру</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextHorizontalAlignment.Left">
            <summary>По левому краю</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Text.FontStyle">
            <summary>Стиль шрифта текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Text.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Text.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Text.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Text.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Text.SubType">
            <summary>Подтип текста</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Text.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Text.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Text">
            <summary>Базовый класс текста</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.TextType">
            <summary>Способы задания текста</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextType.CopyText">
            <summary>Ассоциативная копия текста</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextType.BomText">
            <summary>Спецификация</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextType.ParagraphText">
            <summary>Параграф текст</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextType.MultilineText">
            <summary>Многострочный текст</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextType.LineText">
            <summary>Строчный текст</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.TextType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:TFlex.Model.Diagnostics.Add(TFlex.Model.DiagnosticsMessage)">
            <summary>Добавить сообщение</summary>
            <param name="message">Добавляемое сообщение</param>
        </member>
        <member name="M:TFlex.Model.Diagnostics.Enable(System.Boolean)">
            <summary>Разрешить или запретить добавление сообщений в контейнер.</summary>
            <param name="enable">true, если необходимо разрешить выдачу сообщений; false в случае запрета</param>
            <returns>Значение параметра, которое было установлено до вызова данного метода</returns>
            <remarks>В некоторых случаях полезно запретить вывод сообщений в окно диагностики системы.
С этой целью можно воспользоваться данным методом. После завершения действий,
связанных с данным запретом, необходимо установить данный параметр в значение, которое он имел до этого.</remarks>
        </member>
        <member name="M:TFlex.Model.Diagnostics.EndGroup">
            <summary>Закрыть группу сообщений</summary>
            <remarks>Этот метод закрывает группу сообщений, открытых с помощью метода <see cref="M:TFlex.Model.Diagnostics.StartGroup" />.</remarks>
        </member>
        <member name="M:TFlex.Model.Diagnostics.StartGroup">
            <summary>Открыть группу сообщений</summary>
            <remarks>Для того, чтобы избежать множества звуковых сигналов об ошибках,
в системе введено понятие "группы сообщений". Звуковой сигнал об ошибке выдаётся один раз внутри группы сообщений.
открытую группу сообщений необходимо закрыть при помощи метода <see cref="M:TFlex.Model.Diagnostics.EndGroup" />. Группы могут быть вложенными.</remarks>
        </member>
        <member name="M:TFlex.Model.Diagnostics.RemoveAll">
            <summary>Удалить все сообщения контейнера</summary>
        </member>
        <member name="T:TFlex.Model.Diagnostics">
            <summary>Класс контейнера диагностических сообщений документа</summary>
        </member>
        <member name="P:TFlex.Model.DiagnosticsMessage.Object">
            <summary>Объект, связанный с сообщением</summary>
        </member>
        <member name="P:TFlex.Model.DiagnosticsMessage.Message">
            <summary>Содержание сообщения</summary>
        </member>
        <member name="P:TFlex.Model.DiagnosticsMessage.Type">
            <summary>Тип сообщения</summary>
        </member>
        <member name="M:TFlex.Model.DiagnosticsMessage.#ctor(TFlex.Model.DiagnosticsMessageType,System.String,TFlex.Model.ModelObject)">
            <summary>Конструктор</summary>
            <param name="type">Тип сообщения</param>
            <param name="message">Содержание сообщения</param>
            <param name="object">Объект, связанный с сообщением</param>
        </member>
        <member name="M:TFlex.Model.DiagnosticsMessage.#ctor(TFlex.Model.DiagnosticsMessageType,System.String)">
            <summary>Конструктор</summary>
            <param name="type">Тип сообщения</param>
            <param name="message">Содержание сообщения</param>
        </member>
        <member name="T:TFlex.Model.DiagnosticsMessage">
            <summary>Класс сообщения, добавляемого в контейнер диагноситики документа</summary>
        </member>
        <member name="T:TFlex.Model.DiagnosticsMessageType">
            <summary>Перечилситель типов диагностических сообщений</summary>
        </member>
        <member name="F:TFlex.Model.DiagnosticsMessageType.Information">
            <summary>Информационное сообщение</summary>
        </member>
        <member name="F:TFlex.Model.DiagnosticsMessageType.Warning">
            <summary>Предупреждение</summary>
        </member>
        <member name="F:TFlex.Model.DiagnosticsMessageType.FileError">
            <summary>Ошибка при работе с файлом</summary>
        </member>
        <member name="F:TFlex.Model.DiagnosticsMessageType.Error">
            <summary>Ошибка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ExternalObject.Layer">
            <summary>Слой</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ExternalObject.Priority">
            <summary>Приоритет</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ExternalObject.Level">
            <summary>Уровень</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ExternalObject.Color">
            <summary>Цвет</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ExternalObject.Page">
            <summary>Страница</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.ExternalObject.ResetPlugin(TFlex.Plugin,System.Int32)">
            <summary>Перезадать приложение, определяющее промежуточный (прокси-) объект</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ProxyObject2D.TransformContext.ReturnIgnore">
            <summary>Трансформация запрещена</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ProxyObject2D.TransformContext.ReturnOK">
            <summary>Трансформация возможна</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ProxyObject2D.TransformContext.Map">
            <summary>Афинное преобразование трансформации</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ProxyObject2D.TransformContext">
            <summary>Класс трансформации прокси объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ProxyObject2D.Owner2D">
            <summary>2D владелец прокси объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ProxyObject2D.#ctor(System.IntPtr)">
            <summary>Конструктор, принимающий родительский объект</summary>
            <param name="OwnerHandle" />
        </member>
        <member name="M:TFlex.Model.Model2D.ProxyObject2D.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ProxyObject2D">
            <summary>Класс 2D прокси объекта</summary>
        </member>
        <member name="M:TFlex.Model.ProxyObject.GetMarkObjects">
            <summary>Получить список дополнительных объектов для пометки при выборе</summary>
        </member>
        <member name="M:TFlex.Model.ProxyObject.AddDiagnosticsMessage(TFlex.Model.DiagnosticsMessage)">
            <summary>Добавить диагностическое сообщение. Надо вызывать из Draw</summary>
            <param name="message">Сообщение</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.GetTextProp(System.String)">
            <summary>Получить значение текстового свойства по имени</summary>
            <param name="name">Имя свойства</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.GetRealProp(System.String)">
            <summary>Получить значение свойства с действительным значением по имени</summary>
            <param name="name">Имя свойства</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.GetPropList(TFlex.Model.PropertyArray)">
            <summary>Получить массив свойств</summary>
            <param name="Array">Ссылка на массив</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.OnCommand(System.Int32,TFlex.Model.View)">
            <summary>Метод для обработки команд контекстного меню</summary>
            <param name="commandID">Идентификатор команды объекта</param>
            <param name="view">Вид документа</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.GetContextMenu(TFlex.Menu)">
            <summary>Метод вызывается при вызове контекстного меню прокси объекта</summary>
            <param name="Menu">Контекстное меню</param>
            <remarks>В реализации данного метода можно добавить или удалить команды</remarks>
        </member>
        <member name="M:TFlex.Model.ProxyObject.GetNode(System.Int32,System.Double@,System.Double@)">
            <summary>Получить координаты узла привязки по ID</summary>
            <param name="id">ID узла</param>
            <param name="x">Координата x узла</param>
            <param name="y">Координата y узла</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.GetNodeID(System.Int32)">
            <summary>Получить идентификатор узла по номеру</summary>
            <param name="Number">Номер узла модели</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.GetNodeCount">
            <summary>Получить количество узлов в модели</summary>
        </member>
        <member name="M:TFlex.Model.ProxyObject.EditProperties">
            <summary>Метод для редактирования свойств прокси объекта</summary>
            <returns>Результат изменения свойств прокси объекта</returns>
        </member>
        <member name="F:TFlex.Model.ProxyObject.PropertyChange.ChangeMaterial">
            <summary>Изменить материал</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.PropertyChange.ChangeTree">
            <summary>Изменить дерево</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.PropertyChange.Regenerate">
            <summary>Пересчитать модель</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.PropertyChange.ReloadInScene">
            <summary>Загрузить в сцену</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.PropertyChange.UpdateScene">
            <summary>Обновить сцену</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.PropertyChange.WeakChange">
            <summary>Незначительные изменения</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.PropertyChange.Nothing">
            <summary>Ничего не делать</summary>
        </member>
        <member name="T:TFlex.Model.ProxyObject.PropertyChange">
            <summary>Перечислитель действий при изменении свойств прокси объекта</summary>
        </member>
        <member name="M:TFlex.Model.ProxyObject.Edit(TFlex.Model.View)">
            <summary>Виртуальный метод изменения прокси объекта</summary>
            <param name="View">Вид</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.OnUndoAction(TFlex.Model.ProxyObject.UndoActionType)">
            <summary>Обработчик события отмены</summary>
            <param name="type">Тип отмены</param>
        </member>
        <member name="F:TFlex.Model.ProxyObject.UndoActionType.Erased">
            <summary>Стёрт</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.UndoActionType.Shown">
            <summary>Показан</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.UndoActionType.Deleted">
            <summary>Удалён</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.UndoActionType.Created">
            <summary>Создан</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.UndoActionType.Changed">
            <summary>Изменён</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObject.UndoActionType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="T:TFlex.Model.ProxyObject.UndoActionType">
            <summary>Тип отменяющего действия</summary>
        </member>
        <member name="M:TFlex.Model.ProxyObject.OnDelete">
            <summary>Событие возникающее при удалении прокси объекта</summary>
        </member>
        <member name="M:TFlex.Model.ProxyObject.Draw(TFlex.Model.ProxyObjectDrawContext)">
            <summary>Метод для прорисовки объекта</summary>
            <param name="context">Объект класса <see cref="T:TFlex.Model.ProxyObjectDrawContext" /></param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.Draw(TFlex.Drawing.Graphics)">
            <summary>Метод для прорисовки объекта</summary>
            <param name="graphics">Объект класса <see cref="T:TFlex.Drawing.Graphics" /></param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.IsReallyChanged">
            <summary>изменился ли в действительности прокси объект</summary>
        </member>
        <member name="M:TFlex.Model.ProxyObject.Write(System.IO.Stream)">
            <summary>Метод для записи данных прокси объекта в файл</summary>
            <param name="stream">Поток в который происходит запись данных</param>
        </member>
        <member name="M:TFlex.Model.ProxyObject.Read(System.IO.Stream,System.Int32)">
            <summary>Метод для считывания данных прокси объекта из файла</summary>
            <param name="stream">Поток из которого происходит считывание данных</param>
            <param name="Version">Версия объекта, на момент сохранения объекта в файл</param>
        </member>
        <member name="P:TFlex.Model.ProxyObject.Version">
            <summary>Версия прокси объекта</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObject.IconID">
            <summary>Идентификатор иконки прокси объекта</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObject.IsAlwaysDrawing">
            <summary>Отключить кэширование рисования</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObject.IsConstruction">
            <summary>Определить прокси объект как элемент построения</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObject.TypeName">
            <summary>Имя типа объекта</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObject.TypeID">
            <summary>Идентификатор типа объекта</summary>
            <remarks>Тип объекта является уникальным в пределах приложения и не должен меняться. В соответствии с типом, система вызывает метод <see cref="M:TFlex.Plugin.CreateObject(TFlex.Model.Document,System.IntPtr,System.Int32)" /> для создания 
прокси объекта при чтении файла, выполнении отмены действий и т.д.</remarks>
        </member>
        <member name="M:TFlex.Model.ProxyObject.Equals(TFlex.Model.ProxyObject)">
            <summary>Метод выполняет сравнение прокси объекта <see cref="T:TFlex.Model.ProxyObject" /> с исходным</summary>
            <param name="object">Прокси объект, с которым сравнивает текущий прокси объект</param>
            <returns>true, если объекты одинаковы, в противном случае false</returns>
        </member>
        <member name="M:TFlex.Model.ProxyObject.Clone(System.IntPtr)">
            <summary>Метод создает неполную копию прокси объекта</summary>
            <param name="OwnerHandle" />
            <returns>Новый прокси объект, который является неполной копией текущего</returns>
        </member>
        <member name="P:TFlex.Model.ProxyObject.Plugin">
            <summary>Приложение, определяющее промежуточный (прокси-) объект</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObject.Owner">
            <summary>Владелец объекта</summary>
        </member>
        <member name="M:TFlex.Model.ProxyObject.#ctor(System.IntPtr)">
            <summary>Конструктор, принимающий родительский объект</summary>
            <param name="OwnerHandle" />
        </member>
        <member name="M:TFlex.Model.ProxyObject.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.ProxyObject">
            <summary>Класс прокси объекта</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObjectDrawContext.AssemblyContext">
            <summary>Стек документов сборки от корневой до текущего документа фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObjectDrawContext.DrawingView">
            <summary>Чертёжный вид, в контексте которого отображается документ с прокси объектом</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObjectDrawContext.FragmentType.EditingFragment">
            <summary>Фрагмент в режиме редактирования</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObjectDrawContext.FragmentType.CreatingFragment">
            <summary>Фрагмент в режиме создания</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObjectDrawContext.FragmentType.Fragment">
            <summary>Фрагмент модели</summary>
        </member>
        <member name="F:TFlex.Model.ProxyObjectDrawContext.FragmentType.NotFragment">
            <summary>Не фрагмент</summary>
        </member>
        <member name="T:TFlex.Model.ProxyObjectDrawContext.FragmentType">
            <summary>Режим документа прокси объекта</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObjectDrawContext.Fragment">
            <summary>Фрагмент, в контексте которого отображается документ с прокси объектом</summary>
        </member>
        <member name="P:TFlex.Model.ProxyObjectDrawContext.Graphics">
            <summary>Графический контекст</summary>
        </member>
        <member name="T:TFlex.Model.ProxyObjectDrawContext">
            <summary>Контекст отображения прокси объекта</summary>
        </member>
        <member name="M:TFlex.Model.PropertyArray.Add(System.String,System.String,TFlex.Model.PropertyArray.Type,System.Int32)">
            <summary>Добавить свойство в массив свойств</summary>
            <param name="Name">Имя свойства</param>
            <param name="Description">Описание свойства</param>
            <param name="TypeID">ID типа свойства</param>
            <param name="ClassID">ID класса</param>
        </member>
        <member name="M:TFlex.Model.PropertyArray.Add(System.String,System.String,TFlex.Model.PropertyArray.Type)">
            <summary>Добавить свойство в массив свойств</summary>
            <param name="Name">Имя свойства</param>
            <param name="Description">Описание свойства</param>
            <param name="TypeID">ID типа свойства</param>
        </member>
        <member name="F:TFlex.Model.PropertyArray.Type.Text">
            <summary>Текстовый </summary>
        </member>
        <member name="F:TFlex.Model.PropertyArray.Type.Real">
            <summary>Действительный </summary>
        </member>
        <member name="F:TFlex.Model.PropertyArray.Type.Int">
            <summary>Целый </summary>
        </member>
        <member name="T:TFlex.Model.PropertyArray.Type">
            <summary>Тип переменной </summary>
        </member>
        <member name="P:TFlex.Model.PropertyArray.Reason">
            <summary>Тип свойства</summary>
        </member>
        <member name="F:TFlex.Model.PropertyArray.ReasonType.Properties">
            <summary>Свойства</summary>
        </member>
        <member name="F:TFlex.Model.PropertyArray.ReasonType.Measure">
            <summary>Измерение </summary>
        </member>
        <member name="F:TFlex.Model.PropertyArray.ReasonType.Undefined">
            <summary>Неопределённый </summary>
        </member>
        <member name="T:TFlex.Model.PropertyArray.ReasonType">
            <summary>Тип свойств</summary>
        </member>
        <member name="T:TFlex.Model.PropertyArray">
            <summary>Класс свойств прокси объекта</summary>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.RemoveAll">
            <summary>Удаляет все кнопки из этого набора</summary>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.Remove(System.Int32,TFlex.Plugin)">
            <summary>Удаляет указанную кнопку из этого набора</summary>
            <param name="commandId">Идентификатор команды приложения</param>
            <param name="plugin">Объект приложения</param>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.Remove(System.Int32)">
            <summary>Удаляет из этого набора кнопку с указанным идентификатором</summary>
            <param name="id">Идентификатор кнопки</param>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.Add(System.Int32,System.Boolean,TFlex.Plugin)">
            <summary>Добавляет в этот набор кнопку вызова указанной команды</summary>
            <param name="commandId">Идентификатор команды приложения</param>
            <param name="required">true, если кнопка всегда должна отображаться в панели; false, если
    допускается расположение кнопки в расширенном меню</param>
            <param name="plugin">Объект приложения</param>
            <returns>true, если кнопка была добавлена в этот набор; false, если указанный идентификатор
    команды недействителен или используется одной из кнопок, уже имеющихся в этом наборе</returns>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.Add(System.Int32,System.Boolean)">
            <summary>Добавляет в этот набор кнопку с указанными параметрами</summary>
            <param name="id">Идентификатор кнопки</param>
            <param name="required">true, если кнопка всегда должна отображаться в панели; false, если
    допускается расположение кнопки в расширенном меню</param>
            <returns>true, если кнопка была добавлена в этот набор; false, если указанный идентификатор
    некорректен или используется одной из кнопок, уже имеющихся в этом наборе</returns>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.Add(System.Int32,TFlex.Plugin)">
            <summary>Добавляет в этот набор кнопку вызова указанной команды</summary>
            <param name="commandId">Идентификатор команды приложения</param>
            <param name="plugin">Объект приложения</param>
            <returns>true, если кнопка была добавлена в этот набор; false, если указанный идентификатор
    команды недействителен или используется одной из кнопок, уже имеющихся в этом наборе</returns>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.Add(System.Int32)">
            <summary>Добавляет в этот набор кнопку с указанным идентификатором</summary>
            <param name="id">Идентификатор кнопки</param>
            <returns>true, если кнопка была добавлена в этот набор; false, если указанный идентификатор
    недействителен или используется одной из кнопок, уже имеющихся в этом наборе</returns>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.Contains(System.Int32,TFlex.Plugin)">
            <summary>Определяет, есть в этом наборе указанная кнопка или нет</summary>
            <param name="commandId">Идентификатор команды приложения</param>
            <param name="plugin">Объект приложения</param>
            <returns>true, если этот набор содержит кнопку вызова указанной команды, иначе false</returns>
        </member>
        <member name="M:TFlex.PopupToolBarButtonSet.Contains(System.Int32)">
            <summary>Определяет, есть в этом наборе указанная кнопка или нет</summary>
            <param name="id">Идентификатор кнопки</param>
            <returns>true, если этот набор содержит кнопку с указанным идентификатором, иначе false</returns>
        </member>
        <member name="T:TFlex.PopupToolBarButtonSet">
            <summary>Набор кнопок, отображаемых в динамической панели</summary>
        </member>
        <member name="M:filtering.Filter.Parse(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,filtering.Term!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Перобразовывает заданное строковое представление фильтра в эквивалентный ему объект фильтра</summary>
            <param name="str">Строковое представление фильтра</param>
            <param name="templateTerm">шаблон выражения</param>
            <returns>Фильтр, эквивалентный указанному строковому представлению</returns>
        </member>
        <member name="M:filtering.Filter.ToString">
            <summary>Возвращает строковое представление фильтра</summary>
            <returns>Строковое представление фильтра</returns>
        </member>
        <member name="M:filtering.Filter.Match(filtering.IFilteringObject*)">
            <summary>Возвращает значение, указывающее, соответствует ли указанный объект условиям фильтра</summary>
            <param name="pObject">Объект для проверки</param>
            <returns>Значение true, если объект соответствует условиям фильтра; в противном случае - значение false</returns>
        </member>
        <member name="M:filtering.Filter.IsValid">
            <summary>Возвращает значение, указывающее, является ли фильтр допустимым</summary>
            <returns>Значение true, если фильтр является допустимым; в противном случае - значение false</returns>
        </member>
        <member name="M:filtering.Filter.GetTerms">
            <summary>Возвращает корневую группу условий фильтра</summary>
        </member>
        <member name="M:filtering.TermGroup.RemoveItemAt(System.Int32)">
            <summary>Удаляет из текущей группы условий элемент с указанным индексом</summary>
            <param name="index">Индекс элемента в группе</param>
        </member>
        <member name="M:filtering.TermGroup.Insert(System.Int32,filtering.TermGroupItem*)">
            <summary>Добавляет в текущую группу условий указанный элемент по заданному индексу</summary>
            <param name="index">Индекс, по которому следует вставить элемент</param>
            <param name="pItem">Элемент, добавляемый в группу условий</param>
        </member>
        <member name="M:filtering.TermGroup.ToString">
            <summary>Возвращает строковое представление группы условий</summary>
            <returns>Строковое представление группы условий</returns>
        </member>
        <member name="M:filtering.TermGroup.Match(filtering.IFilteringObject*)">
            <summary>Возвращает значение, указывающее, соответствует ли указанный объект условиям группы</summary>
            <param name="pObject">Объект для проверки</param>
            <returns>Значение true, если объект соответствует условиям группы; в противном случае - значение false</returns>
        </member>
        <member name="M:filtering.TermGroup.AsGroup">
            <summary>Приводит текущий объект к типу <see cref="T:filtering.TermGroup" /></summary>
        </member>
        <member name="M:filtering.TermGroup.RemoveErrorItems(System.Boolean)">
            <summary>Удаляет из текущей группы элементы, которые находятся в ошибочном состоянии</summary>
            <param name="recursive">Значение true, если требуется удалять элементы в дочерних группах; в противном случае - значение false</param>
        </member>
        <member name="M:filtering.TermGroup.RemoveEmptyGroups(System.Boolean)">
            <summary>Удаляет из текущей группы элементы, которые являются пустыми группами</summary>
            <param name="recursive">Значение true, если требуется удалять элементы в дочерних группах; в противном случае - значение false</param>
        </member>
        <member name="M:filtering.TermGroup.AddGroup(filtering.LogicalOperator)">
            <summary>Добавляет дочернюю группу условий в текущую группу</summary>
            <param name="logicalOperator">Логический оператор</param>
            <returns>Добавленная группа условий</returns>
        </member>
        <member name="M:filtering.TermGroupItem.Match(filtering.IFilteringObject*)">
            <summary>Возвращает значение, указывающее, соответствует ли указанный объект условиям текущего элемента</summary>
            <param name="pObject">объект для проверки</param>
            <returns>Значение true, если объект соответствует условиям текущего элемента; в противном случае - значение false</returns>
        </member>
        <member name="M:filtering.TermGroupItem.IsError">
            <summary>Возвращает значение, указывающее, находится ли элемент в ошибочном состоянии</summary>
        </member>
        <member name="M:filtering.TermGroupItem.GetLogicalOperator">
            <summary>Логический оператор, которым текущий элемент соединяется с предыдущим элементом в группе условий</summary>
        </member>
        <member name="M:filtering.TermGroupItem.IsTerm">
            <summary>Возвращает значение, указывающее, является ли текущий элемент условием</summary>
        </member>
        <member name="M:filtering.TermGroupItem.AsTerm">
            <summary>Преобразует текущий элемент к типу <see cref="T:filtering.Term" /> (если он является условием)</summary>
        </member>
        <member name="M:filtering.TermGroupItem.IsGroup">
            <summary>Возвращает значение, указывающее, является ли текущий элемент группой условий</summary>
        </member>
        <member name="M:filtering.TermGroupItem.AsGroup">
            <summary>Приводит текущий элемент к типу <see cref="T:filtering.TermGroup" /> (если он является группой условий)</summary>
        </member>
        <member name="T:CFragmentEngine2D">
Класс для хранения связи с 3D-фрагментом, если 2D-фрагмент читается в 2D-версии
</member>
        <member name="M:CFragmentEngine.CanAssignCoordsFromBinding">
Если привязка 3D фрагмента задаётся в 3D, то координаты точек привязки на 2D игнорируются
</member>
        <member name="M:CFragmentEngine.AssignCoordsFromBinding(TFDocRegenContext*,CFragment*)">
В настоящий момент возвращаются точки, задающие целевую систему координат
Сама целевая система может быть агрегирована в преобразование 3D фрагмента или быть объектом сборочной модели
</member>
        <member name="M:CFragmentEngine.GetBindingParents(CParentsArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Существуют внешние переменные, значения которых задаются параметрами объектов, задающих положение 3D фрагмента в сборке
{
В этом случае 2D фрагмент в режиме 3D пересчета должен пересчитываться после пересчета объектов, задающих положение 3D фрагмента в сборке
</member>
        <member name="M:CFragmentEngine.Is3DTransform">
Преобразование задаётся в 3D. У планировки нет совего дополнительного преобразования
</member>
        <member name="M:CFragmentEngine.OnPlaneMovement(TFDocRegenContext*,CFragment*,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Дополнительное перемещение 3D фрагмента задаётся 2D преобразованием системы координат страницы рабочей плоскости планировки
В этом случае метод возвращает проекцию точки системы координат на плоскость планировки
</member>
        <member name="M:CFragmentEngine.TransformFragment(TFDocRegenContext*,FRAGMENT*,System.Double,System.Double,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Перемещение фрагмента
Метод редактирует порядок планировок при расчете положения Фрагмента и изменяет дополнительные преобразования в случае несобственных перемещений
Метод возвращает true, если был открыт undo-блок
</member>
        <member name="M:CFragmentEngine.RepositionFragment(TFDocRegenContext*,FRAGMENT*,CEditFragment*)">
Метод редактирует порядок планировок при расчете положения Фрагмента и изменяет дополнительные преобразования в случае несобственных перемещений
Метод возвращает true, если был открыт undo-блок
</member>
        <member name="T:CTFSelectedEntitySorted">
Выбор отдельных сегментов проекционного фрагмента
</member>
        <member name="M:CFragmentEngine.DegreesOfFreedom(TFDocRegenContext*,FRAGMENT!System.Runtime.CompilerServices.IsConst*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="M:CFragmentEngine.Draw(FRAGMENT*,TFGC*,TFDocRegenContext*)">
true - если 2D-фрагмент рисуется средствами аггрегированной проекции
false - 2D-фрагмент рисуется базовыми средствами рисования 2D-фрагментов
</member>
        <member name="M:CFragmentEngine.ReplaceParent(ReplaceParentStruct*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Расчет координат вектора привязки на 2D, если задан вектор и рабочая плоскость фрагмента при вставке в сборку параллельна рабочей плоскости сборки
</member>
        <member name="F:FailedFragmentUsedIn3DOnly">
- нет доступа к 3D-фрагменту. Например, документ открыт в режиме чтения только 2D-данных;
- это 3D-картинка, у которой нет информации о сборке;
- у 3D фрагмента нет информации о сборке. Например, фрагмент в момент его создания ещё не пересчитан
</member>
        <member name="T:CFragmentEngine.AssemblyNodeResult">
Результат получения корневого узла
</member>
        <member name="T:CFragmentEngine">
Базовый класс для управления набором связанных проекционной связью 2D-фрагментов
</member>
        <member name="T:Layout.WayToMove">
Способ перемещения
</member>
        <member name="T:Layout.RestrictionOnTheWayToMove">
Ограничение на способ перемещения
</member>
        <member name="T:Layout.FixingMode">
Способ проецирования
</member>
        <member name="M:CEditFragment.DegreesOfFreedom(TFDocRegenContext*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="M:CEditFragment.Get3DFragment">
Методы для работы с планировками
</member>
        <member name="M:CEditFragment.StoreFixingCoordinates">
В документе фрагмента собирается и кешируется информация о всех векторах привязки
</member>
        <member name="M:TFlex.Model.ObjectId.Create(System.UInt64)">
            <summary>Возвращает новый ObjectId, если idData корректный. Иначе возвращает null.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.Create(System.UInt32)">
            <summary>Возвращает новый ObjectId, если oldID корректный. Иначе возвращает null.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.TryParse(System.String,TFlex.Model.ObjectId@)">
            <summary>Распарсить строку в ObjectId. Вернет false, если строка некорректна.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.TryParse(System.String)">
            <summary>Распарсить строку в ObjectId. Вернет null, если строка некорректна.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.Parse(System.String)">
            <summary>Распарсить строку в ObjectId. Выбросит исключение ArgumentException, если строка некорректна.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.ToString">
            <summary>Возвращает строку, представляющую текущий объект.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.Equals(System.Object)">
            <summary>Определяет, равны ли два экземпляра объекта.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.GetHashCode">
            <summary>Служит хэш-функцией по умолчанию.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.Clone">
            <summary>Создает новый объект, являющийся копией текущего экземпляра.</summary>
        </member>
        <member name="M:TFlex.Model.ObjectId.CompareTo(System.Object)">
            <summary>Сравнивает текущий экземпляр с другим объектом того же типа и возвращает целое число, которое показывает, расположен ли текущий экземпляр перед, после или на той же позиции в порядке сортировки, что и другой объект.</summary>
            <param name="obj">Объект для сравнения с данным экземпляром. </param>
        </member>
        <member name="P:TFlex.Model.ObjectId.IsValid">
            <summary>Является ли идентификатор корректным</summary>
        </member>
        <member name="T:TFlex.Model.ObjectId">
            <summary>Класс идентификации объектов ModelObject</summary>
        </member>
        <member name="P:TFlex.Model.DeepFragmentVariableValue.TextValue">
            <summary>Текстовое значение переменной</summary>
        </member>
        <member name="P:TFlex.Model.DeepFragmentVariableValue.RealValue">
            <summary>Вещественное значение переменной</summary>
        </member>
        <member name="P:TFlex.Model.DeepFragmentVariableValue.IsText">
            <summary>Проверка, является ли переменная текстовой</summary>
        </member>
        <member name="P:TFlex.Model.DeepFragmentVariableValue.IsReal">
            <summary>Проверка, является ли переменная вещественной</summary>
        </member>
        <member name="P:TFlex.Model.DeepFragmentVariableValue.Name">
            <summary>Имя переменной</summary>
        </member>
        <member name="T:TFlex.Model.DeepFragmentVariableValue">
            <summary>Класс предназначенный для задания значения переменной фрагмента чере уровень</summary>
        </member>
        <member name="M:TFlex.Model.FragmentVariables.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.FragmentVariables">
            <summary>Класс контейнера переменных фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.FragmentVariableValue.GetValueList">
            <summary>Получить список значений, которые может принимать переменная, если он задан</summary>
        </member>
        <member name="M:TFlex.Model.FragmentVariableValue.SetValueFromConnector">
            <summary>Установка значения переменной в соотвествии со значением этой переменной в коннекторе,
использованном для привязки фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.IsValueFromConnector">
            <summary>Установлено ли значение переменной в соответствии со значением этой переменной в коннекторе</summary>
        </member>
        <member name="M:TFlex.Model.FragmentVariableValue.SetDefaultValue">
            <summary>Установка значения переменной по умолчанию,
на основе значения этой переменной внутри документа фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.IsSet">
            <summary>Задано ли значение переменной.
Если значение не задано, то оно определяется значением переменной внутри документа фрагмента.</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.AttachedNode">
            <summary>Узел сборки, связанный с внешней переменной</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.AttachedVariable">
            <summary>Выражение для внешней переменной</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.OriginalTextValue">
            <summary>Текстовое значение переменной из документа фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.OriginalRealValue">
            <summary>Вещественное значение переменной из документа фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.TextValue">
            <summary>Текстовое значение переменной</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.RealValue">
            <summary>Вещественное значение переменной</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.IsText">
            <summary>Проверка, является ли переменная текстовой</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.IsReal">
            <summary>Проверка, является ли переменная вещественной</summary>
        </member>
        <member name="P:TFlex.Model.FragmentVariableValue.Name">
            <summary>Имя переменной</summary>
        </member>
        <member name="T:TFlex.Model.FragmentVariableValue">
            <summary>Класс предназначенный для задания значения переменной фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.FileLinks.Enumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.FileLinks.Enumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.FileLinks.Enumerator.CurrentT">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.FileLinks.RefreshAll">
            <summary>Обновить все ссылки</summary>
        </member>
        <member name="M:TFlex.Model.FileLinks.RefreshNonActual">
            <summary>Обновить только неактуальные ссылки</summary>
        </member>
        <member name="M:TFlex.Model.FileLinks.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.FileLinks">
            <summary>Перечислитель ссылок на файлы</summary>
        </member>
        <member name="M:TFlex.Model.FileLink.MakeExternal(System.String)">
            <summary>Преобразовать ссылку во внешнюю. Будут преобразованы все ссылки в документе на данный файл.</summary>
        </member>
        <member name="M:TFlex.Model.FileLink.MakeEmbedded">
            <summary>Преобразовать ссылку во вложенную. Будут преобразованы все ссылки в документе на данный файл.</summary>
        </member>
        <member name="P:TFlex.Model.FileLink.Document">
            <summary>Документ объекта</summary>
        </member>
        <member name="P:TFlex.Model.FileLink.IsDisposed">
            <summary>Возвращает true, если вызывался Dispose()</summary>
        </member>
        <member name="P:TFlex.Model.FileLink.IsEmpty">
            <summary>Возвращает true, если ссылка пустая</summary>
        </member>
        <member name="P:TFlex.Model.FileLink.InternalID">
            <summary>Внутренний идентификатор</summary>
        </member>
        <member name="P:TFlex.Model.FileLink.IsOriginalFormat">
            <summary>Возвращает true, если ссылка на документ T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.Model.FileLink.IsEmbedded">
            <summary>Возвращает true, если ссылка внутренняя</summary>
        </member>
        <member name="P:TFlex.Model.FileLink.FullFilePath">
            <summary>Полный путь файла</summary>
        </member>
        <member name="P:TFlex.Model.FileLink.FilePath">
            <summary>Путь файла</summary>
        </member>
        <member name="M:TFlex.Model.FileLink.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.FileLink.#ctor(TFlex.Model.FileLink)">
            <summary>Конструктор копии ссылки на файл</summary>
            <param name="link">Ссылка на файл</param>
        </member>
        <member name="M:TFlex.Model.FileLink.#ctor(TFlex.Model.Document,System.IntPtr)">
            <summary>Конструктор ссылки на файл по внутреннему идентификатору</summary>
            <param name="document">Документ ссылки</param>
            <param name="internalID">Внутренней идентификатор</param>
        </member>
        <member name="M:TFlex.Model.FileLink.#ctor(TFlex.Model.BackFileLinkParameters)">
            <summary>Конструктор обратной ссылки</summary>
            <param name="parameters">Параметры конструктора</param>
        </member>
        <member name="M:TFlex.Model.FileLink.#ctor(TFlex.Model.TempFileLinkParameters)">
            <summary>Конструктор ссылки на временный файл</summary>
            <param name="parameters">Параметры конструктора</param>
        </member>
        <member name="M:TFlex.Model.FileLink.#ctor(TFlex.Model.Document,System.String,TFlex.Model.Document)">
            <summary>Конструктор ссылки на внутренний файл по документу в памяти</summary>
            <param name="document">Документ, в котором будет создана ссылка</param>
            <param name="nameFormat">Имя ссылки</param>
            <param name="fragment">Внутренний документ, на который указывает ссылка</param>
        </member>
        <member name="M:TFlex.Model.FileLink.#ctor(TFlex.Model.Document,System.String,System.Boolean)">
            <summary>Конструктор ссылки на внутренний файл по пути</summary>
            <param name="document">Документ ссылки</param>
            <param name="filePath">Путь к ссылке</param>
            <param name="embedded">true, если файл вложенный</param>
        </member>
        <member name="M:TFlex.Model.FileLink.#ctor(TFlex.Model.Document,System.String)">
            <summary>Конструктор ссылки на файл по пути</summary>
            <param name="document">Документ ссылки</param>
            <param name="filePath">Путь к ссылке</param>
        </member>
        <member name="M:TFlex.Model.FileLink.#ctor(TFlex.Model.Document)">
            <summary>Конструктор пустой ссылки на файл</summary>
            <param name="document">Документ ссылки</param>
        </member>
        <member name="T:TFlex.Model.FileLink">
            <summary>Класс ссылки на файл</summary>
        </member>
        <member name="P:TFlex.Model.BackFileLinkParameters.LinkingDocument">
            <summary>Документ, на который указывает ссылка</summary>
        </member>
        <member name="P:TFlex.Model.BackFileLinkParameters.OwnerDocument">
            <summary>Документ, которому принадлежит ссылка</summary>
        </member>
        <member name="T:TFlex.Model.BackFileLinkParameters">
            <summary>Класс содержит свойства обратной ссылки</summary>
        </member>
        <member name="P:TFlex.Model.TempFileLinkParameters.TempName">
            <summary>Временное имя</summary>
        </member>
        <member name="P:TFlex.Model.TempFileLinkParameters.Template">
            <summary>Путь к документу шаблона</summary>
        </member>
        <member name="P:TFlex.Model.TempFileLinkParameters.Document">
            <summary>Документ, которому принадлежит ссылка</summary>
        </member>
        <member name="T:TFlex.Model.TempFileLinkParameters">
            <summary>Класс содержит свойства ссылки, указывающей на временный документ</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Connector.ParentFragment">
            <summary>Родительский фрагмент</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Connector.AddVariable(System.String,TFlex.Model.Parameter)">
            <summary>Добавить переменную в список переменных коннектора</summary>
            <param name="name">Имя переменной</param>
            <param name="value">Значение переменной</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Connector.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Fragment,System.String)">
            <summary>Конструктор, создающий ссылочный коннектор фрагмента</summary>
            <param name="document">Документ объекта</param>
            <param name="fragment">Фрагмент, содержащий коннектор,
который требуется перевести в сборку</param>
            <param name="connectorComment">Имя коннектора в документе фрагмента, который требуется перевести в сборку</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Connector.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ объекта</param>
        </member>
        <member name="T:TFlex.Model.Model2D.Connector">
            <summary>Класс коннектора</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FixingVector.FindByFragment(TFlex.Model.Model2D.Fragment)">
            <summary>Найти все векстора привязки фрагмента</summary>
            <param name="fragment">Родительский фрагмент</param>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.Comment">
            <summary>Комментарий (Имя)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.EndPoint">
            <summary>Конечная точка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.StartPoint">
            <summary>Начальная точка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.UseOnlyFirstPoint">
            <summary>Использовать только первую точку</summary>
            <remarks>При установке данного свойства в true, второй узел удаляется.
При установки данного свойства в false, после вызова данного свойства необходимо
заново задать второй узел с помощью свойства <see cref="P:TFlex.Model.Model2D.FixingVector.EndNode" /></remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.EndNode">
            <summary>Конечный узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.StartNode">
            <summary>Начальный узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FixingVector.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FixingVector.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ объекта</param>
        </member>
        <member name="T:TFlex.Model.Model2D.FixingVector">
            <summary>Класс вектора привязки</summary>
            <example>
                <code name="Вектор привязки">
public static void FixingVector()//вектор привязки
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа			
   document.BeginChanges("Построение вектора привязки");//Открытие блока изменений документа

   FixingVector fv = new FixingVector(document);
   //создание узлов
   FreeNode fn1 = new FreeNode(document, 50, 400);
   FreeNode fn2 = new FreeNode(document, 200, 400);

   fv.StartNode = fn1;//Начальный узел
   fv.EndNode = fn2;//Конечный узел
   fv.Color = 21;//цвет вектора	
	
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.SetTextValue(System.String,TFlex.Model.Variable)">
            <summary>Установить текстовое значение параметра</summary>
            <param name="name">Имя параметра</param>
            <param name="value">Текстовое значение переменной</param>
            <remarks>Данный метод используется для установки выражения у параметра коннектора.
Результатом выражения должно быть текстовое значение.</remarks>
            <returns>Индекс параметра</returns>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.SetTextValue(System.String,System.String)">
            <summary>Установить текстовое значение параметра</summary>
            <param name="name">Имя параметра</param>
            <param name="value">Текстовое значение</param>
            <returns>Индекс параметра</returns>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.SetRealValue(System.String,TFlex.Model.Parameter)">
            <summary>Установить вещественное значение параметра</summary>
            <param name="name">Имя параметра</param>
            <param name="value">Вещественное значение переменной</param>
            <remarks>Данный метод используется для установки выражения у параметра коннектора.
Результатом выражения должно быть вещественное число.</remarks>
            <returns>Индекс параметра</returns>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.SetRealValue(System.String,System.Double)">
            <summary>Установить вещественное значение параметра</summary>
            <param name="name">Имя параметра</param>
            <param name="value">Вещественное значение</param>
            <returns>Индекс параметра</returns>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.Find(System.String)">
            <summary>Найти индекс по имени параметра</summary>
            <param name="name">Имя параметра</param>
            <returns>Индекс параметра</returns>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.GetTextValue(System.Int32)">
            <summary>Получить текстовое значение параметра</summary>
            <param name="index">Индекс параметра</param>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.GetRealValue(System.Int32)">
            <summary>Получить вещественное значение параметра</summary>
            <param name="index">Индекс параметра</param>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.GetVariable(System.Int32)">
            <summary>Получить переменную связанную с параметром</summary>
            <param name="index">Индекс параметра</param>
            <returns>Переменная</returns>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.IsReal(System.Int32)">
            <summary>Проверить является ли значением параметра текстовое значение</summary>
            <param name="index">Индекс параметра</param>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.IsText(System.Int32)">
            <summary>Проверить является ли значением параметра вещественное число</summary>
            <param name="index">Индекс параметра</param>
        </member>
        <member name="M:TFlex.Model.ConnectorParameters.GetParameter(System.Int32)">
            <summary>Получить имя параметра по индексу</summary>
            <param name="index">Индекс параметра</param>
            <returns>Имя параметра</returns>
        </member>
        <member name="P:TFlex.Model.ConnectorParameters.Count">
            <summary>Количество параметров коннектора</summary>
        </member>
        <member name="T:TFlex.Model.ConnectorParameters">
            <summary>Сonnector parameters</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Angle">
            <summary>Угол поворота картинки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Y2">
            <summary>Координата Y второй точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.X2">
            <summary>Координата X второй точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Y1">
            <summary>Координата Y первой точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.X1">
            <summary>Координата X первой точки привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Node2">
            <summary>Второй узел привязки картинки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Node1">
            <summary>Первый узел привязки картинки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.PictureFixingMode">
            <summary>Способ привязки картинки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Scale">
            <summary>Масштаб изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.IsMultipage">
            <summary>true, если картинка содержит несколько страниц</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.ShownPageCount">
            <summary>Количество страниц изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.ShownPageName">
            <summary>Имя отображаемой страницы</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.ShownPageID">
            <summary>ID отображаемой страницы чертежа</summary>
            <remarks>Используется только для чертежей T-Flex</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.ShownPageIndex">
            <summary>Индекс отображаемой страницы</summary>
            <remarks>Для чертежей T-Flex не используется</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.FileLink">
            <summary>Ссылка на файл картинки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.FullFilePath">
            <summary>Полный путь файла картинки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.FilePath">
            <summary>Имя файла картинки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Picture.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Picture.#ctor(TFlex.Model.FileLink)">
            <summary>Конструктор с именем файла картинки</summary>
            <param name="link">Ссылка на файл картинки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Picture.#ctor(TFlex.Model.Document,System.String)">
            <summary>Конструктор с именем файла картинки</summary>
            <param name="Doc">Документ объекта</param>
            <param name="filePath">Имя файла картинки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Picture.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ объекта</param>
        </member>
        <member name="F:TFlex.Model.Model2D.Picture.FixingMode.TwoPoints">
            <summary>Привязка картинки по двум точкам</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Picture.FixingMode.PointAndScale">
            <summary>Привязка картинки по одной точке, с использованием масштаба и угла поворота</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Picture.FixingMode">
            <summary>Способ привязки картинки</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Picture">
            <summary>Класс картинки</summary>
        </member>
        <member name="P:TFlex.PluginFloatingWindow.Visible">
            <summary>Свойство видимости окна</summary>
        </member>
        <member name="P:TFlex.PluginFloatingWindow.Icon">
            <summary>Иконка окна</summary>
        </member>
        <member name="P:TFlex.PluginFloatingWindow.Caption">
            <summary>Заголовок окна</summary>
        </member>
        <member name="E:TFlex.PluginFloatingWindow.ChangingDocument">
            <summary>Событие, возникающее при смене одного активного документа на другой</summary>
        </member>
        <member name="P:TFlex.PluginFloatingWindow.ActiveDocument">
            <summary>Возвращает активный документ</summary>
        </member>
        <member name="P:TFlex.PluginFloatingWindow.ID">
            <summary>Возвращает идентификатор окна</summary>
        </member>
        <member name="P:TFlex.PluginFloatingWindow.Owner">
            <summary>Возвращает объект приложения, в котором было создано плавающее окно</summary>
        </member>
        <member name="P:TFlex.PluginFloatingWindow.Control">
            <summary>Возвращает клиентскую часть всплывающего окна</summary>
        </member>
        <member name="M:TFlex.PluginFloatingWindow.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="T:TFlex.PluginFloatingWindow">
            <summary>Класс, представляющий плавающее окно приложения</summary>
        </member>
        <member name="T:TFlex.ChangingFloatingWindowDocumentEventHandler">
            <summary>Делегат представляющий метод, который будет обрабатывать событие, возникающее при смене одного активного документа на другой</summary>
            <param name="sender">Источник события</param>
            <param name="e">Аргументы события</param>
        </member>
        <member name="M:TFlex.PluginException.ReportUnknownError(System.String)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportUnknownError(TFlex.Command.ICustomCommand)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportUnknownError(TFlex.PluginFactory)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportUnknownError(TFlex.Plugin)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportError(System.String,System.Exception)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportError(System.String,System.String)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportError(TFlex.PluginFactory,System.Exception)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportError(TFlex.PluginFactory,System.String)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportError(TFlex.Command.ICustomCommand,System.Exception)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportError(TFlex.Plugin,System.Exception)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportError(TFlex.Plugin,System.String)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.ReportError">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="P:TFlex.PluginException.Message">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.#ctor(TFlex.PluginFactory,System.String,System.Exception)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.#ctor(TFlex.PluginFactory,System.String)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.#ctor(TFlex.Plugin,System.String,System.Exception)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.PluginException.#ctor(TFlex.Plugin,System.String)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="T:TFlex.PluginException">
            <summary>Класс для внутреннего использования</summary>
        </member>
        <member name="F:ELLIPSE_IMAGE.m_nCenterKnot">
По центру и радиусам
</member>
        <member name="T:ELLIPSE_IMAGE.EllipseType">
Способ задания
</member>
        <member name="M:ELLIPSE_IMAGE.#ctor(CTfw32Doc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
По центру и радиусам
</member>
        <member name="T:CircArc_IMAGE.ArcType">
Способ задания
</member>
        <member name="M:CircArc_IMAGE.#ctor(CTfw32Doc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
дуга, проходящая через три точки
</member>
        <member name="T:CIRCLE_IMAGE.CircleType">
Способ задания
</member>
        <member name="T:FIXING_POINT.OrientationType">
Ориентация вида
</member>
        <member name="M:TFlex.Drawing.Polyline.Add(System.Double,System.Double)">
            <summary>Добавить точку к полилинии</summary>
            <param name="x">Координата X добавляемой точки</param>
            <param name="y">Координата Y добавляемой точки</param>
        </member>
        <member name="P:TFlex.Drawing.Polyline.ContourCount">
            <summary>Количество контуров в полилинии</summary>
        </member>
        <member name="P:TFlex.Drawing.Polyline.PointCount(System.Int32)">
            <summary>Количество точек для заданного контура</summary>
        </member>
        <member name="P:TFlex.Drawing.Polyline.Y(System.Int32)">
            <summary>Получить координату Y точки по ее индексу</summary>
        </member>
        <member name="P:TFlex.Drawing.Polyline.X(System.Int32)">
            <summary>Получить координату X точки по ее индексу</summary>
        </member>
        <member name="P:TFlex.Drawing.Polyline.Empty">
            <summary>Признак наличия точек в полилинии</summary>
        </member>
        <member name="M:TFlex.Drawing.Polyline.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Drawing.Polyline">
            <summary>Класс содержит полилинию - замкнутый контур, состоящий из отрезков, или набор контуров в вещественных координатах</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FragmentPathObject.Enumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FragmentPathObject.Enumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentPathObject.Enumerator.CurrentT">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FragmentPathObject.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentPathObject.TargetElement">
            <summary>Объект в сборке</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentPathObject.SourceElement">
            <summary>Исходный объект</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FragmentPathObject">
            <summary>Класс содержащий информацию о привязке объекта к фрагменту</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.RestoreAssociatedLayers(TFlex.Model.Document)">
            <summary>Восстанавливаем видимость слоев, связанных с вектором привязки</summary>
            <param name="document">Документ для изменений</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.RestoreAssociatedLayers">
            <summary>Восстанавливаем видимость слоев, связанных с вектором привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.HideAssociatedLayers(TFlex.Model.Document)">
            <summary>Гасим слои, связанные с вектором привязки</summary>
            <param name="document">Документ для изменений</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.HideAssociatedLayers">
            <summary>Гасим слои, связанные с вектором привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetUserBomData(System.Boolean)">
            <summary>Пользовательские данные для спецификации</summary>
            <param name="onlyVisible">Собирать информацию только для видимых объектов</param>
            <returns>Подсборка</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.NeverIncludeInBom">
            <summary>Никогда не включать в спецификации</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.Quantity">
            <summary>Количество</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.Variables">
            <summary>Переменный</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructures">
            <summary>Данные о структурах изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.Records">
            <summary>Пользовательские данные</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.Children">
            <summary>Подсборки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.Path">
            <summary>Путь к файлу</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.Elements">
            <summary>Информация об элементах структуры изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.Columns">
            <summary>Информация о колонках структуры изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.SchemeID">
            <summary>Идентификатор типа(схемы) структуры изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.Name">
            <summary>Имя структуры изделия</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ElementInfo.GetAllValueInfos">
            <summary>Возвращает значения элемента</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ElementInfo.GetAllValues">
            <summary>Возвращает значения элемента</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ElementInfo.GetUnit(System.Guid)">
            <summary>Возвращает единицу измерения значение элемента для колонки заданной с помощью идентификатора id</summary>
            <param name="paramId">Идентификатор параметра</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ElementInfo.GetStringValue(System.Guid)">
            <summary>Возвращает строковое значение элемента для колонки заданной с помощью идентификатора id</summary>
            <param name="paramId">Идентификатор параметра</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ElementInfo.GetValue(System.Guid)">
            <summary>Возвращает значение элемента для колонки заданной с помощью идентификатора id</summary>
            <param name="paramId">Идентификатор параметра</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ElementInfo.default(System.Guid)">
            <summary>Возвращает значение элемента для колонки заданной с помощью идентификатора id</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ElementInfo.ID">
            <summary>Уникальный идентификатор элемента</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ElementInfo">
            <summary>Данные об элементе структуры изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ValueInfo.Unit">
            <summary>Единица измерения значения ячейки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ValueInfo.ObjectValue">
            <summary>Значение ячейки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ValueInfo.StringValue">
            <summary>Значение, приведенное к троке</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ValueInfo">
            <summary>Данные о значении ячейки элемента структуры изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ColumnInfo.Name">
            <summary>Имя колонки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ColumnInfo.ID">
            <summary>Уникальный идентификатор колонки</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData.ColumnInfo">
            <summary>Данные о колонке структуры изделия</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.FileUserData.ProductStructureData">
            <summary>Данные о структуре изделия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.VariablesData.IsText">
            <summary>Проверка типа переменной</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.VariablesData.RealValue">
            <summary>Вещественное значение переменной</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.VariablesData.TextValue">
            <summary>Текстовое значение переменной</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.VariablesData.Name">
            <summary>Имя переменной</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.FileUserData.VariablesData">
            <summary>Запись с данными о переменных</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Amount">
            <summary>Количество</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Materail3">
            <summary>Материал 3</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Materail2">
            <summary>Материал 2</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.CageCode">
            <summary>Коммерческий код</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Zone">
            <summary>Зона</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Format">
            <summary>Формат</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Remarks">
            <summary>Примечания</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Price">
            <summary>Цена</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Massa">
            <summary>Масса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Materail1">
            <summary>Материал 1</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Denotation">
            <summary>Обозначение</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Name">
            <summary>Наименование</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.Group">
            <summary>Раздел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.UserDates">
            <summary>Пользовательские данные</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.UserData.Value">
            <summary>Значение пользовательского данного</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.UserData.Name">
            <summary>Имя пользовательского данного</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData.UserData">
            <summary>Пользовательские данные</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.FileUserData.RecordUserData">
            <summary>Запись с пользовательскими данными</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.FileUserData">
            <summary>Подсборка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.AlwaysRegenerate3DModel">
            <summary>Всегда пересчитывать 3D модель</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.AutoSave">
            <summary>Создавать фрагмент в режиме автосохранения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FragmentFileFolder">
            <summary>Путь на папку относительно папки сборки при сохранении в папку сборки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.SaveFragmentToAssemblyFolder">
            <summary>Cохранять файл фрагмента в папку сборки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetBOMQuantity(System.Boolean)">
            <summary>Получить количество копий фрагмента в всех массивах</summary>
            <param name="onlyVisible">Считать количество только видимых копий, иначе считать все</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.IncludeInSpecificBom(System.String)">
            <summary>Включение в спецификацию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.IncludeInNewBom">
            <summary>Включение в новую спецификацию</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.EditInContext">
            <summary>Редактировать в контексте сборки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.AssignAssemblyVariables">
            <summary>Назначить переменные сборки по умолчанию</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.Create3DFragment">
            <summary>Создать 3D фрагмент</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.ExtractFragment(TFlex.Model.Model2D.FragmentExtractOptions)">
            <summary>Создание фрагмента на основе списка объектов (Выделить фрагмент)</summary>
            <param name="fragmentExtractOptions">Параметры для выделения фрагмента</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.Explode(TFlex.Model.Model2D.FragmentExplodeOptions)">
            <summary>Раскрыть фрагмент</summary>
            <param name="explodeOptions">Параметры раскрытия фрагмента</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.Explode(System.Boolean)">
            <summary>Раскрыть фрагмент</summary>
            <param name="createConstructions">Раскрыть фрагмент с построениями</param>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Transformation">
            <summary>Получить текущее преобразование фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetFixingVectorName(System.Int32)">
            <summary>Получить имя вектора привязки фрагмента с указанным номером</summary>
            <param name="index">Номер вектора привязки</param>
            <returns>Имя вектора привязки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetFixingVectorCount">
            <summary>Получить количество векторов привязки фрагмента</summary>
            <returns>Количество векторов привязки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetFixingVectorName">
            <summary>Получить имя текущего вектора привязки фрагмента</summary>
            <returns>Имя вектора привязки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.SetFixingVectorName(System.String)">
            <summary>Установить привязку фрагмента по вектору привязки с указанным именем</summary>
            <param name="name">Имя вектора привязки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.SetDefaultFixingVector">
            <summary>Установить привязку фрагмента по основному вектору привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.ShowVariablesDialog">
            <summary>Показать диалог "Переменные"</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.UpdateVariablesFromFragmentDocument">
            <summary>Обновить переменные фрагмента по документу фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetVariablesFromFragment(TFlex.Model.Model2D.Fragment)">
            <summary>Установить значения всех переменных фрагмента в соответствии с переменными входящего фрагмента</summary>
            <param name="sourceFragment">Исходный фрагмент</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.SetDefaultVariableValues">
            <summary>Установить значения переменных фрагмента из документа фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetVariables(System.Boolean,System.Boolean)">
            <summary>Контейнер переменных фрагмента</summary>
            <param name="includeInternal">Включить скрытые переменные</param>
            <param name="includeFixing">Включить переменные фиксации (x1, y1 - x9, y9)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetVariables(System.Boolean)">
            <summary>Получить контейнер переменных фрагмента</summary>
            <param name="includeInternal">Включить скрытые переменные</param>
            <returns>Контейнер переменных фрагмента</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetVariables">
            <summary>Контейнер переменных фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetVariableValue(System.String,System.Boolean)">
            <summary>Получить переменную фрагмента по имени</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetVariableValue(System.String,System.Boolean,System.Boolean)">
            <summary>Получить переменную фрагмента по имени</summary>
            <param name="name">Имя переменной</param>
            <param name="forSet">Признак необходимости изменения переменной</param>
            <returns>Переменная фрагмента</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.HaveFixingPoint(System.Int32)">
            <summary>Проверка существования точки привязки фрагмента,
привязанного при помощи переменных привязки</summary>
            <param name="index">Номер точки привязки. Может иметь значение от 1 до 9</param>
            <returns>true, если точка привязки фрагмента с указанным номером существует, иначе false</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.SetFixingNode(System.Int32,TFlex.Model.Model2D.Node)">
            <summary>Установка узла привязки точки привязки фрагмента,
привязанного при помощи переменных привязки</summary>
            <param name="index">Номер точки привязки. Может иметь значение от 1 до 9</param>
            <param name="node">Узел, к которому привязана точка привязки фрагмента</param>
            <remarks>Переменные привязки - переменные в документе фрагмента с имененем x или y и индексом от 1 до 9</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetFixingNode(System.Int32)">
            <summary>Установка узла привязки точки привязки фрагмента,
привязанного при помощи переменных привязки</summary>
            <param name="index">Номер точки привязки. Может иметь значение от 1 до 9</param>
            <returns>Узел, к которому привязаны точки привязки фрагмента</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.SetFixingPoint(System.Int32,System.Double,System.Double)">
            <summary>Установка координат точки привязки фрагмента,
привязанного при помощи переменных привязки</summary>
            <param name="index">Номер точки привязки. Может иметь значение от 1 до 9</param>
            <param name="x">Координата X точки привязки</param>
            <param name="y">Координата Y точки привязки</param>
            <remarks>Переменные привязки - переменные в документе фрагмента с имененем x или y и индексом от 1 до 9</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetFixingY(System.Int32)">
            <summary>Получение координаты Y точки привязки фрагмента, привязанного
при помощи переменных привязки</summary>
            <param name="index">Номер точки привязки. Может иметь значение от 1 до 9</param>
            <returns>Координата Y точки привязки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetFixingX(System.Int32)">
            <summary>Получение координаты X точки привязки фрагмента,
привязанного при помощи переменных привязки</summary>
            <param name="index">Номер точки привязки. Может иметь значение от 1 до 9</param>
            <returns>Координата X точки привязки</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Angle">
            <summary>Угол поворота вектора привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.EndY">
            <summary>Координата Y привязки конечной точки вектора привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.EndX">
            <summary>Координата X привязки конечной точки вектора привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.EndNode">
            <summary>Узел привязки конечной точки вектора привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.StartY">
            <summary>Координата Y привязки начальной точки вектора привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.StartX">
            <summary>Координата X привязки начальной точки вектора привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.StartNode">
            <summary>Узел привязки начальной точки вектора привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.UseAssemblyStatus">
            <summary>Использовать статус сборки, иначе - статус документа фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Scale">
            <summary>Параметр "Масштаб"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.ScaleLineWidth">
            <summary>Параметр "Масштабировать толщину линий"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Symmetric">
            <summary>Параметр "Симметричный относительно вектора привязки"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Constant">
            <summary>Параметр "Постоянный фрагмент (символ)"</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.OpenPart(TFlex.Model.Model2D.Fragment.OpenPartOptions)">
            <summary>Создать деталировку с данными параметрами</summary>
            <returns>Новый деталированный документ</returns>
        </member>
        <member name="F:TFlex.Model.Model2D.Fragment.OpenPartOptions.DocumentPath">
            <summary>Путь</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Fragment.OpenPartOptions.DocumentTitle">
            <summary>Заголовок</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Fragment.OpenPartOptions.SubstituteVariables">
            <summary>Подставлять переменные</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Fragment.OpenPartOptions.SubstituteStatus">
            <summary>Подставлять статус</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Fragment.OpenPartOptions.SubstituteGeometry">
            <summary>Подставлять геометрию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Fragment.OpenPartOptions.DontShowDocument">
            <summary>Не показывать документ</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Fragment.OpenPartOptions.SaveDocument">
            <summary>Сохранять документ</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.Fragment.OpenPartOptions.QuietMode">
            <summary>Не показывать диалог</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment.OpenPartOptions">
            <summary>Параметры создания деталировки</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.OpenPart">
            <summary>Создать деталировку</summary>
            <returns>Новый деталированный документ</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetFragmentDocument(System.Boolean)">
            <summary>Получить документ фрамента с подстановкой значений переменных фрагмента</summary>
            <returns>Документ фрагмента</returns>
            <param name="substitute">Признак необходимости подстановки значений переменных</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.GetFragmentDocument">
            <summary>Получить документ фрамента</summary>
            <returns>Документ фрагмента</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Connector">
            <summary>Коннектор, к которому привязан фрагмент</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FileLink">
            <summary>Ссылка на файл фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FullFilePath">
            <summary>Полный путь файла фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FilePath">
            <summary>Имя файла фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.FragmentDocumentPage">
            <summary>Страница с которой берётся фрагмент</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Fragment.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.#ctor(TFlex.Model.FileLink)">
            <summary>Конструктор с именем файла фрагмента</summary>
            <param name="link">Ссылка на файл фрагмента</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.#ctor(TFlex.Model.Document,System.String,System.Boolean,System.Boolean)">
            <summary>Конструктор с именем файла фрагмента</summary>
            <param name="document">Документ объекта</param>
            <param name="filePath">Имя файла фрагмента</param>
            <param name="copy">Использовать файл как шаблон для создания нового документа фрагмента в оперативной памяти</param>
            <param name="autoSave">Создавать фрагмент в режиме автосохранения</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.#ctor(TFlex.Model.Document,System.String)">
            <summary>Конструктор с именем файла фрагмента</summary>
            <param name="document">Документ объекта</param>
            <param name="filePath">Имя файла фрагмента</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Fragment.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ объекта</param>
        </member>
        <member name="T:TFlex.Model.Model2D.Fragment">
            <summary>Класс 2D фрагмента</summary>
            <example>
                <code name="FragmentNodes">
public static void FragmentNodes(string pathFragment)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа			
   document.BeginChanges("2D фрагменты вставка по узлам");//Открытие блока изменений документа

   Fragment fragment = new Fragment(document, pathFragment);//фрагмент
   FreeNode fn1 = new FreeNode(document, 0, 180);
   fragment.SetFixingNode(1, fn1);//Установка узла привязки точки привязки фрагмента, привязанного при помощи переменных привязки
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
                <code name="FragmentFixingVector">
public static void FragmentFixingVector(string pathFragment)
{	
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("2D фрагменты вставка по вектору привязки");//Открытие блока изменений документа

   Fragment fragment = new Fragment(document, pathFragment);			
   FixingVector fv = new FixingVector(document); //вектор привязки
   fv.Name = "FixingVector";

   FreeNode fn1 = new FreeNode(document, 10, 160);
   FreeNode fn2 = new FreeNode(document, 100, 160);

   fv.StartNode = fn1;
   fv.EndNode = fn2;
   fv.Color = 200;
   //установить привязку фрагмента по вектору привязки с указанным именем
   fragment.SetFixingVectorName("FixingVector");

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
                <code name="FragmentConnector">
public static void FragmentConnector(string pathFragment)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("2D фрагменты вставка по коннектору");//Открытие блока изменений документа

   Fragment fragment = new Fragment(document, pathFragment);//фрагмент	
   FreeNode fn1 = new FreeNode(document, -100, 700);
   fragment.SetFixingNode(1, fn1);
   Connector connector = new Connector(document);//коннектор
   connector.StartNode = new FreeNode(document, -100, 700);//Начальный узел			
   connector.EndNode = new FreeNode(document, 100, 700);//Конечный узел			
   fragment.Connector = connector;//привязка созданного коннектора к фрагменту

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
                <code name="FragmentVariables">
public static void FragmentVariables(string pathFragment)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("2D фрагменты");//Открытие блока изменений документа

   Fragment fragment = new Fragment(document, pathFragment);
   foreach(FragmentVariableValue v in fragment.GetVariables())//цикл по переменным фрагмента
   {
    if(v.Name == "D" &amp;&amp; v.IsReal)//находим переменную "D" 
    {
	    v.RealValue = 100;//устанавливаем значение
    }
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
                <code name="FragmentAction">
public static void FragmentAction(string pathFragment)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("действия над фрагментами");//Открытие блока изменений документа

   Fragment fragment = new Fragment(document, pathFragment);
   fragment.EditInContext();//Редактировать в контексте сборки
   fragment.Explode(true);//Раскрыть фрагмент true - с построением
   fragment.OpenPart();//деталировка
		
   document.EndChanges();//Закрытие блока изменений документа			
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExtractOptions.DeleteSourceObjects">
            <summary>Удалить исходные объекты</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExtractOptions.FixingVectorComment">
            <summary>Описание вектора привязки. Может быть не задано.</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExtractOptions.SecondFixingVectorNode">
            <summary>Второй узел вектора привязки. Может быть не задан.</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExtractOptions.FirstFixingVectorNode">
            <summary>Первый узел вектора привязки. Может быть не задан.</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExtractOptions.NewFragmentDocumentFilePath">
            <summary>Путь к создаваемому файлу фргагмента. Может быть не задан.</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExtractOptions.Objects">
            <summary>Объекты для копирования</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FragmentExtractOptions">
            <summary>Параметры выделения фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExplodeOptions.UniteInGroup">
            <summary>Значение по умолчанию "Объединить объекты, полученные при раскрытии фрагмента, в группу". Используется при Silent == true</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExplodeOptions.Silent">
            <summary>Режим "без вопроса"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentExplodeOptions.CreateConstructions">
            <summary>Раскрыть фрагмент с построениями</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FragmentExplodeOptions.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FragmentExplodeOptions">
            <summary>Параметры раскрытия фрагмента</summary>
        </member>
        <member name="T:TFlex.Model.IncludeInBom">
            <summary>Типы включения в спецификации</summary>
        </member>
        <member name="F:TFlex.Model.IncludeInBom.OnlyParametricBom">
            <summary>Только параметрическая спецификация</summary>
        </member>
        <member name="F:TFlex.Model.IncludeInBom.WithParametricBom">
            <summary>С параметрической спецификацией</summary>
        </member>
        <member name="F:TFlex.Model.IncludeInBom.OnlyBom">
            <summary>Только спецификацию</summary>
        </member>
        <member name="F:TFlex.Model.IncludeInBom.WithBom">
            <summary>Со спецификацией</summary>
        </member>
        <member name="F:TFlex.Model.IncludeInBom.OnlyEmbeddedElements">
            <summary>Только вложенные элементы</summary>
        </member>
        <member name="F:TFlex.Model.IncludeInBom.WithEmbeddedElements">
            <summary>С вложенными элементами</summary>
        </member>
        <member name="F:TFlex.Model.IncludeInBom.WithoutEmbeddedElements">
            <summary>Без вложенных элементов</summary>
        </member>
        <member name="F:TFlex.Model.IncludeInBom.NotIncluded">
            <summary>Не включать</summary>
        </member>
        <member name="M:FRAGMENT.DegreesOfFreedom(TFDocRegenContext*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="M:FRAGMENT.Get3DFragment">
Методы для работы с планировками
</member>
        <member name="M:FRAGMENT.IsCopied">
Фрагмент является копией другого фрагмента
</member>
        <member name="M:CFragment.DegreesOfFreedom(TFDocRegenContext*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="M:CFragment.Get3DFragment">
Методы для работы с планировками
</member>
        <member name="M:CFragment.GetVariableFragment">
Индекс фрагмента, c которого фрагмент берёт значения переменных
</member>
        <member name="M:CFragment.GetSourceFragment">
Индекс фрагмента, копией которго является данный фрагмент
</member>
        <member name="M:CFragment.GetSourceMap(TAffineMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Преобразование положения фрагмента без дополнительных преобразований
</member>
        <member name="M:CFragment.GetCurrentFragmentMap(TAffineMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Суммарное преобразование с учетом дополнительных преобразований
</member>
        <member name="M:TFlex.Model.Model2D.RevolveArray.SetRowParameters(TFlex.Model.Model2D.RevolveArrayParameters,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров массива</summary>
            <param name="paramsSet">Набор параметров, которые устанавливаются функцией</param>
            <param name="arrFullAngle">Общая угол массива</param>
            <param name="arrStepAngle">Шаг угла для элементов</param>
            <param name="arrNumber">Количество элементов</param>
            <remarks>В зависимости от заданного набора задаваемых параметров (paramsSet), оставшийся параметр будет автоматически рассчитываться по заданным двум
(его значение, переданное в функцию будет проигнорировано).					
</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.RevolveArray.CenterY">
            <summary>Y-координата центра массива</summary>
            <remarks>Если установлен центральный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.RevolveArray.CenterX">
            <summary>X-координата центра массива</summary>
            <remarks>Если установлен центральный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.RevolveArray.CenterNode">
            <summary>Центральный узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RevolveArray.CopyType">
            <summary>Подтип операции копирования</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.RevolveArray.#ctor(TFlex.Model.Document)">
            <summary>Стандартный конструктор</summary>
            <param name="document">Документ</param>
        </member>
        <member name="T:TFlex.Model.Model2D.RevolveArray">
            <summary>Круговой массив</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RevolveArrayParameters">
            <summary>Набор задаваемых параметров кругового массива</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RevolveArrayParameters.FullAngleAndNumber">
            <summary>Задаются общий угол и количество</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RevolveArrayParameters.StepAndFullAngle">
            <summary>Задаются шаг и общий угол</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RevolveArrayParameters.StepAndNumber">
            <summary>Задаются шаг и количество</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearArray.SetRowParameters(TFlex.Model.Model2D.LinearArrayParameters,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров рядов массива</summary>
            <param name="paramsSet">Набор параметров, которые устанавливаются функцией</param>
            <param name="rowsLength">Общая длина массива в направлении рядов</param>
            <param name="rowsStep">Шаг рядов</param>
            <param name="rowsNumber">Количество рядов</param>
            <remarks>В зависимости от заданного набора задаваемых параметров (paramsSet), оставшийся параметр будет автоматически рассчитываться по заданным двум
(его значение, переданное в функцию будет проигнорировано).</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearArray.SetColumnParameters(TFlex.Model.Model2D.LinearArrayParameters,TFlex.Model.Model2D.NodeNeeds,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка параметров столбцов массива</summary>
            <param name="paramsSet">Набор параметров, которые устанавливаются функцией</param>
            <param name="nodeNeed">Указывает способ использования конечной точка</param>
            <param name="colsLength">Общая длина массива в направлении столбцов</param>
            <param name="colsStep">Шаг столбцов</param>
            <param name="colsNumber">Количество столбцов</param>
            <remarks>В зависимости от заданного набора задаваемых параметров (paramsSet), оставшийся параметр будет автоматически рассчитываться по заданным двум
(его значение, переданное в функцию будет проигнорировано).
В зависимости от заданного флага узла (nodeNeed), переданное в функцию значение параметра, получаемого с узла, будет проигнорировано.
При попытке указать для получения по конечной точке привязки расчитываемого значения, nodeNeed будет автоматически установлен в None.</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearArray.EndY">
            <summary>Y-координата конечной точки</summary>
            <remarks>Если установлен начальный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearArray.EndX">
            <summary>X-координата конечной точки</summary>
            <remarks>Если установлен начальный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearArray.StartY">
            <summary>Y-координата начальной точки</summary>
            <remarks>Если установлен начальный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearArray.StartX">
            <summary>X-координата начальной точки</summary>
            <remarks>Если установлен начальный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearArray.EndNode">
            <summary>Конечный узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearArray.StartNode">
            <summary>Начальный узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearArray.CopyType">
            <summary>Подтип операции копирования</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearArray.#ctor(TFlex.Model.Document)">
            <summary>Стандартный конструктор</summary>
            <param name="document">Документ</param>
        </member>
        <member name="T:TFlex.Model.Model2D.LinearArray">
            <summary>Линейный массив</summary>
            <example>
                <code name="Линейный массив">
public static void LinearArray()//Создание 2D-массива
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, -15, 880);//создание узла
   FreeNode fn2 = new FreeNode(document, -35, 850);
			
   ConstructionOutline l1 = new ConstructionOutline(document, fn1, fn2);

   LinearArray linearArray = new LinearArray(document);//массив
   linearArray.AddSource(l1);//добавление объекта (прямой)
   linearArray.StartNode = new FreeNode(document, -15, 800);//Начальный узел
   linearArray.EndNode = new FreeNode(document, 0, 810);//Конечный узел
   linearArray.SetColumnParameters(LinearArrayParameters.LengthAndNumber, NodeNeeds.None, 30, 5, 5);//Установка параметров столбцов массива

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.NodeNeeds">
            <summary>Типы использования конечной точки массива</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeNeeds.ForStep">
            <summary>Шаг берётся как расстояние между заданными точками</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeNeeds.ForLength">
            <summary>Длина берётся как расстояние между заданными точками</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeNeeds.None">
            <summary>Точка не используется для задания параметров (задаёт только направление)</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LinearArrayParameters">
            <summary>Набор задаваемых параметров линейного массива</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearArrayParameters.LengthAndNumber">
            <summary>Задаются длина и количество</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearArrayParameters.StepAndLength">
            <summary>Задаются шаг и длина</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearArrayParameters.StepAndNumber">
            <summary>Задаются шаг и количество</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SymmetryCopy.SetNodeAndOffset(TFlex.Model.Model2D.Node,System.Double,System.Double,System.Double,System.Double)">
            <summary>Установка оси симметрии по узлу и смещению</summary>
            <param name="baseNode">Базовый узел - первая точка, определяющая ось</param>
            <param name="baseX">X-координата базовой точки</param>
            <param name="baseY">Y-координата базовой точки</param>
            <param name="dX">Смещение по оси X для второй точки, определяющей ось</param>
            <param name="dY">Смещение по оси Y для второй точки, определяющей ось</param>
            <remarks>Если базовый узел не задан (NULL), то привязка происходит по точке с заданными координатами. В противном случае - координаты игнорируются</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.SymmetryCopy.SetLine(TFlex.Model.Model2D.Object2D)">
            <summary>Установка оси симметрии по линии построения-прямой</summary>
            <param name="axisLine">Линия, задающая ось </param>
        </member>
        <member name="M:TFlex.Model.Model2D.SymmetryCopy.SetNodes(TFlex.Model.Model2D.Node,System.Double,System.Double,TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка оси симметрии по двум узлам</summary>
            <param name="firstNode">Первый узел, определяющий ось</param>
            <param name="firstX">X-координата первой точи, определяющей ось</param>
            <param name="firstY">Y-координата первой точи, определяющей ось</param>
            <param name="secondNode">Второй узел, определяющий ось</param>
            <param name="secondX">X-координата второй точи, определяющей ось</param>
            <param name="secondY">Y-координата второй точи, определяющей ось</param>
            <remarks>Если какой-либо из узлов не задан (NULL), то привязка происходит по точке с заданными координатами. В противном случае - координаты игнорируются</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.SymmetryCopy.SymmetryType">
            <summary>Тип задания оси симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SymmetryCopy.CopyType">
            <summary>Подтип операции копирования</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SymmetryCopy.#ctor(TFlex.Model.Document)">
            <summary>Стандартный конструктор</summary>
            <param name="document">Документ</param>
        </member>
        <member name="T:TFlex.Model.Model2D.SymmetryCopy">
            <summary>Копия-симметрия</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.SymmetryType">
            <summary>Типы задания оси симметрии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SymmetryType.NodeAndOffset">
            <summary>Ось по узлу и точке, смещенной относительно узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SymmetryType.Line">
            <summary>Ось вдоль линии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SymmetryType.Nodes">
            <summary>Ось по двум узлам</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.SymmetryType.Undefined">
            <summary>Не задана</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.Scale">
            <summary>Масштаб</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.Angle">
            <summary>Угол поворота</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.EndY">
            <summary>Y-координата конечной точки</summary>
            <remarks>Если установлен начальный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.EndX">
            <summary>X-координата конечной точки</summary>
            <remarks>Если установлен начальный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.StartY">
            <summary>Y-координата начальной точки</summary>
            <remarks>Если установлен начальный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.StartX">
            <summary>X-координата начальной точки</summary>
            <remarks>Если установлен начальный узел - изменения координат будет проигнорировано</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.EndNode">
            <summary>Конечный узел, определяющий перемещение</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.StartNode">
            <summary>Начальный узел, определяющий перемещение</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.MoveCopy.CopyType">
            <summary>Подтип объекта-копии</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.MoveCopy.#ctor(TFlex.Model.Document)">
            <summary>Стандартный конструктор</summary>
            <param name="document">Document</param>
        </member>
        <member name="T:TFlex.Model.Model2D.MoveCopy">
            <summary>Копия-перемещение</summary>
            <example>
                <code name="Копия с перемещением">
public static void MoveCopy()//Создание 2D-копий
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Копирование 2D объекта");//Открытие блока изменений документа

   int r1 = 50;
   int r2 = 30;

   FreeNode fnCenter = new FreeNode(document, 50, 700);
   FreeNode fn1 = new FreeNode(document, fnCenter.X.Value + r1, fnCenter.Y.Value);
   FreeNode fn2 = new FreeNode(document, fnCenter.X.Value, fnCenter.Y.Value + r2);

   EllipseConstruction ec = new EllipseConstruction(document);
   ec.SetCenterAndTwoNodes(fnCenter, fn1, fn2);//эллипс через центр и два узла

   MoveCopy moveCopy = new MoveCopy(document);
   moveCopy.AddSource(ec);//добавление в копию объекта (эллипса)
   moveCopy.StartNode = new FreeNode(document, 50, 700);//Начальный узел, определяющий перемещение
   moveCopy.EndNode = new FreeNode(document, 100, 800);//Конечный узел, определяющий перемещение

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOperation.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.CopyOperation.Explode(System.Boolean)">
            <summary>Разрушение операции</summary>
            <param name="GroupObjects">Объединять разрушенные объекты в группу</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CopyOperation.RestoreDeletedAssociatives">
            <summary>Восстановление удаленных ассоциативных объектов</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CopyOperation.DeleteAssociative(System.Int32,System.Int32)">
            <summary>Удаление ассоциативного объекта</summary>
            <param name="indexSource">Индекс исходного объекта в списке объекта-копии</param>
            <param name="indexTransformation">Индекс преобразования</param>
            <returns>false - если индексы выходит за границы списка исходных объектов и трансформаций</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.CopyOperation.RemoveSource(System.Int32)">
            <summary>Удаление исходного объекта из копии</summary>
            <param name="index">Индекс в удаляемого исходного объекта в списке объекта-копии</param>
            <returns>false - если индекс выходит за границы списка исходных объектов</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.CopyOperation.AddSource(TFlex.Model.Model2D.Object2D)">
            <summary>Добавление в копию исходного объекта</summary>
            <param name="addSource">Добавляемый исходный объект</param>
            <returns>Индекс в объекте-копии добавленного исходного объекта</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.CopyOperation.GetAssociate(System.Int32,System.Int32)">
            <summary>Получение ассоциативного объекта (результата копирования)</summary>
            <param name="indexSource">Индекс исходного объекта в списке объекта-копии</param>
            <param name="indexTransformation">Индекс преобразования</param>
            <returns>Ассоциативный объект (результат копирования)</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.CopyOperation.GetSourceObject(System.Int32)">
            <summary>Получение исходного объекта</summary>
            <param name="index">Индекс исходного объекта в списке объекта-копии</param>
            <returns>Получение исходного объекта по его индексу</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOperation.TransformationCount">
            <summary>Количество преобразований копируемых объектов</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOperation.SourcesCount">
            <summary>Количество копируемых объектов</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOperation.CopyType">
            <summary>Значение подтипа объекта "Копия"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOperation.GroupType">
            <summary>Тип объекта "Копия"</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CopyOperation">
            <summary>Базовый класс операции копирования</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CopyType">
            <summary>Подтипы объектов-копий</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CopyType.RevolveArray">
            <summary>Круговой массив</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CopyType.LinearArray">
            <summary>Линейный массив</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CopyType.SymmetryCopy">
            <summary>Копия-симметрия</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CopyType.MoveCopy">
            <summary>Копия-перемещение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CopyType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="T:CTFCurveArrayObj">
Массив по кривой
</member>
        <member name="M:TFlex.Drawing.AffineMap.Multiply(TFlex.Drawing.AffineMap)">
            <summary>Умножить карту преобразования на другую карту</summary>
            <param name="other">Карта, на которую умножаем</param>
        </member>
        <member name="P:TFlex.Drawing.AffineMap.Scale">
            <summary>Масштаб афинного преобразования</summary>
        </member>
        <member name="P:TFlex.Drawing.AffineMap.Angle">
            <summary>Угол афинного преобразования</summary>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.ApplyToAngle(System.Double@)">
            <summary>Применить афинное преобразование к углу</summary>
            <param name="angle">Значение угола в исходной системе координат</param>
            <remarks>На выходе метода получаем значение угла в преобразованной системе координат</remarks>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.ToLCS(System.Double@,System.Double@)">
            <summary>Отменить афинное преобразование</summary>
            <param name="x">Координата x точки в системе координат после преобразования</param>
            <param name="y">Координата y точки в системе координат после преобразования</param>
            <remarks>Входные значения координат x и y передаются по ссылке, на выходе метода получаем значения x и y в исходной системе координат</remarks>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.ToWCS(System.Double@,System.Double@)">
            <summary>Применить афинное преобразование</summary>
            <param name="x">Координата x точки в исходной системе координат</param>
            <param name="y">Координата y точки в исходной системе координат</param>
            <remarks>Входные значения координат x и y передаются по ссылке, на выходе метода получаем значения x и y в преобразованной системе координат</remarks>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="scale">Масштаб</param>
            <param name="angle">Угол поворота</param>
            <param name="originX">Цент вращения X</param>
            <param name="originY">Цент вращения Y</param>
            <param name="offsetX">Отступ по X</param>
            <param name="offsetY">Отступ по Y</param>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.#ctor(System.Double,System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="offsetX">Отступ по X</param>
            <param name="offsetY">Отступ по Y</param>
            <param name="angle">Угол поворота</param>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.#ctor(TFlex.Drawing.AffineMap)">
            <summary>Конструктор</summary>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.Finalize">
            <summary>Финализатор. Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Drawing.AffineMap.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="T:TFlex.Drawing.AffineMap">
            <summary>Класс двухмерного афинного преобразования</summary>
        </member>
        <member name="P:TFlex.Model.Layer.LineWidth">
            <summary>Значение толщины линии</summary>
            <example>
                <code name="Установка толщины линии">
public static void SetLineWidth(ModelObject ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка толщины линии");//Открытие блока изменений документа

   ob.LineWidth = 3;	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Layer.SetLineWidth">
            <summary>Параметр слоя "Установлена толщина линии"</summary>
        </member>
        <member name="P:TFlex.Model.Layer.VisibleOnlyOnFragment">
            <summary>Параметр слоя "видимый только на фрагменте"</summary>
        </member>
        <member name="P:TFlex.Model.Layer.HiddenOnFragment">
            <summary>Параметр слоя "невидимый на фрагменте"</summary>
        </member>
        <member name="P:TFlex.Model.Layer.Screen">
            <summary>Параметр слоя "экранный"</summary>
        </member>
        <member name="P:TFlex.Model.Layer.ColorVariable">
            <summary>Переменная цвета слоя</summary>
        </member>
        <member name="P:TFlex.Model.Layer.Color">
            <summary>Цвет слоя</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Layer.Monochrome">
            <summary>Параметр слоя "одноцветный"</summary>
        </member>
        <member name="P:TFlex.Model.Layer.ProgrammaticallyFrozen">
            <summary>Параметр слоя "замороженный". Недоступно из пользовательского интерфейса.</summary>
        </member>
        <member name="P:TFlex.Model.Layer.Frozen">
            <summary>Параметр слоя "замороженный"</summary>
        </member>
        <member name="P:TFlex.Model.Layer.HiddenVariable">
            <summary>Переменная, задающая параметр слоя "невидимый"</summary>
        </member>
        <member name="P:TFlex.Model.Layer.Hidden">
            <summary>Параметр слоя "невидимый"</summary>
        </member>
        <member name="P:TFlex.Model.Layer.Name">
            <summary>Имя слоя</summary>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Layer.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Layer.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
            <param name="doc">Документ слоя</param>
        </member>
        <member name="T:TFlex.Model.Layer">
            <summary>Класс слоя</summary>
            <example>
                <code name="Слой">
public static void Layer()//создания нового слоя на чертеже и установки его параметров
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Создание нового слоя");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//одноцветный
   l.Color = 12;//цвет слоя
   l.SetLineWidth = true;

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
                <code name="Пример иллюстрирующий перебор всех линий изображения и изменение их в зависимости от типа линии изображения">
    //Пример иллюстрирующий перебор всех линий изображения и изменение их в зависимости от типа линии изображения
public static void TypeOutline()
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Изменение типа линий");//Открытие блока изменений документа

   Layer l1 = new Layer(document);
   l1.Name = "Основные линии";

   Layer l2 = new Layer(document);
   l2.Name = "Тонкие линии";

   Layer l3 = new Layer(document);
   l3.Name = "Осевые линии";

   foreach (Outline ol in document.GetOutlines())//цикл по линиям изображения
   {
    //назначении линии слоя "основные линии"
    if (ol.PatternName == "CONTINUOUS"){ ol.Layer = l1; }
    else if (ol.PatternName == "THIN") { ol.Layer = l2;}
    else if (ol.PatternName == "CENTER" || ol.PatternName == "CENTER2"){ ol.Layer = l3;}
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Parameter.op_Implicit(TFlex.Model.Variable)~TFlex.Model.Parameter">
            <summary>Оператор приведения к типу параметра</summary>
            <param name="var">Переменная</param>
        </member>
        <member name="M:TFlex.Model.Parameter.op_Implicit(System.Int32)~TFlex.Model.Parameter">
            <summary>Оператор приведения к типу параметра</summary>
            <param name="value">Целое значение</param>
        </member>
        <member name="M:TFlex.Model.Parameter.op_Implicit(System.Double)~TFlex.Model.Parameter">
            <summary>Оператор приведения к типу параметра</summary>
            <param name="value">Вещественное значение</param>
        </member>
        <member name="P:TFlex.Model.Parameter.IntValue">
            <summary>Константное значение в виде целого числа</summary>
        </member>
        <member name="P:TFlex.Model.Parameter.Value">
            <summary>Константное значение в виде вещественного числа</summary>
        </member>
        <member name="P:TFlex.Model.Parameter.Variable">
            <summary>Ссылка на переменную</summary>
        </member>
        <member name="M:TFlex.Model.Parameter.Default">
            <summary>Возвращает параметр с данными "из статуса"</summary>
        </member>
        <member name="M:TFlex.Model.Parameter.#ctor(System.Int32)">
            <summary>Конструктор для создания параметра, заданного целочисленной константой</summary>
            <param name="value">Целочисленная константа</param>
        </member>
        <member name="M:TFlex.Model.Parameter.#ctor(System.Double)">
            <summary>Конструктор для создания параметра, заданного вещественной константой</summary>
            <param name="value">Вещественная константа</param>
        </member>
        <member name="M:TFlex.Model.Parameter.#ctor(TFlex.Model.Variable)">
            <summary>Конструктор для создания параметра, заданного переменной</summary>
            <param name="var">Переменная</param>
        </member>
        <member name="T:TFlex.Model.Parameter">
            <summary>Класс для хранения чиcловых переменных или констант</summary>
            <remarks>В отличие от класса хранения переменных и выражений данный класс не является экземпляром модели.
Этот инструментальный класс используется для упрощения работы с параметрами объектов модели,
которые могут задаваться как переменными, так и константами</remarks>
        </member>
        <member name="P:TFlex.Model.Variable.ErrorString">
            <summary>Строка ошибки</summary>
        </member>
        <member name="P:TFlex.Model.Variable.ErrorState">
            <summary>Состояние ошибки</summary>
        </member>
        <member name="P:TFlex.Model.Variable.PdmParameterFormat">
            <summary>Строка форматирования параметра PDM системы</summary>
        </member>
        <member name="P:TFlex.Model.Variable.PdmParameterType">
            <summary>Тип параметра PDM системы</summary>
            <example>
                <code name="Передача параметров в DOCs">
public static void VariableToDOCs()
{
   Document doc = TFlex.Application.ActiveDocument;//Получение активного документа
   doc.BeginChanges("Передача параметров в DOCs");//Открытие блока изменений документа

   //создание переменной
   TFlex.Model.Variable var = new TFlex.Model.Variable(doc, "$xxx", "111");
   //Строка описания параметра PDM системы - в виде Guid
   var.PdmParameterDescription = "[262a61a6-ca61-4404-9131-ddb992230c31]";
   //Направление передачи параметров при интеграции с PDM - в обе стороны
   var.PdmConnectionDirection = PdmConnectionDirection.Both;
   //Тип параметра PDM системы - параметр файла
   var.PdmParameterType = PdmParameterType.File;
   
   doc.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Variable.PdmConnectionDirection">
            <summary>Строка описания параметра PDM системы</summary>
            <example>
                <code name="Передача параметров в DOCs">
public static void VariableToDOCs()
{
   Document doc = TFlex.Application.ActiveDocument;//Получение активного документа
   doc.BeginChanges("Передача параметров в DOCs");//Открытие блока изменений документа

   //создание переменной
   TFlex.Model.Variable var = new TFlex.Model.Variable(doc, "$xxx", "111");
   //Строка описания параметра PDM системы - в виде Guid
   var.PdmParameterDescription = "[262a61a6-ca61-4404-9131-ddb992230c31]";
   //Направление передачи параметров при интеграции с PDM - в обе стороны
   var.PdmConnectionDirection = PdmConnectionDirection.Both;
   //Тип параметра PDM системы - параметр файла
   var.PdmParameterType = PdmParameterType.File;
   
   doc.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Variable.PdmParameterDescription">
            <summary>Строка описания параметра PDM системы</summary>
            <example>
                <code name="Передача параметров в DOCs">
public static void VariableToDOCs()
{
   Document doc = TFlex.Application.ActiveDocument;//Получение активного документа
   doc.BeginChanges("Передача параметров в DOCs");//Открытие блока изменений документа

   //создание переменной
   TFlex.Model.Variable var = new TFlex.Model.Variable(doc, "$xxx", "111");
   //Строка описания параметра PDM системы - в виде Guid
   var.PdmParameterDescription = "[262a61a6-ca61-4404-9131-ddb992230c31]";
   //Направление передачи параметров при интеграции с PDM - в обе стороны
   var.PdmConnectionDirection = PdmConnectionDirection.Both;
   //Тип параметра PDM системы - параметр файла
   var.PdmParameterType = PdmParameterType.File;
   
   doc.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Variable.GroupName">
            <summary>Имя группы переменной</summary>
        </member>
        <member name="P:TFlex.Model.Variable.IsFunction">
            <summary>Переменная является функцией</summary>
        </member>
        <member name="P:TFlex.Model.Variable.AssemblyVariableName">
            <summary>Имя переменной сборки</summary>
        </member>
        <member name="M:TFlex.Model.Variable.DeleteAllValueListStrings">
            <summary>Удалить все строки в списке значений</summary>
        </member>
        <member name="M:TFlex.Model.Variable.DeleteValueListString(System.Int32)">
            <summary>Удалить строку в списке значений</summary>
            <param name="index">Номер позиции в списке</param>
        </member>
        <member name="M:TFlex.Model.Variable.InsertValueListString(System.String,System.Int32)">
            <summary>Добавить строку в список значений</summary>
            <param name="index">Номер позиции в списке</param>
            <param name="str">Добавляемая строка</param>
        </member>
        <member name="M:TFlex.Model.Variable.AddValueListString(System.String)">
            <summary>Добавить строку в список значений</summary>
            <param name="str">Добавляемая строка</param>
        </member>
        <member name="P:TFlex.Model.Variable.ValueListCount">
            <summary>Количество строк в списке значений</summary>
        </member>
        <member name="M:TFlex.Model.Variable.GetValueListString(System.Int32)">
            <summary>Получить строку в списке значений</summary>
            <param name="index">Номер позиции в списке</param>
        </member>
        <member name="M:TFlex.Model.Variable.SetDateListFormat(System.String)">
            <summary>Установить формат даты</summary>
            <param name="format">Формат даты</param>
            <remarks>
Формат даты:
"d"  День месяца в виде одной или двух цифр,
"dd"  День месяца в виде двух цифр, 
"ddd"  День недели в виде трёх букв,
"dddd"  Полное название дня недели, 
"M"  Номер месяца в виде одной или двух цифр, 
"MM"  Номер месяца в виде двух цифр,
"MMM"  Месяц в виде трёх букв, 
"MMMM"  Полное название месяца,
"y"  Последняя цифра года, 
"yy"  Последние две цифры года,
"yyy"  Полный год.
</remarks>
        </member>
        <member name="M:TFlex.Model.Variable.GetDateListFormat">
            <summary>Получить формат даты</summary>
            <returns>Формат даты</returns>
        </member>
        <member name="M:TFlex.Model.Variable.SetDatabaseList(System.String,System.String,System.String,System.String)">
            <summary>Установить параметры для формирования списка значений на основе базы данных </summary>
            <param name="databaseName">Имя базы данных</param>
            <param name="fromFieldName">Имя колонки базы данных, из которой будут отбираться значения</param>
            <param name="showFieldName">Имя колонки базы данных, которые будут появляться при отображении списка.
Если колонок несколько, имена колонок в параметре разделяются точкой с запятой.</param>
            <param name="filter">Условие, по которому будут отбираться значения из базы данных</param>
        </member>
        <member name="M:TFlex.Model.Variable.GetDatabaseList(System.String@,System.String@,System.String@,System.String@)">
            <summary>Получить параметры для формирования списка значений на основе базы данных </summary>
            <param name="databaseName">Имя базы данных</param>
            <param name="fromFieldName">Имя колонки базы данных, из которой будут отбираться значения</param>
            <param name="showFieldName">Имя колонки базы данных, которые будут появляться при отображении списка.
Если колонок несколько, имена колонок в параметре разделяются точкой с запятой.</param>
            <param name="filter">Условие, по которому будут отбираться значения из базы данных</param>
        </member>
        <member name="P:TFlex.Model.Variable.Service">
            <summary>true, если переменная является вспомогательной</summary>
        </member>
        <member name="P:TFlex.Model.Variable.Hidden">
            <summary>true, если переменная является скрытой</summary>
        </member>
        <member name="P:TFlex.Model.Variable.Comment">
            <summary>Комментарий переменной</summary>
        </member>
        <member name="P:TFlex.Model.Variable.Expression">
            <summary>Выражение, задающее значение переменной</summary>
        </member>
        <member name="P:TFlex.Model.Variable.IsUsed">
            <summary>true, если переменная используется (есть ссылка на неё из другого модельного объекта).</summary>
        </member>
        <member name="P:TFlex.Model.Variable.IsConstant">
            <summary>true, если переменная является константной.</summary>
            <remarks>Переменная является константной если её выражение состоит только из значения
одного числа или текстовой константы.</remarks>
        </member>
        <member name="P:TFlex.Model.Variable.External">
            <summary>true, если переменная является помеченной (внешней)</summary>
            <remarks>Данный параметр можно установить в true только в том случае, если переменная является константной
(свойство <see cref="P:TFlex.Model.Variable.IsConstant" /> должен возвращать true)</remarks>
        </member>
        <member name="P:TFlex.Model.Variable.IsText">
            <summary>true, если переменная является текстовой</summary>
        </member>
        <member name="P:TFlex.Model.Variable.IsReal">
            <summary>true, если переменная является вещественной</summary>
        </member>
        <member name="P:TFlex.Model.Variable.TextValue">
            <summary>Значение текстовой переменной</summary>
        </member>
        <member name="P:TFlex.Model.Variable.RealValue">
            <summary>Значение вещественной переменной</summary>
        </member>
        <member name="M:TFlex.Model.Variable.SetName(System.String,System.Boolean)">
            <summary>Переименовать переменную</summary>
            <param name="name">Новое имя переменной</param>
            <param name="includeAllExpressions">Заменить имя переменной на новое в выражениях других переменных</param>
        </member>
        <member name="P:TFlex.Model.Variable.Name">
            <summary>Имя переменной</summary>
            <remarks>Если после переименования требуется обновить имя данной переменной в
выражениях других переменных, используйте вместо данного свойства метод RenameName</remarks>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Variable.ListType">
            <summary>Тип списка значений переменной</summary>
        </member>
        <member name="P:TFlex.Model.Variable.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="M:TFlex.Model.Variable.#ctor(TFlex.Model.Document,System.String,System.String,System.Boolean)">
            <summary>Конструктор, создающий переменную с указанным выражением</summary>
            <param name="document">Документ переменной</param>
            <param name="name">Имя переменной</param>
            <param name="expression">Выражение переменной</param>
            <param name="external">Признак внешней переменной</param>
        </member>
        <member name="M:TFlex.Model.Variable.#ctor(TFlex.Model.Document,System.String,System.Double,System.Boolean)">
            <summary>Конструктор, создающий вещественную переменную с указанным значением</summary>
            <param name="document">Документ переменной</param>
            <param name="name">Имя переменной</param>
            <param name="value">Значение переменной</param>
            <param name="external">Признак внешней переменной</param>
        </member>
        <member name="M:TFlex.Model.Variable.#ctor(TFlex.Model.Document,System.String,System.String)">
            <summary>Конструктор, создающий переменную с указанным выражением</summary>
            <param name="document">Документ переменной</param>
            <param name="name">Имя переменной</param>
            <param name="expression">Выражение переменной</param>
        </member>
        <member name="M:TFlex.Model.Variable.#ctor(TFlex.Model.Document,System.String,System.Double)">
            <summary>Конструктор, создающий вещественную переменную с указанным значением</summary>
            <param name="document">Документ переменной</param>
            <param name="name">Имя переменной</param>
            <param name="value">Значение переменной</param>
        </member>
        <member name="M:TFlex.Model.Variable.#ctor(TFlex.Model.Document,System.Boolean)">
            <summary>Конструктор</summary>
            <param name="document">Документ переменной</param>
            <param name="isText">true, если переменная текстовая</param>
        </member>
        <member name="M:TFlex.Model.Variable.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
            <param name="document">Документ переменной</param>
        </member>
        <member name="T:TFlex.Model.Variable">
            <summary>Класс переменной</summary>
            <example>
                <code name="Создание переменных">
public static void Variables()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Создание переменных");//Открытие блока изменений документа

   Variable v1 = new Variable(document, "v1", 1.7);//вещественная переменная
   Variable v2 = new Variable(document, "$v2", "123"); //текстовая переменная
   Variable v3 = new Variable(document, "v3", 2.3);
   Variable v4 = new Variable(document, "v4", "v1 + v3");//использование выражений с другими переменными

   foreach(Variable v in document.GetVariables())
   {
       if(v.Name == "v1")
       {
           v2.RealValue = v.RealValue;//присвоение значения переменной
       }
   }

   document.EndChanges();//Закрытие блока изменений документа 
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.VariableListType">
            <summary>Тип списка значений переменной</summary>
        </member>
        <member name="F:TFlex.Model.VariableListType.Date">
            <summary>Список на основе данных</summary>
        </member>
        <member name="F:TFlex.Model.VariableListType.File">
            <summary>Список на основе файла</summary>
        </member>
        <member name="F:TFlex.Model.VariableListType.Database">
            <summary>Список на основе базы данных</summary>
        </member>
        <member name="F:TFlex.Model.VariableListType.Text">
            <summary>Список строк</summary>
        </member>
        <member name="F:TFlex.Model.VariableListType.Not">
            <summary>Не является списком</summary>
        </member>
        <member name="T:TFlex.Model.PdmParameterType">
            <summary>Тип параметра PDM системы</summary>
            <example>
                <code name="Передача параметров в DOCs">
public static void VariableToDOCs()
{
   Document doc = TFlex.Application.ActiveDocument;//Получение активного документа
   doc.BeginChanges("Передача параметров в DOCs");//Открытие блока изменений документа

   //создание переменной
   TFlex.Model.Variable var = new TFlex.Model.Variable(doc, "$xxx", "111");
   //Строка описания параметра PDM системы - в виде Guid
   var.PdmParameterDescription = "[262a61a6-ca61-4404-9131-ddb992230c31]";
   //Направление передачи параметров при интеграции с PDM - в обе стороны
   var.PdmConnectionDirection = PdmConnectionDirection.Both;
   //Тип параметра PDM системы - параметр файла
   var.PdmParameterType = PdmParameterType.File;
   
   doc.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="F:TFlex.Model.PdmParameterType.File">
            <summary>Файл</summary>
        </member>
        <member name="F:TFlex.Model.PdmParameterType.Document">
            <summary>Документ</summary>
        </member>
        <member name="F:TFlex.Model.PdmParameterType.Nomenclature">
            <summary>Номенклатура</summary>
        </member>
        <member name="F:TFlex.Model.PdmParameterType.None">
            <summary>Не определён</summary>
        </member>
        <member name="T:TFlex.Model.PdmConnectionDirection">
            <summary>Направление передачи параметров при интеграции с PDM</summary>
            <example>
                <code name="Передача параметров в DOCs">
public static void VariableToDOCs()
{
   Document doc = TFlex.Application.ActiveDocument;//Получение активного документа
   doc.BeginChanges("Передача параметров в DOCs");//Открытие блока изменений документа

   //создание переменной
   TFlex.Model.Variable var = new TFlex.Model.Variable(doc, "$xxx", "111");
   //Строка описания параметра PDM системы - в виде Guid
   var.PdmParameterDescription = "[262a61a6-ca61-4404-9131-ddb992230c31]";
   //Направление передачи параметров при интеграции с PDM - в обе стороны
   var.PdmConnectionDirection = PdmConnectionDirection.Both;
   //Тип параметра PDM системы - параметр файла
   var.PdmParameterType = PdmParameterType.File;
   
   doc.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="F:TFlex.Model.PdmConnectionDirection.FromCad">
            <summary>из CAD</summary>
        </member>
        <member name="F:TFlex.Model.PdmConnectionDirection.FromPdm">
            <summary>из PDM</summary>
        </member>
        <member name="F:TFlex.Model.PdmConnectionDirection.Both">
            <summary>двустороняя передача</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.comboButtonPlacement">
            <summary>Положение кнопки раскрывающегося списка значений</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.colorHighlight">
            <summary>Цвет выделения при редактировании</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.fHighlight">
            <summary>При редактировании выделять цветом</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.fEditable">
            <summary>Редактирование значения допускается</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.precision">
            <summary>Точность представления значения, только для вещественной переменной</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.ComboButtonPlacement.cbpOutOfLine">
            <summary>Справа от границы текста</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.ComboButtonPlacement.cbpNone">
            <summary>Отсутствует</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.ComboButtonPlacement.cbpLine">
            <summary>Слева от границы текста</summary>
        </member>
        <member name="F:TFlex.Model.VariableProperties.ComboButtonPlacement.cbpField">
            <summary>Справа от текста</summary>
        </member>
        <member name="T:TFlex.Model.VariableProperties.ComboButtonPlacement">
            <summary>Положение кнопки раскрывающегося списка значений</summary>
        </member>
        <member name="T:TFlex.Model.VariableProperties">
            <summary>Параметры переменной, размещённой в тексте</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.ClosedSpline">
            <summary>Замкнутый сплайн</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.SplinePoints">
            <summary>Количество точек сплайна</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.ConvertToSpline">
            <summary>Создавать сплайн по полилинии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.CurvatureOptimization">
            <summary>оптимизировать по кривизне</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.CurvatureTolerance">
            <summary>Допуск при оптимизации по кривизне (при переменном шаге полилинии)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.NumberOfPoints">
            <summary>Количество точек (при постоянном шаге полилинии)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.XAxisSymmetry">
            <summary>Симметрия по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.ScalseY">
            <summary>Масштаб по оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.ScalseX">
            <summary>Масштаб по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.End">
            <summary>Окончание функцию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.Start">
            <summary>Начало функцию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.SecondTerm">
            <summary>Второе выражение, задающие функцию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.FirstTerm">
            <summary>Первое выражение, задающие функцию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.Type">
            <summary>Тип функции</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FunctionConstruction.FunctionType.Polarparametric">
            <summary>Полярная параметрическая</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FunctionConstruction.FunctionType.Polar">
            <summary>Полярная</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FunctionConstruction.FunctionType.Parametric">
            <summary>Параметрическая</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.FunctionConstruction.FunctionType.Plain">
            <summary>Обычная</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FunctionConstruction.FunctionType">
            <summary>Типы функций</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.FunctionName">
            <summary>Имя функции</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.DirectionNode">
            <summary>Узел направления системы координат</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.OriginNode">
            <summary>Начальный узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.GeometryType">
            <summary>Тип геометрии линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FunctionConstruction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FunctionConstruction.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.FunctionConstruction">
            <summary>Линия построения - функция</summary>
            <example>
                <code name="Функция">
public static void FunctionConstruction()//функция
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Построение функции");//Открытие блока изменений документа

   FunctionConstruction fc = new FunctionConstruction(document);
   fc.FunctionName = "Паpабола";//имя функции
               
   fc.FirstTerm = "#1**2";//Первое выражение, задающие функцию
   fc.Start = -3;//Начало функции
   fc.End = 3;//Окончание функции

   FreeNode fn1 = new FreeNode(document, 10, 20);
   FreeNode fn2 = new FreeNode(document, 13, 20);

   fc.OriginNode = fn1;//Начальный узел
   fc.DirectionNode = fn2;//Узел направления системы координат
   fc.FunctionType = FunctionConstruction.FunctionType.Plain;//Типы функции - обычная

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.SplineConstruction.GetPointWeight(System.Int32)">
            <summary>Получить вес точки</summary>
            <param name="index">Индекс точки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.SplineConstruction.SetPointWeight(System.Int32,TFlex.Model.Parameter)">
            <summary>Установить вес точки</summary>
            <param name="index">Индекс точки</param>
            <param name="weight">Вес точки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.IsPolyline">
            <summary>Сплайн - полилиния</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.Closed">
            <summary>Замкнутый сплайн</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.Interpolating">
            <summary>Интерполяционный сплайн</summary>
            <remarks>Данное свойство позволяет задать тип сплайна.
true, если необходимо установить тип сплайна "По ломаной", 
false - определяет тип "Через узлы"</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.SplineConstruction.DeletePoint(System.Int32)">
            <summary>Удалить точку</summary>
            <param name="index">Индекс удаляемой точки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.SplineConstruction.InsertPoint(System.Int32,TFlex.Model.Model2D.Node)">
            <summary>Вставить точку</summary>
            <param name="index">Индекс точки, перед которой будет добавлена данная точка</param>
            <param name="node">Добавляемый узел</param>
        </member>
        <member name="M:TFlex.Model.Model2D.SplineConstruction.AddPoint(TFlex.Drawing.Point,TFlex.Model.Parameter)">
            <summary>Добавить точку</summary>
            <param name="point">Добавляемая точка</param>
            <param name="weight">Вес точки</param>
            <returns>Индекс точки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.SplineConstruction.AddPoint(TFlex.Model.Model2D.Node)">
            <summary>Добавить точку</summary>
            <param name="node">Добавляемый узел</param>
            <returns>Индекс узла</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.EndExtensionValue">
            <summary>Значение смещения в конце сплайна</summary>
            <remarks>Параметры смещения не доступны для замкнутых сплайнов</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.EndExtensionType">
            <summary>Тип управления удлинением в конце сплайна</summary>
            <remarks>Параметры смещения не доступны для замкнутых сплайнов</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.EndExtension">
            <summary>Управление удлинением в конце сплайна</summary>
            <remarks>Параметры смещения не доступны для замкнутых сплайнов</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.StartExtensionValue">
            <summary>Значение смещения в начале сплайна</summary>
            <remarks>Параметры смещения не доступны для замкнутых сплайнов</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.StartExtensionType">
            <summary>Тип управления удлинением в начале сплайна</summary>
            <remarks>Параметры смещения не доступны для замкнутых сплайнов</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.StartExtension">
            <summary>Управление удлинением в начале сплайна</summary>
            <remarks>Параметры смещения не доступны для замкнутых сплайнов</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.PointCount">
            <summary>Количество точек сплайна</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.EndTangentNode">
            <summary>Узел, задающий касание в конце</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.StartTangentNode">
            <summary>Узел, задающий касание в начале</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SplineConstruction.SetDegree(System.Int32)">
            <summary>Установить степень сплайна (может игнорироваться)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.GeometryType">
            <summary>Тип геометрии линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.SplineConstruction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.SplineConstruction.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.SplineConstruction">
            <summary>Линия построения - сплайн</summary>
            <example>
                <code name="Сплайн">
public static void Spline()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Сплайн");//Открытие блока изменений документа

   //...Изменения, вносимые в документ должны располагаться здесь
   //Создаем объект SplineConstruction 
   SplineConstruction sc = new SplineConstruction(document);
   sc.Color = 200;
   sc.Interpolating = false;
   //Создаем 2D-узел
   FreeNode fn1 = new FreeNode(document, 10, 200);
   FreeNode fn2 = new FreeNode(document, 30, 240);
   FreeNode fn3 = new FreeNode(document, 100, 240);
   //Добавляем точки
   sc.StartTangentNode = fn1;
   sc.AddPoint(fn2);
   sc.AddPoint(fn3);

   document.EndChanges();	//Закрытие блока изменений документа	
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.ExtensionType">
            <summary>Тип способа управления смещением</summary>
            <remarks>Параметры смещения не доступны для замкнутых сплайнов</remarks>
        </member>
        <member name="F:TFlex.Model.Model2D.ExtensionType.ByArc">
            <summary>По дуге</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ExtensionType.ByParameter">
            <summary>По параметру</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ExtensionType.Mirror">
            <summary>С отражением</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ExtensionType.KeepCurvature">
            <summary>Непрерывный по кривизне</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ExtensionType.ByStraightLine">
            <summary>Линейный</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OffsetConstruction.OffsetNode">
            <summary>Узел, задающий смещение </summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OffsetConstruction.Offset">
            <summary>Смещение эквидистанты</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OffsetConstruction.Source">
            <summary>Исходная линия построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OffsetConstruction.GeometryType">
            <summary>Тип геометрии линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OffsetConstruction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.OffsetConstruction.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.OffsetConstruction">
            <summary>Линия построения - эквидистанта</summary>
            <example>
                <code name="Эквидистанта">
public static void OffsetConstruction()//эквидистанта
{		
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Построение эллипса");//Открытие блока изменений документа

   //Создаем 2D-узлы
   int r1 = 50;
   int r2 = 30;

   FreeNode fnCenter = new FreeNode(document, 50, 300);
   FreeNode fn1 = new FreeNode(document, fnCenter.X.Value + r1, fnCenter.Y.Value);
   FreeNode fn2 = new FreeNode(document, fnCenter.X.Value, fnCenter.Y.Value + r2);

   EllipseConstruction ec = new EllipseConstruction(document);
   ec.SetCenterAndTwoNodes(fnCenter, fn1, fn2);//эллипс через центр и два узла

   document.EndChanges();//Закрытие блока изменений документа

   document.BeginChanges("Построение эквидистанты");//Открытие блока изменений документа

   //Создаем объект OffsetConstruction
   OffsetConstruction oc = new OffsetConstruction(document);
   oc.Source = ec;
   oc.OffsetNode = new FreeNode(document, 50, 400);
   oc.Color = 100;//цвет

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyConstruction.Transformation">
            <summary>Преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyConstruction.SourceCopyOperation">
            <summary>Исходный объект-копия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyConstruction.Source">
            <summary>Исходная линия построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyConstruction.GeometryType">
            <summary>Тип геометрии линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyConstruction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CopyConstruction">
            <summary>Класс линии построения, полученной ассоциативным копированием</summary>
            <remarks>Объект данного класса не может быть создан приложением.
он может создаваться только автоматически системой при создании
операции копирования или массива</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.PathConstruction.Contour">
            <summary>Контур пути</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.PathConstruction.GetCircleArcApproximation(System.Double)">
            <summary>Геометрия дуг окружностей</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.PathConstruction.PolylineConstructionGeometry">
            <summary>Геометрия линии построения (полилиния)</summary>
            <remarks>После использования рекомендуется удалить полученную геометрию, использую функцию Dispose().</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.PathConstruction.ConstructionGeometry">
            <summary>Геометрия линии построения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.PathConstruction.GetAngle(System.ValueType!TFlex.Drawing.Point!System.Runtime.CompilerServices.IsBoxed)">
            <summary>Получить угол наклона касательной в заданной точке пути</summary>
            <param name="point">Точка на пути</param>
            <returns>Угол относительно оси OX(в градусах)</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.PathConstruction.GetRelativePointToBegin(System.Double)">
            <summary>Получить точку на пути</summary>
            <param name="distance">Расстояние от начала пути</param>
            <returns>Точка на пути</returns>
            <remarks>Параметр distance не должен превышать длину пути</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.PathConstruction.Length">
            <summary>Длина пути</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.PathConstruction.GeometryType">
            <summary>Тип геометрии линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.PathConstruction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.PathConstruction.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.PathConstruction">
            <summary>Линия построения - путь</summary>
            <example>
                <code name="Путь">	
public static void PathConstruction()//путь
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("2D-путь");//Открытие блока изменений документа

   PathConstruction pathConstruction = new PathConstruction(document);
   Contour cn = pathConstruction.Contour;//контур

   //создание узлов
   FreeNode fn1 = new FreeNode(document, -200, 50);			
   FreeNode fn2 = new FreeNode(document, -160, 100);
   FreeNode fn3 = new FreeNode(document, -120, 50);			
   FreeNode fn4 = new FreeNode(document, -80, 100);
             
   //соединяем узлы линиями
   ConstructionOutline l1 = new ConstructionOutline(document, fn1, fn2);
   ConstructionOutline l2 = new ConstructionOutline(document, fn2, fn3);
   ConstructionOutline l3 = new ConstructionOutline(document, fn3, fn4);

   double r = 68;	
   //дуга окружности, проходящая через два узла с заданным радиусом
   TwoPointArcOutline twoPointArcOutline = new TwoPointArcOutline(document, fn4, fn1, r);
		    
   //отнесение этих линий к контуру 
   OutlineContourSegment s1 = new OutlineContourSegment(cn);
   OutlineContourSegment s2 = new OutlineContourSegment(cn);
   OutlineContourSegment s3 = new OutlineContourSegment(cn);
   OutlineContourSegment s4 = new OutlineContourSegment(cn);
            
   s1.Outline = l1; s2.Outline = l2; s3.Outline = l3;s4.Outline = twoPointArcOutline; 
         
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetOutline(TFlex.Model.Model2D.Outline)">
            <summary>Эллипс, проходящий по линии изображения (эллипсу или дуге эллипса)</summary>
            <param name="srcOutline">Линия изображения, по которой проходит эллипс</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetCenterAndLineAndRadius(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter)">
            <summary>Эллипс проходящий через узел, касательный к прямой, с заданным радиусом</summary>
            <param name="centerNode">Узел, через который проходит эллипс</param>
            <param name="srcLine">Прямая, которой касается эллипс</param>
            <param name="radius">Радиус эллипса</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetNodeAndTwoLines(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction)">
            <summary>Эллипс проходящий через узел, касательный к двум прямым</summary>
            <param name="srcNode">Узел, через который проходит эллипс</param>
            <param name="srcLine1">Первая прямая, которой касается эллипс</param>
            <param name="srcLine2">Вторая прямая, которой касается эллипс</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetCircleAndLine(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction)">
            <summary>Эллипс с полуосью, заданной окружностью, касательный к прямой</summary>
            <param name="srcCircle">Окружность, задающая полуось эллипса</param>
            <param name="srcLine">Прямая, которой касается эллипс</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetCircleAndNode(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node)">
            <summary>Эллипс с полуосью, заданной окружностью, проходящий через узел</summary>
            <param name="srcCircle">Окружность, задающая полуось эллипса</param>
            <param name="srcNode">Узел, через который проходит эллипс</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetCenterAndLineAndNode(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node)">
            <summary>Эллипс с центром в узле, касательный к прямой, проходящий через узел</summary>
            <param name="centerNode">Центр эллипса</param>
            <param name="srcLine">Прямая, которой касается эллипс</param>
            <param name="srcNode">Узел, через который проходит эллипс</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetTwoNodesAndLine(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction)">
            <summary>Эллипс с заданной полуосью, касательный к прямой</summary>
            <param name="srcNode1">Первый узел полуоси эллипса</param>
            <param name="srcNode2">Второй узел полуоси эллипса</param>
            <param name="srcLine">Прямая, которой касается эллипс</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetCenterAndNodeAndLine(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction)">
            <summary>Эллипс с центром, проходящий через узел и касательный к прямой</summary>
            <param name="centerNode">Центр эллипса</param>
            <param name="srcNode">Узел, через который проходит эллипс</param>
            <param name="srcLine">Прямая, которой касается эллипс</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetTwoNodesAndRadius(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Эллипс с заданной полуосью, с заданным радиусом</summary>
            <param name="srcNode1">Первый узел полуоси эллипса</param>
            <param name="srcNode2">Второй узел полуоси эллипса</param>
            <param name="radius">Радиус эллипса</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetThreeNodes(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Эллипс с заданной полуосью, проходящий через узел</summary>
            <param name="srcNode1">Первый узел полуоси эллипса</param>
            <param name="srcNode2">Второй узел полуоси эллипса</param>
            <param name="srcNode3">Узел, через который проходит эллипс</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetCenterAndNodeAndRadius(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Эллипс с центром в узле, проходящий через узел, с заданным радиусом</summary>
            <param name="centerNode">Центр эллипса</param>
            <param name="srcNode">Узел, через который проходит эллипс</param>
            <param name="radius">Радиус эллипса</param>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.SetCenterAndTwoNodes(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Эллипс с центром в узле, проходящий через два узла</summary>
            <param name="centerNode">Центр эллипса</param>
            <param name="srcNode1">Первый узел, через который проходит эллипс</param>
            <param name="srcNode2">Второй узел, через который проходит эллипс</param>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseConstruction.EllipseType">
            <summary>Тип привязки эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseConstruction.EllipseConstructionGeometry">
            <summary>Геометрия линии построения (эллипса)</summary>
            <remarks>После использования рекомендуется удалить полученную геометрию, использую функцию Dispose().</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseConstruction.ConstructionGeometry">
            <summary>Геометрия линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseConstruction.GeometryType">
            <summary>Тип геометрии линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseConstruction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseConstruction.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.EllipseConstruction">
            <summary>Линия построения - эллипс</summary>
            <example>
                <code name="Эллипс">
public static void EllipseConstruction()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа			
   document.BeginChanges("Эллипс");//Открытие блока изменений документа

   //Создаем 2D-узлы
   int r1 = 50;
   int r2 = 30;

   FreeNode fnCenter = new FreeNode(document, 50, 100);
   FreeNode fn1 = new FreeNode(document, fnCenter.X.Value + r1, fnCenter.Y.Value);
   FreeNode fn2 = new FreeNode(document, fnCenter.X.Value, fnCenter.Y.Value + r2);

   EllipseConstruction ec = new EllipseConstruction(document);
   ec.SetCenterAndTwoNodes(fnCenter, fn1, fn2);//эллипс через центр и два узла

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.EllipseTypes">
            <summary>Типы привязок эллипсов</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.Outline">
            <summary>Проходящий по линии изображения (эллипсу или дуге эллипса)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.CenterAndLineAndRadius">
            <summary>Проходящий через узел, касательный к прямой, с заданным радиусом</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.NodeAndTwoLines">
            <summary>Проходящий через узел, касательный к двум прямым</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.CircleAndLine">
            <summary>С полуосью, заданной окружностью, касательный к прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.CircleAndNode">
            <summary>С полуосью, заданной окружностью, проходящий через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.CenterAndLineAndNode">
            <summary>С центром в узле, касательный к прямой, проходящий через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.TwoNodesAndLine">
            <summary>С заданной полуосью, касательный к прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.CenterAndNodeAndLine">
            <summary>С центром, проходящий через узел и касательный к прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.TwoNodesAndRadius">
            <summary>С заданной полуосью, с заданным радиусом</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.ThreeNodes">
            <summary>С заданной полуосью, проходящий через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.CenterAndNodeAndRadius">
            <summary>С центром в узле, проходящий через узел, с заданным радиусом</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.CenterAndTwoNodes">
            <summary>С центром в узле, проходящий через два узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.EllipseTypes.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetOutline(TFlex.Model.Model2D.Outline)">
            <summary>Окружность, проходящая по линии изображения (окружности или дуге окружности)</summary>
            <param name="srcOutline">Линия изображения, по которой проходит окружность</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToTwoEllipses(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к двум эллипсам</summary>
            <param name="srcEllipse1">Первый эллипс, которого касается окружность</param>
            <param name="srcEllipse2">Второй эллипс, которого касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToEllipseAndPolyline(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к эллипсу и сплайну или другой полилинии</summary>
            <param name="srcEllipse">Эллипс, которого касается окружность</param>
            <param name="srcPolyline">Полилиния, которой касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToCircleAndEllipse(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к окружности и эллипсу</summary>
            <param name="srcCircle">Окружность, которой касается окружность</param>
            <param name="srcEllipse">Эллипс, которого касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToLineAndEllipse(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к прямой и эллипсу</summary>
            <param name="srcLine">Прямая, которой касается окружность</param>
            <param name="srcEllipse">Эллипс, которого касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToTwoPolylines(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к двум сплайнам или другим полилиниям</summary>
            <param name="srcPolyline1">Первая полилиния, которой касается окружность</param>
            <param name="srcPolyline2">Вторая полилиния, которой касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToCircleAndPolyline(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к окружности и сплайну или другой полилинии</summary>
            <param name="srcCircle">Окружность, которой касается окружность</param>
            <param name="srcPolyline">Полилиния, которой касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToLineAndPolyline(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к прямой и сплайну или другой полилинии</summary>
            <param name="srcLine">Прямая, которой касается окружность</param>
            <param name="srcPolyline">Полилиния, которой касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToThreeCircles(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, касательная к трём окружностям</summary>
            <param name="srcCircle1">Первая окружность, которой касается окружность</param>
            <param name="srcCircle2">Вторая окружность, которой касается окружность</param>
            <param name="srcCircle3">Третья окружность, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToLineAndTwoCircles(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, касательная к прямой и двум окружностям</summary>
            <param name="srcLine">Прямая, которой касается окружность</param>
            <param name="srcCircle1">Первая окружность, которой касается окружность</param>
            <param name="srcCircle2">Вторая окружность, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToTwoLinesAndCircle(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, касательная к двум прямым и окружности</summary>
            <param name="srcLine1">Первая прямая, которой касается окружность</param>
            <param name="srcLine2">Вторая прямая, которой касается окружность</param>
            <param name="srcCircle">Окружность, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetNodeTangentToTwoCircles(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, проходящая через узел, касательная к двум окружностям</summary>
            <param name="srcNode">Узел, через который проходит окружность</param>
            <param name="srcCircle1">Первая окружность, которой касается окружность</param>
            <param name="srcCircle2">Вторая окружность, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetNodeTangentToLineAndCircle(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, проходящая через узел, касательная к прямой и окружности</summary>
            <param name="srcNode">Узел, через который проходит окружность</param>
            <param name="srcLine">Прямая, которой касается окружность</param>
            <param name="srcCircle">Окружность, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTwoNodesTangentToCircle(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, проходящая через два узла, касательная к окружности</summary>
            <param name="srcNode1">Первый узел, через который проходит окружность</param>
            <param name="srcNode2">Второй узел, через который проходит окружность</param>
            <param name="srcCircle">Окружность, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetNodeTangentToTwoLines(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, проходящая через узел, касательная к двум прямым</summary>
            <param name="srcNode">Узел, через который проходит окружность</param>
            <param name="srcLine1">Первая прямая, которой касается окружность</param>
            <param name="srcLine2">Вторая прямая, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTwoNodesTangentToLine(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, проходящая через два узла, касательная к прямой</summary>
            <param name="srcNode1">Первый узел, через который проходит окружность</param>
            <param name="srcNode2">Второй узел, через который проходит окружность</param>
            <param name="srcLine">Прямая, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetOffset(TFlex.Model.Model2D.Construction,TFlex.Model.Parameter)">
            <summary>Окружность, концентричная исходной окружности на заданном расстоянии</summary>
            <param name="srcCircle">Исходная окружность</param>
            <param name="offset">Расстояние</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTwoNodes(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, проходящая через два узла</summary>
            <param name="srcNode1">Первый узел, через который проходит окружность</param>
            <param name="srcNode2">Второй узел, через который проходит окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetCenterAndEllipse(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction)">
            <summary>Окружность с центром в узле, касательная к эллипсу</summary>
            <param name="centerNode">Центр окружности</param>
            <param name="srcEllipse">Эллипс, которого касается окружность</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetCenterAndCircle(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction)">
            <summary>Окружность с центром в узле, касательная к окружности</summary>
            <param name="centerNode">Центр окружности</param>
            <param name="srcCircle">Окружность, которой касается окружность</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetCenterAndLine(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction)">
            <summary>Окружность с центром в узле, касательная к прямой</summary>
            <param name="centerNode">Центр окружности</param>
            <param name="srcLine">Прямая, которой касается окружность</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetCenterAndNode(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Окружность с центром в узле, проходящая через узел</summary>
            <param name="centerNode">Центр окружности</param>
            <param name="srcNode">Узел, через который проходит окружность</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetSymmetric(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction)">
            <summary>Окружность, симметричная другой окружности относительно оси (прямой)</summary>
            <param name="srcCircle">Исходная окружность</param>
            <param name="axisLine">Ось (прямая)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetThreeNodes(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Окружность, проходящая через три узла</summary>
            <param name="srcNode1">Первый узел</param>
            <param name="srcNode2">Второй узел</param>
            <param name="srcNode3">Третий узел</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToThreeLines(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Окружность, касательная к трём прямым</summary>
            <param name="srcLine1">Первая прямая, которой касается окружность</param>
            <param name="srcLine2">Вторая прямая, которой касается окружность</param>
            <param name="srcLine3">Третья прямая, которой касается окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToTwoCircles(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к двум окружностям</summary>
            <param name="srcCircle1">Первая окружность, которой касается окружность</param>
            <param name="srcCircle2">Вторая окружность, которой касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToCircleAndLine(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к окружности и прямой</summary>
            <param name="srcCircle">Окружность, которой касается окружность</param>
            <param name="srcLine">Прямая, которой касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToTwoLines(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,TFlex.Model.Model2D.Node)">
            <summary>Окружность, касательная к двум прямым</summary>
            <param name="srcLine1">Первая прямая, которой касается окружность</param>
            <param name="srcLine2">Вторая прямая, которой касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="anchorNode">Узел привязки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToTwoLines(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к двум прямым</summary>
            <param name="srcLine1">Первая прямая, которой касается окружность</param>
            <param name="srcLine2">Вторая прямая, которой касается окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToCircleAndNode(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к окружности, проходящая через узел</summary>
            <param name="srcCircle">Окружность, которой касается окружность</param>
            <param name="srcNode">Узел, через который проходит окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetTangentToLineAndNode(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Parameter,System.Int32)">
            <summary>Окружность, касательная к прямой, проходящая через узел</summary>
            <param name="srcLine">Прямая, которой касается окружность</param>
            <param name="srcNode">Узел, через который проходит окружность</param>
            <param name="radius">Радиус окружности</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.SetCenterAndRadius(TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Окружность с центром в узле и заданным радиусом</summary>
            <param name="centerNode">Центр окружности</param>
            <param name="radius">Радиус окружности</param>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleConstruction.CircleType">
            <summary>Тип привязки окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleConstruction.CircleConstructionGeometry">
            <summary>Геометрия линии построения (окружности)</summary>
            <remarks>После использования рекомендуется удалить полученную геометрию, использую функцию Dispose().</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleConstruction.ConstructionGeometry">
            <summary>Геометрия линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleConstruction.GeometryType">
            <summary>Тип геометрии линии построения (окружность)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleConstruction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.#ctor(TFlex.Model.Document,TFlex.Drawing.Point,TFlex.Model.Model2D.SplineConstruction,TFlex.Model.Model2D.SplineConstruction)">
            <summary>Конструктор</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="centerPoint">Точка задающая положение окружности</param>
            <param name="firstTangentSpline">Первый сплайн, которого касается окружность</param>
            <param name="secondTangentSpline">Второй сплайн, которого касается окружность</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleConstruction.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.CircleConstruction">
            <summary>Линия построения - окружность</summary>
            <example>
                <code name="Окружность">
public static void CircleConstruction()//окружность
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Окружность");//Открытие блока изменений документа

   FreeNode fn0 = new FreeNode(document, 10, 10);//Создаем 2D-узел
   CircleConstruction c1 = new CircleConstruction(document);
   c1.SetCenterAndRadius(fn0, 20);//окружность через центра и радиус
   //создание прямых
   FreeNode fn1 = new FreeNode(document, 10, 10);
   FreeNode fn2 = new FreeNode(document, 10, 50);
   LineConstruction l1 = new LineConstruction(document);
   l1.SetThroughNodes(fn1, fn2);

   FreeNode fn3 = new FreeNode(document, 0, 40);
   FreeNode fn4 = new FreeNode(document, 50, 40);
   LineConstruction l2 = new LineConstruction(document);
   l2.SetThroughNodes(fn3, fn4);
			
   //окружность - касательная к двум прямым с заданным радиусом
   CircleConstruction c2 = new CircleConstruction(document);
   int r = 20; //радиус окружности
   //Номер варианта касания
   int i = 2;
   c2.SetTangentToTwoLines(l1, l2, r, i);
               
   //меняем положение окржуности
   i = 4;
   c2.SetTangentToTwoLines(l1, l2, r, i);

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.CircleTypes">
            <summary>Типы привязок окружностей</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.Outline">
            <summary>Проходящая по линии изображения (окружности или дуге окружности)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToTwoEllipses">
            <summary>Касательная к двум эллипсам</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToEllipseAndPolyline">
            <summary>Касательная к эллипсу и сплайну или другой полилинии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToCircleAndEllipse">
            <summary>Касательная к окружности и эллипсу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToLineAndEllipse">
            <summary>Касательная к прямой и эллипсу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToTwoPolylines">
            <summary>Касательная к двум сплайнам или другим полилиниям</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToCircleAndPolyline">
            <summary>Касательная к окружности и сплайну или другой полилинии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToLineAndPolyline">
            <summary>Касательная к прямой и сплайну или другой полилинии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToThreeCircles">
            <summary>Касательная к трём окружностям</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToLineAndTwoCircles">
            <summary>Касательная к прямой и двум окружностям</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToTwoLinesAndCircle">
            <summary>Касательная к двум прямым и окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.NodeTangentToTwoCircles">
            <summary>Проходящая через узел, касательная к двум окружностям</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.NodeTangentToLineAndCircle">
            <summary>Проходящая через узел, касательная к прямой и окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TwoNodesTangentToCircle">
            <summary>Проходящая через два узла, касательная к окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.NodeTangentToTwoLines">
            <summary>Проходящая через узел, касательная к двум прямым</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TwoNodesTangentToLine">
            <summary>Проходящая через два узла, касательная к прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.Offset">
            <summary>Концентричная исходной окружности на заданном расстоянии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TwoNodes">
            <summary>Проходящая через два узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.CenterAndEllipse">
            <summary>С центром в узле, касательная к эллипсу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.CenterAndCircle">
            <summary>С центром в узле, касательная к окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.CenterAndLine">
            <summary>С центром в узле, касательная к прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.CenterAndNode">
            <summary>С центром в узле, проходящая через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.Symmetric">
            <summary>Симметричная другой окружности относительно оси</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.ThreeNodes">
            <summary>Проходящая через три узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToThreeLines">
            <summary>Касательная к трём прямым</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToTwoCircles">
            <summary>Касательная к двум окружностям</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToCircleAndLine">
            <summary>Касательная к окружности и прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToTwoLines">
            <summary>Касательная к двум прямым</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToCircleAndNode">
            <summary>Касательная к окружности, проходящая через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.TangentToLineAndNode">
            <summary>Касательная к прямой, проходящая через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.CenterAndRadius">
            <summary>С центром в узле и заданным радиусом</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircleTypes.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetParallelTangentToPolyline(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Прямая, параллельная другой прямой, касательная к сплайну или другой полилинии</summary>
            <param name="srcLine">Исходная прямая</param>
            <param name="srcPolyline">Исходная полилиния</param>
            <param name="variant">Номер варианта прямой</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetThoughNodeTangentToPolyline(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Прямая, проходящая через узел, касательная к сплайну или другой полилинии</summary>
            <param name="srcNode">Исходный узел</param>
            <param name="srcPolyline">Исходная полилиния</param>
            <param name="variant">Номер варианта прямой</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetParallelTangentToEllipse(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Прямая, параллельная другой прямой, касательная к эллипсу</summary>
            <param name="srcLine">Исходный узел</param>
            <param name="srcEllipse">Исходный эллипс</param>
            <param name="variant">Номер варианта прямой</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetThoughNodeTangentToEllipse(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Прямая, проходящая через узел, касательная к эллипсу</summary>
            <param name="srcNode">Исходный узел</param>
            <param name="srcEllipse">Исходный эллипс</param>
            <param name="variant">Номер варианта касания прямой</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetDividingNodes(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Прямая, перпендикулярная отрезку между двумя узлами, делящая отрезок в заданной пропорции</summary>
            <param name="srcNode1">Первый исходный узел</param>
            <param name="srcNode2">Второй исходный узел</param>
            <param name="param">Значение параметра, коэффициент. Имеет значение 0, если результирующая прямая продит через первый узел,
1, если проходит черз второй узел, 0.5, если делит отрезок пополам. Может принимать любое значение</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetOnAngleThroughNode(TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Прямая, проходящая через узел, под углом к горизонтали</summary>
            <param name="srcNode">Исходный узел</param>
            <param name="angle">Значение угла в градусах</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetPerpendicularThroughNode(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node)">
            <summary>Прямая, перпендикулярная другой прямой, проходящая через узел</summary>
            <param name="srcLine">Исходная прямая</param>
            <param name="srcNode">Исходный узел</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetHorizontalThroughNode(TFlex.Model.Model2D.Node)">
            <summary>Горизонтальная прямая, проходящая через узел</summary>
            <param name="srcNode">Исходный узел</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetVerticalThroughNode(TFlex.Model.Model2D.Node)">
            <summary>Вертикальная прямая, проходящая через узел</summary>
            <param name="srcNode">Исходный узел</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetParallelTangentToCircle(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Прямая, параллельная другой прямой, касательная к окружности</summary>
            <param name="srcLine">Исходная прямая</param>
            <param name="srcCircle">Исходная окружность</param>
            <param name="variant">Номер варианта прямой</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetParallelThroughNode(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node)">
            <summary>Прямая, параллельная другой прямой, проходящая через узел</summary>
            <param name="srcLine">Исходная прямая</param>
            <param name="srcNode">Исходный узел</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetTangentToCircleOnAngle(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32,TFlex.Model.Parameter)">
            <summary>Прямая, касательная к окружности, под углом к другой прямой</summary>
            <param name="srcLine">Исходная прямая</param>
            <param name="srcCircle">Исходная окружность</param>
            <param name="variant">Номер варианта прямой</param>
            <param name="angle">Значение угла в градусах</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetAxisOfLines(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Прямая, являющаяся осью симметрии двух прямых</summary>
            <param name="srcLine1">Первая исходная прямая</param>
            <param name="srcLine2">Вторая исходная прямая</param>
            <param name="variant">Номер варианта прямой</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetSymmetric(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction)">
            <summary>Прямая, симметричная другой прямой относительно оси (прямой)</summary>
            <param name="srcLine">Исходная прямая</param>
            <param name="axisLine">Ось (прямая)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetTangentToCircles(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Прямая, касательная к двум окружностям</summary>
            <param name="srcCircle1">Первая исходная окружность</param>
            <param name="srcCircle2">Вторая исходная окружность</param>
            <param name="variant">Номер варианта касания</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetThroughNodes(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Прямая, проходящая через два узла</summary>
            <param name="srcNode1">Первый исходный узел</param>
            <param name="srcNode2">Второй исходный узел</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetTangentToCircle(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Прямая, проходящая через узел, касательная к окружности</summary>
            <param name="srcNode">Исходный узел</param>
            <param name="srcCircle">Исходная окружность</param>
            <param name="variant">Номер варианта прямой</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetOnAngleToLineThroughNode(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Parameter)">
            <summary>Прямая, проходящая через узел, под углом к другой прямой</summary>
            <param name="srcLine">Исходная линия построения (прямая)</param>
            <param name="srcNode">Исходный узел</param>
            <param name="angle">Устанавливаемое значение угла в градусах</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetParallel(TFlex.Model.Model2D.Construction,TFlex.Model.Parameter)">
            <summary>Параллельная прямая</summary>
            <remarks>Функция устанавливает параметры линии построения, соответствующие прямой, параллельной исходной прямой.
Прямая располагается на расстоянии distance от исходной прямой (без учёта масштаба текущей страницы).</remarks>
            <param name="srcLine">Исходная линия построения (прямая)</param>
            <param name="distance">Устанавливаемое значение расстояния</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetVertical(TFlex.Model.Parameter)">
            <summary>Вертикальная прямая</summary>
            <remarks>Функция устанавливает параметры линии построения, соответствующие вертикальной прямой
Прямая располагается на расстоянии distance от оси Y системы координат модели (без учёта масштаба текущей страницы)</remarks>
            <param name="distance">Устанавливаемое значение координаты X</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.SetHorizontal(TFlex.Model.Parameter)">
            <summary>Горизонтальная прямая</summary>
            <remarks>Функция устанавливает параметры линии построения, соответствующие горизонтальной прямой.
Прямая располагается на расстоянии distance от оси X системы координат модели (без учёта масштаба текущей страницы)</remarks>
            <param name="distance">Устанавливаемое значение координаты Y</param>
        </member>
        <member name="P:TFlex.Model.Model2D.LineConstruction.LineConstructionGeometry">
            <summary>Геометрия линии построения (прямой)</summary>
            <remarks>После использования рекомендуется удалить полученную геометрию, использую функцию Dispose().</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.LineConstruction.ConstructionGeometry">
            <summary>Геометрия линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineConstruction.GeometryType">
            <summary>Тип геометрии линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineConstruction.LineView">
            <summary>Вид прямой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineConstruction.LineType">
            <summary>Тип привязки прямой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineConstruction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LineConstruction.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model2D.LineConstruction">
            <summary>Линия построения - прямая</summary>
            <example>
                <code name="Прямая">
public static void LineConstruction()//прямая
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа	
   document.BeginChanges("Прямая");//Открытие блока изменений документа

   //Создаем 2D-узел
   FreeNode fn1 = new FreeNode(document, 10, 10);
   FreeNode fn2 = new FreeNode(document, 50, 10);
   LineConstruction lc = new LineConstruction(document);//создаем объект
   lc.SetThroughNodes(fn1, fn2);			

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.ViewLineMode">
            <summary>Вид прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ViewLineMode.Infinite">
            <summary>Бесконечная</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ViewLineMode.Truncated">
            <summary>Обрезанная</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ViewLineMode.Default">
            <summary>По умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LineTypes">
            <summary>Типы привязок прямых</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.ThoughNodeTangentToPolyline">
            <summary>Проходящая через узел, касательная к полилинии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.ParallelTangentToPolyline">
            <summary>Параллельная другой прямой, касательная к полилинии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.ParallelTangentToEllipse">
            <summary>Параллельная другой прямой, касательная к эллипсу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.ThoughNodeTangentToEllipse">
            <summary>Проходящая через узел, касательная к эллипсу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.DividingNodes">
            <summary>Перпендикулярная отрезку между двумя узлами, делящая отрезок в заданной пропорции</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.OnAngleThroughNode">
            <summary>Проходящая через узел, под углом к горизонтали</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.PerpendicularThroughNode">
            <summary>Перпендикулярная другой прямой, проходящая через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.HorizontalThroughNode">
            <summary>Горизонтальная прямая, проходящая через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.VerticalThroughNode">
            <summary>Вертикальная прямая, проходящая через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.ParallelTangentToCircle">
            <summary>Параллельная другой прямой, касательная к окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.ParallelThroughNode">
            <summary>Параллельная другой прямой, проходящая через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.TangentToCircleOnAngle">
            <summary>Касательная к окружности, под углом к другой прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.AxisOfLines">
            <summary>Ось симметрии двух прямых</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.Symmetric">
            <summary>Симметричная другой прямой относительно оси</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.TangentToCircles">
            <summary>Касательная к двум окружностям</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.ThroughNodes">
            <summary>Через два узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.TangentToCircle">
            <summary>Через узел, касательная к окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.OnAngleToLineThroughNode">
            <summary>Проходящая через узел, под углом к другой прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.Parallel">
            <summary>Параллельная прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.Vertical">
            <summary>Вертикаль</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.Horizontal">
            <summary>Горизонталь</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LineTypes.Undefined">
            <summary>Не определена</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.IsFixedPositionLocked">
            <summary>Block the ability to control fixation of construction line from interface</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.IsFixedPosition">
            <summary>Lock position of line</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Construction.UpdateLimits">
            <summary>Обновление выступания линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.ConstructionGeometry">
            <summary>Геометрия линии построения</summary>
            <remarks>После использования рекомендуется удалить полученную геометрию, использую функцию Dispose().</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.GeometryType">
            <summary>Тип геометрии линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.Param">
            <summary>Значение параметра линии построения. Тип параметра зависит от типа линии построения.</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.SubType">
            <summary>Подтип линии построения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Construction.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Construction">
            <summary>Базовый класс линии построения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ConstructionType">
            <summary>Подтипы линий построения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.FunctionConstruction">
            <summary>Функция. Класс
<see cref="T:TFlex.Model.Model2D.FunctionConstruction" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.SplineConstruction">
            <summary>Сплайн. Класс
<see cref="T:TFlex.Model.Model2D.SplineConstruction" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.OffsetConstruction">
            <summary>Эквидистанта. Класс
<see cref="T:TFlex.Model.Model2D.OffsetConstruction" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.CopyConstruction">
            <summary>Линия построения, полученная ассоциативным копированием. Класс
<see cref="T:TFlex.Model.Model2D.CopyConstruction" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.PathConstruction">
            <summary>Линия построения - путь. Класс 
<see cref="T:TFlex.Model.Model2D.PathConstruction" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.EllipseConstruction">
            <summary>Линия построения - эллипс. Класс
<see cref="T:TFlex.Model.Model2D.EllipseConstruction" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.CircleConstruction">
            <summary>Линия построения - окружность. Класс 
<see cref="T:TFlex.Model.Model2D.CircleConstruction" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.LineConstruction">
            <summary>Линия построения - прямая. Класс 
<see cref="T:TFlex.Model.Model2D.LineConstruction" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BetweenNode.SecondNode">
            <summary>Второй узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BetweenNode.FirstNode">
            <summary>Первый узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.BetweenNode.Coefficient">
            <summary>Коэффициент, определящий положение между двумя узлами</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.BetweenNode.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Конструктор создающий узел по двум узлам и вещественному параметру.</summary>
            <param name="document">Документ объекта</param>
            <param name="first">Первый узел</param>
            <param name="second">Первый узел</param>
            <param name="coeff">Коэффициент, определящий положение между двумя узлами</param>
        </member>
        <member name="M:TFlex.Model.Model2D.BetweenNode.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию. Координаты установлены в значение 0, 0</summary>
            <param name="document">Документ объекта</param>
        </member>
        <member name="P:TFlex.Model.Model2D.BetweenNode.SubType">
            <summary>Подтип способа построения узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.BetweenNode">
            <summary>Узел между двумя узлами</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ProjectionNode.ProjectedObject">
            <summary>проецируемый объект</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ProjectionNode.Workplane">
            <summary>Рабочая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ProjectionNode.#ctor(TFlex.Model.Document,TFlex.Model.ModelObject,TFlex.Model.ModelObject)">
            <summary>Конструктор, задающий 3d объекты</summary>
            <param name="document">Документ объекта</param>
            <param name="workplane">Рабочая плоскость</param>
            <param name="projectedObject">Проецируемый объект (вершина или 3d узел)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ProjectionNode.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию. Координаты установлены в значение 0,0</summary>
            <param name="document">Документ объекта</param>
        </member>
        <member name="P:TFlex.Model.Model2D.ProjectionNode.SubType">
            <summary>Тип узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ProjectionNode">
            <summary>Узел полученный проецированием</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.NamedFragmentNode.SourceNodeName">
            <summary>Имя узла во фрагменте, на основе которого создан узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.NamedFragmentNode.Fragment">
            <summary>Фрагмент, на основе которого создан узел</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.NamedFragmentNode.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Fragment,System.String)">
            <summary>Конструктор </summary>
            <param name="document">Документ, в котором создаётся узел</param>
            <param name="fragment">Фрагмент, на основе которого создаётся узел</param>
            <param name="name">Имя узла в модели фрагмента, на основе которого создаётся узел</param>
        </member>
        <member name="P:TFlex.Model.Model2D.NamedFragmentNode.SubType">
            <summary>Подтип способа построения узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.NamedFragmentNode">
            <summary>Класс узла, построенного на основе именованного узла фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentNode.FragmentPath">
            <summary>Объект, задающий путь к исходному элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentNode.SubType">
            <summary>Подтип узла</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FragmentNode.Create(TFlex.Model.Document,TFlex.Model.Model2D.Fragment[],TFlex.Model.Model2D.Object2D,System.Int32)">
            <summary>Создание узла в указанном документе, соответствующего заданному узлу элемента, находящегося на вложенном фрагменте</summary>
            <param name="document">Документ</param>
            <param name="arrPath">Массив вложенных фрагментов</param>
            <param name="sourceElement">Заданный элемент</param>
            <param name="id">Идентификатор узла элемента</param>
            <returns>Созданный объект</returns>
            <remarks>0-й фрагмент в массиве - должен быть вложен в указанный документ.
Заданный объект должен находиться на последнем фрагменте массива.
В данный момент возможно создание узла на конце (id=1) или в начале (id=0) линии построения.</remarks>
        </member>
        <member name="T:TFlex.Model.Model2D.FragmentNode">
            <summary>Класс узла, построенного на основе элемента фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyNode.Transformation">
            <summary>Преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyNode.SourceCopyOperation">
            <summary>Исходный объект-копия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyNode.Source">
            <summary>Исходный узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyNode.SubType">
            <summary>Подтип способа построения узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CopyNode">
            <summary>Класс узла, полученного ассоциативным копированием</summary>
            <remarks>Объект данного класса не может быть создан приложением.
Он создаётся системой автоматически при создании операции копирования</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.RelativeNode.SetEndOfPolyline(TFlex.Model.Model2D.Construction,System.Boolean)">
            <summary>Установка привязки к одному из концов линии построения - полилинии</summary>
            <param name="srcConstruction">Исходная линия построения</param>
            <param name="alignToStart">Параметр для определения положения узла</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RelativeNode.SetByParameter(TFlex.Model.Model2D.Construction,TFlex.Model.Parameter)">
            <summary>Установка привязки к линии построения (Окружность, Эллипс, Полилиния) по параметру</summary>
            <param name="srcConstruction">Исходная линия построения</param>
            <param name="param">Параметр для определения положения узла</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RelativeNode.SetOnConstruction(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Parameter)">
            <summary>Установка смещения относительно родительского узла по линии построения</summary>
            <param name="parentNode">Родительский узел</param>
            <param name="srcConstruction">Исходная линия построения</param>
            <param name="distance">Параметр смещения</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RelativeNode.SetOffset(TFlex.Model.Model2D.Node,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установка смещения относительно родительского узла</summary>
            <param name="parentNode">Родительский узел</param>
            <param name="dX">Смещение по оси X (без учёта масштаба текущей страницы)</param>
            <param name="dY">Смещение по оси Y (без учёта масштаба текущей страницы)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.RelativeNode.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ объекта</param>
        </member>
        <member name="P:TFlex.Model.Model2D.RelativeNode.RelationType">
            <summary>Тип привязки узла</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.RelativeNode.SubType">
            <summary>Подтип способа построения узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RelativeNode">
            <summary>Класс узла, заданного относительно другого элемента</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RelativeType">
            <summary>Типы задания узла, заданного относительно другого узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RelativeType.EndOfPolyline">
            <summary>На конце полилинии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RelativeType.ByParameter">
            <summary>Заданние параметром на линии построения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RelativeType.OnConstruction">
            <summary>На линии построения, по расстоянию до заданного узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RelativeType.Offset">
            <summary>Смещение, относительно заданного узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RelativeType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectNode.Index">
            <summary>Идентификатор узла для определения номера его точки привязки к объекту</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectNode.ParentObject">
            <summary>Объект, которому принадлежит узел</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ObjectNode.#ctor(TFlex.Model.Document,System.UInt32,TFlex.Model.ModelObject)">
            <summary>Конструктор, задающий родительский 3D объект и идентификатор узла</summary>
            <param name="document">Документ объекта</param>
            <param name="parentObject">Родительский 3D объект</param>
            <param name="index">Идентификатор</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ObjectNode.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Object2D,System.UInt32)">
            <summary>Конструктор, задающий родительский 2D объект и идентификатор узла</summary>
            <param name="document">Документ объекта</param>
            <param name="parentObject">Родительский 2D объект</param>
            <param name="index">Идентификатор</param>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectNode.SubType">
            <summary>Подтип способа построения узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ObjectNode">
            <summary>Класс узла, принадлежащего объекту</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.IntersectionNode.Construction2">
            <summary>Вторая линия построения, к которой будет привязан узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.IntersectionNode.Construction1">
            <summary>Первая линия построения, к которой привязан узел</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.IntersectionNode.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Double,System.Double)">
            <summary>Конструктор, задающий линии построения, на пересечении которых находится узел и координаты точки, ближайшей к требуемому варианту пересечения</summary>
            <param name="document">Документ объекта</param>
            <param name="srcConstruction1">Первая линия построения</param>
            <param name="srcConstruction2">Вторая линия построения</param>
            <param name="x">Коордианата X точки</param>
            <param name="y">Коордианата Y точки</param>
        </member>
        <member name="M:TFlex.Model.Model2D.IntersectionNode.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction,System.Int32)">
            <summary>Конструктор, задающий линии построения, на пересечении которых находится узел и вариант пересечения</summary>
            <param name="document">Документ объекта</param>
            <param name="srcConstruction1">Первая линия построения</param>
            <param name="srcConstruction2">Вторая линия построения</param>
            <param name="variant">Вариант исполнения</param>
        </member>
        <member name="M:TFlex.Model.Model2D.IntersectionNode.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Construction)">
            <summary>Конструктор, задающий линии построения, на пересечении которых находится узел</summary>
            <param name="document">Документ объекта</param>
            <param name="srcConstruction1">Первая линия построения</param>
            <param name="srcConstruction2">Вторая линия построения</param>
        </member>
        <member name="M:TFlex.Model.Model2D.IntersectionNode.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию. Координаты установлены в значение 0,0</summary>
            <param name="document">Документ объекта</param>
        </member>
        <member name="P:TFlex.Model.Model2D.IntersectionNode.SubType">
            <summary>Подтип способа построения узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.IntersectionNode">
            <summary>Класс узла, построенного на пересечении линий построения</summary>
            <example>
                <code name="Узел на пересечении линий построения">
public static void IntersectionNode()
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа			
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 300, 400);//создание узла			
   FreeNode fn2 = new FreeNode(document, 400, 500);
		    
   FreeNode fn3 = new FreeNode(document, 400, 400);//создание узла			
   FreeNode fn4 = new FreeNode(document, 300, 500);

   LineConstruction l1 = new LineConstruction(document);
   l1.SetThroughNodes(fn1, fn2);  
			
   LineConstruction l2 = new LineConstruction(document);
   l2.SetThroughNodes(fn3, fn4);  

   IntersectionNode n = new IntersectionNode(document, l1, l2);//узел пересечения двух прямых
   /*
   //в случае, если линии имеют несколько точек пересечения можно применить конструктор с 
   //параметром variant - вариант исполнения. 
   int i = 1;
   IntersectionNode n = new IntersectionNode(document, l1, l2, i);*/

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FreeNode.Y">
            <summary>Значение координаты Y узла</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FreeNode.X">
            <summary>Значение координаты X узла</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FreeNode.#ctor(TFlex.Model.Document,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор, задающий координаты x,y в системе координат модели, без учёта масштаба текущей страницы</summary>
            <param name="document">Документ объекта</param>
            <param name="x">Координата X</param>
            <param name="y">Координата Y</param>
        </member>
        <member name="M:TFlex.Model.Model2D.FreeNode.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию. Координаты установлены в значение 0,0</summary>
            <param name="document">Документ объекта</param>
        </member>
        <member name="P:TFlex.Model.Model2D.FreeNode.SubType">
            <summary>Подтип способа построения узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.FreeNode">
            <summary>Класс узла, построенного в абсолютных координатах</summary>
            <example>
                <code name="Свободный узел">
public static void FreeNode()
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа			
   document.BeginChanges("2D-узел");//Открытие блока изменений документа

   //Создаем 2D-узел
   FreeNode fn1 = new FreeNode(document, 10, 10);
   FreeNode fn2 = new FreeNode(document, 50, 10);

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.AbsY">
            <summary>Координата Y в системе координат модели (без учёта масштаба страницы)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.AbsX">
            <summary>Координата X в системе координат модели (без учёта масштаба страницы)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.Coordinates">
            <summary>Координаты узла в системе координат модели (без учёта масштаба страницы)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.SubType">
            <summary>Подтип способа построения узла</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Node.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Node">
            <summary>Базовый класс 2D узла</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.NodeType">
            <summary>Способы задания узла</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.BetweenNode">
            <summary>Узел между двумя узлами</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.ProjectionNode">
            <summary>Узел полученный проецированием			</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.NamedFragmentNode">
            <summary>Узел, на основе именованного узла фрагмента</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.FragmentNode">
            <summary>Узел, на элементе фрагмента</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.CopyNode">
            <summary>Узел, полученный ассоциативным копированием</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.RelativeNode">
            <summary>Относительный узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.ObjectNode">
            <summary>Узел объекта</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.IntersectionNode">
            <summary>Узел на пересечении линий построения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.FreeNode">
            <summary>Свободный узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.NodeType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:TFlex.Model.Page.ResetName">
            <summary>Перезадать имя страницы согласно правилам именования страниц</summary>
            <remarks>Актуально после смены типа страницы</remarks>
        </member>
        <member name="M:TFlex.Model.Page.PrepareGraphics(TFlex.Drawing.Graphics)">
            <summary>Подготовка графического контекста для прорисовки на данной странице</summary>
            <param name="graphics">Графический контекст</param>
        </member>
        <member name="P:TFlex.Model.Page.SelectionMode">
            <summary>Режим выбора элементов</summary>
        </member>
        <member name="P:TFlex.Model.Page.Rank">
            <summary>Порядковый номер страницы</summary>
        </member>
        <member name="P:TFlex.Model.Page.Top">
            <summary>Верхняя Y-координата границ бумаги</summary>
        </member>
        <member name="P:TFlex.Model.Page.Right">
            <summary>Правая X-координата границ бумаги</summary>
        </member>
        <member name="P:TFlex.Model.Page.Bottom">
            <summary>Нижняя Y-координата границ бумаги</summary>
        </member>
        <member name="P:TFlex.Model.Page.Left">
            <summary>Левая X-координата границ бумаги</summary>
        </member>
        <member name="P:TFlex.Model.Page.DimensionQuality">
            <summary>Квалитет размеров по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Page.AngularDimensionPrecision">
            <summary>Точность угловых размеров</summary>
        </member>
        <member name="P:TFlex.Model.Page.LinearDimensionPrecision">
            <summary>Точность линейных размеров</summary>
        </member>
        <member name="P:TFlex.Model.Page.AngularDimensionMinimalDigits">
            <summary>Минимальное количество цифр после точки для угловых размеров</summary>
        </member>
        <member name="P:TFlex.Model.Page.LinearDimensionMinimalDigits">
            <summary>Минимальное количество цифр после точки для линейных размеров</summary>
        </member>
        <member name="P:TFlex.Model.Page.AngularDimensionUnits">
            <summary>Единицы измерения угловых размеров</summary>
        </member>
        <member name="P:TFlex.Model.Page.LinearDimensionUnits">
            <summary>Единицы измерения линейных размеров</summary>
        </member>
        <member name="P:TFlex.Model.Page.LinePatternScale">
            <summary>Масштаб штрихов штриховых линий по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Page.ThinLineThickness">
            <summary>Толщина тонких линий по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Page.ThickLineThickness">
            <summary>Толщина основных линий по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Page.DefaultArrowSize">
            <summary>Размер стрелок по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Page.IndexSymbolScale">
            <summary>Масштаб подстрочных и надстрочных символов</summary>
        </member>
        <member name="P:TFlex.Model.Page.PlusMinusCode">
            <summary>Код символа "плюс-минус"</summary>
        </member>
        <member name="P:TFlex.Model.Page.DegreeCode">
            <summary>Код символа "градус"</summary>
        </member>
        <member name="P:TFlex.Model.Page.IsSelectedForExporting">
            <summary>Страница, выбранная для экспорта</summary>
        </member>
        <member name="P:TFlex.Model.Page.IsSelectedForPrinting">
            <summary>Страница, выбранная для печати</summary>
        </member>
        <member name="P:TFlex.Model.Page.DiameterCode">
            <summary>Код символа "диаметр"</summary>
        </member>
        <member name="P:TFlex.Model.Page.SymbolFontName">
            <summary>Имя символьного шрифта</summary>
        </member>
        <member name="P:TFlex.Model.Page.FragmentForNewPageFileLink">
            <summary>Ссылка на документ, который будет вставлен, как фрагмент,
при создании страницы, следующей за этой страницей</summary>
        </member>
        <member name="P:TFlex.Model.Page.FontStyle">
            <summary>Стиль шрифта текста</summary>
        </member>
        <member name="P:TFlex.Model.Page.Scale">
            <summary>Масштаб страницы</summary>
        </member>
        <member name="P:TFlex.Model.Page.DrawingLimits">
            <summary>Прямоугольник границ элементов страницы</summary>
        </member>
        <member name="P:TFlex.Model.Page.Rectangle">
            <summary>Прямоугольник границ страницы</summary>
        </member>
        <member name="P:TFlex.Model.Page.PageType">
            <summary>Тип страницы</summary>
        </member>
        <member name="P:TFlex.Model.Page.Name">
            <summary>Имя страницы</summary>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Page.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="M:TFlex.Model.Page.#ctor(TFlex.Model.Document,TFlex.Model.PageType)">
            <summary>Конструктор</summary>
            <param name="document">Документ страницы</param>
            <param name="pageType">Тип страницы</param>
        </member>
        <member name="M:TFlex.Model.Page.#ctor(TFlex.Model.Page)">
            <summary>Конструктор</summary>
            <param name="source">Страница</param>
        </member>
        <member name="M:TFlex.Model.Page.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
            <param name="document">Документ страницы</param>
        </member>
        <member name="T:TFlex.Model.Page">
            <summary>Класс страницы документа</summary>
            <example>
                <code name="Страница (Статус) документа">
public static void Page()//создания новой страницы и установки её параметров
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Новая страница");//Открытие блока изменений документа

   Page p = new Page(document);
   p.Name = "Новая страница";//название страницы
   p.FontStyle.Italic = true;//устновка стиля шрифта - наклонный		

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.ElementSelectionMode">
            <summary>Режим выбора элементов</summary>
        </member>
        <member name="F:TFlex.Model.ElementSelectionMode.VisibleOnly">
            <summary>Только видимые элементы</summary>
        </member>
        <member name="F:TFlex.Model.ElementSelectionMode.All">
            <summary>Все элементы</summary>
        </member>
        <member name="T:TFlex.Model.PageType">
            <summary>Перечислитель типов страниц документа</summary>
        </member>
        <member name="F:TFlex.Model.PageType.Circuit">
            <summary>Электрическая схема</summary>
        </member>
        <member name="F:TFlex.Model.PageType.BillOfMatrials">
            <summary>Спецификация</summary>
        </member>
        <member name="F:TFlex.Model.PageType.BillOfMaterials">
            <summary>Спецификация</summary>
        </member>
        <member name="F:TFlex.Model.PageType.Text">
            <summary>Текстовый документ</summary>
        </member>
        <member name="F:TFlex.Model.PageType.Auxiliary">
            <summary>Вспомогательная</summary>
        </member>
        <member name="F:TFlex.Model.PageType.Dialog">
            <summary>Страница диалога с элементами управления</summary>
        </member>
        <member name="F:TFlex.Model.PageType.Workplane">
            <summary>Страница рабочей плоскости</summary>
        </member>
        <member name="F:TFlex.Model.PageType.Normal">
            <summary>Обычная</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.DrawLeaderLine">
            <summary>Параметр рисования выносной линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.DrawPlus">
            <summary>Флага рисования знака "+" у положительных значений размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.StringsOffset">
            <summary>Величина смещения строк от размерной линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.Standard">
            <summary>Тип стандарта размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.Accuracy">
            <summary>Точность</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.MinDigits">
            <summary>Минимальное число знаков после запятой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.Units">
            <summary>Тип единиц измерения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.ArrowSize">
            <summary>Размер стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.AltScaleFactor">
            <summary>Величина дополнительного масштабирования альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.AltScaleFactorType">
            <summary>Тип дополнительного масштабирования альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.ScaleFactor">
            <summary>Величина дополнительного масштабирования размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.ScaleFactorType">
            <summary>Тип дополнительного масштабирования размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.Dual">
            <summary>Режим отображения двойного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.ParentDimension">
            <summary>Родительский размер</summary>
            <remarks>В зависимости от положения родительского размера будет вычисляться значение текущего размера.
Установленный родительский размер не должен иметь других родительских размеров</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionDimension.SetOffsets(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNodeX">Первый узел привязки, смещение размера от точки привязки по горизонтали</param>
            <param name="offsetX">Смещение размера от точки привязки по горизонтали (используется, если fixNodeX не задан)</param>
            <param name="fixNodeY">Второй узел привязки, смещение размера от точки привязки по вертикали</param>
            <param name="offsetY">Смещение размера от точки привязки по вертикали (используется, если fixNodeY не задан)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionDimension.SetOutline(TFlex.Model.Model2D.Outline,System.Boolean)">
            <summary>Прикрепление размера к линии изображения</summary>
            <param name="horizontalLine">Линия изображения, к которой прикрепляется размер</param>
            <param name="isOnEnd1">Параметр рисования выносной линии до конечной точки линии изображения (иначе - рисуется до начальной)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionDimension.SetConstruction(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node)">
            <summary>Прикрепление размера к линии построения</summary>
            <param name="horizontalLine">Линия построения, к которой прикрепляется размер</param>
            <param name="node">Узел, до которого рисуется выносная линия размера</param>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionDimension.SetNode(TFlex.Model.Model2D.Node)">
            <summary>Прикрепление размера к узлу</summary>
            <param name="node">Узел, к которому прикрепляется размер</param>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.ConstructionDimType">
            <summary>Тип привязки размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionDimension.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionDimension.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ</param>
        </member>
        <member name="T:TFlex.Model.Model2D.ConstructionDimension">
            <summary>Класс строительного размера</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ConstructionDimensionType">
            <summary>Типы привязок строительных размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionDimensionType.Outline">
            <summary>К линии изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionDimensionType.Construction">
            <summary>К линии построения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionDimensionType.Node">
            <summary>К узлу</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ConstructionDimensionType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircularDimension.SetDiametralDimensionType(TFlex.Model.Model2D.DiametralDimensionType)">
            <summary>Установка размера, как диаметрального</summary>
            <param name="type">Тип отрисовки диаметрального размера</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircularDimension.SetRadialDimensionType(TFlex.Model.Model2D.RadialDimensionType)">
            <summary>Установка размера, как радиального</summary>
            <param name="type">Тип отрисовки радиального размера</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircularDimension.SetShortenedRadial(TFlex.Model.Model2D.Object2D,TFlex.Model.Model2D.Node,System.Double,System.Double,TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Установка радиального размера с изломом размерной линии</summary>
            <param name="circle">Окружность - линия построения или изображения, на которой устанавливается размер</param>
            <param name="fixAngleNode">Узел привязки размерной стрелки (привязка угла положения и начала стрелки)</param>
            <param name="angle">Угол, на котором находится размерная стрелка (используется, если отсутствует fixAngleNode)</param>
            <param name="offset">Расстояние от начала размерной линии до окружности (используется, если отсутствует fixAngleNode)</param>
            <param name="fixRatioNode">Узел привязки положения излома размерной стрелки</param>
            <param name="ratio">Соотношение, суммарной длины стрелки и длины стрелки после излома  (используется, если отсутствует fixRatioNode)</param>
            <param name="fixWidthNode">Узел привязки ширины излома размерной стрелки</param>
            <param name="width">Ширина излома размерной стрелки (используется, если отсутствует fixWidthNode)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircularDimension.SetDiametral(TFlex.Model.Model2D.Object2D,TFlex.Model.Model2D.DiametralDimensionType,TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка диаметрального размера</summary>
            <param name="circle">Окружность - линия построения или изображения, на которой устанавливается размер</param>
            <param name="type">Тип отрисовки диаметрального размера</param>
            <param name="fixNode">Узел привязки размерной стрелки</param>
            <param name="angle">Угол, на котором находится размерная стрелка (используется, если отсутствует fixNode)</param>
            <param name="offset">Расстояние от размерного числа до окружности (используется, если отсутствует fixNode)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircularDimension.SetOffsets(TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка положения размера на окружности</summary>
            <param name="fixNode">Узел привязки размерной стрелки</param>
            <param name="angle">Угол, на котором находится размерная стрелка (используется, если отсутствует fixNode)</param>
            <param name="offset">Расстояние от размерного числа до окружности (используется, если отсутствует fixNode)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CircularDimension.SetRadial(TFlex.Model.Model2D.Object2D,TFlex.Model.Model2D.RadialDimensionType,TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка радиального размера</summary>
            <param name="circle">Окружность - линия построения или изображения, на которой устанавливается размер</param>
            <param name="type">Тип отрисовки радиального размера</param>
            <param name="fixNode">Узел привязки размерной стрелки</param>
            <param name="angle">Угол, на котором находится размерная стрелка (используется, если отсутствует fixNode)</param>
            <param name="offset">Расстояние от размерного числа до окружности (используется, если отсутствует fixNode)</param>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimension.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircularDimension.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ</param>
        </member>
        <member name="T:TFlex.Model.Model2D.CircularDimension">
            <summary>Размер на окружности на 2D</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltTextAfter">
            <summary>Текст после числа альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltTextBefore">
            <summary>Текст перед числом альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltLocation">
            <summary>Расположение альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltAccuracy">
            <summary>Точность для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltMinDigits">
            <summary>Минимальное количество знаков после запятой для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltUnits">
            <summary>Тип единиц измерения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltTolerLowerDev">
            <summary>Величина нижнего отклонения допуска для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltTolerUpperDev">
            <summary>Величина верхнего отклонения допуска для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltTolerLetters">
            <summary>Поле допуска с квалитетом для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltSeparator">
            <summary>Тип разделителя для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltTolerType">
            <summary>Тип задания допуска для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltTextParameters">
            <summary>Параметры для отображения в тексте альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.FitView">
            <summary>Вид посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.TolerSize">
            <summary>Тип отображения допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.FitLowerDev">
            <summary>Величина нижнего отклонения посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.FitUpperDev">
            <summary>Величина верхнего отклонения посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.FitLetters">
            <summary>Поле посадки с квалитетом</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.PlaceFit">
            <summary>Параметр отображения посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.TolerLowerDev">
            <summary>Величина нижнего отклонения допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.TolerUpperDev">
            <summary>Величина верхнего отклонения допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.TolerLetters">
            <summary>Поле допуска с квалитетом</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.TolerAutomatic">
            <summary>Указывает на то, что допуск будет рассчитываться автоматически</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.StringsOffset">
            <summary>Величина смещения строк от размерной линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.Standard">
            <summary>Тип стандарта размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.OutsideArrows">
            <summary>Состояние флага отображения стрелок с внешней стороны</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.Cross">
            <summary>Состояние флага отображения крестика</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.PrefixSymbol">
            <summary>Символ перед размерным числом</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.Accuracy">
            <summary>Точность</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.MinDigits">
            <summary>Минимальное число знаков после запятой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.Units">
            <summary>Тип единиц измерения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.EndArrowSize">
            <summary>Размер конечной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.StartArrowSize">
            <summary>Размер начальной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.EndArrowType">
            <summary>Типа конечной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.StartArrowType">
            <summary>Тип начальной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltScaleFactor">
            <summary>Величина дополнительного масштабирования альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.AltScaleFactorType">
            <summary>Тип дополнительного масштабирования альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.ScaleFactor">
            <summary>Величина дополнительного масштабирования размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.ScaleFactorType">
            <summary>Тип дополнительного масштабирования размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.Dual">
            <summary>Режим отображения двойного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircularDimensionBase.CircularDimType">
            <summary>Подтип размера на окружности</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CircularDimensionBase">
            <summary>Базовый класс для размеров на окружности</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DiametralDimensionType">
            <summary>Типы диаметральных размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DiametralDimensionType.ExternalArrows">
            <summary>Стрелки снаружи</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DiametralDimensionType.Normal">
            <summary>Нормальное отображение</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.RadialDimensionType">
            <summary>Типы радиальных размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RadialDimensionType.Opposite">
            <summary>Стрелка от положения размерного числа до противоположной точки окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RadialDimensionType.FromPosition">
            <summary>Стрелка начинается от размерного числа (возможно - снаружи окружности)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.RadialDimensionType.Normal">
            <summary>Нормальное отображение</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CircularDimensionType">
            <summary>Типы размеров на окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircularDimensionType.ShortenedRadial">
            <summary>Радиальный, с изломом размерной линии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircularDimensionType.Diametral">
            <summary>Диаметральный</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircularDimensionType.Radial">
            <summary>Радиальный</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CircularDimensionType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.AngularDimension.SetLeaderNote(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNode1">Первый узел привязки, задает положение размерной линии</param>
            <param name="offset1">Смещение размерной линии относительно начала первой выносной линии (используется, если fixNode1 не задан)</param>
            <param name="fixLeaderNode">Второй узел привязки, задает положение выносной полки</param>
            <param name="dX">Смещение по горизонтали конца выносной полки относительно середины размерной линии (используется, если fixLeaderNode не задан)</param>
            <param name="dY">Смещение по вертикали конца выносной полки относительно середины размерной линии (используется, если fixLeaderNode не задан)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.AngularDimension.SetOffsets(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNode1">Первый узел привязки, задает положение размерной линии</param>
            <param name="offset1">Смещение размерной линии относительно начала первой выносной линии (используется, если fixNode1 не задан)</param>
            <param name="fixNode2">Второй узел привязки, задает положение размерного числа</param>
            <param name="offset2">Смещение размерного числа по дуге относительно середины размерной линии (используется, если fixNode2 не задан)</param>
            <param name="fixNode3">Третий узел привязки, задает положения конца полки размера</param>
            <param name="offset3">Смещение длина полки размера (используется, если fixNode3 не задан)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.AngularDimension.SetConstructionAndOutline(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Model2D.AnglePosition)">
            <summary>Установка параметров размера между линией построения и линией изображения</summary>
            <param name="line1">Прямая</param>
            <param name="node1">Узел, задающий положение начала выносной линии на прямой</param>
            <param name="line2">Отрезок</param>
            <param name="isOnEnd2">Указывает на то, что размер прикреплен к концу отрезка (иначе - к началу)</param>
            <param name="position">Между какими направлениями измеряется угол</param>
        </member>
        <member name="M:TFlex.Model.Model2D.AngularDimension.SetTwoConstructions(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.AnglePosition)">
            <summary>Установка параметров размера между двумя линиями построения</summary>
            <param name="line1">Первая прямая</param>
            <param name="node1">Узел, задающий положение начала выносной линии на прямой</param>
            <param name="line2">Вторая прямая</param>
            <param name="node2">Узел, задающий положение начала выносной линии на прямой</param>
            <param name="position">Между какими направлениями измеряется угол</param>
        </member>
        <member name="M:TFlex.Model.Model2D.AngularDimension.SetTwoOutlines(TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Model2D.AnglePosition)">
            <summary>Установка параметров размера между двумя линиями изображения</summary>
            <param name="line1">Первый отрезок</param>
            <param name="isOnEnd1">Указывает на то, что размер прикреплен к концу отрезка (иначе - к началу)</param>
            <param name="line2">Второй отрезок</param>
            <param name="isOnEnd2">Указывает на то, что размер прикреплен к концу отрезка (иначе - к началу)</param>
            <param name="position">Между какими направлениями измеряется угол</param>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimension.TextOnLine">
            <summary>Текст вдоль линии, а не по дуге</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimension.AngularDimType">
            <summary>Подтип углового размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimension.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.AngularDimension.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.AngularDimension">
            <summary>Угловой размер на 2D</summary>
            <example>
                <code name="Угловой размер">
public static void AngularDimension()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Размер");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 300, 400);//создание узла			
   FreeNode fn2 = new FreeNode(document, 400, 500);
		    
   FreeNode fn3 = new FreeNode(document, 400, 400);//создание узла			
   FreeNode fn4 = new FreeNode(document, 300, 480);

   LineConstruction l1 = new LineConstruction(document);//прямая1
   l1.SetThroughNodes(fn1, fn2);  
			
   LineConstruction l2 = new LineConstruction(document);//прямая2
   l2.SetThroughNodes(fn3, fn4);  

   AngularDimension a = new AngularDimension(document);//угловой размер
   //размер между двумя линиями изображения
   //(прямая1, начало выносной линии на прямой, прямая2, начало выносной линии на прямой, 
   // положения угловых размеров-между положительными направлениями линий(AnglePosition.BetweenHeadAndHead))
   a.SetTwoConstructions(l1, fn1, l2, fn3, AnglePosition.BetweenHeadAndHead);

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.TolerLowerDev">
            <summary>Величина нижнего отклонения допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.TolerUpperDev">
            <summary>Величина верхнего отклонения допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.TolerAutomatic">
            <summary>Указывает на то, что допуск будет рассчитываться автоматически</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.ExtOffset">
            <summary>Величина смещения выносных линий</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.StringsOffset">
            <summary>Величина смещения строк от размерной линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.Standard">
            <summary>Тип стандарта размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.OutsideArrows">
            <summary>Состояние флага отображения стрелок с внешней стороны</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.LinesType">
            <summary>Режим отображения размерных и выносных линий</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.Accuracy">
            <summary>Точность</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.MinDigits">
            <summary>Минимальное число знаков после запятой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.Units">
            <summary>Тип единиц измерения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.EndArrowSize">
            <summary>Размер конечной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.StartArrowSize">
            <summary>Размер начальной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.EndArrowType">
            <summary>Тип конечной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AngularDimensionBase.StartArrowType">
            <summary>Тип начальной стрелки</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.AngularDimensionBase">
            <summary>Базовый класс угловых размеров</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.AnglePosition">
            <summary>Положения угловых размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AnglePosition.BetweenTailAndTail">
            <summary>Между отрицательными направлениями линий</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AnglePosition.BetweenTailAndHead">
            <summary>Между отрицательным направлением 1-й линии и положительным направление 2-й</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AnglePosition.BetweenHeadAndTail">
            <summary>Между положительным направлением 1-й линии и отрицательным направление 2-й</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AnglePosition.BetweenHeadAndHead">
            <summary>Между положительными направлениями линий</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.AngularDimTypes">
            <summary>Типы угловых размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AngularDimTypes.ConstructionAndOutline">
            <summary>Между линиями построения и изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AngularDimTypes.TwoConstructions">
            <summary>Между двумя линиями построения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AngularDimTypes.TwoOutlines">
            <summary>Между двумя линиями изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.AngularDimTypes.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.Link(TFlex.Model.Model2D.LinearDimension.LinkedObject,TFlex.Model.Model2D.LinearDimension.LinkedObject)">
            <summary>Привязать размер к объектам</summary>
            <param name="start">Начальный объект привязки</param>
            <param name="end">Конечный объект привязки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimension.LinkedEnd">
            <summary>Конечный объект привязки размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimension.LinkedStart">
            <summary>Начальный объект привязки размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimension.LinkedObject.IsEnding">
            <summary>Конец или начало линии привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimension.LinkedObject.Line">
            <summary>Линия привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimension.LinkedObject.LinkedLineType">
            <summary>Тип линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimension.LinkedObject.Node">
            <summary>Узел привязки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimension.LinkedObject.LineType.Outline">
            <summary>Линия изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimension.LinkedObject.LineType.Construction">
            <summary>Линия построения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimension.LinkedObject.LineType.Undefined">
            <summary>Отсутствует</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LinearDimension.LinkedObject.LineType">
            <summary>Типы линий привязки</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LinearDimension.LinkedObject">
            <summary>Объект привязки размера</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.ForceCenter">
            <summary>Принудительное центрирование размера</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetLeaderNote(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNode1">Первый узел привязки, задает положение размерной линии</param>
            <param name="offset1">Смещение размерной линии относительно начала первой выносной линии (используется, если fixNode1 не задан)</param>
            <param name="fixLeaderNode">Второй узел привязки, задает положение выносной полки</param>
            <param name="dX">Смещение по горизонтали конца выносной полки относительно середины размерной линии (используется, если fixLeaderNode не задан)</param>
            <param name="dY">Смещение по вертикали конца выносной полки относительно середины размерной линии (используется, если fixLeaderNode не задан)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetOffsets(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNode1">Первый узел привязки, задает положение размерной линии</param>
            <param name="offset1">Смещение размерной линии относительно начала первой выносной линии (используется, если fixNode1 не задан)</param>
            <param name="fixNode2">Второй узел привязки, задает положение размерного числа</param>
            <param name="offset2">Смещение размерного числа относительно середины размерной линии (используется, если fixNode2 не задан)</param>
            <param name="fixNode3">Третий узел привязки, задает положения конца полки размера</param>
            <param name="offset3">Смещение длины полки размера (используется, если fixNode3 не задан)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetArcLength(TFlex.Model.Model2D.Object2D,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,System.Boolean)">
            <summary>Установка параметров размера - длины дуги</summary>
            <param name="arcOrCircle">Измеряемая дуга, либо окружность, часть которой меряется</param>
            <param name="node1">Узел, с которого (против часовой стрелки) начинается измерение</param>
            <param name="node2">Узел, на котором (против часовой стрелки) заканчивается измерение</param>
            <param name="linesAreRadial">Указывает на то, что выносныме линии размера должны быть радиальными (иначе - параллельны друг другу)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetTwoNodesAndLine(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Object2D)">
            <summary>Установка параметров размера между двумя узлами, перпендикулярно линии</summary>
            <param name="node1">Первый узел</param>
            <param name="node2">Второй узел</param>
            <param name="guideLine">Направляющая линия (построения или изображения)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetOutlineAndNode(TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Model2D.Node)">
            <summary>Установка параметров размера между линией изображения и узлом</summary>
            <param name="line1">Отрезок</param>
            <param name="isOnEnd1">Указывает на то, что размер прикреплен к концу отрезка (иначе - к началу)</param>
            <param name="node2">Узел, до которого измеряется расстояние</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetConstructionAndNode(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Установка параметров размера между линией построения и узлом</summary>
            <param name="line1">Прямая</param>
            <param name="node1">Узел, задающий положение начала выносной линии на прямой</param>
            <param name="node2">Узел, до которого измеряется расстояние</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetConstructionAndOutline(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Outline,System.Boolean)">
            <summary>Установка параметров размера между линией построения и линией изображения</summary>
            <param name="line1">Прямая</param>
            <param name="node1">Узел, задающий положение начала выносной линии на прямой</param>
            <param name="line2">Отрезок</param>
            <param name="isOnEnd2">Указывает на то, что размер прикреплен к концу отрезка (иначе - к началу)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetTwoConstructions(TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Node)">
            <summary>Установка параметров размера между двумя линиями построения</summary>
            <param name="line1">Первая прямая</param>
            <param name="node1">Узел, задающий положение начала выносной линии на прямой</param>
            <param name="line2">Вторая прямая</param>
            <param name="node2">Узел, задающий положение начала выносной линии на прямой</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetTwoOutlines(TFlex.Model.Model2D.Outline,System.Boolean,TFlex.Model.Model2D.Outline,System.Boolean,System.Boolean)">
            <summary>Установка параметров размера между двумя линиями изображения</summary>
            <param name="line1">Первый отрезок</param>
            <param name="isOnEnd1">Указывает на то, что размер прикреплен к концу отрезка (иначе - к началу)</param>
            <param name="line2">Второй отрезок</param>
            <param name="isOnEnd2">Указывает на то, что размер прикреплен к концу отрезка (иначе - к началу)</param>
            <param name="isConusDim">Параметр, показывающий что размер ставится на конусе, ребрами которого являются отрезки, иначе - размер берётся как расстояние между отрезками</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetSegment(TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.DimensionAlignType)">
            <summary>Установка параметров размера на отрезке</summary>
            <param name="line1">Отрезок</param>
            <param name="align">Тип измерения</param>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.SetTwoNodes(TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.DimensionAlignType)">
            <summary>Установка параметров размера между двумя узлами</summary>
            <param name="node1">Первый узел</param>
            <param name="node2">Второй узел</param>
            <param name="align">Тип измерения</param>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimension.LinearDimType">
            <summary>Подтип размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimension.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LinearDimension.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LinearDimension">
            <summary>Класс линейного размера на 2D</summary>
            <example>
                <code name="Линейный размер">
public static void LinearDimension()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Размер");//Открытие блока изменений документа

   LinearDimension linearDimension = new LinearDimension(document);
   linearDimension.SetTwoNodes(new FreeNode(document, 75, 680), new FreeNode(document, 125, 680), DimensionAlignType.Horizontal);						
   linearDimension.TolerUpperDev = 10;//Величина верхнего отклонения допуска
   linearDimension.TolerLowerDev = -5;//Величина нижнего отклонения допуска
   linearDimension.TolerLetters = "TolerLetters";//Поле допуска с квалитетом
   linearDimension.StartArrowType = 1;//Тип начальной стрелки
   linearDimension.EndArrowType = 4;//Тип конечной стрелки

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltTextAfter">
            <summary>Текст после числа альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltTextBefore">
            <summary>Текст перед числом альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltLocation">
            <summary>Расположение альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltAccuracy">
            <summary>Точность для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltMinDigits">
            <summary>Минимальное количество знаков после запятой для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltUnits">
            <summary>Единицы измерения для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltTolerLowerDev">
            <summary>Величина нижнего отклонения допуска для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltTolerUpperDev">
            <summary>Величина верхнего отклонения допуска для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltTolerLetters">
            <summary>Поле допуска с квалитетом для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltSeparator">
            <summary>Тип разделителя для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltTolerType">
            <summary>Тип задания допуска для альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltTextParameters">
            <summary>Параметры для отображения в тексте альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.FitView">
            <summary>Вид посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.TolerSize">
            <summary>Тип отображения допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.FitLowerDev">
            <summary>Величина нижнего отклонения посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.FitUpperDev">
            <summary>Величина верхнего отклонения посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.FitLetters">
            <summary>Поле посадки с квалитетом</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.PlaceFit">
            <summary>Параметр отображения посадки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.TolerLowerDev">
            <summary>Величина нижнего отклонения допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.TolerUpperDev">
            <summary>Величина верхнего отклонения допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.TolerLetters">
            <summary>Поле допуска с квалитетом</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.TolerAutomatic">
            <summary>Параметр автоматического расчёта допуска</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.ExtOffset">
            <summary>Величина смещения выносных линий</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.StringsOffset">
            <summary>Величина смещения строк от размерной линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.Standard">
            <summary>Тип стандарта размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.OutsideArrows">
            <summary>Состояние флага отображения стрелок с внешней стороны</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.LinesType">
            <summary>Режим отображения размерных и выносных линий</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.PrefixSymbol">
            <summary>Символ перед размерным числом</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.Accuracy">
            <summary>Точность</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.MinDigits">
            <summary>Минимальное число знаков после запятой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.Units">
            <summary>Единицы измерения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.EndArrowSize">
            <summary>Размер конечной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.StartArrowSize">
            <summary>Размер начальной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.EndArrowType">
            <summary>Тип конечной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.StartArrowType">
            <summary>Тип начальной стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltScaleFactor">
            <summary>Величина дополнительного масштабирования альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.AltScaleFactorType">
            <summary>Тип дополнительного масштабирования альтернативного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.ScaleFactor">
            <summary>Величина дополнительного масштабирования размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.ScaleFactorType">
            <summary>Тип дополнительного масштабирования размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.Dual">
            <summary>Режим отображения двойного размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LinearDimensionBase.Leader">
            <summary>Параметр отображения размера с выносной полкой</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LinearDimensionBase">
            <summary>Базовый класс линейных размеров</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LinearDimensionType">
            <summary>Типы линейных размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.ArcLength">
            <summary>Длина дуги</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.TwoNodesAndLine">
            <summary>Расстояние между узлами, в направлении, перпендикулярном линии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.OutlineAndNode">
            <summary>Расстояние от узла до отрезка</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.ConstructionAndNode">
            <summary>Расстояние от узла до прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.ConstructionAndOutline">
            <summary>Расстояние между прямой и отрезком</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.TwoConstructions">
            <summary>Расстояние между прямыми</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.TwoOutlines">
            <summary>Расстояние между отрезками</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.Segment">
            <summary>Длина отрезка</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.TwoNodesVertical">
            <summary>Расстояние между двумя узлами по вертикали</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.TwoNodesHorizontal">
            <summary>Расстояние между двумя узлами по горизонтали</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.TwoNodes">
            <summary>Между двумя узлами</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.LinearDimensionType.Undefined">
            <summary>Не задан</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionDrawStyle">
            <summary>Типы отрисовки размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionDrawStyle.LeaderNote">
            <summary>Отрисовка с выносной полкой</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionDrawStyle.Offsets">
            <summary>Отрисовка по смещениям</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionAlignType">
            <summary>Типы измерения для линейных размеров между узлами</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAlignType.ParallelShift">
            <summary>Расстояние, выносные линии под наклоном</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAlignType.Vertical">
            <summary>Расстояние по вертикали</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAlignType.Horizontal">
            <summary>Расстояние по горизонтали</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAlignType.Distance">
            <summary>Расстояние</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Offset3">
            <summary>Отступ размера. Тип отступа зависит от типа размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Offset2">
            <summary>Отступ размера. Тип отступа зависит от типа размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Offset1">
            <summary>Отступ размера. Тип отступа зависит от типа размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.BoxAroundText">
            <summary>Рамка вокруг текста</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Dimension.SetDefaults">
            <summary>Установка параметров размера в соответствии с параметрами по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.FontStyle">
            <summary>Получение стиля шрифта текста для получения или установки его параметров</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Priority">
            <summary>Приоритет объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Level">
            <summary>Уровень объекта</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Color">
            <summary>Цвет объекта</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Page">
            <summary>Страница, на которой размещается элемент</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ClearUnderEndArrow">
            <summary>Параметр очистки фона под второй стрелкой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ClearUnderStartArrow">
            <summary>Параметр очистки фона под первой стрелкой</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ClearUnderLines">
            <summary>Параметр очистки фона под выносными линиями</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ClearUnderArrows">
            <summary>Параметр очистки фона под стрелками и размерной линией</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.TextParameters">
            <summary>Способ отображения параметров размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.NominalOnlyText">
            <summary>Строка текста со значением только номинала размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ValueText">
            <summary>Строка текста со значением размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.TextUnder">
            <summary>Строка текста под текстом значения размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.TextAfter">
            <summary>Строка текста после текстом значения размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.TextBefore">
            <summary>Строка текста перед текстом значения размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.LeaderDirection">
            <summary>Направление полки с размерным числом</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ParentDimension">
            <summary>Родительский размер</summary>
            <remarks>Используется для определения положения в списке размеров в цепи, от базы, строительных</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.State">
            <summary>Тип положения размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.AltValueCorrection">
            <summary>Коррекция номинала альтернативного размера (применяется после применения масштаба)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ValueCorrection">
            <summary>Коррекция номинала размера (применяется после применения масштаба)</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ManualValueCorrection">
            <summary>Использование заданного вручную значения коррекции размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.ValueType">
            <summary>Способ формирования строки номинала размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.HasSourceLines">
            <summary>Проверить размер на возможность приведения параметра номинала размера к типу "По исходным линиям"</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.Value">
            <summary>Численное значение размера</summary>
            <remarks>Если у размера не установлен параметр простановки значения "вручную", новое значение не будет установлено.</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.Dimension.SetValue(System.Double)">
            <summary>Установка значения размера</summary>
            <remarks>Данная функция пересчитывает параметры модели таким образом, чтобы значение размера стало равным устанавливаемому.</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Dimension.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Dimension.ResetParameters">
            <summary>Установка параметров размера по-умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Dimension">
            <summary>Базовый класс размера</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionValueType">
            <summary>Способы формирования строки номинала размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionValueType.FromSourceObjects">
            <summary>Расчет по исходным объектам (для размеров на ассоциативных копиях)</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionValueType.From3dParent">
            <summary>С родительского 3D размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionValueType.FromExtraData">
            <summary>Обозначение берётся из дополнительных данных с родительских объектов</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionValueType.Manual">
            <summary>Вручную</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionValueType.AutoCount">
            <summary>Расчет</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionValueType.NoNominal">
            <summary>Нет номинала</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionAltDimSeparatorType">
            <summary>Типы разделителя альтернативного размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimSeparatorType.RoundBraces">
            <summary>Круглые скобки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimSeparatorType.Braces">
            <summary>Фигурные скобки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimSeparatorType.Brackets">
            <summary>Квадратные скобки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimSeparatorType.None">
            <summary>Нет</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimSeparatorType.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionAltDimLocationType">
            <summary>Типы расположения альтернативного размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimLocationType.Above">
            <summary>Над</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimLocationType.Under">
            <summary>Под</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimLocationType.Before">
            <summary>До</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimLocationType.After">
            <summary>После</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltDimLocationType.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionDualDimType">
            <summary>Тип отображения двойного размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionDualDimType.Off">
            <summary>Не отображать</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionDualDimType.On">
            <summary>Отображать</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionDualDimType.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionTolerSizeType">
            <summary>Типы отображения допуска</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionTolerSizeType.FullHeight">
            <summary>Полный размер шрифта</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionTolerSizeType.ReducedHeight">
            <summary>Уменьшенный размер шрифта</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionScaleFactorType">
            <summary>Типы дополнительного масштабирования размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionScaleFactorType.Custom">
            <summary>Пользователя</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionScaleFactorType.MetricToInch">
            <summary>Метры/дюймы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionScaleFactorType.InchToMetric">
            <summary>Дюймы/метры</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionScaleFactorType.No">
            <summary>Нет</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionScaleFactorType.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionAngularUnits">
            <summary>Типы единиц измерения угловых размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAngularUnits.DecimalFractionComma">
            <summary>Десятичная дробь с запятой в качестве разделителя</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAngularUnits.MinutesAndSeconds">
            <summary>С минутами с секундами</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAngularUnits.DecimalFraction">
            <summary>Десятичная дробь</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAngularUnits.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionLinearUnits">
            <summary>Типы единиц измерения линейных размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLinearUnits.MetricComma">
            <summary>В метрической системе, с запятой в качестве разделителя</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLinearUnits.InchDiversity">
            <summary>В дюймах с разностью</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLinearUnits.InchFraction">
            <summary>В дюймах с дробью</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLinearUnits.Inch">
            <summary>В дюймах</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLinearUnits.Metric">
            <summary>В метрической системе</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLinearUnits.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionStandardType">
            <summary>Стандарт размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionStandardType.ISO">
            <summary>ЕСКД</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionStandardType.BS309">
            <summary>AR_ANSI</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionStandardType.ANSI">
            <summary>ANSI</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionStandardType.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionAltTolerType">
            <summary>Тип проставления допуска у альтернативного размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltTolerType.Manually">
            <summary>Вручную</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltTolerType.AutoISO">
            <summary>Авто-ЕСКД</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltTolerType.AutoANSI">
            <summary>Авто-ANSI</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionAltTolerType.AutoScale">
            <summary>Авто-Масштаб</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionViewType">
            <summary>Параметры отображения размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionViewType.AllParameters">
            <summary>Все параметры</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionViewType.NominalAndTolerance">
            <summary>Отображать номинал и поле допуска</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionViewType.NominalAndDeviations">
            <summary>Отображать номинал и отклонение</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionViewType.Limits">
            <summary>Отображать пределы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionViewType.Nominal">
            <summary>Отображать номинал</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionViewType.Default">
            <summary>По умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionFitViewType">
            <summary>Типы расположения посадки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionFitViewType.Diagonal">
            <summary>Диагональная дробь</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionFitViewType.Horizontal">
            <summary>Горизонтальная дробь</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionLines">
            <summary>Типы отрисовки выносных и размерных линий</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.OnlyText">
            <summary>Рисовать только текст</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.NoLines">
            <summary>Не рисовать выносные линии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.NoRightLine">
            <summary>Не рисовать правую выносную линию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.NoLeftLine">
            <summary>Не рисовать левую выносную линию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.NoRightArrow">
            <summary>Не рисовать правую стрелку и выносную линию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.NoLeftArrow">
            <summary>Не рисовать левую стрелку и выносную линию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.LeftHalf">
            <summary>Рисовать только левую половину размерной линии и выносную линию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.RightHalf">
            <summary>Рисовать только правую половину размерной линии и выносную линию</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLines.Full">
            <summary>Рисовать все</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionPrefixSymbol">
            <summary>Символы - префиксы размерного числа</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionPrefixSymbol.Sphere">
            <summary>Сфера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionPrefixSymbol.Scuare">
            <summary>Квадрат</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionPrefixSymbol.Thread">
            <summary>Резьба</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionPrefixSymbol.Diameter">
            <summary>Диаметр</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionPrefixSymbol.Radius">
            <summary>Радиус</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionPrefixSymbol.None">
            <summary>Нет символа</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionLeaderDirection">
            <summary>Направления полки у размера</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLeaderDirection.Right">
            <summary>Полка вправо</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLeaderDirection.Left">
            <summary>Полка влево</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionLeaderDirection.None">
            <summary>Нет полки</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionState">
            <summary>Положения размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionState.FromBase">
            <summary>Размер от базы</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionState.InChain">
            <summary>В цепочке</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionState.Normal">
            <summary>Обычный одиночный размер</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.DimensionType">
            <summary>Типы размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.ProjectedAngularDimension">
            <summary>Спроецированный угловой размер</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.ProjectedCircularDimension">
            <summary>Спроецированный размер на окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.ProjectedLinearDimension">
            <summary>Спроецированный линейный размер</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.CircularDimension3D">
            <summary>Размер на окружности на 3D</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.AngularDimension3D">
            <summary>Угловой размер на 3D</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.LinearDimension3D">
            <summary>Линейный размер на 3D</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.ConstructionDimension">
            <summary>Строительный размер</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.CircularDimension">
            <summary>Размер на окружности на 2D</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.AngularDimension">
            <summary>Угловой размер на 2D</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.LinearDimension">
            <summary>Линейный размер на 2D</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.DimensionType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="T:DIMENSION.DistanceChirality">
Полупространство
</member>
        <member name="M:DIMENSION.GetStatusCode">
Данные для решателя ограничений
</member>
        <member name="M:DIMENSION.ReplaceCharacteristicDataReferences(CharacteristicDataToReplace!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Заменить ссылки на характерные данные других объектов </summary>
            <remarks> Если входящие данные не находят соответствия как-либо ссылке, то она просто пропускается. </remarks>
            <param name="iData"> Входящие данные для замены ссылок </param>
            <returns> false, если хотя бы одна ссылка была удалена, true - иначе </returns>
        </member>
        <member name="T:Constraints2D.GeometryCode.Codes">
Коды результатов поиска решений на ограничениях
</member>
        <member name="T:Constraints2D.GeometryCode">
Диагностика результатов поиска решения на геометрии
</member>
        <member name="T:Constraints2D.ConstraintCode.Codes">
Коды результатов поиска решений на ограничениях
</member>
        <member name="T:Constraints2D.ConstraintCode">
Диагностика результатов поиска решения ограничений
</member>
        <member name="T:Constraints2D.SystemCode.Codes">
Общие коды результатов
</member>
        <member name="T:Constraints2D.SystemCode">
Общий код результата
</member>
        <member name="M:LinearBy3PointsDIMENSIONConstraints2D.GetCoincident2">
Совпадение второй точки с прямой
</member>
        <member name="M:LinearBy3PointsDIMENSIONConstraints2D.GetCoincident1">
Совпадение первой точки с прямой
</member>
        <member name="M:LinearBy3PointsDIMENSIONConstraints2D.GetLine">
Линия, на которой лежат две точки. Размер строится между этой линией и третьей точкой
</member>
        <member name="T:LinearBy3PointsDIMENSIONConstraints2D">
Данные для решателя ограничений. Размер по трём точкам
</member>
        <member name="M:CurveLengthDIMENSIONConstraints2D.GetEquation">
Линейное уравнение, связывающее значение суммарной длины составной кривой и сумму переменных, задающих длины отдельных кривых
</member>
        <member name="M:CurveLengthDIMENSIONConstraints2D.GetID2Length">
Массив ограничений на длину каждой кривой
</member>
        <member name="T:CurveLengthDIMENSIONConstraints2D">
Данные для решателя ограничений
</member>
        <member name="T:SplineDistanceDIMENSIONConstraints2D">
Данные для решателя ограничений
</member>
        <member name="T:DIMENSIONConstraints2D">
Данные для решателя ограничений
</member>
        <member name="T:DIMENSIONConstraints2DBase">
Данные для решателя ограничений
</member>
        <member name="M:LcsUtils.TranslatePointsInLcs(FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,std.list&lt;std.reference_wrapper&lt;TFPoint&gt;,std.allocator&lt;std.reference_wrapper&lt;TFPoint&gt;&gt;&gt;)">
            <summary> Перевести точки из СК страницы в ЛСК </summary>
            <param name="iLcs"> ЛСК в которую нужно перевести точки </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <param name="iPoints"> Точки </param>
        </member>
        <member name="M:LcsUtils.TranslatePointsInPageCs(FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,std.list&lt;std.reference_wrapper&lt;TFPoint&gt;,std.allocator&lt;std.reference_wrapper&lt;TFPoint&gt;&gt;&gt;)">
            <summary> Перевести точки из ЛСК в СК страницы </summary>
            <param name="iLcs"> ЛСК в которой заданы точки </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <param name="iPoints"> Точки </param>
        </member>
        <member name="M:LcsUtils.GetPointInPageCs(FIXING_POINT!System.Runtime.CompilerServices.IsConst*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить координаты точки (заданной в ЛСК) в СК страницы </summary>
            <param name="iLcs"> ЛСК </param>
            <param name="iPointInLcs"> Точка, заданная в ЛСК iLcs </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в СК страницы </returns>
        </member>
        <member name="M:LcsUtils.GetPointInLcs(FIXING_POINT!System.Runtime.CompilerServices.IsConst*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить координаты точки (заданной в СК страницы) в ЛСК </summary>
            <param name="iLcs"> ЛСК </param>
            <param name="iPointInPageCS"> Точка, заданная в СК страницы </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в ЛСК </returns>
        </member>
        <member name="M:TFModelPoint.Regenerate(TFDocument*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFDocRegenContext*)">
Методы для вызова в соответствующих виртуальных методах объектов, содержащих TFModelPoint
</member>
        <member name="M:TFModelPoint.DetachNode(CTFObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,TFDocument!System.Runtime.CompilerServices.IsConst*)">
            <summary> Отвязаться от узла (обновляет координаты из узла) </summary>
            <param name="srcDoc"> Документ </param>
            <param name="setNodeCoords"> false, если не требуется обновление координат </param>
            <returns> true - если удалось получить узел, обновить координаты и отвязаться от него </returns>
        </member>
        <member name="M:TFModelPoint.UpdateWithConstraints(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Обновить с учётом ограничений </summary>
            <param name="iDoc"> Документ </param>
            <param name="iToModelScale"> Коэффициент преобразования в координаты модели </param>
            <param name="iPageScale"> Масштаб страницы </param>
        </member>
        <member name="M:TFModelPoint.GetPointInActiveLcs(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить точку в активной системе координат </summary>
            <param name="iDoc"> Документ </param>
            <returns> Точка в активной системе координат </returns>
        </member>
        <member name="M:TFModelPoint.GetPointInSpecifiedLcs(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить точку в указанной системе координат </summary>
            <param name="iDoc"> Документ </param>
            <param name="iLcs"> Система координт (если nullptr, то возвращает точку в СК страницы без учёта масштаба(!)) </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в указанной системе координат </returns>
        </member>
        <member name="M:TFModelPoint.GetPointInLcs(STATUS!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить точку в локальной системе координат (если ЛСК не задана, то в СК страницы без учёта масштаба(!)) </summary>
            <param name="lcsStatus"> Страница, ЛСК которой используется </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в локальной системе координат </returns>
        </member>
        <member name="M:TFModelPoint.GetPoint(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить точку в системе координат страницы </summary>
            <param name="iDoc"> Документ </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в системе координат страницы </returns>
        </member>
        <member name="M:TFModelPoint.SetPoint(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Задать точку (копирует все данные из входящей точки, кроме данных, относящихся к решателю ограничений) </summary>
            <param name="iPoint"> Входящая точка, из которой будут скопированны данные </param>
        </member>
        <member name="M:TFModelPoint.SetPoint(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Задать точку с учётом ЛСК (преобразует точку из системы координат страницы в координаты ЛСК, если она есть) </summary>
            <param name="iDoc"> Документ </param>
            <param name="iPointInPageCS"> Точка в системе координат страницы (с учётом масштаба) </param>
            <param name="iPageScale"> Масштаб страницы </param>
        </member>
        <member name="M:TFModelPoint.SetPoint(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Задать точку с выбором новой ЛСК (преобразует точку из системы координат страницы в координаты ЛСК) </summary>
            <param name="iPointInPageCS"> Точка в системе координат страницы (с учётом масштаба) </param>
            <param name="iLcs"> Новая локальная система координат </param>
            <param name="iPageScale"> Масштаб страницы </param>
        </member>
        <member name="M:TFModelPoint.SetPointByActivePage(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,STATUS!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Задать точку с выбором новой ЛСК (активной да данной странице) и масштабом (преобразует точку из системы координат страницы в координаты ЛСК) </summary>
            <param name="iPointInPageCS"> Точка в системе координат страницы (с учётом масштаба) </param>
            <param name="iPage"> Страница, с которой будет взята активная ЛСК и масштаб </param>
        </member>
        <member name="M:TFModelPoint.SetPoint(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Задать точку с выбором новой ЛСК (преобразует точку из системы координат страницы в координаты ЛСК) </summary>
            <param name="iDoc"> Документ </param>
            <param name="iPointInPageCS"> Точка в системе координат страницы (с учётом масштаба) </param>
            <param name="iLcs"> Индекс новой локальной системы координат </param>
            <param name="iPageScale"> Масштаб страницы </param>
        </member>
        <member name="M:TFModelPoint.IsInPageCs(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Проверка задана ли точка в СК страницы </summary>
            <param name="iDoc"> Документ </param>
            <returns> true - если точка задана в СК страницы, false - иначе </returns>
        </member>
        <member name="M:TFModelPoint.GetLcsIndex">
            <summary> Получить индекс локальной системы координат, в которой задана точка </summary>
            <returns> Индекс локальной системы координат (если точка задана в СК страницы, то -1) </returns>
        </member>
        <member name="T:FIXING_POINT">
            <summary> Получить локальную систему координат, в которой задана точка </summary>
            <param name="iDoc"> Документ </param>
            <returns> Указатель на локальную систему координат (если ЛСК не задана - nullptr) </returns>
        </member>
        <member name="M:TFModelPoint.HaveNode">
            <summary> Проверка на наличие узла </summary>
            <returns> true - если узел есть, false - иначе </returns>
        </member>
        <member name="M:TFModelPoint.GetNodeIndex">
            <summary> Получить индекс узла, которым задана точка </summary>
            <returns> Индекс узла (если узел не задан, то -1) </returns>
        </member>
        <member name="T:KNOT">
            <summary> Получить узел, которым задана точка </summary>
            <param name="iDoc"> Документ </param>
            <returns> Указатель узел (если узел не задан - nullptr) </returns>
            <summary> Получить узел, которым задана точка </summary>
            <param name="iDoc"> Документ </param>
            <returns> Указатель узел (если узел не задан - nullptr) </returns>
        </member>
        <member name="M:TFModelPoint.SetNode(System.Int32)">
            <summary> Устновить узел, задающий точку </summary>
            <param name="iNode"> Индекс узла </param>
        </member>
        <member name="M:TFModelPoint.op_Equality(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор сравнения
</member>
        <member name="M:TFModelPoint.op_Assign(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор присваивания (копирует указатели на данные для ограничений)
</member>
        <member name="M:TFModelPoint.#ctor(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
Конструктор для точки, заданной в глобальной системе координат, с переводом в локальную
</member>
        <member name="M:TFModelPoint.#ctor(System.Double,System.Double,System.Int32)">
Конструктор для точки, заданной координатами в глобальной или локальной системе координат
</member>
        <member name="M:TFModelPoint.#ctor(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Конструктор для точки, заданной координатами в глобальной или локальной системе координат
</member>
        <member name="M:TFModelPoint.#ctor(System.Int32!System.Runtime.CompilerServices.IsConst)">
Конструктор для точки, заданной узлом
</member>
        <member name="M:TFModelPoint.#ctor(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Копирующий конструктор
</member>
        <member name="M:TFModelPoint.#ctor">
Конструктор по умолчанию
</member>
        <member name="M:TFMiddlePointConstraints2D.GetMiddle">
Точка на средней линии двух концов отрезка
</member>
        <member name="T:TFMiddlePointConstraints2D">
Точка на середине отрезка
</member>
        <member name="M:TFModelPointConstraints2DFixParameter.GetFixParameter">
Методы получения данных для решателя ограничений
</member>
        <member name="T:TFModelPointConstraints2DFixParameter">
Фиксация параметра на кривой
</member>
        <member name="M:TFModelPointConstraints2D.GetConstraintPoint">
Методы получения данных для решателя ограничений
</member>
        <member name="T:TFModelPointConstraints2D">
Данные для решателя ограничений
</member>
        <member name="M:TFlex.Container.GetDocumentPtr(TFlex.Model.Document)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Container.GetDocument(System.IntPtr)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Container.GetFileLink(System.IntPtr)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Container.UndoIsOpen">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Container.ForceRollbackUndoIfOpen">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="P:TFlex.Container.Manager">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="T:TFlex.Container">
            <summary>Класс для внутреннего использования</summary>
        </member>
        <member name="T:TFlex.IManaged3dApi">
            <summary>Интерфейс для внутреннего использования</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointEllipseOutline.Radius">
            <summary>Радиус эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointEllipseOutline.EndNode">
            <summary>Конечная точка эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointEllipseOutline.StartNode">
            <summary>Начальная точка эллипса</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.TwoPointEllipseOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="startNode">Начальная точка эллипса</param>
            <param name="endNode">Конечная точка эллипса</param>
            <param name="radius">Радиус эллипса</param>
        </member>
        <member name="T:TFlex.Model.Model2D.TwoPointEllipseOutline">
            <summary>Эллипс через две точки и радиус</summary>
            <example>
                <code name="Эллипс через две точки и радиус">
public static void TwoPointEllipseOutline()
{		
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 560, 460);			
   FreeNode fn2 = new FreeNode(document, 600, 460);
   double r = 15;
   //Эллипс через две точки и радиус
   TwoPointEllipseOutline twoPointEllipseOutline = new TwoPointEllipseOutline(document, fn1, fn2, r);

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseOutline.Radius">
            <summary>Радиус эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseOutline.Point">
            <summary>Точка эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseOutline.CenterNode">
            <summary>Центр эллипса</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="center">Центр эллипса</param>
            <param name="point">Точка эллипса</param>
            <param name="radius">Радиус эллипса</param>
        </member>
        <member name="T:TFlex.Model.Model2D.EllipseOutline">
            <summary>Эллипс по центру и точке</summary>
            <example>
                <code name="Эллипс по центру и точке">
public static void EllipseOutline()
{		
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 580, 400);			
   FreeNode fn2 = new FreeNode(document, 520, 400);
   double r = 25;
   EllipseOutline ellipseOutline = new EllipseOutline(document, fn1, fn2, r);//Эллипс по центру и точке

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcOutline.ArcNode">
            <summary>Точка на дуге эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcOutline.EndNode">
            <summary>Конечная точка дуги эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcOutline.StartNode">
            <summary>Начальная точка дуги эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcOutline.CenterNode">
            <summary>Центр дуги эллипса</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseArcOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="center">Центр дуги эллипса</param>
            <param name="startNode">Начальная точка дуги эллипса</param>
            <param name="endNode">Конечная точка дуги эллипса</param>
            <param name="arcNode">Точка на дуге эллипса</param>
        </member>
        <member name="T:TFlex.Model.Model2D.EllipseArcOutline">
            <summary>Дуга эллипса</summary>
            <example>
                <code name="Дуга эллипса">
public static void EllipseArcOutline()
{		
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
	
   FreeNode fn1 = new FreeNode(document, 580, 320);			
   FreeNode fn2 = new FreeNode(document, 550, 320);
   FreeNode fn3 = new FreeNode(document, 610, 320);			
   FreeNode fn4 = new FreeNode(document, 580, 360);	
   EllipseArcOutline ellipseArcOutline = new EllipseArcOutline(document, fn1, fn2, fn3, fn4);//Дуга эллипса

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlinesIntersection.Level">
            <summary>Уровень</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlinesIntersection.Page">
            <summary>Страница</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlinesIntersection.LineWidth">
            <summary>Толщина линии</summary>
            <example>
                <code name="Установка толщины линии">
public static void SetLineWidth(ModelObject ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка толщины линии");//Открытие блока изменений документа

   ob.LineWidth = 3;	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlinesIntersection.Size">
            <summary>Размер</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlinesIntersection.Form">
            <summary>Форма пересечения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlinesIntersection.PointIndex">
            <summary>номер точки пересечения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlinesIntersection.Outline2">
            <summary>Вторая линия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.OutlinesIntersection.Outline1">
            <summary>Первая линия</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.OutlinesIntersection.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline,System.Int32,TFlex.Model.Model2D.OutlinesIntersection.Forms,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="outline1">Первая линия изображения</param>
            <param name="outline2">Вторая линия изображения</param>
            <param name="point">Номер точки пересечения</param>
            <param name="form">Форма обозначения</param>
            <param name="size">Размер обозначения</param>
            <param name="lineWidth">Толлщина линии обозначения</param>
        </member>
        <member name="T:TFlex.Model.Model2D.OutlinesIntersection.Forms">
            <summary>Форма пересечения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.OutlinesIntersection">
            <summary>Обозначение пересечения линий изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AxisOutline.Limit2Outline">
            <summary>Вторая ограничивающая линия изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AxisOutline.Limit1Outline">
            <summary>Первая ограничивающая линия изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AxisOutline.Source2Outline">
            <summary>Вторая исходная линия изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.AxisOutline.Source1Outline">
            <summary>Первая исходная линия изображения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.AxisOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="source1">Первая исходная линия изображения</param>
            <param name="source2">Вторая исходная линия изображения</param>
            <param name="limit1">Первая ограничивающая линия изображения</param>
            <param name="limit2">Вторая ограничивающая линия изображения</param>
        </member>
        <member name="M:TFlex.Model.Model2D.AxisOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="source1">Первая исходная линия изображения</param>
            <param name="source2">Вторая исходная линия изображения</param>
        </member>
        <member name="P:TFlex.Model.Model2D.AxisOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.AxisOutline">
            <summary>Линия изображения - ось двух других линий изображения</summary>
            <example>
                <code name="Ось двух других линий изображения">	
public static void AxisOutline()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fnCenter = new FreeNode(document, 200, 370);//создание узла
   int r1 = 50;
   CircleOutline co = new  CircleOutline(document, fnCenter, r1);//окружность
   CenterAxisOutline cao = new CenterAxisOutline(document, co, false);//центральная ось окружности
   FreeNode fn1 = new FreeNode(document, 400, 320);		
   FreeNode fn2 = new FreeNode(document, 400, 420);
   ConstructionOutline conOutline = new ConstructionOutline(document, fn1, fn2);
   //ось двух линий изображения (центральной оси окружности и прямой)
   AxisOutline axOutline = new AxisOutline(document, cao, conOutline);

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.Limit2Node">
            <summary>Второй ограничивающий узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.Limit1Node">
            <summary>Первый ограничивающий узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.Limit2Outline">
            <summary>Вторая ограничивающая линия изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.Limit1Outline">
            <summary>Первая ограничивающая линия изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.CenterOutline">
            <summary>Линия изображения, определяющая центр</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.CenterConstruction">
            <summary>Линия построения, определяющая центр</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.CenterNode">
            <summary>Центральный узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.SourceOutline">
            <summary>Исходная линия изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.AxisType">
            <summary>Тип оси</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CenterAxisOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Конструктор для создания оси от центра, заданного дугой или окружностью изображения</summary>
            <param name="document">Документ</param>
            <param name="source">Обозначаемая линия изображения</param>
            <param name="axisType">Тип оси</param>
            <param name="centerOutline">Окружность или дуга, определяющая центр</param>
            <param name="limit1Outline">Первая ограничивающая линия изображения (допускается значение null)</param>
            <param name="limit2Outline">Вторая ограничивающая линия изображения (допускается значение null)</param>
            <param name="limit1Node">Первый ограничивающий узел (допускается значение null)</param>
            <param name="limit2Node">Второй ограничивающий узел (допускается значение null)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CenterAxisOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType,TFlex.Model.Model2D.Construction,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Конструктор для создания оси от центра, заданного окружностью построения</summary>
            <param name="document">Документ</param>
            <param name="source">Обозначаемая линия изображения</param>
            <param name="axisType">Тип оси</param>
            <param name="centerConstruction">Окружность, определяющая центр</param>
            <param name="limit1Outline">Первая ограничивающая линия изображения (допускается значение null)</param>
            <param name="limit2Outline">Вторая ограничивающая линия изображения (допускается значение null)</param>
            <param name="limit1Node">Первый ограничивающий узел (допускается значение null)</param>
            <param name="limit2Node">Второй ограничивающий узел (допускается значение null)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CenterAxisOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Outline,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Конструктор для создания оси от центра в узле</summary>
            <param name="document">Документ</param>
            <param name="source">Обозначаемая линия изображения</param>
            <param name="axisType">Тип оси</param>
            <param name="centerNode">Узел центра</param>
            <param name="limit1Outline">Первая ограничивающая линия изображения (допускается значение null)</param>
            <param name="limit2Outline">Вторая ограничивающая линия изображения (допускается значение null)</param>
            <param name="limit1Node">Первый ограничивающий узел (допускается значение null)</param>
            <param name="limit2Node">Второй ограничивающий узел (допускается значение null)</param>
        </member>
        <member name="M:TFlex.Model.Model2D.CenterAxisOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Outline,System.Boolean)">
            <summary>Конструктор для создания горизонтальной или вертикальной оси окружности</summary>
            <param name="document">Документ</param>
            <param name="source">Обозначаемая линия изображения</param>
            <param name="horizontal">true, если ось является горизонтальной</param>
        </member>
        <member name="P:TFlex.Model.Model2D.CenterAxisOutline.SubType">
            <summary>Тип линии изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType.Circle">
            <summary>Окружность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType.ClockwiseArc">
            <summary>Дуга по направлению хода часовой стрелки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType.CounterclockwiseArc">
            <summary>Дуга по направлению против хода часовой стрелки</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType.TangentLine">
            <summary>Линия, касательная к дуге оси</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType.RadialLine">
            <summary>Линия через узел</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType.VertLine">
            <summary>Вертикальная линия</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType.HorzLine">
            <summary>Горизонтальная линия</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CenterAxisOutline.CenterAxisType">
            <summary>Типы оси</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CenterAxisOutline">
            <summary>Линия изображения - ось окружности или эллипса</summary>
            <example>
                <code name="Ось окружности или эллипса">	
public static void CenterAxisOutline()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fnCenter = new FreeNode(document, 200, 370);
   int r = 50;
   CircleOutline co = new  CircleOutline(document, fnCenter, r);//создание окружности
   CenterAxisOutline cao = new CenterAxisOutline(document, co, false);//ось окружности, false - ось вертикальная 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointCircleOutline.Radius">
            <summary>Радиус окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointCircleOutline.SecondNode">
            <summary>Второй узел</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointCircleOutline.FirstNode">
            <summary>Первый узел</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.TwoPointCircleOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="firstNode">Первый узел</param>
            <param name="secondNode">Первый узел</param>
            <param name="radius">Радиус окружности</param>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointCircleOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.TwoPointCircleOutline">
            <summary>Линия изображения - окружность, проходящая через два узла с заданным радиусом</summary>
            <example>
                <code name="Окружность, проходящая через два узла с заданным радиусом">
public static void TwoPointCircleOutline()
{		
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("окружность");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 440, 420);			
   FreeNode fn2 = new FreeNode(document, 500, 420);
   double r = 30;	
   //окружность, проходящая через два узла с заданным радиусом
   TwoPointCircleOutline twoPointCircleOutline = new TwoPointCircleOutline(document, fn1, fn2, r);

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointArcOutline.Radius">
            <summary>Радиус окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointArcOutline.EndNode">
            <summary>Конечный узел дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointArcOutline.StartNode">
            <summary>Начальный узел дуги</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.TwoPointArcOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="startNode">Начальный узел дуги</param>
            <param name="endNode">Конечный узел дуги</param>
            <param name="radius">Радиус дуги</param>
        </member>
        <member name="P:TFlex.Model.Model2D.TwoPointArcOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.TwoPointArcOutline">
            <summary>Линия изображения - дуга окружности, проходящая через два узла с заданным радиусом</summary>
            <example>
                <code name="Дуга окружности, проходящая через два узла с заданным радиусом">
public static void TwoPointArcOutline()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 450, 380);			
   FreeNode fn2 = new FreeNode(document, 490, 380);
   double r = 20;	
   //дуга окружности, проходящая через два узла с заданным радиусом
   TwoPointArcOutline twoPointArcOutline = new TwoPointArcOutline(document, fn1, fn2, r);

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.ThreePointArcOutline.EndNode">
            <summary>Конечный узел дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ThreePointArcOutline.MiddleNode">
            <summary>Узел, через который проходит дуга </summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ThreePointArcOutline.StartNode">
            <summary>Начальный узел дуги</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ThreePointArcOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="startNode">Начальный узел дуги</param>
            <param name="middleNode">Узел, через который проходит дуга</param>
            <param name="endNode">Конечный узел дуги</param>
        </member>
        <member name="P:TFlex.Model.Model2D.ThreePointArcOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ThreePointArcOutline">
            <summary>Линия изображения - дуга окружности, проходящая через три узла</summary>
            <example>
                <code name="Дуга окружности, проходящая через три узла">
public static void ThreePointArcOutline()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 450, 320);			
   FreeNode fn2 = new FreeNode(document, 470, 340);			
   FreeNode fn3 = new FreeNode(document, 490, 320);			
   ThreePointArcOutline threePointArcOutline = new ThreePointArcOutline(document, fn1, fn2, fn3);//дуга окружности, проходящая через три узла

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleOutline.Radius">
            <summary>Радиус окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleOutline.CenterNode">
            <summary>Центр окружности</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Конструктор</summary>
            <param name="document">Документ</param>
            <param name="center">Центр окружности</param>
            <param name="radius">Радиус окружности</param>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CircleOutline">
            <summary>Линия изображения - окружность с центром в узле с заданным радиусом</summary>
            <example>
                <code name="Окружность с центром в узле с заданным радиусом">
public static void CircleOutline()
{		
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fnCenter = new FreeNode(document, 200, 370);
   int r = 50;
   //окружность с центром в узле с заданным радиусом
   CircleOutline co = new  CircleOutline(document, fnCenter, r);

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentOutline.FragmentPath">
            <summary>Исходный объект - путь к исходному элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.FragmentOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.FragmentOutline.Create(TFlex.Model.Document,TFlex.Model.Model2D.Fragment[],TFlex.Model.Model2D.Outline)">
            <summary>Создание элемента в указанном документе, соответствующего заданному элементу, находящегося на вложенном фрагменте</summary>
            <param name="doc">Документ</param>
            <param name="arrPath">Массив вложенных фрагментов</param>
            <param name="sourceElement">Заданный элемент</param>
            <returns>Созданный объект</returns>
            <remarks>0-й фрагмент в массиве - должен быть вложен в указанный документ.
Заданный объект должен находиться на последнем фрагменте массива.</remarks>
        </member>
        <member name="T:TFlex.Model.Model2D.FragmentOutline">
            <summary>Класс линии изображения, поднятой с фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOutline.Transformation">
            <summary>Преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOutline.SourceCopyOperation">
            <summary>Исходный объект-копия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOutline.Source">
            <summary>Исходная линия изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CopyOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CopyOutline">
            <summary>Класс линии изображения, полученной ассоциативным копированием</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.PolylineOutline.GeometryType">
            <summary>Тип геометрии линии изображения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.PolylineOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.PolylineGeometry)">
            <summary>Конструктор, задающий узлы, между которыми пройдет линия, и линию построения</summary>
            <param name="document">Документ объекта</param>
            <param name="polyline">Геометрия полилинии</param>
        </member>
        <member name="T:TFlex.Model.Model2D.PolylineOutline">
            <summary>Линия изображения заданная геометрией</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionOutline.GeometryType">
            <summary>Тип геометрии линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionOutline.EndNode">
            <summary>Конечный узел линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionOutline.StartNode">
            <summary>Начальный узел линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.ConstructionOutline.Construction">
            <summary>Линия построения, по которой проходит линия изображения</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Construction)">
            <summary>Конструктор, задающий линию построения по которой будет построена новая линия. </summary>
            <param name="document">Документ объекта</param>
            <param name="srcConstruction">Линия построения</param>
            <remarks>В качестве линии построения не может быть задана прямая</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Construction)">
            <summary>Конструктор, задающий узлы, между которыми пройдет линия, и линию построения</summary>
            <param name="document">Документ объекта</param>
            <param name="startNode">Первый узел</param>
            <param name="endNode">Второй узел</param>
            <param name="srcConstruction">Линия построения</param>
            <remarks>При отсутствии линии построения будет создан отрезок между узлами</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.ConstructionOutline.#ctor(TFlex.Model.Document,TFlex.Model.Model2D.Node,TFlex.Model.Model2D.Node)">
            <summary>Конструктор, задающий узлы между которыми будет проведён отрезок</summary>
            <param name="document">Документ объекта</param>
            <param name="startNode">Первый узел</param>
            <param name="endNode">Второй узел</param>
        </member>
        <member name="T:TFlex.Model.Model2D.ConstructionOutline">
            <summary>Класс линии изображения, основанной на узлах и линиях построения</summary>
            <remarks>Геометрия линии изображения данного класса определяется положением конечных узлов и/или
геометрией подложенной линии построения.</remarks>
            <example>
                <code name="Класс линии изображения, основанной на узлах и линиях построения">
public static void ConstructionOutline()//Класс линии изображения, основанной на узлах и линиях построения
{		
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   FreeNode fn1 = new FreeNode(document, 400, 320);//создание узла			
   FreeNode fn2 = new FreeNode(document, 400, 420);
   ConstructionOutline conOutline = new ConstructionOutline(document, fn1, fn2);//прямая

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model2D.Outline.SetDefaults">
            <summary>Установка параметров линий изображения в соответствии с параметрами по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.IsService">
            <summary>Вспомогательная линия</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.WaveHeight">
            <summary>Высота волны волнистой линии</summary>
            <remarks>Реальная высота волны измеряется как длина волны, умноженная на значение данного параметра</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.WaveLength">
            <summary>Длина волны волнистой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.WaveNumber">
            <summary>Количество волн волнистой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.WaveSetting">
            <summary>Способ задания волнистой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.EndArrowSize">
            <summary>Размер конечной стрелки линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.StartArrowSize">
            <summary>Размер начальной стрелки линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.EndArrowType">
            <summary>Тип конечной стрелки линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.StartArrowType">
            <summary>Тип начальной стрелки линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.PatternName">
            <summary>Имя образца штриховой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.PatternScale">
            <summary>Масштаб штрихов штриховой линии</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.LineWidth">
            <summary>Толщина линии изображения</summary>
            <example>
                <code name="Установка толщины линии">
public static void SetLineWidth(ModelObject ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка толщины линии");//Открытие блока изменений документа

   ob.LineWidth = 3;	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.Style">
            <summary>Стиль линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.Layer">
            <summary>Слой линии изображения</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.Priority">
            <summary>Приоритет линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.Level">
            <summary>Уровень линии</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.Color">
            <summary>Цвет линии изображения</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.Page">
            <summary>Страница линии изображения</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.GeometryAsPolyline">
            <summary>Получение геометрии в виде полилинии независимо от типа</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.ModelGeometry">
            <summary>Получение геометрии линии изображения без учёта масштаба</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.Geometry">
            <summary>Получение геометрии линии изображения с учётом масштаба</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.GeometryType">
            <summary>Тип геометрии линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.Outline.GroupType">
            <summary>Тип объекта "Линия изображения"</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.Outline">
            <summary>Базовый класс линии изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.OutlineWaveType">
            <summary>Способ задания волнистой линии</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineWaveType.ByWaveLength">
            <summary>Длиной периода волны</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineWaveType.ByWaveNumber">
            <summary>Количеством волн</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.OutlineStyle">
            <summary>Стиль линии изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineStyle.Wave">
            <summary>Волнистая линия</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineStyle.Dashed">
            <summary>Штриховая линия</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineStyle.Thick">
            <summary>Основная линия</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineStyle.Thin">
            <summary>Тонкая линия</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.OutlineType">
            <summary>Подтипы линий изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.AxisOutline">
            <summary>Линия изображения - ось двух других линий изображения. Класс
<see cref="T:TFlex.Model.Model2D.AxisOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.CenterAxisOutline">
            <summary>Линия изображения - ось окружности или эллипса. Класс
<see cref="T:TFlex.Model.Model2D.CenterAxisOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.TwoPointCircleOutline">
            <summary>Линия изображения - окружность, проходящая через два узла с заданным радиусом. Класс
<see cref="T:TFlex.Model.Model2D.TwoPointCircleOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.TwoPointArcOutline">
            <summary>Линия изображения - дуга окружности, проходящая через два узла с заданным радиусом. Класс
<see cref="T:TFlex.Model.Model2D.TwoPointArcOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.ThreePointArcOutline">
            <summary>Линия изображения - дуга окружности, проходящая через три узла. Класс
<see cref="T:TFlex.Model.Model2D.ThreePointArcOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.CircleOutline">
            <summary>Линия изображения - окружность с центром в узле с заданным радиусом. Класс
<see cref="T:TFlex.Model.Model2D.CircleOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.FragmentOutline">
            <summary>Линия изображения, поднятая с фрагмента. Класс
<see cref="T:TFlex.Model.Model2D.FragmentOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.ProjectionOutline">
            <summary>Линия изображения, принадлежащая 2D проекции. Класс
<see cref="T:TFlex.Model.Model3D.ProjectionOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.CopyOutline">
            <summary>Линия изображения, полученная ассоциативным копированием. Класс
<see cref="T:TFlex.Model.Model2D.CopyOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.ConstructionOutline">
            <summary>Линия изображения, основанная на узлах и линиях построения. Класс
<see cref="T:TFlex.Model.Model2D.ConstructionOutline" /></summary>
        </member>
        <member name="F:TFlex.Model.Model2D.OutlineType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="M:IMAGE.SetConstraintPoint(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Редактирование кривой перемещением точки, лежащей на кривой
</member>
        <member name="M:IMAGE.IsFixedForConstraint">
Линия фиксирована в решателе ограничений
</member>
        <member name="M:IMAGE.GetDistance(RGPlatform.Geometry.Context*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить расстояние от точки до кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPointInPageCs"> Точка с учётом масштаба страницы, от которой ищется расстояние </param>
            <param name="oDistance"> Найденное расстояние </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:IMAGE.FindNearestPoint(RGPlatform.Geometry.Context*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Получить параметр точки на кривой, ближайшей к передаваемой точке </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPointInPageCs"> Точка с учётом масштаба страницы, для которой ищется ближайшая точка на кривой </param>
            <param name="oParameter"> Найденный параметр ближайшей точки на кривой </param>
            <param name="iTolerance"> Точность, с которой ищется ближайшая точка </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:IMAGE.EvaluatePoint(RGPlatform.Geometry.Context*,System.Double,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить значение кривой по параметру </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iParameter"> Параметр на кривой, в котором вычисляется значение </param>
            <param name="oPointInPageCs"> Вычисленное значение с учётом масштаба страницы </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:IMAGE.Parameterise(RGPlatform.Geometry.Context*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
            <summary> Определить параметр точки, лежащей на кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPointInPageCs"> Точка на кривой с учётом масштаба страницы </param>
            <param name="ioParameter"> Найденный параметр на кривой (на входе может содержать начальное приближение) </param>
            <param name="iUseGuess"> Использовать ли начальное приближение </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:SplineIMAGEConstraints2D.GetStartTangentLine">
Данные для решателя ограничений
Касательные условия на концах
</member>
        <member name="T:SplineIMAGEConstraints2D">
Данные для решателя ограничений
</member>
        <member name="D:IMAGEConstraints2D.CharacteristicPoints">
Фиксированные характерные точки линии изображения. Например, центр эллипса или окружности, построенной по линии построения или на проекции
</member>
        <member name="M:IMAGEConstraints2D.ResetConstraintPoint">
Редактирование кривой перемещением точки, лежащей на кривой
</member>
        <member name="M:IMAGEConstraints2D.GetConstraintGeometry">
Данные для решателя ограничений
</member>
        <member name="T:IMAGEConstraints2D">
Данные для решателя ограничений
</member>
        <member name="M:TFlex.Model.Model2D.PolylineGeometry.GetCircleArcApproximationByArray(System.Double[],System.Double[],System.Double)">
            <summary>Аппроксимация дугами окружности.</summary>
            <remarks>Каждые шесть элементов (xb, yb, xm, ym, xe, ye) задают дугу.</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.PolylineGeometry.GetCircleArcApproximation(System.Double[],System.Double[],System.Double)">
            <summary>Аппроксимация дугами окружности.</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.PolylineGeometry.GetCircleArcApproximation(System.Double)">
            <summary>Аппроксимация дугами окружности.</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.PolylineGeometry.GetY(System.Int32)">
            <summary>Y-координата точки полилинии с указанным индексом</summary>
            <remarks>Индекс может принимать значения от 0 до Count-1</remarks>
        </member>
        <member name="M:TFlex.Model.Model2D.PolylineGeometry.GetX(System.Int32)">
            <summary>X-координата точки полилинии с указанным индексом</summary>
            <remarks>Индекс может принимать значения от 0 до Count-1</remarks>
        </member>
        <member name="P:TFlex.Model.Model2D.PolylineGeometry.Count">
            <summary>Количество точек полилинии</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.PolylineGeometry.#ctor(System.Collections.Generic.IEnumerable`1{TFlex.Drawing.Point})">
            <summary>Конструктор, инициализирующий параметры геометрии</summary>
            <param name="points">Точки полилинии</param>
        </member>
        <member name="P:TFlex.Model.Model2D.PolylineGeometry.Type">
            <summary>Тип геометрии</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.PolylineGeometry">
            <summary>Класс 2D геометрии - полилиния</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.EndY">
            <summary>Y-координата конца дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.EndX">
            <summary>X-координата конца дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.StartY">
            <summary>Y-координата начала дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.StartX">
            <summary>X-координата начала дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.Y2">
            <summary>Y-координата второй точки, задающей эллипс</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.X2">
            <summary>X-координата второй точки, задающей эллипс</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.Y1">
            <summary>Y-координата первой точки, задающей эллипс</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.X1">
            <summary>X-координата первой точки, задающей эллипс</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.CenterY">
            <summary>Y-координата центра эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.CenterX">
            <summary>X-координата центра эллипса</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseArcGeometry.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор, инициализирующий параметры геометрии</summary>
            <param name="centerX">X-координата центра эллипса</param>
            <param name="centerY">Y-координата центра эллипса</param>
            <param name="x1">X-координата первой точки, задающей эллипс</param>
            <param name="y1">Y-координата первой точки, задающей эллипс</param>
            <param name="x2">X-координата второй точки, задающей эллипс</param>
            <param name="y2">Y-координата второй точки, задающей эллипс</param>
            <param name="startX">X-координата начала дуги</param>
            <param name="startY">Y-координата начала дуги</param>
            <param name="endX">X-координата конца дуги</param>
            <param name="endY">Y-координата конца дуги</param>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseArcGeometry.Type">
            <summary>Тип геометрии</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.EllipseArcGeometry">
            <summary>Класс 2D геометрии - дуга эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseGeometry.Y2">
            <summary>Y-координата второй точки, задающей эллипс</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseGeometry.X2">
            <summary>X-координата второй точки, задающей эллипс</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseGeometry.Y1">
            <summary>Y-координата первой точки, задающей эллипс</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseGeometry.X1">
            <summary>X-координата первой точки, задающей эллипс</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseGeometry.CenterY">
            <summary>Y-координата центра эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseGeometry.CenterX">
            <summary>X-координата центра эллипса</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.EllipseGeometry.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор, инициализирующий параметры геометрии</summary>
            <param name="centerX">X-координата центра эллипса</param>
            <param name="centerY">Y-координата центра эллипса</param>
            <param name="x1">X-координата первой точки, задающей эллипс</param>
            <param name="y1">Y-координата первой точки, задающей эллипс</param>
            <param name="x2">X-координата второй точки, задающей эллипс</param>
            <param name="y2">Y-координата второй точки, задающей эллипс</param>
        </member>
        <member name="P:TFlex.Model.Model2D.EllipseGeometry.Type">
            <summary>Тип геометрии</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.EllipseGeometry">
            <summary>Класс 2D геометрии - эллипс</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleArcGeometry.GetThreePoints(System.Double@,System.Double@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>Три точки лежащие на дуге и определяющие её. (начало, середина, конец).</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleArcGeometry.EndY">
            <summary>Y-координата конца дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleArcGeometry.EndX">
            <summary>X-координата конца дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleArcGeometry.StartY">
            <summary>Y-координата начала дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleArcGeometry.StartX">
            <summary>X-координата начала дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleArcGeometry.Radius">
            <summary>Радиус окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleArcGeometry.CenterY">
            <summary>Y-координата центра окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleArcGeometry.CenterX">
            <summary>X-координата центра окружности</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleArcGeometry.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор, инициализирующий параметры геометрии</summary>
            <param name="centerX">X-координата центра окружности</param>
            <param name="centerY">Y-координата центра окружности</param>
            <param name="startX">X-координата начала дуги</param>
            <param name="startY">Y-координата начала дуги</param>
            <param name="endX">X-координата конца дуги</param>
            <param name="endY">Y-координата конца дуги</param>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleArcGeometry.Type">
            <summary>Тип геометрии</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CircleArcGeometry">
            <summary>Класс 2D геометрии - дуга окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleGeometry.Radius">
            <summary>Радиус окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleGeometry.CenterY">
            <summary>Y-координата центра окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleGeometry.CenterX">
            <summary>X-координата центра окружности</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.CircleGeometry.#ctor(System.Double,System.Double,System.Double)">
            <summary>Конструктор, инициализирующий параметры геометрии</summary>
            <param name="centerX">X-координата центра окружности</param>
            <param name="centerY">Y-координата центра окружности</param>
            <param name="radius">Радиус окружности</param>
        </member>
        <member name="P:TFlex.Model.Model2D.CircleGeometry.Type">
            <summary>Тип геометрии</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.CircleGeometry">
            <summary>Класс 2D геометрии - окружность</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineGeometry.Y2">
            <summary>Y-координата второй точки прямой или конца отрезка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineGeometry.X2">
            <summary>X-координата второй точки прямой или конца отрезка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineGeometry.Y1">
            <summary>Y-координата первой точки прямой или начала отрезка</summary>
        </member>
        <member name="P:TFlex.Model.Model2D.LineGeometry.X1">
            <summary>X-координата первой точки прямой или начала отрезка</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.LineGeometry.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор, инициализирующий параметры геометрии</summary>
            <param name="x1">X-координата первой точки прямой или начала отрезка</param>
            <param name="y1">Y-координата первой точки прямой или начала отрезка</param>
            <param name="x2">X-координата второй точки прямой или конца отрезка</param>
            <param name="y2">Y-координата второй точки прямой или конца отрезка</param>
        </member>
        <member name="P:TFlex.Model.Model2D.LineGeometry.Type">
            <summary>Тип геометрии</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.LineGeometry">
            <summary>Класс 2D геометрии - отрезок или прямая</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ObjectGeometry.GetDistance(System.Double,System.Double)">
            <summary>Минимальное расстояние до точки</summary>
            <param name="x">X-координата точки</param>
            <param name="y">Y-координата точки</param>
        </member>
        <member name="P:TFlex.Model.Model2D.ObjectGeometry.Type">
            <summary>Тип геометрии</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.ObjectGeometry.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ObjectGeometry">
            <summary>Базовый класс 2D геометрии</summary>
        </member>
        <member name="T:TFlex.Model.Model2D.ObjectGeometryType">
            <summary>Типы 2D геометрии, которые могут возвращать объекты модели</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ObjectGeometryType.Polyline">
            <summary>Полилиния</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ObjectGeometryType.EllipseArc">
            <summary>Дуга эллипса</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ObjectGeometryType.Ellipse">
            <summary>Эллипс</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ObjectGeometryType.CircleArc">
            <summary>Дуга окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ObjectGeometryType.Circle">
            <summary>Окружность</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ObjectGeometryType.Line">
            <summary>Прямая или отрезок</summary>
        </member>
        <member name="F:TFlex.Model.Model2D.ObjectGeometryType.Undefined">
            <summary>Не определена</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Object2D.Draw(TFlex.Drawing.Graphics)">
            <summary>Нарисовать объект</summary>
            <param name="graphics">Объект класса Graphics, через который производится рисование.</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Object2D.Transform(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Применение преобразования.</summary>
            <param name="scale">Масштаб</param>
            <param name="angle">Угол</param>
            <param name="OriginX">Координата x центра вращения</param>
            <param name="OriginY">Координата y центра вращения</param>
            <param name="OffsetX">Координата x сдвига</param>
            <param name="OffsetY">Координата y сдвига</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Object2D.Translate(System.Double,System.Double)">
            <summary>Сдвиг объекта на данный вектор</summary>
            <param name="dx">Координта x</param>
            <param name="dy">Координта y</param>
        </member>
        <member name="M:TFlex.Model.Model2D.Object2D.GetDistance(TFlex.Drawing.Point)">
            <summary>Получение растояния до объекта</summary>
            <param name="point">Точка в единицах измерения модели</param>
            <returns>Растояние до объекта</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.Object2D.BoundRect">
            <summary>Получение координат прямоугольника, обрамляющего объект</summary>
        </member>
        <member name="M:TFlex.Model.Model2D.Object2D.GetPoint(System.UInt32)">
            <summary>Получение координат характерной точки объекта</summary>
            <param name="id">Уникальный для данного объекта идентификатор точки</param>
            <returns>Координаты характерной точки объекта с указанным идентификатором</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Object2D.GetPointID(System.Int32)">
            <summary>Получение идентификатора характерной точеки объекта с номером index</summary>
            <param name="index">Номер точки</param>
            <returns>Уникальный для данного объекта идентификатор точки</returns>
        </member>
        <member name="M:TFlex.Model.Model2D.Object2D.GetPointCount">
            <summary>Получение количества характерных точек объекта, в которых может быть построен узел</summary>
            <returns>Количество точек</returns>
        </member>
        <member name="P:TFlex.Model.Model2D.Object2D.Page">
            <summary>Страница, на которой размещается объект</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model2D.Object2D">
            <summary>Класс 2D объекта модели</summary>
        </member>
        <member name="P:TFlex.Model.Document.InsertMethodString">
            <summary>Способ вставки фрагмента (строка)</summary>
        </member>
        <member name="M:TFlex.Model.Document.ExportIcon(System.String)">
            <summary>Экспорт иконки</summary>
            <param name="pathName">Имя выходного файла</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="M:TFlex.Model.Document.ImportIcon(System.String)">
            <summary>Импорт иконки</summary>
            <param name="pathName">Имя выходного файла</param>
        </member>
        <member name="P:TFlex.Model.Document.InsertMethod">
            <summary>Способ вставки фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Document.DetachPlugin(TFlex.Plugin)">
            <summary>Отписаться от прихода уведомлений о событиях для данного документа</summary>
            <param name="plugin">Объект класса приложения</param>
        </member>
        <member name="M:TFlex.Model.Document.AttachPlugin(TFlex.Plugin)">
            <summary>Подписаться на приход уведомлений о событиях для данного документа.</summary>
            <param name="plugin">Объект класса приложения</param>
            <remarks>Использование данного метода касается всех уведомлений,
которые связаны с конкретным документом, а именно:
<list type="bullet"><item><see cref="M:TFlex.Plugin.SavingDocumentEventHandler(TFlex.DocumentEventArgs)" /> -
вызывается перед сохранением документа</item><item><see cref="M:TFlex.Plugin.DocumentSavedEventHandler(TFlex.DocumentEventArgs)" /> -
вызывается после успешного сохранения документа</item><item><see cref="M:TFlex.Plugin.ClosingDocumentEventHandler(TFlex.DocumentEventArgs)" /> -
вызывается перед закрытием документа</item><item><see cref="M:TFlex.Plugin.ViewActivatedEventHandler(TFlex.ViewEventArgs)" /> -
вызывается после активизации окна документа</item><item><see cref="M:TFlex.Plugin.ViewDeactivatedEventHandler(TFlex.ViewEventArgs)" /> -
вызывается после деактивизации окна документа </item><item><see cref="M:TFlex.Plugin.DynamicAnalysisSteppedEventHandler(TFlex.DynamicAnalysisEventArgs)" /> - вызывается при выполнении различных задач динамического анализа</item><item><see cref="M:TFlex.Plugin.ObjectCreatedEventHandler(TFlex.ObjectEventArgs)" /> -
вызывается после создания объекта</item><item><see cref="M:TFlex.Plugin.DeletingObjectEventHandler(TFlex.ObjectEventArgs)" /> -
вызывается перед удалением объекта</item><item><see cref="M:TFlex.Plugin.ObjectDeletedEventHandler(TFlex.ObjectEventArgs)" /> -
вызывается после удаления объекта</item><item><see cref="M:TFlex.Plugin.ObjectChangedEventHandler(TFlex.ObjectEventArgs)" /> -
вызывается после изменения объекта</item><item><see cref="M:TFlex.Plugin.ObjectSelectionChangedEventHandler(TFlex.ObjectEventArgs)" /> -
вызывается при изменении селекции объекта</item><item><see cref="M:TFlex.Plugin.RegeneratingDocumentEventHandler(TFlex.RegenerateDocumentEventArgs)" /> - вызывается перед пересчётом документа</item><item><see cref="M:TFlex.Plugin.DocumentRegeneratedEventHandler(TFlex.RegenerateDocumentEventArgs)" /> - вызывается после пересчёта документа</item><item><see cref="M:TFlex.Plugin.TrackingContextPopupMenuEventHandler(TFlex.TrackingContextPopupMenuEventArgs)" /> - вызывается перед показом контекстного меню объекта</item><item><see cref="M:TFlex.Plugin.DrawingDocumentEventHandler(TFlex.DrawingDocumentEventArgs)" /> -
вызывается перед отрисовкой документа</item><item><see cref="M:TFlex.Plugin.DocumentDrawnEventHandler(TFlex.DrawingDocumentEventArgs)" /> -
вызывается после отрисовки документа</item></list></remarks>
        </member>
        <member name="P:TFlex.Model.Document.DraggerManager">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="P:TFlex.Model.Document.DecorationManager">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="P:TFlex.Model.Document.Scene">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Model.Document.GetAssemblyContextData2D">
            <summary />
        </member>
        <member name="M:TFlex.Model.Document.Regenerate(TFlex.Model.RegenerateOptions)">
            <summary>Пересчёт модели с заданными опциями</summary>
            <param name="options">Опции регенерации модели</param>
        </member>
        <member name="P:TFlex.Model.Document.LastSavedVersion">
            <summary>Версия системы, в которой документ был сохранён последний раз</summary>
        </member>
        <member name="M:TFlex.Model.Document.SaveInNomenclature(System.Boolean)">
            <summary>Сохранить документ в справочник номенклатуры DOCs</summary>
            <param name="recursive">Сохранять сборку со всеми входящими фрагментами</param>
        </member>
        <member name="M:TFlex.Model.Document.AssignParametersToDOCs(System.IntPtr)">
            <summary>Cвязать переменные T-Flex CAD с параметрами документа DOCs</summary>
            <param name="hDOCsHandle">Идентификатор документа DOCs</param>
        </member>
        <member name="M:TFlex.Model.Document.ConvertLibraryFileLinksToDOCs(System.IntPtr)">
            <summary>Переназначить ссылки на файлы в библиотеке T-Flex CAD на ссылки в библиотеке DOCs</summary>
            <param name="hDOCsHandle">Идентификатор документа DOCs</param>
        </member>
        <member name="P:TFlex.Model.Document.ExplodeMode">
            <summary>Режим разборки 3D модели</summary>
            <remarks>Открытие блока изменения документа является необязательным <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" /></remarks>
        </member>
        <member name="M:TFlex.Model.Document.SetExplodeStatus(System.Boolean)">
            <summary>Перевод 3D модели в режим сборки-разборки без открытия блока изменения документа <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" /></summary>
        </member>
        <member name="M:TFlex.Model.Document.Regenerate3D">
            <summary>Пересчёт 3D модели без открытия блока изменения документа <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" /></summary>
            <returns>true в случае успешного пересчёта, в противном случае false</returns>
        </member>
        <member name="P:TFlex.Model.Document.BOMData">
            <summary>Контейнер данных для спецификации</summary>
        </member>
        <member name="P:TFlex.Model.Document.ModelConfigurations">
            <summary>Контейнер конфигураций модели</summary>
        </member>
        <member name="M:TFlex.Model.Document.ShowVariablesDialog">
            <summary>Показать диалог "Переменные модели"</summary>
        </member>
        <member name="M:TFlex.Model.Document.FindVariable(System.String)">
            <summary>Найти переменную по имени</summary>
            <param name="name">Имя переменной</param>
            <returns>Переменная</returns>
        </member>
        <member name="P:TFlex.Model.Document.FileLinks">
            <summary>Ссылки на файлы</summary>
        </member>
        <member name="M:TFlex.Model.Document.CopyObjects(System.Collections.Generic.List`1{TFlex.Model.ModelObject},TFlex.Model.CopyObjectsOptions)">
            <summary>Копирование модельных объектов с учётом афинного преобразования на заданную страницу</summary>
            <param name="sourceObjects">Список копируемых модельных объектов</param>
            <param name="options">Настройки</param>
            <remarks>Данный метод позволяет копировать в текущий документ модельные объекты из другого документа</remarks>
        </member>
        <member name="M:TFlex.Model.Document.CopyObjects(TFlex.Model.Page,System.Collections.Generic.List`1{TFlex.Model.ModelObject},TFlex.Drawing.AffineMap)">
            <summary>Копирование модельных объектов с учётом афинного преобразования на заданную страницу</summary>
            <param name="targetPage">Страница на которую копируются объекты</param>
            <param name="sourceObjects">Список копируемых модельных объектов</param>
            <param name="affineMap">Аффинное преобразование</param>
            <remarks>Данный метод позволяет копировать в текущий документ модельные объекты из другого документа</remarks>
        </member>
        <member name="M:TFlex.Model.Document.CreateRealVariable(System.String,System.Double@,TFlex.Model.CreateVariableMode)">
            <summary>Создает новую вещественную переменную</summary>
        </member>
        <member name="M:TFlex.Model.Document.CreateRealVariable(System.String,System.Double)">
            <summary>Создает новую вещественную переменную</summary>
        </member>
        <member name="M:TFlex.Model.Document.CreateTextVariable(System.String,System.String)">
            <summary>Создает новую текстовую переменную</summary>
        </member>
        <member name="M:TFlex.Model.Document.CreateVariable(System.String)">
            <summary>Создает новую переменную</summary>
        </member>
        <member name="P:TFlex.Model.Document.ImportFromACAD">
            <summary>Объект, импортирующий данные из формата AutoCAD</summary>
        </member>
        <member name="P:TFlex.Model.Document.ImportFromParasolid">
            <summary>Объект, импортирующий данные из формата Parasolid</summary>
        </member>
        <member name="P:TFlex.Model.Document.ImportFromSTEP">
            <summary>Объект, импортирующий данные из формата STEP</summary>
        </member>
        <member name="P:TFlex.Model.Document.ImportVariables">
            <summary>Объект, импортирующий переменные документа</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportVariables">
            <summary>Объект, экспортирующий переменные документа</summary>
        </member>
        <member name="P:TFlex.Model.Document.MacroNames">
            <summary>Список полных имен макросов</summary>
        </member>
        <member name="M:TFlex.Model.Document.MacroExists(System.String,System.Boolean)">
            <summary>Проверка наличия макроса с указанным именем</summary>
            <param name="macro">Имя макроса</param>
            <param name="macroWithParameters">Проверять макросы с аргументами</param>
            <returns>true если макрос существует</returns>
        </member>
        <member name="M:TFlex.Model.Document.MacroExists(System.String)">
            <summary>Проверка наличия макроса с указанным именем</summary>
            <param name="macro">Имя макроса</param>
            <returns>true если макрос существует</returns>
        </member>
        <member name="M:TFlex.Model.Document.RunMacro(System.String,System.Object[])">
            <summary>Выполнить макрос с заданным именем и передать в него параметры</summary>
            <param name="macro">Имя макроса</param>
            <param name="parameters">Аргументы для вызова метода</param>
            <returns>Возвращает результат выполнения макроса</returns>
        </member>
        <member name="M:TFlex.Model.Document.RunMacro(System.String)">
            <summary>Выполнить макрос с заданным именем</summary>
            <param name="macro">Имя макроса</param>
            <returns>true макрос был выполнен успешно</returns>
        </member>
        <member name="M:TFlex.Model.Document.GetAttributes">
            <summary>Получить контейнер атрибутов документа</summary>
            <remarks>Приложение может использовать данный
контейнер для хранения своих данных, связанных с документом</remarks>
            <returns>Контейнер атрибутов документа</returns>
        </member>
        <member name="M:TFlex.Model.Document.InsertFragment(TFlex.Model.FileLink)">
            <summary>Вставить фрагмент</summary>
        </member>
        <member name="M:TFlex.Model.Document.InsertFragment(System.String)">
            <summary>Вставить фрагмент</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToRhino">
            <summary>Объект, экспортирующий документ в формат Rhino</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToInventor">
            <summary>Объект, экспортирующий документ в формат Open Inventor</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToVRML">
            <summary>Объект, экспортирующий документ в формат VRML</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToDXF3D">
            <summary>Объект, экспортирующий документ в формат DXF 3D</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToParasolid">
            <summary>Объект, экспортирующий документ в форматы Parasolid</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToSTL">
            <summary>Объект, экспортирующий документ в формат STL</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToBMF">
            <summary>Объект, экспортирующий документ в формат BMF</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToMetafileWMF">
            <summary>Объект, экспортирующий документ формата Windows Metafile (WMF)</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToMetafile">
            <summary>Объект, экспортирующий документ формата Windows Enhanced Metafile (EMF)</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToIGES">
            <summary>Объект, экспортирующий документ в формат IGES</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToSTEP">
            <summary>Объект, экспортирующий документ в формат STEP</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToBitmap">
            <summary>Объект, экспортирующий документ в растровые форматы</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToDXF">
            <summary>Объект, экспортирующий документ в формат DXF</summary>
        </member>
        <member name="P:TFlex.Model.Document.ExportToDWG">
            <summary>Объект, экспортирующий документ в формат DWG</summary>
        </member>
        <member name="M:TFlex.Model.Document.DeletePage(TFlex.Model.Page,TFlex.Model.DeleteOptions)">
            <summary>Удаление страницы</summary>
            <param name="page">Удаляемая страница</param>
            <param name="options">Опции удаления</param>
            <returns>true в случае успешного удаления, иначе false</returns>
        </member>
        <member name="M:TFlex.Model.Document.DeleteUnusedObjects(TFlex.Model.DeleteUnusedOptions)">
            <summary>Удаление неиспользуемых объектов документа</summary>
            <param name="options">Опции удаления объектов модели</param>
            <returns>true в случае успешного удаления, иначе false</returns>
        </member>
        <member name="M:TFlex.Model.Document.DeletePages(System.Collections.Generic.ICollection`1{TFlex.Model.Page},TFlex.Model.DeleteOptions)">
            <summary>Удаление страниц документа</summary>
            <param name="pages">Массив удаляемых страниц</param>
            <param name="options">Опции удаления страниц</param>
            <returns>true в случае успешного удаления, иначе false</returns>
        </member>
        <member name="M:TFlex.Model.Document.DeleteObjects(TFlex.Model.ObjectArray,TFlex.Model.DeleteOptions)">
            <summary>Удаление объектов документа</summary>
            <param name="objects">Массив удаляемых объектов модели</param>
            <param name="options">Опции удаления объектов модели</param>
            <returns>true в случае успешного удаления, иначе false</returns>
        </member>
        <member name="P:TFlex.Model.Document.Diagnostics">
            <summary>Контейнер диагностических сообщений документа или 0, если контейнера нет</summary>
        </member>
        <member name="P:TFlex.Model.Document.ActivePage">
            <summary>Активная страница документа или 0 если нет такой страницы</summary>
        </member>
        <member name="M:TFlex.Model.Document.Print(TFlex.Model.PrintOptions)">
            <summary>Печать документа</summary>
            <param name="options">Параметры печати</param>
        </member>
        <member name="M:TFlex.Model.Document.PrintPages(System.IntPtr,TFlex.Model.ObjectArray)">
            <summary>Печать страниц документа</summary>
            <param name="window">Родительское окно</param>
            <param name="pages">Страницы для печати</param>
        </member>
        <member name="M:TFlex.Model.Document.PrintPage(System.IntPtr,TFlex.Model.Page)">
            <summary>Печать документа</summary>
            <param name="window">Родительское окно</param>
            <param name="page">Страница для печати</param>
        </member>
        <member name="M:TFlex.Model.Document.PrintNoDialog">
            <summary>Печать документа</summary>
        </member>
        <member name="M:TFlex.Model.Document.Print(System.IntPtr,System.Boolean,System.Boolean)">
            <summary>Печать документа</summary>
            <param name="window">Родительское окно</param>
            <param name="selectAllPages">Выбрать все страницы, иначе - только активную</param>
            <param name="fitAndCenter">Центрировать и вписать в страницу</param>
            <example>
                <code name="Печать содержимого">
public static void DocPrint(IntPtr window)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа

   bool selectAllPages = true; //true-выбрать все страницы, false - только активную
   bool fitAndCenter = true;//Центрировать и вписать в страницу
   //метод вызывает диалоговое окно.
   document.Print(window, selectAllPages, fitAndCenter);
   //document.PrintNoDialog(); //печать без диалгового окна
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Document.Print(System.IntPtr,System.Boolean)">
            <summary>Печать документа</summary>
            <param name="window">Родительское окно</param>
            <param name="selectAllPages">Выбрать все страницы, иначе - только активную</param>
        </member>
        <member name="M:TFlex.Model.Document.Redraw(System.Boolean)">
            <summary>Перерисовка всех видов документа</summary>
            <param name="updateNow">Перерисовать синхронно</param>
        </member>
        <member name="M:TFlex.Model.Document.Redraw">
            <summary>Перерисовка всех видов документа</summary>
        </member>
        <member name="M:TFlex.Model.Document.Draw(TFlex.Drawing.Graphics,TFlex.Model.Page)">
            <summary>Прорисовка указанной страниницы документа
в указанный объект вывода графичесого изображения</summary>
            <param name="graphics">Объект вывода графичекого изображения</param>
            <param name="pg">Страница документа, которую необходимо вывести</param>
        </member>
        <member name="P:TFlex.Model.Document.CloseAfterCurrentMacroCompletion">
            <summary>Закрыть документ после завершения текущего макроса</summary>
        </member>
        <member name="M:TFlex.Model.Document.Close">
            <summary>Закрыть документ</summary>
            <remarks>После выполнения операции, с документом нельзя производить никакие операции</remarks>
        </member>
        <member name="P:TFlex.Model.Document.PdmLinkedObject">
            <summary>Объект PDM-системы в контексте которого открыт документ</summary>
        </member>
        <member name="P:TFlex.Model.Document.PdmNomenclatureObject">
            <summary>Объект номенклатуры PDM-системы в контексте которого открыт документ</summary>
        </member>
        <member name="P:TFlex.Model.Document.HasPdmNomenclatureReference">
            <summary>Документ ассоциирован с объектом номенклатуры</summary>
        </member>
        <member name="P:TFlex.Model.Document.Changed">
            <summary>Признак изменения документа</summary>
        </member>
        <member name="M:TFlex.Model.Document.SaveCopy(System.String)">
            <summary>Сохранить текущее состояние документа в другой файл</summary>
            <param name="fileName">Имя файла</param>
            <returns>true если операция сохранения была успешной</returns>
        </member>
        <member name="M:TFlex.Model.Document.SaveAs(System.String)">
            <summary>Сохранить документ в другой файл</summary>
            <param name="fileName">Имя файла</param>
            <returns>true если операция сохранения была успешной</returns>
        </member>
        <member name="M:TFlex.Model.Document.Save">
            <summary>Сохранить документ</summary>
            <returns>true если операция сохранения была успешной</returns>
        </member>
        <member name="M:TFlex.Model.Document.GetShortPathName(System.String)">
            <summary>Получение короткого пути относительно файла документа</summary>
            <param name="fileName">Имя файла </param>
            <returns>Короткий путь к файлу</returns>
        </member>
        <member name="P:TFlex.Model.Document.Title">
            <summary>Имя документа</summary>
        </member>
        <member name="P:TFlex.Model.Document.FilePath">
            <summary>Путь файла документа, не включая имя файла</summary>
        </member>
        <member name="P:TFlex.Model.Document.FileName">
            <summary>Полный путь файла документа, включая имя файла</summary>
        </member>
        <member name="M:TFlex.Model.Document.GetDrawingNotes">
            <summary>Получение объекта технических требований</summary>
            <returns>Найденный объект или null если объект не найден</returns>
        </member>
        <member name="M:TFlex.Model.Document.GetClosestObject(TFlex.Drawing.Point,TFlex.Model.Page,TFlex.Model.SelectionFilter,System.Double)">
            <summary>Получить объект, ближайший к заданной точке на заданной странице с учётом фильтра</summary>
            <param name="point">Точка на чертеже</param>
            <param name="page">Страница чертежа</param>
            <param name="filter">Фильтр объектов</param>
            <param name="maxdistance">Максимальное расстояние</param>
            <returns>Найденный объект или null если объект не найден</returns>
        </member>
        <member name="M:TFlex.Model.Document.GetClosestObject(TFlex.Drawing.Point,TFlex.Model.Page,TFlex.Model.SelectionFilter)">
            <summary>Получить объект, ближайший к заданной точке на заданной странице с учётом фильтра</summary>
            <param name="point">Точка на чертеже</param>
            <param name="page">Страница чертежа</param>
            <param name="filter">Фильтр объектов</param>
            <returns>Найденный объект или null если объект не найден</returns>
        </member>
        <member name="M:TFlex.Model.Document.GetObjectById(TFlex.Model.ObjectId)">
            <summary>Получение объекта по идентификатору</summary>
            <param name="id">Идентификатор объекта</param>
            <returns>Найденный объект или null если объект не найден</returns>
        </member>
        <member name="M:TFlex.Model.Document.GetObjectByID(System.UInt32)">
            <summary>Получение объекта по идентификатору</summary>
            <param name="id">Идентификатор объекта</param>
            <returns>Найденный объект или null если объект не найден</returns>
        </member>
        <member name="M:TFlex.Model.Document.GetObjectByName(System.String)">
            <summary>Получение объекта по имени</summary>
            <param name="name">Имя объекта</param>
            <returns>Найденный объект или null если объект не найден</returns>
        </member>
        <member name="P:TFlex.Model.Document.StructureElements">
            <summary>Вспомогательный объект для работы со структурными элементами</summary>
        </member>
        <member name="P:TFlex.Model.Document.Bodies">
            <summary>Контейнер всех тел</summary>
        </member>
        <member name="M:TFlex.Model.Document.Get2DObjects">
            <summary>Контейнер всех 2D объектов документа</summary>
        </member>
        <member name="M:TFlex.Model.Document.GetObjects">
            <summary>Контейнер всех объектов документа</summary>
        </member>
        <member name="M:TFlex.Model.Document.GetPages">
            <summary>Получить контейнер страниц документа</summary>
        </member>
        <member name="P:TFlex.Model.Document.Views">
            <summary>Вид данного документа</summary>
        </member>
        <member name="P:TFlex.Model.Document.ModelObjectGroups">
            <summary>Группы элементов</summary>
        </member>
        <member name="P:TFlex.Model.Document.Selection">
            <summary>Селектор документа</summary>
            <remarks>Объект класса <see cref="T:TFlex.Model.SelectionContainer" />.
может быть 0 в случае если документ не имеет селектора.
Не иметь селектора может, например, документ, используемый в качестве фрагмента.</remarks>
        </member>
        <member name="P:TFlex.Model.Document.IsDisposed">
            <summary>Возвращает true, если вызывался Dispose()</summary>
        </member>
        <member name="P:TFlex.Model.Document.Visible">
            <summary>Проверка является ли документ видимым</summary>
            <returns>True если документ является видимым</returns>
        </member>
        <member name="P:TFlex.Model.Document.IsAnnotation">
            <summary>Проверка того, что документ является аннотацией</summary>
            <returns>
                <c>true</c>, если документ является аннотацией, иначе <c>false</c></returns>
        </member>
        <member name="P:TFlex.Model.Document.IsFragment">
            <summary>Режим открытия документа в качестве фрагмента</summary>
            <returns>True если документ вставлен как фрагмент, иначе False</returns>
        </member>
        <member name="P:TFlex.Model.Document.IsReadOnly">
            <summary>Проверка доступности файла документа для записи <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" /> method</summary>
            <returns>True если файл документа недоступен для записи, иначе false</returns>
        </member>
        <member name="M:TFlex.Model.Document.SaveModified">
            <summary>Показать диалог сохранения изменений в документе</summary>
            <returns>false - для отмены, в противном случае - true</returns>
        </member>
        <member name="M:TFlex.Model.Document.MergeTwoTailUndoBlocks">
            <summary>Объединить два верхних Undo-блока</summary>
        </member>
        <member name="M:TFlex.Model.Document.IsChanging">
            <summary>Проверка того, что открыт блок изменения документа</summary>
            <returns>True если блок изменения документа открыт, в противном случае false</returns>
        </member>
        <member name="M:TFlex.Model.Document.CancelChanges(System.Boolean)">
            <summary>Отменить все изменения и закрыть блок изменения документа</summary>
            <remarks>Функция закрывает блок изменения документа, открытый при помощи функции <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" />
с отменой всех произведённых изменений.</remarks>
        </member>
        <member name="M:TFlex.Model.Document.CancelChanges">
            <summary>Отменить все изменения и закрыть блок изменения документа</summary>
            <remarks>Функция закрывает блок изменения документа, открытый при помощи функции <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" />
с отменой всех произведённых изменений.</remarks>
        </member>
        <member name="M:TFlex.Model.Document.ShowLastErrorDialog">
            <summary>Показать диалоговое окно с информацией о последней ошибке, возникшей в документе</summary>
        </member>
        <member name="M:TFlex.Model.Document.EndChanges(TFlex.Model.EndChangesOptions)">
            <summary>Применить изменения и закрыть блок изменения документа</summary>
            <param name="options">Параметры</param>
            <returns>Результат применения изменений</returns>
        </member>
        <member name="M:TFlex.Model.Document.EndChanges(System.Boolean,System.Boolean,System.Boolean)">
            <summary>Применить изменения и закрыть блок изменения документа</summary>
            <param name="Unconditionally">Условие корректности модели с ошибками пересчета</param>
            <param name="Regenerate">Пересчитывать модель</param>
            <param name="Merge">Объединить Undo-блок с верхним Undo-блоком</param>
            <remarks>Функция закрывает блок изменения документа, открытый при помощи функции <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" />.
Функция автоматически применяет все изменения блока если они являются корректными. В таком случае
возвращаемое значение равно OK. Иначе все изменения отменяются. В данном случае модель с ошибками 
пересчёта является корректной</remarks>
            <returns>Результат применения изменений</returns>
        </member>
        <member name="M:TFlex.Model.Document.EndChanges(System.Boolean,System.Boolean)">
            <summary>Применить изменения и закрыть блок изменения документа</summary>
            <param name="Unconditionally">Условие корректности модели с ошибками пересчёта</param>
            <param name="Regenerate">Пересчитывать модель</param>
            <remarks>Функция закрывает блок изменения документа, открытый при помощи функции <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" />.
Функция автоматически применяет все изменения блока если они являются корректными. В таком случае
возвращаемое значение равно OK. Иначе все изменения отменяются. В данном случае модель с ошибками 
пересчёта является корректной</remarks>
            <returns>Результат применения изменений</returns>
        </member>
        <member name="M:TFlex.Model.Document.EndChanges(System.Boolean)">
            <summary>Применить изменения и закрыть блок изменения документа</summary>
            <param name="Unconditionally">Условие корректности модели с ошибками пересчёта</param>
            <remarks>Функция закрывает блок изменения документа, открытый при помощи функции <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" />.
Функция автоматически применяет все изменения блока если они являются корректными. В таком случае
возвращаемое значение равно OK. Иначе все изменения отменяются. В данном случае модель с ошибками 
пересчёта является корректной</remarks>
            <returns>Результат применения изменений</returns>
        </member>
        <member name="M:TFlex.Model.Document.EndChanges">
            <summary>Применить изменения и закрыть блок изменения документа</summary>
            <remarks>Функция закрывает блок изменения документа, открытый при помощи функции <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" />
Функция автоматически применяет все изменения блока если они являются корректными. В таком случае
возвращаемое значение равно OK. Иначе все изменения отменяются.</remarks>
            <returns>Результат применения изменений</returns>
        </member>
        <member name="M:TFlex.Model.Document.ApplyChanges(System.Boolean)">
            <summary>Применить изменения без закрытия блока изменения документа</summary>
            <param name="regenerate3D">Переcчитать 3D документ</param>
            <remarks>Функция применяет изменения, сделаные после вызова функции <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" />.
В зависимости от параметра regenerate3D пересчитывает или нет 3D документ</remarks>
            <returns>Результат применения изменений</returns>
        </member>
        <member name="M:TFlex.Model.Document.ApplyChanges">
            <summary>Применить изменения без закрытия блока изменения документа</summary>
            <remarks>Функция применяет изменения, сделаные после вызова функции <see cref="M:TFlex.Model.Document.BeginChanges(System.String)" /></remarks>
            <returns>Результат применения изменений</returns>
        </member>
        <member name="M:TFlex.Model.Document.RenameChanges(System.String)">
            <summary>Задать новое имя блока изменения документа</summary>
            <param name="name">Задаёт новое имя блока изменения документа</param>
        </member>
        <member name="M:TFlex.Model.Document.BeginChanges(System.String)">
            <summary>Открытие блока изменения документа</summary>
            <remarks>Для выполнения любых изменений в документе (создание новых объектов, удаление объектов, изменение объектов)
необходимо открыть блок действий по изменению документа (блок изменения документа)
Одновременно может быть открыт только один блок изменения документа.
Вложение блоков изменения документа не допускается. 
Для закрытия блока изменения документа необходимо вызвать <see cref="M:TFlex.Model.Document.EndChanges" /> или <see cref="M:TFlex.Model.Document.CancelChanges" />.
Имя блока изменения документа отображается в диалоге отмены и повтора действий.</remarks>
            <param name="name">Задаёт имя блока изменения документа</param>
        </member>
        <member name="M:TFlex.Model.Document.Activate">
            <summary>Активизировать документ</summary>
        </member>
        <member name="M:TFlex.Model.Document.OpenWorkplaneView(TFlex.Model.Page)">
            <summary>Создать новое 2D окно документа с активной рабочей плоскостью</summary>
            <param name="page">Страница документа</param>
            <returns>Объект вида документа</returns>
        </member>
        <member name="M:TFlex.Model.Document.Open3DView">
            <summary>Создать новое 3D окно документа</summary>
            <returns>Объект вида документа</returns>
        </member>
        <member name="M:TFlex.Model.Document.Open2DView">
            <summary>Создать новое 2D окно документа</summary>
            <returns>Объект вида документа</returns>
        </member>
        <member name="P:TFlex.Model.Document.Properties">
            <summary>Свойства документа</summary>
        </member>
        <member name="P:TFlex.Model.Document.ActiveView">
            <summary>Объект класса View, представляющий активный (текущий) вид документа</summary>
            <returns>Mожет вернуть 0 в том случае если у документа нет активного вида или вообще нет видов.</returns>
            <remarks>У документа есть виды только в том случае, если он открыт для редактирования и не является документом фрагмента или временным документом.</remarks>
        </member>
        <member name="M:TFlex.Model.Document.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="T:TFlex.Model.Document">
            <summary>Класс документа T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.Model.PrintOptions.View">
            <summary>Вид для печати. Необязательный параметр.</summary>
        </member>
        <member name="P:TFlex.Model.PrintOptions.Pages">
            <summary>Страницы для печати. Необязательный параметр.</summary>
        </member>
        <member name="P:TFlex.Model.PrintOptions.OwnerWindowHandle">
            <summary>Дексриптор родительского окна</summary>
        </member>
        <member name="T:TFlex.Model.PrintOptions">
            <summary>Параметры печати</summary>
        </member>
        <member name="T:TFlex.Model.AssemblyContextData2D">
            <summary>Данные редактирования документа в контексте 2д сборки</summary>
        </member>
        <member name="P:TFlex.Model.AssemblyContextData.FragmentDocument">
            <summary>Документ фрагмента</summary>
            <remarks>Документ который редактируется в контексте</remarks>
        </member>
        <member name="P:TFlex.Model.AssemblyContextData.AssemblyDocument">
            <summary>Документ сборки</summary>
            <remarks>Документ в контексте которого редактируется документ фрагмента</remarks>
        </member>
        <member name="P:TFlex.Model.CopyObjectsOptions.ReplaceVariablesByExpression">
            <summary>Заменять переменные</summary>
            <remarks>По умолчанию при совпадении выражения переменые заменяются</remarks>
        </member>
        <member name="P:TFlex.Model.CopyObjectsOptions.ReplaceVariablesByName">
            <summary>Заменять переменные</summary>
            <remarks>По умолчанию при совпадении имен переменые заменяются</remarks>
        </member>
        <member name="P:TFlex.Model.CopyObjectsOptions.AffineMap">
            <summary>Аффинное преобразование</summary>
        </member>
        <member name="P:TFlex.Model.CopyObjectsOptions.TargetPage">
            <summary>Страница на которую копируются объекты</summary>
            <remarks>По умолчанию объекты копируются на активную страницу</remarks>
        </member>
        <member name="M:TFlex.Model.CopyObjectsOptions.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.CopyObjectsOptions">
            <summary>Опции метода Document.CopyObjects</summary>
        </member>
        <member name="P:TFlex.Model.EndChangesOptions.ShowLastErrorDialog">
            <summary>Показать диалоговое окно с информацией о последней ошибке, возникшей в документе</summary>
        </member>
        <member name="P:TFlex.Model.EndChangesOptions.Merge">
            <summary>Объединить Undo-блок с верхним Undo-блоком</summary>
        </member>
        <member name="P:TFlex.Model.EndChangesOptions.Regenerate">
            <summary>Пересчитывать модель</summary>
        </member>
        <member name="P:TFlex.Model.EndChangesOptions.Unconditionally">
            <summary>Условие корректности модели с ошибками пересчёта</summary>
        </member>
        <member name="M:TFlex.Model.EndChangesOptions.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.EndChangesOptions">
            <summary>Опции метода Document.EndChanges</summary>
        </member>
        <member name="P:TFlex.Model.RegenerateOptions.UpdateDrawingViews">
            <summary>Обновить чертёжные виды</summary>
        </member>
        <member name="P:TFlex.Model.RegenerateOptions.UpdateBillOfMaterials">
            <summary>Обновить спецификации</summary>
        </member>
        <member name="P:TFlex.Model.RegenerateOptions.UpdateProductStructures">
            <summary>Обновить структуры изделия</summary>
        </member>
        <member name="P:TFlex.Model.RegenerateOptions.UpdateAllLinks">
            <summary>Обновить все ссылки</summary>
        </member>
        <member name="P:TFlex.Model.RegenerateOptions.Projections">
            <summary>Регенерация 2D проекций</summary>
        </member>
        <member name="P:TFlex.Model.RegenerateOptions.Full">
            <summary>Полная регенерация</summary>
        </member>
        <member name="M:TFlex.Model.RegenerateOptions.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.RegenerateOptions">
            <summary>Опции регенерации модели</summary>
        </member>
        <member name="P:TFlex.Model.DeleteUnusedOptions.DeleteNamed2dObjects">
            <summary>Удалить именованные 2D объекты</summary>
        </member>
        <member name="P:TFlex.Model.DeleteUnusedOptions.DeleteActivePageOnly">
            <summary>Удалить только активную страницу</summary>
        </member>
        <member name="P:TFlex.Model.DeleteUnusedOptions.DeleteVariables">
            <summary>Удалить переменные</summary>
        </member>
        <member name="P:TFlex.Model.DeleteUnusedOptions.DeletePages">
            <summary>Удалить страницы</summary>
        </member>
        <member name="P:TFlex.Model.DeleteUnusedOptions.Delete3dObjects">
            <summary>Удалить 3D объекты</summary>
        </member>
        <member name="P:TFlex.Model.DeleteUnusedOptions.Delete2dObjects">
            <summary>Удалить 2D объекты</summary>
        </member>
        <member name="T:TFlex.Model.DeleteUnusedOptions">
            <summary>Опции удаления объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.DeleteOptions.Exclude">
            <summary>Исключить удаляемые элементы из модели</summary>
        </member>
        <member name="P:TFlex.Model.DeleteOptions.DeletePageObjects">
            <summary>Используется методом DeletePage</summary>
            <remarks>Задаёт удаление страницы и всех элементов, находящихся на ней. Если false, станица будет удалена, если только на ней нет элементов.</remarks>
        </member>
        <member name="P:TFlex.Model.DeleteOptions.DisableMacrosSmartFragments">
            <summary>Отключить запуск макроса у смарт-фрагментов (событие удаления фрагмента)</summary>
        </member>
        <member name="P:TFlex.Model.DeleteOptions.Silent">
            <summary>Режим "без вопроса"</summary>
        </member>
        <member name="M:TFlex.Model.DeleteOptions.#ctor(System.Boolean)">
            <summary>Конструктор</summary>
            <param name="silent">Режим "без вопроса". Если данный параметр имеет значение true, то вопрос об удалении зависимых элементов не задаётся</param>
        </member>
        <member name="M:TFlex.Model.DeleteOptions.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.DeleteOptions">
            <summary>Опции удаления объектов модели</summary>
        </member>
        <member name="T:TFlex.Model.CreateVariableMode">
            <summary>Режим создания переменной</summary>
        </member>
        <member name="F:TFlex.Model.CreateVariableMode.Default">
            <summary>По умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.ChangesResult">
            <summary>Класс результата пересчёта модели при применении или завершении изменений</summary>
        </member>
        <member name="F:TFlex.Model.ChangesResult.CompleteError">
            <summary>Некоторый объект некорректен в смысле полноты и непротиворечивости задания данных</summary>
        </member>
        <member name="F:TFlex.Model.ChangesResult.RecursionError">
            <summary>Рекурсия при установке взаимосвязей между объектами</summary>
        </member>
        <member name="F:TFlex.Model.ChangesResult.VariableError">
            <summary>Ошибка пересчёта переменных модели</summary>
        </member>
        <member name="F:TFlex.Model.ChangesResult.ObjectError">
            <summary>Ошибка пересчёта объекта</summary>
        </member>
        <member name="F:TFlex.Model.ChangesResult.OK">
            <summary>Нет ошибок</summary>
        </member>
        <member name="F:TFlex.Model.ChangesResult.UndefinedError">
            <summary>Неопределённая ошибка</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.ModificationGuid">
            <summary>Guid модификации документа</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.MassUnit">
            <summary>Единица измерения массы документа по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.LinearUnit">
            <summary>Единица измерения длины документа по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.LastAccessDate">
            <summary>Свойства файла-&gt;"Общее"-&gt;Использован</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.LastSaveDate">
            <summary>Свойства файла-&gt;"Общее"-&gt;Изменен</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.CreateDate">
            <summary>Свойства файла-&gt;"Общее"-&gt;Создан</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.EditTime">
            <summary>Свойства файла-&gt;"Статистика"-&gt;Общее время редактирования</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.RevNum">
            <summary>Свойства файла-&gt;"Статистика"-&gt;Номер варианта</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.LastAuthor">
            <summary>Свойства файла-&gt;"Статистика"-&gt;Сохранён</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.Keywords">
            <summary>Свойства файла-&gt;"Информация"-&gt;Ключи</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.Category">
            <summary>Свойства файла-&gt;"Информация"-&gt;Категория</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.Company">
            <summary>Свойства файла-&gt;"Информация"-&gt;Компания</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.Author">
            <summary>Свойства файла-&gt;"Информация"-&gt;Автор</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.Subject">
            <summary>Свойства файла-&gt;"Информация"-&gt;Тема</summary>
        </member>
        <member name="P:TFlex.Model.DocumentProperties.Title">
            <summary>Свойства файла-&gt;"Информация"-&gt;Название</summary>
        </member>
        <member name="T:TFlex.Model.DocumentProperties">
            <summary>Свойства документа</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetRelation(TFlex.Model.ModelObject,System.String)">
            <summary>Измерить отношение двух объектов</summary>
            <param name="other">Второй объект</param>
            <param name="relationName">Имя параметра для измерения, например Distance (см. команду Измерить в пользовательском интерфейсе)</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.Replace(TFlex.Model.ModelObject,System.Boolean)">
            <summary>Заменить объект</summary>
            <param name="source">Исходный объект, который нужно заменить</param>
            <param name="deleteSource">Удалить заменённый объект после замены</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.PasteProperties">
            <summary>Вставить свойства из буфера</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.CopyProperties">
            <summary>Копировать свойства в буфер</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetTextProperty(System.String)">
            <summary>Получить значение свойства элемента</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetRealProperty(System.String)">
            <summary>Получить значение свойства элемента</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetIntProperty(System.String)">
            <summary>Получить значение свойства элемента</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetProperties">
            <summary>Получить описание свойств элемента</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.IsDisposed">
            <summary>Объект удален из модели</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.Editable">
            <summary>Объект находится в состоянии редактирования</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetTextProp(System.String,System.Boolean@)">
            <summary>Измеримые свойства объекта</summary>
            <param name="prop">Имя свойства</param>
            <param name="exist">Признак существования такого свойства</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetRealProp(System.String,System.Boolean@)">
            <summary>Измеримые свойства объекта</summary>
            <param name="prop">Имя свойства</param>
            <param name="exist">Признак существования такого свойства</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetIntProp(System.String,System.Boolean@)">
            <summary>Измеримые свойства объекта</summary>
            <param name="prop">Имя свойства</param>
            <param name="exist">Признак существования такого свойства</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.CreateStyle(System.IntPtr,System.IntPtr)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.CreateStyle(System.IntPtr)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.#ctor(System.IntPtr,System.Boolean)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.CompareTo(System.Object)">
            <summary>Сравнение объектов по идентификаторам</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetRegenerationResult(System.Boolean)">
            <summary>Результат пересчета объекта</summary>
            <param name="partialRegenAsSuccess">Считать частичный пересчёт (с незначительными ошибками) как удавшийся</param>
            <returns>true - если пересчёт прошел успешно, иначе false</returns>
        </member>
        <member name="M:TFlex.Model.ModelObject.Regenerate(System.Boolean)">
            <summary>Пересчитать объект</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.MarkChanged">
            <summary>Пометить объект как изменённый</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.DependsOn(TFlex.Model.ModelObject)">
            <summary>Проверка зависимости объектов</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.ModelObjectGroup">
            <summary>Группа, которая включает данный объект</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.IsInModelObjectGroup">
            <summary>Является ли объект элементом группы</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.Visible">
            <summary>Является ли объект видимым</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.IsVisible">
            <summary>Это свойство устарело и будет удалено. Пожалуйста, используйте свойство 'Visible'.</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.Parents">
            <summary>Контейнер родительских объектов</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetAttributes">
            <summary>Контейнер атрибутов объекта. Приложение может использовать данный
контейнер для хранения своих данных, связанных с объектом</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.ObjectId">
            <summary>Идентификатор объекта. Идентификатор является уникальным для каждого из объектов одного документа</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.ID">
            <summary>Идентификатор объекта. Идентификатор является уникальным числом
для каждого из объектов одного документа</summary>
            <example>
                <code name="Пример использования свойства ID">
public static void ID(UInt32 ID)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   if(document.GetObjectByID(ID)!= null)//получение объекта по идентификатору
   {
    //действия с объектом    
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetName(TFlex.Model.ModelObjectName)">
            <summary>Получить имя объекта</summary>
            <param name="nameType">Тип имени</param>
        </member>
        <member name="P:TFlex.Model.ModelObject.DisplayName">
            <summary>Отображаемое название объекта</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.Name">
            <summary>Имя объекта</summary>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.ModelObject.PageScale">
            <summary>Масштаб страницы объекта</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetFileLinkReference(System.Int32,TFlex.Model.ModelObject.ArrayIndices)">
            <summary>Получить ссылку на файл по ключу и индексу. Используется для организации массивов</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится ссылка</param>
            <param name="indices">Координаты элемента</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.SetFileLinkReference(System.Int32,TFlex.Model.FileLink,TFlex.Model.ModelObject.ArrayIndices)">
            <summary>Установить ссылку на файл по ключу и индексу. Используется для организации массивов</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится ссылка</param>
            <param name="link">Ссылка на файл</param>
            <param name="indices">Координаты элемента</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetFileLinkReference(System.Int32)">
            <summary>Получить ссылку на файл по ключу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится ссылка</param>
            <returns>Ссылка на файл</returns>
        </member>
        <member name="M:TFlex.Model.ModelObject.SetFileLinkReference(System.Int32,TFlex.Model.FileLink)">
            <summary>Установить ссылку на файл по ключу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится ссылка</param>
            <param name="link">Ссылка на файл</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetReference(System.Int32,TFlex.Model.ModelObject.ArrayIndices)">
            <summary>Получить ссылку на родительский объект по ключу и индексу. Используется для организации массивов</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="indices">Координаты элемента</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.GetReference(System.Int32)">
            <summary>Получить ссылку на родительский объект по ключу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.SetReference(System.Int32,TFlex.Model.ModelObject.Reference,TFlex.Model.ModelObject.ArrayIndices)">
            <summary>Установить ссылку на родительский объект по ключу и индексу. Используется для организации массивов</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="reference">Ссылка на родительский объект</param>
            <param name="indices">Координаты элемента</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.SetReference(System.Int32,TFlex.Model.ModelObject.Reference)">
            <summary>Установить ссылку на родительcкий объект по ключу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="reference">Ссылка на родительский объект</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.ArrayIndices.op_Implicit(System.UInt32)~TFlex.Model.ModelObject.ArrayIndices">
            <summary>Получить элемент по индексу</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="P:TFlex.Model.ModelObject.ArrayIndices.Index2">
            <summary>Второй индекс. Для одномерного массива свойство равно 0</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.ArrayIndices.Index1">
            <summary>Первый индекс</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.ArrayIndices.#ctor(System.UInt32,System.UInt32)">
            <summary>Конструктор для двух индексов</summary>
            <param name="index1">Первый индекс</param>
            <param name="index2">Второй индекс</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.ArrayIndices.#ctor(System.UInt32)">
            <summary>Конструктор для одного индекса</summary>
            <param name="index">Индекс</param>
        </member>
        <member name="T:TFlex.Model.ModelObject.ArrayIndices">
            <summary>Класс для передачи ссылок по индексу. Используется для организации массивов</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.Reference.DeleteParentObjects">
            <summary>Удалять родительские объекты</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.Reference.IgnoreAllowDeteteForOneChild">
            <summary>Игнорировать флаг AllowDelete в случае удаления родителя с одним зависимым потомком</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.Reference.AllowDelete">
            <summary>Не удалять объект при удалении родителя (удалять только ссылку)</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.Reference.op_Implicit(TFlex.Model.ModelObject)~TFlex.Model.ModelObject.Reference">
            <summary>Оператор установления ссылки на объект</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.Reference.#ctor(System.UInt32)">
            <summary>Конструктор пустой ссылки по ключу с передаваемым набором флажков</summary>
            <param name="states">Набор флажков</param>
        </member>
        <member name="P:TFlex.Model.ModelObject.Reference.States">
            <summary>Получить набор флагов</summary>
        </member>
        <member name="P:TFlex.Model.ModelObject.Reference.Object">
            <summary>Родительский объект</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.Reference.#ctor(TFlex.Model.ModelObject,System.UInt32)">
            <summary>Конструктор ссылки по ключу с передаваемым набором флажков</summary>
            <param name="object">Родительский объект</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.ModelObject.Reference.#ctor(TFlex.Model.ModelObject)">
            <summary>Конструктор ссылки по ключу</summary>
            <param name="object">Родительский объект</param>
        </member>
        <member name="F:TFlex.Model.ModelObject.Reference.ReferenceStates.NotCheckChanged">
            <summary>Не проверять изменён ли родитель</summary>
        </member>
        <member name="F:TFlex.Model.ModelObject.Reference.ReferenceStates.NotShowInTree">
            <summary>Не показывать ссылку в дереве моделей</summary>
        </member>
        <member name="F:TFlex.Model.ModelObject.Reference.ReferenceStates.NotMark">
            <summary>Не маркировать родительскую операцию (используется в операциях, в которых помимо самой операции задаются ссылки на отдельные элементы этой операции. Поскольку маркируются эти элементы, то весь объект маркировать не надо. Например, операция сглаживания)</summary>
        </member>
        <member name="F:TFlex.Model.ModelObject.Reference.ReferenceStates.SupplementalInformation">
            <summary>Если объект ссылается на операцию, то возможны два варианта: объект подменяет эту операцию или объект опрашивает только информацию с этой операции. Во втором случае, чтобы операция оставалась в сцене, нужно передавать этот параметр.</summary>
        </member>
        <member name="T:TFlex.Model.ModelObject.Reference.ReferenceStates">
            <summary>Флаги для управления ссылками. В настоящей версии, актуальны только для 3D</summary>
        </member>
        <member name="T:TFlex.Model.ModelObject.Reference">
            <summary>Класс для передачи ссылки на другой объект модели</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.IsKindOf(TFlex.Model.ObjectType)">
            <summary>Проверить принадлежность объекта указанному типу</summary>
            <param name="type">Тип для проверки</param>
            <returns>true если объект принадлежит указанному типу</returns>
        </member>
        <member name="P:TFlex.Model.ModelObject.GroupType">
            <summary>Идентификатор типа данного объекта</summary>
            <remarks>Возможные типы перечислены в перечислении ObjectType</remarks>
        </member>
        <member name="P:TFlex.Model.ModelObject.Document">
            <summary>Документ, являющийся родительским для данного объекта</summary>
        </member>
        <member name="M:TFlex.Model.ModelObject.Clone">
            <summary>Создаёт копию объекта</summary>
            <returns>Объект, являющийся копией данного объекта</returns>
        </member>
        <member name="T:TFlex.Model.ModelObject">
            <summary>Класс объекта документа T-FLEX CAD</summary>
            <remarks>Даный класс является базовым для всех классов объектов документа.</remarks>
        </member>
        <member name="T:TFlex.Model.ModelObjectName">
            <summary>Тип имени модельного объекта</summary>
        </member>
        <member name="F:TFlex.Model.ModelObjectName.DisplayNameForTree">
            <summary>Имя, импользуемое в окне "Дерево модели"</summary>
        </member>
        <member name="F:TFlex.Model.ModelObjectName.DisplayName">
            <summary>Отображаемое имя</summary>
        </member>
        <member name="F:TFlex.Model.ModelObjectName.Name">
            <summary>Имя</summary>
        </member>
        <member name="M:TFlex.Model.ObjectArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.ObjectArray.Add(TFlex.Model.ModelObject)">
            <summary>Добавление объекта в массив</summary>
            <param name="object">Добавляемый объект</param>
        </member>
        <member name="M:TFlex.Model.ObjectArray.#ctor(System.Collections.Generic.IEnumerable`1{TFlex.Model.ModelObject})">
            <summary>Конструктор, добавляющий в массив все элементы из перечисления objects</summary>
            <param name="objects">Контейнер элементов</param>
        </member>
        <member name="M:TFlex.Model.ObjectArray.#ctor(TFlex.Model.SelectionContainer)">
            <summary>Конструктор, добавляющий в массив все выбранные элементы модели</summary>
            <param name="selection">Контейнер выбранных элементов</param>
        </member>
        <member name="M:TFlex.Model.ObjectArray.#ctor(TFlex.Model.ModelObject)">
            <summary>Конструктор, добавляющий в массив один объект</summary>
            <param name="object">Добавляемый объект</param>
        </member>
        <member name="M:TFlex.Model.ObjectArray.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.ObjectArray">
            <summary>Массив объектов модели</summary>
        </member>
        <member name="M:TFlex.Model.ParentObjects.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.ParentObjects">
            <summary>Контейнер родительских объектов</summary>
        </member>
        <member name="P:TFlex.Model.ParentObject.Type">
            <summary>Тип связи объекта</summary>
        </member>
        <member name="P:TFlex.Model.ParentObject.Object">
            <summary>Объект</summary>
        </member>
        <member name="T:TFlex.Model.ParentObject">
            <summary>Родительский объект</summary>
        </member>
        <member name="P:TFlex.Model.ObjectProperty.Type">
            <summary>Описание свойства</summary>
        </member>
        <member name="P:TFlex.Model.ObjectProperty.Description">
            <summary>Описание свойства</summary>
        </member>
        <member name="P:TFlex.Model.ObjectProperty.Name">
            <summary>Имя свойства</summary>
        </member>
        <member name="T:TFlex.Model.ObjectProperty">
            <summary>Описание свойства объекта</summary>
        </member>
        <member name="T:TFlex.Model.ObjectPropertyType">
            <summary>Тип свойства</summary>
        </member>
        <member name="F:TFlex.Model.ObjectPropertyType.IntProperty">
            <summary>Целое</summary>
        </member>
        <member name="F:TFlex.Model.ObjectPropertyType.TextProperty">
            <summary>Текстовое</summary>
        </member>
        <member name="F:TFlex.Model.ObjectPropertyType.RealProperty">
            <summary>Вещественный</summary>
        </member>
        <member name="F:TFlex.Model.ObjectPropertyType.UnknownProperty">
            <summary>Неизвестный</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectCollection`1.Enumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectCollection`1.Enumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectCollection`1.Enumerator.CurrentT">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="P:TFlex.Model.ModelObjectCollection`1.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="M:TFlex.Model.ModelObjectCollection`1.GetEnumeratorT">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.ModelObjectCollection`1">
            <summary>Контейнер модельных объектов документа</summary>
        </member>
        <member name="P:TFlex.Model.ObjectContainer.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="M:TFlex.Model.ObjectContainer.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.ObjectContainer.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.ObjectContainer.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.ObjectContainer.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="T:TFlex.Model.ObjectContainer">
            <summary>Контейнер объектов документа</summary>
        </member>
        <member name="M:TFlex.Model.Views.Enumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Views.Enumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Views.Enumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Views.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Views.#ctor(TFlex.Model.Document,System.Boolean)">
            <summary>Конструктор</summary>
            <param name="document">Документ перечислителя видов документа</param>
            <param name="only2D">true в случае если перечислитель 2D объектов, в противном случае false</param>
        </member>
        <member name="M:TFlex.Model.Views.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ перечислителя видов документа</param>
        </member>
        <member name="T:TFlex.Model.Views">
            <summary>Вид документа</summary>
        </member>
        <member name="M:TFlex.Model.ObjectEnumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.ObjectEnumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.ObjectEnumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.ObjectEnumerator.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.ObjectEnumerator.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.ObjectEnumerator.#ctor(TFlex.Model.Document,System.Boolean)">
            <summary>Конструктор</summary>
            <param name="document">Документ перечислителя объектов документа</param>
            <param name="only2D">true в случае если перечислитель 2D объектов,
в противном случае false</param>
        </member>
        <member name="M:TFlex.Model.ObjectEnumerator.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="document">Документ перечислителя объектов документа</param>
        </member>
        <member name="M:TFlex.Model.CustomFilter.CanSelectObject(TFlex.Model.ModelObject)">
            <summary>Разрешить выбирать указанные объекты</summary>
            <param name="Object">Выбираемый объект</param>
        </member>
        <member name="M:TFlex.Model.CustomFilter.CanSelectType(TFlex.Model.ObjectType)">
            <summary>Разрешить выбирать объекты указанного типа</summary>
            <param name="Type">Тип выбираемого объекта</param>
        </member>
        <member name="M:TFlex.Model.CustomFilter.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.CustomFilter">
            <summary>Класс пользовательского фильтра</summary>
        </member>
        <member name="M:TFlex.Model.SelectionFilter.Disable(TFlex.Model.ObjectType)">
            <summary>Запретить выбор объектов указанного типа</summary>
            <param name="type">Тип объекта</param>
        </member>
        <member name="M:TFlex.Model.SelectionFilter.Enable(TFlex.Model.ObjectType)">
            <summary>Разрешить выбор объектов указанного типа</summary>
            <param name="type">Тип объекта</param>
        </member>
        <member name="M:TFlex.Model.SelectionFilter.DisableAllTypes">
            <summary>Выключить выбор объектов всех типов</summary>
        </member>
        <member name="M:TFlex.Model.SelectionFilter.EnableAllTypes">
            <summary>Включить выбор объектов любых типов</summary>
        </member>
        <member name="M:TFlex.Model.SelectionFilter.#ctor">
            <summary>Конструктор. По умолчанию устанавливается выбор всех типов объектов</summary>
        </member>
        <member name="T:TFlex.Model.SelectionFilter">
            <summary>Фильтр, позволяющий выбирать или не выбирать объекты различных типов</summary>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.GetAllObjects">
            <summary>Получить список выбранных объектов</summary>
            <returns>Список выбранных объектов</returns>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.GetAt(System.Int32)">
            <summary>Получить выбранный объект по индексу</summary>
            <param name="i">Индекс</param>
            <returns>Объект, находящийся в контейнере выбранных объектов с указанным индексом. 0 в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.GetSize">
            <summary>Получить количество выбранных объектов</summary>
            <returns>Текущий размер контейнера выбранных объектов</returns>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.DeselectAll">
            <summary>Отменить выбор всех выбранных объектов</summary>
            <remarks>Функция отменяет выбор всех выбранных объектов
(производится очистка контейнера выбранных объектов)</remarks>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.Deselect(TFlex.Model.ModelObject)">
            <summary>Отменить выбор объекта</summary>
            <param name="obj">Объект, выбор которого требуется отменить (удалить из контейнера выбранных объектов.</param>
            <remarks>Данная функция удаляет указанный объект из контейнера выбранных объектов.
При этом отменяется пометка этого объекта на всех видах документа, на которых он является видимым.</remarks>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.DelayedSelect(TFlex.Model.ModelObject)">
            <summary>Выбрать объект</summary>
            <param name="obj">Объект, который требуется выбрать (поместить в контейнер выбранных объектов</param>
            <remarks>Данная функция помещает указанный объект в контейнер выбранных объектов.
При этом объект помечается на всех видах документа, на которых объект является видимым.
Для отмены выбора объекта можно воспользоваться функцией Deselect или DeselectAll</remarks>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.Select(TFlex.Model.ModelObject,TFlex.Model.SelectionContainer.MarkType)">
            <summary>Выбрать объект</summary>
            <param name="obj">Объект, который требуется выбрать (поместить в контейнер выбранных объектов</param>
            <param name="style">Стиль маркировки объекта</param>
            <remarks>Данная функция помещает указанный объект в контейнер выбранных объектов.
При этом объект помечается на всех видах документа, на которых объект является видимым.
Для отмены выбора объекта можно воспользоваться функцией Deselect или DeselectAll</remarks>
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.Force2D">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.Transparent">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.NoEdges">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.NoFill">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.FaceEdge">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.Face">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.Service">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.Node">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.Path">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.ElemGroup">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.ThirdType">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.SecondType">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.FirstType">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.ArrowsOnEdges">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.MouseMarked">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.Active">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.Default">
            <summary />
        </member>
        <member name="F:TFlex.Model.SelectionContainer.MarkType.None">
            <summary />
        </member>
        <member name="T:TFlex.Model.SelectionContainer.MarkType">
            <summary>Стиль маркировки объекта</summary>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.Select(TFlex.Model.ModelObject)">
            <summary>Выбрать объект</summary>
            <param name="obj">Объект, который требуется выбрать (поместить в контейнер выбранных объектов</param>
            <remarks>Данная функция помещает указанный объект в контейнер выбранных объектов.
При этом объект помечается на всех видах документа, на которых объект является видимым.
Для отмены выбора объекта можно воспользоваться функцией Deselect или DeselectAll</remarks>
        </member>
        <member name="M:TFlex.Model.SelectionContainer.IsSelected(TFlex.Model.ModelObject)">
            <summary>Проверка, является ли объект выбранным</summary>
            <param name="obj">Объект для которого производится проверка</param>
            <returns>True, если данный объект является выбранным, то есть находится в контейнере
выбранных объектов</returns>
            <remarks>Данная функция выполняет проверку на наличие указанного объекта в контейнере выбранных объектов</remarks>
        </member>
        <member name="T:TFlex.Model.SelectionContainer">
            <summary>Класс контейнера выбранных объектов.</summary>
            <remarks>Объект данного класса является членом класса 
документа и создаётся только для документов, открытых для редактирования. Т.е. такой невозможно
получить у документа фрагмента или временного документа.</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.GetLinePatternPreview(System.String,System.Drawing.Rectangle@,System.Drawing.Color)">
            <summary>Получение изображения для предпросмотра стиля линии</summary>
            <param name="pattern">Название стиля линии</param>
            <param name="rect">Область рисования</param>
            <param name="backColor">Цвет фона</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.GetLinePatternNames">
            <summary>Получение списка названий стилей линий</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Arc3Points(TFlex.Drawing.Point,TFlex.Drawing.Point,TFlex.Drawing.Point)">
            <summary>Прорисовка дуги, проходящей через три точки</summary>
            <param name="point1">Точка начала дуги</param>
            <param name="point2">Точка на дуге</param>
            <param name="point3">Точка конца дуги</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Arc(TFlex.Drawing.Point,TFlex.Drawing.Point,TFlex.Drawing.Point,System.Boolean)">
            <summary>Прорисовка дуги с центром в заданной точке, проходящей через две точки</summary>
            <param name="center">Центральная точка дуги</param>
            <param name="point1">Точка начала дуги</param>
            <param name="point2">Точка конца дуги</param>
            <param name="direction">Направление дуги. При значении true против часовой стрелки;
false - по часовой стрелке</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Arc(TFlex.Drawing.Point,TFlex.Drawing.Point,TFlex.Drawing.Point)">
            <summary>Прорисовка дуги с центром в заданной точке, проходящей через две точки,
против часовой стрелки</summary>
            <param name="center">Центральная точка дуги</param>
            <param name="point1">Точка начала дуги</param>
            <param name="point2">Точка конца дуги</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.AddDashSpace(System.Double)">
            <summary>Добавление в массив штрихов штрихового типа линии пробела (интервала между штрихами)</summary>
            <param name="length">Длина добавляемого пробела</param>
            <remarks>Суммарное число штрихов и пробелов между ними не должно превышать 20</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.AddDashLine(System.Double)">
            <summary>Добавление в массив штрихов штрихового типа линии сплошного штриха</summary>
            <param name="length">Длина добавляемого штриха</param>
            <remarks>Суммарное число штрихов и пробелов между ними не должно превышать 20</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.ClearDashes">
            <summary>Сброс массива штрихов штрихового типа линии</summary>
            <remarks>Последующее добавление штрихов и пробелов осуществляется
при помощи методов <see cref="M:TFlex.Drawing.Graphics.AddDashLine(System.Double)" /> и <see cref="M:TFlex.Drawing.Graphics.AddDashSpace(System.Double)" /></remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetDashedType(System.Boolean)">
            <summary>Установка прорисовки шрихового типа линии</summary>
            <param name="dashed">true, если необходимо рисовать штриховую линию;
false для сплошного типа линии</param>
            <returns>true, если до вызова была установлена прорисовка штриховой линии;
false для сплошного типа линии</returns>
        </member>
        <member name="P:TFlex.Drawing.Graphics.DashedType">
            <summary>Установка прорисовки шрихового типа линии</summary>
            <remarks>true, если необходимо рисовать штриховую линию;
false для сплошного типа линии</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.DrawMarker(TFlex.Drawing.MarkerType,TFlex.Drawing.Point)">
            <summary>Вывод маркера</summary>
            <param name="type">Тип маркера</param>
            <param name="point">Координаты маркера</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.GetTextHeight(System.String)">
            <summary>Получение высоты текста с текущими установками шрифта</summary>
            <param name="text">Текст</param>
            <returns>Высота текста</returns>
        </member>
        <member name="M:TFlex.Drawing.Graphics.GetTextLength(System.String)">
            <summary>Получение длины текста с текущими установками шрифта</summary>
            <param name="text">Текст</param>
            <returns>Длина текста вдоль его направления</returns>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontVerticalAlignment">
            <summary>Установка выравнивания текста по вертикали</summary>
            <remarks>По умолчанию значение этого параметра равно Lower</remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontHorizontalAlignment">
            <summary>Установка выравнивания текста по горизонтали</summary>
            <remarks>По умолчанию значение этого параметра равно Left</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetFontRotation(System.Double,System.Double)">
            <summary>Установка угла поворота текста с помощью вектора вертикали</summary>
            <param name="dx">Координата x вектора вертикали шрифта</param>
            <param name="dy">Координата y вектора вертикали шрифта</param>
            <remarks>Для вывода обычного горизонтального текста вектор вертикали шрифта
должен быть направлен вверх, например иметь координаты (1,0).
Альтернативным способом задания угла поворота текста является свойство <see cref="P:TFlex.Drawing.Graphics.FontAngle" /></remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontAngle">
            <summary>Установка угла поворота текста</summary>
            <remarks>Угол поворота измеряется от горизонтали. Положительное значение угла
соответствует повороту против часовой стрелки. По умолчанию значение этого параметра равно 0.
Альтернативным способом задания угла поворота текста является метод <see cref="M:TFlex.Drawing.Graphics.SetFontRotation(System.Double,System.Double)" /></remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontClearBackground">
            <summary>Установка параметра "очистка фона"</summary>
            <remarks>По умолчанию значение этого параметра равно false</remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontTilt">
            <summary>Установка угла наклона шрифта</summary>
            <remarks>Угол наклона учитывается только при выводе шрифта формата SHX.
Угол измеряется в градусах. По умолчанию угол наклона шрифта равен 90.</remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontInterval">
            <summary>Установка коэффициента междустрочного интервала</summary>
            <remarks>Абсолютное значение междустрочного интервала вычисляется перемножением
высоты шрифта и данного коэффициента. По умолчанию коэффициент дополнительного
интервала между симолами шрифта равен 0.5</remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontSpacing">
            <summary>Установка дополнительного интервала между символами</summary>
            <remarks>Абсолютное значение дополнительного интервала между символами вычисляется перемножением
высоты шрифта и данного коэффициента. По умолчанию коэффициент дополнительного интервала
между символами шрифта равен 0</remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontExtension">
            <summary>Установка коэффициента расширения шрифта</summary>
            <remarks>Коэффициент расширения шрифта учитывается только при выводе шрифта формата SHX.
По умолчанию коэффициент расширения шрифта равен 1.</remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontSize">
            <summary>Установка размера шрифта</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetFontName(System.String,TFlex.Drawing.FontStyle)">
            <summary>Выбор шрифта для прорисовки текста</summary>
            <param name="fontname">Имя шрифта</param>
            <param name="style">Стиль шрифта. Учитывается только для шрифтов TrueType</param>
            <remarks>Тип шрифта зависит от расширения имени шрифта. Если присутствует расширение".shx",
то будет выбран шрифт формата SHX. Метод <see cref="M:TFlex.Drawing.Graphics.SetFontName(System.String,TFlex.Drawing.FontStyle)" /> является альтернативой данному методу.</remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.FontName">
            <summary>Выбор шрифта для прорисовки текста</summary>
            <remarks>Тип шрифта зависит от расширения имени шрифта. Если присутствует расширение ".shx",
то будет выбран шрифт формата SHX. Если выбирается шрифт типа TrueType (без расширения),
то по умолчанию устанавливается стиль Normal из перечислителя <see cref="T:TFlex.Drawing.FontStyle" />.
Метод <see cref="M:TFlex.Drawing.Graphics.SetFontName(System.String,TFlex.Drawing.FontStyle)" /> является альтернативой данному методу</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.DrawText(TFlex.Drawing.Point,System.String)">
            <summary>Вывод текста в указанной точке</summary>
            <param name="point">Координаты текста</param>
            <param name="text">Содержание текста</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.ArrowArc(TFlex.Drawing.Point,TFlex.Drawing.Point,TFlex.Drawing.Point,System.Int32,System.Double,System.Int32,System.Double)">
            <summary>Прорисовка дуги со стрелками с центром в заданной точке, проходящей через две точки, против часовой стрелки</summary>
            <param name="center">Центральная точка дуги</param>
            <param name="point1">Точка начала дуги</param>
            <param name="point2">Точка конца дуги</param>
            <param name="startType">Тип стрелки в начальной точке</param>
            <param name="startSize">Размер стрелки в начальной точке</param>
            <param name="endType">Тип стрелки в конечной точке</param>
            <param name="endSize">Размер стрелки в конечной точке</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.ArrowPolyline(TFlex.Drawing.Polyline,System.Int32,System.Double,System.Int32,System.Double)">
            <summary>Прорисовка полилинии со стрелками</summary>
            <param name="polyline">Полилиния</param>
            <remarks>Полилиния выводится с учётом установленной растровой операции, цвета вывода, толщины линий, типа линий</remarks>
            <param name="startType">Тип стрелки в начальной точке</param>
            <param name="startSize">Размер стрелки в начальной точке</param>
            <param name="endType">Тип стрелки в конечной точке</param>
            <param name="endSize">Размер стрелки в конечной точке</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.ArrowLine(TFlex.Drawing.Point,TFlex.Drawing.Point,System.Int32,System.Double,System.Int32,System.Double)">
            <summary>Прорисовка отрезка со стрелками</summary>
            <param name="start">Начальная точка отрезка</param>
            <param name="end">Конечная точка отрезка</param>
            <param name="startType">Тип стрелки в начальной точке</param>
            <param name="startSize">Размер стрелки в начальной точке</param>
            <param name="endType">Тип стрелки в конечной точке</param>
            <param name="endSize">Размер стрелки в конечной точке</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Circle(TFlex.Drawing.Point,TFlex.Drawing.Point)">
            <summary>Прорисовка окружности</summary>
            <param name="center">Центр окружности</param>
            <param name="point">Точка на окружности</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Circle(TFlex.Drawing.Point,System.Double)">
            <summary>Прорисовка окружности</summary>
            <param name="center">Центр окружности</param>
            <param name="radius">Радиус окружности</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.FillRectangle(TFlex.Drawing.Rectangle)">
            <summary>Заливка прямоугольника</summary>
            <param name="rect">Прямоугольник</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Rectangle(TFlex.Drawing.Rectangle)">
            <summary>Прорисовка границ прямоугольника</summary>
            <param name="rect">Прямоугольник</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.LineTo(TFlex.Drawing.Point)">
            <summary>Прорисовка отрезка от указателя к данной точке</summary>
            <param name="point">Точка, в которую необходимо провести отрезок и переместить указатель</param>
            <remarks>Отрезок выводится от указателя, который был установлен методом
<see cref="M:TFlex.Drawing.Graphics.MoveTo(TFlex.Drawing.Point)" /> или предыдущим вызовом метода <see cref="M:TFlex.Drawing.Graphics.LineTo(TFlex.Drawing.Point)" /></remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.MoveTo(TFlex.Drawing.Point)">
            <summary>Перемещение указателя в точку</summary>
            <param name="point">Точка, в которую необходимо переместить указатель</param>
            <remarks>Последующий вызов метода <see cref="M:TFlex.Drawing.Graphics.LineTo(TFlex.Drawing.Point)" /> выведет отрезок, начинающийся в данной точке</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Line(TFlex.Drawing.Point,TFlex.Drawing.Point)">
            <summary>Прорисовка отрезка между двумя точками</summary>
            <param name="start">Начальная точка отрезка</param>
            <param name="end">Конечная точка отрезка</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Fill(TFlex.Drawing.Polyline)">
            <summary>Заливка области, ограниченной полилинией</summary>
            <param name="polyline">Полилиния</param>
            <remarks>Заливка производится учётом установленной растровой операции и цвета вывода</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Polyline(TFlex.Drawing.Polyline)">
            <summary>Прорисовка полилинии</summary>
            <param name="polyline">Полилиния</param>
            <remarks>Полилиния выводится с учётом установленной растровой операции,
цвета вывода, толщины линий, типа линий</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.GetWCSPoint(System.Drawing.Point)">
            <summary>Получение координат точки, координаты которой заданы в системе графического устройства,
в мировой системе координат (системе координат модели)</summary>
            <param name="point">Точка в системе координат графического устройства</param>
            <returns>Точка в мировой системе координат (системе координат модели), соответствующая исходной</returns>
        </member>
        <member name="M:TFlex.Drawing.Graphics.GetLCSPoint(TFlex.Drawing.Point)">
            <summary>Получение координат точки, координаты которой заданы в мировой системе координат
(системе координат модели), в системе координат графического устройства</summary>
            <param name="point">Точка в мировой системе координат (системе координат модели)</param>
            <returns>Точка в системе координат графического устройства, соответствующая исходной</returns>
        </member>
        <member name="M:TFlex.Drawing.Graphics.ClearBackground">
            <summary>Очистка фона</summary>
            <remarks>Очистка производится цветом фона, установленного при помощи метода <see cref="M:TFlex.Drawing.Graphics.SetBkColor(System.Int32)" />
или свойства <see cref="P:TFlex.Drawing.Graphics.BkColor" />. По умолчанию установлен белый цвет фона</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetEraseMode(System.Boolean)">
            <summary>Установка режима очистки фона</summary>
            <param name="value">Состояние режима очистки фона</param>
            <returns>Предыдущее значение</returns>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetLineWidth(System.Double)">
            <summary>Установка толщины линии для функций вывода линий, полилиний,
текстов и других линейных объектов</summary>
            <param name="width">Значение толщины линий</param>
            <returns>Толщина линий, которая была установлена до вызова данного метода</returns>
        </member>
        <member name="P:TFlex.Drawing.Graphics.LineWidth">
            <summary>Толщина линии для функций вывода линий, полилиний, текстов и других линейных объектов</summary>
        </member>
        <member name="P:TFlex.Drawing.Graphics.MarkColor">
            <summary>Цвет, используемый для пометки элементов</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetRGBBkColor(System.Int32,System.Int32,System.Int32)">
            <summary>Установка цвета фона в виде компонент красного, зелёного и синего</summary>
            <param name="r">Красная составляющия (от 0 до 255)</param>
            <param name="g">Зелёная составляющия (от 0 до 255)</param>
            <param name="b">Синяя составляющия (от 0 до 255)</param>
            <returns>Цвет фона, который был установлен до вызова данного метода</returns>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetRGBBkColor(System.Int32)">
            <summary>Установка цвета фона в виде компонент красного, зелёного и синего</summary>
            <param name="color">Цвет</param>
            <returns>Цвет фона, который был установлен до вызова данного метода</returns>
        </member>
        <member name="P:TFlex.Drawing.Graphics.RGBBkColor">
            <summary>Цвет фона в виде компонент красного, зелёного и синего</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetBkColor(System.Int32)">
            <summary>Установка цвета фона</summary>
            <param name="color">Цвет</param>
            <returns>Цвет фона, который был установлен до вызова данного метода</returns>
            <remarks>Предопределённые значения перечислены в перечислении <see cref="T:TFlex.Drawing.Color" /></remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.BkColor">
            <summary>Цвет фона</summary>
            <remarks>Предопределённые значения перечислены в перечислителе <see cref="T:TFlex.Drawing.Color" /></remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetRGBColor(System.Int32,System.Int32,System.Int32)">
            <summary>Установка цвета, которым должен производиться вывод,
в виде компонент красного, зелёного и синего</summary>
            <param name="r">Красная составляющая (от 0 до 255)</param>
            <param name="g">Зелёная составляющая (от 0 до 255)</param>
            <param name="b">Синяя составляющая (от 0 до 255)</param>
            <returns>Цвет, который был установлен до вызова данного метода</returns>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetRGBColor(System.Int32)">
            <summary>Установка цвета, которым должен производиться вывод,
в виде компонент красного, зелёного и синего</summary>
            <param name="color">Цвет</param>
            <returns>Цвет, который был установлен до вызова данного метода</returns>
        </member>
        <member name="P:TFlex.Drawing.Graphics.RGBColor">
            <summary>Цвет, которым производится вывод, в виде компонент красного, зелёного и синего</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetColor(System.Int32)">
            <summary>Установка цвета, которым должен производиться вывод</summary>
            <param name="color">Цвет</param>
            <returns>Цвет, который был установлен до вызова данного метода</returns>
            <remarks>Предопределённые значения перечислены в перечислителе <see cref="T:TFlex.Drawing.Color" /></remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.Color">
            <summary>Цвет, которым производится вывод</summary>
            <remarks>Предопределённые значения перечислены в перечислителе <see cref="T:TFlex.Drawing.Color" /></remarks>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetColorLock(System.Boolean)">
            <summary>Установка режима запрета смены цвета (одноцветный режим)</summary>
            <param name="lock">true, если необходимо установить режим запрета смены цвета;
false, если необходимо отменить этот режим</param>
            <returns>Режим запрета смены цвета, установленный до вызова данного метода</returns>
        </member>
        <member name="P:TFlex.Drawing.Graphics.ColorLock">
            <summary>Режим запрета смены цвета (одноцветный режим)</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.SetRop(TFlex.Drawing.RasterOperation)">
            <summary>Установка типа растровой операции, которую необходимо использовать для вывода</summary>
            <param name="rop">Тип растровой операции</param>
            <returns>Тип растровой операции, который был установлен до вызова данного метода</returns>
        </member>
        <member name="P:TFlex.Drawing.Graphics.Rop">
            <summary>Тип растровой операции, установленной для вывода</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.ReleaseDeviceContext(System.IntPtr)">
            <summary>Освобождение дескриптора графического устройства (HDC)</summary>
            <param name="Handle">Дескриптор графического устройства</param>
            <example>
                <code name="Вывод графического изображения на экран">
using System;
using System.Drawing;
using System.Windows.Forms;
using System.IO;

using TFlex;
using TFlex.Model;
using TFlex.Model.Model2D;
using TFlex.Model.Model3D;
using TFlex.Command;
using TFlex.Drawing;

namespace NewMacroNamespace
{
   public class NewMacroClass
   {
       public static void NewMacro()
       {
           TFlex.Command.CommandState commandState = new TFlex.Command.CommandState();
           DeviceContextCommand deviceContextCommand = new DeviceContextCommand(commandState);
           deviceContextCommand.InsertGroove(commandState);
       }

       public class DeviceContextCommand : CustomCommand
       {
           public DeviceContextCommand(TFlex.Command.CommandState cmd)
               : base(cmd)
           {

           }

           TFlex.Model.Document _document;

           public override void OnInitialize(InitializeEventArgs e)
           {
               _document = TFlex.Application.ActiveDocument;
               _document.BeginChanges("");

               base.OnInitialize(e);

               UpdateAutomenu();
           }

           public override void OnExit(ExitEventArgs e)
           {
               _document.EndChanges();
           }

           public void InsertGroove(TFlex.Command.CommandState cmd)
           {
               try
               {
                   CustomCommand d = new DeviceContextCommand(cmd);
                   d.Run(null);
               }
               catch (Exception e)
               {
                   MessageBox.Show(e.StackTrace);
               }
           }

           public InputState State { get; set; }

           public enum InputState
           {
               None,//ничего не выбрано
               Draw,//начать рисование
               Exit//закончить рисование
           };

           //событие перемещения курсора
           public override void OnShowCursor(TFlex.Command.MouseEventArgs e)
           {
               base.OnShowCursor(e);

               if (State == InputState.Draw)
               {
                   IntPtr hdc = e.Graphics.GetDeviceContext();

                   //создание класса Graphics
                   System.Drawing.Graphics newGraphics = System.Drawing.Graphics.FromHdc(hdc);

                   //рисование прямоугольника с рамкой
                   newGraphics.DrawRectangle(new Pen(System.Drawing.Color.BlueViolet, 3), (int)(e.X), (int)(e.Y), 100, 50);
                   //картинка
                   Image img = Image.FromFile(Path.Combine(TFlex.Application.ActiveDocument.FilePath, "mail.png"));
                   //рисование прямоугольника с заливкой картинкой
                   newGraphics.FillRectangle(new TextureBrush(img), new System.Drawing.Rectangle(new System.Drawing.Point((int)(e.X), (int)(e.Y)), new System.Drawing.Size(100, 50)));

                   //освобождение ресурсов
                   img.Dispose();
                   e.Graphics.ReleaseDeviceContext(hdc);
                   newGraphics.Dispose();
               }
           }

           public override void OnKeyPressed(TFlex.Command.KeyEventArgs e)
           {
               _document = e.Document;
               switch (e.Code)
               {
                   case KeyCode.keyEND:
                       {
                           State = InputState.Draw;

                           _document.ApplyChanges();
                           UpdateAutomenu();
                       }
                       break;

                   case KeyCode.keyESCAPE:
                       {

                           State = InputState.Exit;
                           GoToNextState(null);
                           OnExit(null);
                       }
                       break;
               }
           }

           //формирование кнопок автоменю
           protected void UpdateAutomenu()
           {
               TFlex.Command.Button[] buttonsAutoMenu = new TFlex.Command.Button[2];

               buttonsAutoMenu[0] = new DefaultButton(DefaultButton.Kind.OK, KeyCode.keyEND,
                   State == InputState.Draw ? TFlex.Command.Button.Style.Checked : TFlex.Command.Button.Style.Default);

               buttonsAutoMenu[1] = new DefaultButton(State == InputState.Exit ? DefaultButton.Kind.Exit : DefaultButton.Kind.Cancel);

               Automenu = new Automenu(buttonsAutoMenu);
           }

       };

   }
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Drawing.Graphics.GetDeviceContext">
            <summary>Получение дескриптора графического устройства (HDC)</summary>
            <returns>Дескриптор графического устройства</returns>
            <remarks>Для того чтобы воспользоваться дескриптором графического устройства,
который используется для вывода данным классом, его можно получить при помощи данного метода.
Ненулевое значение может быть получено только когда процесс вывода инициализирован
при помощи <see cref="M:TFlex.Drawing.Graphics.BeginDraw" /> или вызван метод <see cref="P:TFlex.Drawing.Graphics.DeviceContext" /> с ненулевым значением дескриптора
графического устройства.</remarks>
            <example>
                <code name="Вывод графического изображения на экран">
using System;
using System.Drawing;
using System.Windows.Forms;
using System.IO;

using TFlex;
using TFlex.Model;
using TFlex.Model.Model2D;
using TFlex.Model.Model3D;
using TFlex.Command;
using TFlex.Drawing;

namespace NewMacroNamespace
{
   public class NewMacroClass
   {
       public static void NewMacro()
       {
           TFlex.Command.CommandState commandState = new TFlex.Command.CommandState();
           DeviceContextCommand deviceContextCommand = new DeviceContextCommand(commandState);
           deviceContextCommand.InsertGroove(commandState);
       }

       public class DeviceContextCommand : CustomCommand
       {
           public DeviceContextCommand(TFlex.Command.CommandState cmd)
               : base(cmd)
           {

           }

           TFlex.Model.Document _document;

           public override void OnInitialize(InitializeEventArgs e)
           {
               _document = TFlex.Application.ActiveDocument;
               _document.BeginChanges("");

               base.OnInitialize(e);

               UpdateAutomenu();
           }

           public override void OnExit(ExitEventArgs e)
           {
               _document.EndChanges();
           }

           public void InsertGroove(TFlex.Command.CommandState cmd)
           {
               try
               {
                   CustomCommand d = new DeviceContextCommand(cmd);
                   d.Run(null);
               }
               catch (Exception e)
               {
                   MessageBox.Show(e.StackTrace);
               }
           }

           public InputState State { get; set; }

           public enum InputState
           {
               None,//ничего не выбрано
               Draw,//начать рисование
               Exit//закончить рисование
           };

           //событие перемещения курсора
           public override void OnShowCursor(TFlex.Command.MouseEventArgs e)
           {
               base.OnShowCursor(e);

               if (State == InputState.Draw)
               {
                   IntPtr hdc = e.Graphics.GetDeviceContext();

                   //создание класса Graphics
                   System.Drawing.Graphics newGraphics = System.Drawing.Graphics.FromHdc(hdc);

                   //рисование прямоугольника с рамкой
                   newGraphics.DrawRectangle(new Pen(System.Drawing.Color.BlueViolet, 3), (int)(e.X), (int)(e.Y), 100, 50);
                   //картинка
                   Image img = Image.FromFile(Path.Combine(TFlex.Application.ActiveDocument.FilePath, "mail.png"));
                   //рисование прямоугольника с заливкой картинкой
                   newGraphics.FillRectangle(new TextureBrush(img), new System.Drawing.Rectangle(new System.Drawing.Point((int)(e.X), (int)(e.Y)), new System.Drawing.Size(100, 50)));

                   //освобождение ресурсов
                   img.Dispose();
                   e.Graphics.ReleaseDeviceContext(hdc);
                   newGraphics.Dispose();
               }
           }

           public override void OnKeyPressed(TFlex.Command.KeyEventArgs e)
           {
               _document = e.Document;
               switch (e.Code)
               {
                   case KeyCode.keyEND:
                       {
                           State = InputState.Draw;

                           _document.ApplyChanges();
                           UpdateAutomenu();
                       }
                       break;

                   case KeyCode.keyESCAPE:
                       {

                           State = InputState.Exit;
                           GoToNextState(null);
                           OnExit(null);
                       }
                       break;
               }
           }

           //формирование кнопок автоменю
           protected void UpdateAutomenu()
           {
               TFlex.Command.Button[] buttonsAutoMenu = new TFlex.Command.Button[2];

               buttonsAutoMenu[0] = new DefaultButton(DefaultButton.Kind.OK, KeyCode.keyEND,
                   State == InputState.Draw ? TFlex.Command.Button.Style.Checked : TFlex.Command.Button.Style.Default);

               buttonsAutoMenu[1] = new DefaultButton(State == InputState.Exit ? DefaultButton.Kind.Exit : DefaultButton.Kind.Cancel);

               Automenu = new Automenu(buttonsAutoMenu);
           }

       };

   }
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Drawing.Graphics.DeviceContext">
            <summary>Установка дескриптора графического устройства (HDC)</summary>
            <remarks>В некоторых случаях необходимо выводить изображение непосредственно
на графическое устройство с использованием его дескриптора. Для этого используется данный метод.
Для этого можно сконструировать объект данного класса со значением hWnd равным 0.
Затем необходимо воспользоваться данным методом для установки дескриптора 
графического устройства. После завершения вывода обязательно обнуление дескриптора графического
устройства. Для этого в качестве значения параметра hdc должно быть передано значение 0.</remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.EndDraw">
            <summary>Завершение вывода изображения</summary>
            <remarks>Данную функцию необходимо вызвать после завершения вывода
изображения с использованием функций данного класса. До начала необходимо вызвать метод <see cref="M:TFlex.Drawing.Graphics.BeginDraw" /></remarks>
        </member>
        <member name="M:TFlex.Drawing.Graphics.BeginDraw">
            <summary>Начало вывода изображения</summary>
            <remarks>Данный метод необходимо вызвать перед началом вывода изображения
с использованием функций данного класса. Завершение вывода должно заканчиваться
вызовом метода <see cref="M:TFlex.Drawing.Graphics.EndDraw" />. Вызовы этой пары функций могут быть вложенными,
однако обязательным является соблюдение парности. Каждому вызову <see cref="M:TFlex.Drawing.Graphics.BeginDraw" />
должен соответствовать вызов <see cref="M:TFlex.Drawing.Graphics.EndDraw" />.</remarks>
        </member>
        <member name="P:TFlex.Drawing.Graphics.Scale">
            <summary>Масштаб преобразования в систему координат графического устройства</summary>
        </member>
        <member name="P:TFlex.Drawing.Graphics.LCSRectangle">
            <summary>Прямоугольник вывода в системе координат графического устройства</summary>
        </member>
        <member name="P:TFlex.Drawing.Graphics.WCSRectangle">
            <summary>Прямоугольник вывода в мировой системе координат</summary>
        </member>
        <member name="P:TFlex.Drawing.Graphics.IsMarkDevice">
            <summary>Текущий вывод производится для пометки объекта</summary>
        </member>
        <member name="P:TFlex.Drawing.Graphics.IsExportDevice">
            <summary>Текущий вывод производится в файл другого формата</summary>
        </member>
        <member name="P:TFlex.Drawing.Graphics.IsPrinterDevice">
            <summary>Текущий вывод производится на принтер</summary>
        </member>
        <member name="P:TFlex.Drawing.Graphics.IsDisplayDevice">
            <summary>Текущий вывод производится на экран</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.#ctor(TFlex.Drawing.Graphics,TFlex.Drawing.AffineMap)">
            <summary>Конструктор. Новый объект основанный на baseGraphics с применением к нему преобразования transformation.</summary>
            <param name="baseGraphics">Базовый объект</param>
            <param name="transformation">Преобразование</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.#ctor(System.IntPtr,System.Drawing.Rectangle,TFlex.Drawing.Rectangle)">
            <summary>Конструктор</summary>
            <param name="hWnd">Дескриптор окна</param>
            <param name="rect">Прямоугольник в системе координат устройства, в который производится вывод изображения</param>
            <param name="window">Прямоугольник в мировой системе координат, соответствующий прямоугольнику в системе координат устройства</param>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Finalize">
            <summary>Финализатор. Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Drawing.Graphics.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="T:TFlex.Drawing.Graphics">
            <summary>Класс предназначен для вывода графического изображения на экран или другое графическое устройство с использованием вещественных координат в системе координат документа.</summary>
        </member>
        <member name="M:TFlex.Drawing.StandardColors.FindClosestIndex(System.UInt32)">
            <summary>Найти индекс, наиболее соответствующий данному цвету</summary>
            <param name="colorref">Цвет в формате Windows GDI (COLORREF)</param>
            <remarks>Этот метод выполняется дольше, чем остальные методы класса,
поэтому при возможности его результаты следует кэшировать.</remarks>
        </member>
        <member name="M:TFlex.Drawing.StandardColors.FindClosestIndex(System.Drawing.Color)">
            <summary>Найти индекс, наиболее соответствующий данному цвету</summary>
            <param name="color">Системный цвет</param>
            <remarks>Этот метод выполняется дольше, чем остальные методы класса,
поэтому при возможности его результаты следует кэшировать.</remarks>
        </member>
        <member name="M:TFlex.Drawing.StandardColors.IndexFromColor(System.Drawing.Color)">
            <summary>Получить индекс для цвета, не входящего в основную палитру</summary>
        </member>
        <member name="M:TFlex.Drawing.StandardColors.ColorNameFromIndex(System.Int32)">
            <summary>Получить имя цвет по данному индексу</summary>
        </member>
        <member name="M:TFlex.Drawing.StandardColors.ColorFromIndex(System.Int32)">
            <summary>Получить цвет по данному индексу</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.EdgesInShadingIndex">
            <summary>Цвет рёбер при закраске модели</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Decoration3Index">
            <summary>Цвет декораций неактивных</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Decoration2Index">
            <summary>Цвет декораций дополнительный</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Decoration1Index">
            <summary>Цвет декораций</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveDraggerIndex">
            <summary>Цвет активного манипулятора</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.DraggerIndex">
            <summary>Цвет манипулятора</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveServiceIndex">
            <summary>Вспомогательный цвет активного элемента</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Service4Index">
            <summary>Вспомогательный цвет 4 (точки соответствия...)</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Service3Index">
            <summary>Вспомогательный цвет 3 (точки соответствия...)</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Service2Index">
            <summary>Вспомогательный цвет 2 (точки соответствия...)</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Service1Index">
            <summary>Вспомогательный цвет 1 (нормали и касательные)</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.LCSMarkIndex">
            <summary>Цвет пометки систем координат</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SectionMarkIndex">
            <summary>Цвет пометки сечений</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.WorkplaneMarkIndex">
            <summary>Цвет пометки рабочих плоскостей</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveNodeMarkIndex">
            <summary>Цвет пометки активных 3D узлов</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.NodeMark3Index">
            <summary>Цвет пометки 3D узлов 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.NodeMark2Index">
            <summary>Цвет пометки 3D узлов 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.NodeMark1Index">
            <summary>Цвет пометки 3D узлов 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveEdgeMarkIndex">
            <summary>Цвет пометки активных рёбер</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.EdgeMarkIndex">
            <summary>Цвет пометки рёбер</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActivePathMarkIndex">
            <summary>Цвет пометки активных путей и профилей</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.PathMark3Index">
            <summary>Цвет пометки путей и профилей 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.PathMark2Index">
            <summary>Цвет пометки путей и профилей 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.PathMark1Index">
            <summary>Цвет пометки путей и профилей 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveFaceEdgeIndex">
            <summary>Цвет пометки рёбер активной грани</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceEdgeMark3Index">
            <summary>Цвет пометки рёбер грани 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceEdgeMark2Index">
            <summary>Цвет пометки рёбер грани 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceEdgeMark1Index">
            <summary>Цвет пометки рёбер грани 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveFaceMarkIndex">
            <summary>Цвет пометки активной грани</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceMark3Index">
            <summary>Цвет пометки грани 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceMark2Index">
            <summary>Цвет пометки грани 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceMark1Index">
            <summary>Цвет пометки грани 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SolidMark3Index">
            <summary>Цвет пометки тела 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SolidMark2Index">
            <summary>Цвет пометки тела 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SolidMark1Index">
            <summary>Цвет пометки тела 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.DynamicMarkIndex">
            <summary>Цвет динамической подсветки элементов в 3D окне</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ClipPlaneIndex">
            <summary>Цвет плоскости обрезки</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveViewIndex">
            <summary>Цвет рамки активного вида</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.PageBorderIndex">
            <summary>Цвет рамки форматки</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.GridIndex">
            <summary>Цвет сетки</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ConstructionIndex">
            <summary>Цвет линий построения по умолчанию</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.NodeIndex">
            <summary>Цвет 2D узлов по умолчанию</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SameAsBackgroundIndex">
            <summary>Цвет элементов, имеющих цвет фона</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.BackgroundIndex">
            <summary>Цвет фона 2D страниц документа</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.XorMarkIndex">
            <summary>Цвет, используемый для пометки в режиме XOR</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.EdgesInShading">
            <summary>Цвет рёбер при закраске модели</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Decoration3">
            <summary>Цвет декораций неактивных</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Decoration2">
            <summary>Цвет декораций дополнительный</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Decoration1">
            <summary>Цвет декораций</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveDragger">
            <summary>Цвет активного манипулятора</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Dragger">
            <summary>Цвет манипулятора</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveService">
            <summary>Вспомогательный цвет активного элемента</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Service4">
            <summary>Вспомогательный цвет 4 (точки соответствия...)</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Service3">
            <summary>Вспомогательный цвет 3 (точки соответствия...)</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Service2">
            <summary>Вспомогательный цвет 2 (точки соответствия...)</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Service1">
            <summary>Вспомогательный цвет 1 (нормали и касательные)</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.LCSMark">
            <summary>Цвет пометки систем координат</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SectionMark">
            <summary>Цвет пометки сечений</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.WorkplaneMark">
            <summary>Цвет пометки рабочих плоскостей</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveNodeMark">
            <summary>Цвет пометки активных 3D узлов</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.NodeMark3">
            <summary>Цвет пометки 3D узлов 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.NodeMark2">
            <summary>Цвет пометки 3D узлов 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.NodeMark1">
            <summary>Цвет пометки 3D узлов 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveEdgeMark">
            <summary>Цвет пометки активных рёбер</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.EdgeMark">
            <summary>Цвет пометки рёбер</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActivePathMark">
            <summary>Цвет пометки активных путей и профилей</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.PathMark3">
            <summary>Цвет пометки путей и профилей 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.PathMark2">
            <summary>Цвет пометки путей и профилей 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.PathMark1">
            <summary>Цвет пометки путей и профилей 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveFaceEdge">
            <summary>Цвет пометки рёбер активной грани</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceEdgeMark3">
            <summary>Цвет пометки рёбер грани 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceEdgeMark2">
            <summary>Цвет пометки рёбер грани 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceEdgeMark1">
            <summary>Цвет пометки рёбер грани 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveFaceMark">
            <summary>Цвет пометки активной грани</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceMark3">
            <summary>Цвет пометки грани 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceMark2">
            <summary>Цвет пометки грани 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.FaceMark1">
            <summary>Цвет пометки грани 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SolidMark3">
            <summary>Цвет пометки тела 3</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SolidMark2">
            <summary>Цвет пометки тела 2</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SolidMark1">
            <summary>Цвет пометки тела 1</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.DynamicMark">
            <summary>Цвет динамической подсветки элементов в 3D окне</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ClipPlane">
            <summary>Цвет плоскости обрезки</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.ActiveView">
            <summary>Цвет рамки активного вида</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.PageBorder">
            <summary>Цвет рамки форматки</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Grid">
            <summary>Цвет сетки</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Construction">
            <summary>Цвет линий построения по умолчанию</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Node">
            <summary>Цвет 2D узлов по умолчанию</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.SameAsBackground">
            <summary>Цвет элементов, имеющих цвет фона</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.Background">
            <summary>Цвет фона 2D страниц документа</summary>
        </member>
        <member name="P:TFlex.Drawing.StandardColors.XorMark">
            <summary>Цвет, используемый для пометки в режиме XOR</summary>
        </member>
        <member name="T:TFlex.Drawing.StandardColors">
            <summary>Стандартные цвета</summary>
            <remarks>Класс позволяет использовать во внешних приложениях стандартные цвета T-Flex,
задаваемые в диалоге "Настройка-&gt;Установка-&gt;Цвета".
Статические свойства типа int предназначены для использования в методах Color(int) внутри API.
Статические свойства типа System.Drawing.Color могут использоваться в прочих случаях.</remarks>
        </member>
        <member name="T:TFlex.Drawing.MarkerType">
            <summary>Типы маркеров</summary>
        </member>
        <member name="F:TFlex.Drawing.MarkerType.FreeNode">
            <summary>Маленький квадрат</summary>
        </member>
        <member name="F:TFlex.Drawing.MarkerType.NodeMark">
            <summary>Большой квадрат</summary>
        </member>
        <member name="F:TFlex.Drawing.MarkerType.NodeCross">
            <summary>Косой крестик</summary>
        </member>
        <member name="T:TFlex.Drawing.FontVerticalAlignment">
            <summary>Типы выравнивания текста по вертикали</summary>
        </member>
        <member name="F:TFlex.Drawing.FontVerticalAlignment.Upper">
            <summary>По линии выше верхней границы текста</summary>
        </member>
        <member name="F:TFlex.Drawing.FontVerticalAlignment.Top">
            <summary>По верхней границе текста</summary>
        </member>
        <member name="F:TFlex.Drawing.FontVerticalAlignment.Center">
            <summary>По середине</summary>
        </member>
        <member name="F:TFlex.Drawing.FontVerticalAlignment.Bottom">
            <summary>По нижней границе текста</summary>
        </member>
        <member name="F:TFlex.Drawing.FontVerticalAlignment.Lower">
            <summary>По линии ниже нижней границы текста</summary>
        </member>
        <member name="T:TFlex.Drawing.FontHorizontalAlignment">
            <summary>Типы выравнивания текста по горизонтали</summary>
        </member>
        <member name="F:TFlex.Drawing.FontHorizontalAlignment.Right">
            <summary>По правому краю</summary>
        </member>
        <member name="F:TFlex.Drawing.FontHorizontalAlignment.Center">
            <summary>По середине</summary>
        </member>
        <member name="F:TFlex.Drawing.FontHorizontalAlignment.Left">
            <summary>По левому краю</summary>
        </member>
        <member name="T:TFlex.Drawing.FontStyle">
            <summary>Перечислитель стилей шрифта</summary>
        </member>
        <member name="F:TFlex.Drawing.FontStyle.BoldItalic">
            <summary>Полужирный наклонный</summary>
        </member>
        <member name="F:TFlex.Drawing.FontStyle.Italic">
            <summary>Наклонный</summary>
        </member>
        <member name="F:TFlex.Drawing.FontStyle.Bold">
            <summary>Полужирный</summary>
        </member>
        <member name="F:TFlex.Drawing.FontStyle.Normal">
            <summary>Обычный</summary>
        </member>
        <member name="T:TFlex.Drawing.RasterOperation">
            <summary>Перечислитель типов растровых операций, используемых при выводе на экран или другое графическое устройство</summary>
        </member>
        <member name="F:TFlex.Drawing.RasterOperation.XOR">
            <summary>Операция "исключающее или"</summary>
        </member>
        <member name="F:TFlex.Drawing.RasterOperation.OR">
            <summary>Операция "или"</summary>
        </member>
        <member name="F:TFlex.Drawing.RasterOperation.Set">
            <summary>Копирование. Данное значение установлено по умолчанию</summary>
        </member>
        <member name="T:TFlex.Drawing.Color">
            <summary>Предопределённые цвета, используемые в свойстве Color</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.White">
            <summary>Белый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.Yellow">
            <summary>Жёлтый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.LightMagenta">
            <summary>Розовый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.LightRed">
            <summary>Ярко-красный</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.LightCyan">
            <summary>Светло-бирюзовый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.LightGreen">
            <summary>Светло-зелёный</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.LightBlue">
            <summary>Голубой</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.DarkGray">
            <summary>Тёмно-серый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.LightGray">
            <summary>Светло-серый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.Brown">
            <summary>Коричневый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.Magenta">
            <summary>Сиреневый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.Red">
            <summary>Красный</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.Cyan">
            <summary>Бирюзовый</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.Green">
            <summary>Зелёный</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.Blue">
            <summary>Синий</summary>
        </member>
        <member name="F:TFlex.Drawing.Color.Black">
            <summary>Чёрный</summary>
        </member>
        <member name="M:TFlex.RibbonBar.AddTab(System.String)">
            <summary>Добавляет новую вкладку в эту ленту</summary>
        </member>
        <member name="P:TFlex.RibbonBar.Tabs">
            <summary>Вкладки этой ленты</summary>
        </member>
        <member name="P:TFlex.RibbonBar.ActiveTab">
            <summary>Активная вкладка этой ленты</summary>
        </member>
        <member name="M:TFlex.RibbonBar.GetTab(System.Int32)">
            <summary>i-ая вкладка этой ленты</summary>
        </member>
        <member name="P:TFlex.RibbonBar.Tab(System.Int32)">
            <summary>i-ая вкладка этой ленты</summary>
        </member>
        <member name="P:TFlex.RibbonBar.TabCount">
            <summary>Количество вкладок в этой ленте</summary>
        </member>
        <member name="P:TFlex.RibbonBar.ApplicationsTab">
            <summary>Вкладка, общая для всех приложений</summary>
        </member>
        <member name="M:TFlex.RibbonBar.LoadTabsFromString(System.String)">
            <summary>Загружает вкладки из указанной строки в формате XML и добавляет их в ленту каждого из открытых главных окон T-FLEX CAD</summary>
        </member>
        <member name="M:TFlex.RibbonBar.LoadTabsFromFile(System.String)">
            <summary>Загружает вкладки из указанного файла и добавляет их в ленту каждого из открытых главных окон T-FLEX CAD</summary>
        </member>
        <member name="T:TFlex.RibbonBar">
            <summary>Лента T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.PluginFactory.BeforeAll">
            <summary>Загружать плагин перед окном T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.PluginFactory.Name">
            <summary>Название приложения</summary>
        </member>
        <member name="P:TFlex.PluginFactory.ID">
            <summary>Глобальный уникальный идентификатор приложения (GUID)</summary>
        </member>
        <member name="M:TFlex.PluginFactory.CreateInstance">
            <summary>Cоздает объект приложения</summary>
        </member>
        <member name="T:TFlex.PluginFactory">
            <summary>Данный класс отвечает за регистрацию приложения. Он является точкой входа в приложение</summary>
        </member>
        <member name="M:TFlex.Plugin.CircuitLinkSplitMergeEventHandler(TFlex.CircuitLinkSplitMergeEventArgs)">
            <summary>Обработчик объединения/разделения линий связи</summary>
        </member>
        <member name="M:TFlex.Plugin.AlterColorButtonPressedHandler(TFlex.AlterColorButtonPressedEventArgs)">
            <summary>Обработчик события, при нажатии кнопки альтернативного выбора цвета</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.PlaneCreateEventHandler(TFlex.PlaneCreateEventArgs)">
            <summary>Обработчик события, возникающего при создании рабочей плоскости на линейке</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.PlaneChangedEventHandler(TFlex.PlaneEventArgs)">
            <summary>Обработчик события, возникающего при перемещении рабочей плоскости на линейке</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.FileDroppedEventHandler(TFlex.FileDroppedEventArgs)">
            <summary>Обработчик события, возникающего при перемещении и отпускании файла в одном из видов документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.DynamicAnalysisSteppedEventHandler(TFlex.DynamicAnalysisEventArgs)">
            <summary>Обработчик события, возникающего при решении задач динамического анализа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.HelpWindowOpeningEventHandler(TFlex.HelpWindowOpeningEventArgs)">
            <summary>Обработчик события, возникающего перед показом окна справки</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ExportDialogShownEventHandler(TFlex.ImportExportDialogShownEventArgs)">
            <summary>Обработчик события, возникающего после показа диалога экспорта</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ImportDialogShownEventHandler(TFlex.ImportExportDialogShownEventArgs)">
            <summary>Обработчик события, возникающего после показа диалога импорта</summary>
            <param name="args">Аргументы события</param>
            <seealso cref="M:TFlex.Plugin.ImportFile(System.String)" />
        </member>
        <member name="M:TFlex.Plugin.ShowingExportDialogEventHandler(TFlex.ShowingImportExportDialogEventArgs)">
            <summary>Обработчик события, возникающего перед показом диалога экспорта</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ShowingImportDialogEventHandler(TFlex.ShowingImportExportDialogEventArgs)">
            <summary>Обработчик события, возникающего перед показом диалога импорта</summary>
            <param name="args">Аргументы события</param>
            <seealso cref="M:TFlex.Plugin.ImportFile(System.String)" />
        </member>
        <member name="M:TFlex.Plugin.DocumentDrawnEventHandler(TFlex.DrawingDocumentEventArgs)">
            <summary>Обработчик события, возникающего после отрисовки документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.SelectionChangedEventHandler(TFlex.DocumentEventArgs)">
            <summary>Обработчик события, возникающего после изменения списка выбранных объектов без команды</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.DrawingDocumentEventHandler(TFlex.DrawingDocumentEventArgs)">
            <summary>Обработчик события, возникающего перед отрисовкой документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.CopyPropertiesCommandEventHandler(TFlex.CopyPropertiesCommandEventArgs)">
            <summary>Класс, содержащий данные о событии - вызвана команда</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.PluginCommandEventHandler(TFlex.PluginCommandEventArgs)">
            <summary>Класс, содержащий данные о событии - вызвана команда</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.WorkplaneCommandEventHandler(TFlex.WorkplaneCommandEventArgs)">
            <summary>Класс, содержащий данные о событии - вызвана команда управления рабочими плоскостями</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ViewRulerContextMenuCommandEventHandler(TFlex.ViewRulerContextMenuCommandEventArgs)">
            <summary>Обработчик события - вызвана локальная команда из контекстного меню линейки вида</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.TrackingContextPopupMenuEventHandler(TFlex.TrackingContextPopupMenuEventArgs)">
            <summary>Обработчик события, возникающего перед показом контекстного меню объекта</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ObjectPropertiesDialogCompletedEventHandler(TFlex.ObjectPropertiesDialogCompletedEventArgs)">
            <summary>Обработчик завершения редактирования объекта в окне "Параметры".</summary>
            <param name="args">Аргументы события</param>
            <remarks>В этой версии виртульного метода параметры более специфичны. Старая версия оставлена для совместимости.</remarks>
        </member>
        <member name="M:TFlex.Plugin.ObjectPropertiesDialogCompletedEventHandler(TFlex.ObjectEventArgs)">
            <summary>Обработчик завершения редактирования объекта в окне "Параметры".</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.MeasureResultsUpdatingEventHandler(TFlex.MeasureResultsUpdatingEventArgs)">
            <summary>Обработчик обновления результатов измерения. Приложение может добавить свои результаты в нее.</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ProductStructureUpdatingEventHandler(TFlex.ProductStructureUpdatingEventArgs)">
            <summary>Обработчик обновления структуры изделия. Приложение может добавить свои записи в нее.</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.MoveSelectedObjectsActionEventHandler(TFlex.MoveSelectedObjectsEventArgs)">
            <summary />
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.BlockChangesActionEventHandler(TFlex.BlockChangesEventArgs)">
            <summary>Обработчик события, возникающего перед открытием блока изменений и после закрытия блока изменений</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.AfterUndoActionEventHandler(TFlex.DocumentEventArgs)">
            <summary>Обработчик события, возникающего после отката действия</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.DocumentRegeneratedEventHandler(TFlex.RegenerateDocumentEventArgs)">
            <summary>Обработчик события, возникающего после пересчета документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.RegeneratingDocumentEventHandler(TFlex.RegenerateDocumentEventArgs)">
            <summary>Обработчик события, возникающего перед пересчетом документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ObjectSelectionChangedEventHandler(TFlex.ObjectEventArgs)">
            <summary>Обработчик события, возникающего при изменения селекции документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ObjectChangedEventHandler(TFlex.ObjectEventArgs)">
            <summary>Обработчик события, возникающего после изменения объекта</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ObjectDeletedEventHandler(TFlex.ObjectEventArgs)">
            <summary>Обработчик события, возникающего после удаления объекта модели</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.DeletingObjectEventHandler(TFlex.ObjectEventArgs)">
            <summary>Обработчик события, возникающего перед удалением объекта модели</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.DeletingObjectParentsEventHandler(TFlex.DeletingObjectParentsEventArgs)">
            <summary>Обработчик события, возникающего перед удалением объекта модели для получания дополнтиельных зависимых объектов для удаления</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ObjectCreatedEventHandler(TFlex.ObjectEventArgs)">
            <summary>Обработчик события, возникающего после создания объекта модели</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ViewDeactivatedEventHandler(TFlex.ViewEventArgs)">
            <summary>Обработчик события, возникающего после деактивизации окна документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ViewCreatedEventHandler(TFlex.ViewEventArgs)">
            <summary>Обработчик события, возникающего после создания окна документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ViewActivatedEventHandler(TFlex.ViewEventArgs)">
            <summary>Обработчик события, возникающего после активизации окна документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.ClosingDocumentEventHandler(TFlex.DocumentEventArgs)">
            <summary>Обработчик события, возникающего перед закрытием документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.DocumentSavedEventHandler(TFlex.DocumentEventArgs)">
            <summary>Обработчик события, возникающего после сохранения документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.SavingDocumentEventHandler(TFlex.DocumentEventArgs)">
            <summary>Обработчик события, возникающего перед сохранением документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.DocumentOpenEventHandler(TFlex.DocumentEventArgs)">
            <summary>Обработчик события открытия документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.NewDocumentCreatedEventHandler(TFlex.DocumentEventArgs)">
            <summary>Обработчик события создания нового документа</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.CreateFloatingWindowControl(System.UInt32)">
            <summary>Создать клиентскую часть плавающего окна приложения</summary>
            <param name="id">Идентификатор плавающего окна</param>
        </member>
        <member name="M:TFlex.Plugin.CreateFloatingWindow(System.UInt32,System.String,TFlex.FloatingWindowParameters)">
            <summary>Создать плавающее окно приложения</summary>
            <param name="id">Идентификатор окна</param>
            <param name="title">Заголовок окна</param>
            <param name="parameters">Параметры окна</param>
        </member>
        <member name="M:TFlex.Plugin.CreateFloatingWindow(System.UInt32,System.String)">
            <summary>Создать плавающее окно приложения</summary>
            <param name="id">Идентификатор окна</param>
            <param name="title">Заголовок окна</param>
        </member>
        <member name="M:TFlex.Plugin.CreateObject(TFlex.Model.Document,System.IntPtr,System.Int32)">
            <summary>Приложение переопределяет эту функцию для создания объекта модели указанного типа</summary>
            <param name="OwnerHandle" />
            <param name="TypeID" />
        </member>
        <member name="M:TFlex.Plugin.ImportFile(System.String)">
            <summary>Приложение переопределяет данный метод для импорта указанного файла</summary>
            <returns>Документ, в который был импортирован указанный файл, либо <c>null</c>, если формат файла не
поддерживается данным приложением</returns>
            <exception cref="T:System.OperationCanceledException">Выбрасывается, если данное приложение поддерживает формат
указанного файла, но импорт был отменён пользователем</exception>
            <remarks>В отличие от <see cref="M:TFlex.Plugin.ShowingImportDialogEventHandler(TFlex.ShowingImportExportDialogEventArgs)" /> и
<see cref="M:TFlex.Plugin.ImportDialogShownEventHandler(TFlex.ImportExportDialogShownEventArgs)" />, этот метод вызывается при передаче имён файлов через
параметры командной строки или перетаскивании файлов на главное окно T-FLEX CAD.</remarks>
            <seealso cref="M:TFlex.Plugin.ShowingImportDialogEventHandler(TFlex.ShowingImportExportDialogEventArgs)" />
            <seealso cref="M:TFlex.Plugin.ImportDialogShownEventHandler(TFlex.ImportExportDialogShownEventArgs)" />
        </member>
        <member name="M:TFlex.Plugin.OnUpdateSystemCommand(TFlex.Command.CommandUI)">
            <summary>Обновление состояния системной команды</summary>
        </member>
        <member name="M:TFlex.Plugin.OnSystemCommand(TFlex.Model.Document,System.Int32)">
            <summary>Обработка системной команды</summary>
        </member>
        <member name="M:TFlex.Plugin.RegisterSystemCommand(System.Int32)">
            <summary>Регистрация необходимости обработки одной из системных команд</summary>
        </member>
        <member name="M:TFlex.Plugin.OnUpdateCommand(TFlex.Command.CommandUI)">
            <summary>Приложение переопределяет данную функцию для того, чтобы запрещать или разрешать выполнение своих команд, а также устанавливать переключатели в меню и инструментальнй панели</summary>
        </member>
        <member name="M:TFlex.Plugin.OnCommand(TFlex.CommandEventArgs)">
            <summary>Приложение переопределяет эту функцию для получения команд, которые этим приложением зарегистрированы</summary>
            <param name="args">Аргументы команды</param>
        </member>
        <member name="M:TFlex.Plugin.OnCommand(TFlex.Model.Document,System.Int32)">
            <summary>Приложение переопределяет эту функцию для получения команд, которые этим приложением зарегистрированы</summary>
            <param name="pDocument">Документ, который является активным в момент выполнения данной команды</param>
            <param name="id">Идентификатор команды, под которым приложение эту команду зарегестрировало</param>
        </member>
        <member name="M:TFlex.Plugin.RegisterObjectTypeIcon(System.Int32,System.Drawing.Icon)">
            <summary>Регистрация иконку объекта модели приложения</summary>
            <param name="ID">Идентификатор иконки</param>
            <param name="TypeIcon">Иконка (16х16 пикселей)</param>
        </member>
        <member name="M:TFlex.Plugin.CreateHelpMenuItem(System.String,System.Int32,System.Int32)">
            <summary>Создать пункт меню в меню справки</summary>
            <param name="caption">Название пункта</param>
            <param name="commandId">Идентификатор команды</param>
            <param name="position">Позиция пункта в меню</param>
        </member>
        <member name="M:TFlex.Plugin.CreateSubMenu(TFlex.Menu,System.String,System.Int32)">
            <summary>Создать подменю в меню приложения</summary>
            <param name="menu">Меню для добавления</param>
            <param name="caption">Название панели</param>
            <param name="position">Позиция подменю в системном меню</param>
        </member>
        <member name="M:TFlex.Plugin.CreateToolbar(System.String,System.Int32[],System.Boolean)">
            <summary>Создать панель инструментов</summary>
            <param name="Caption">Название панели</param>
            <param name="CmdIDs">Массив идентификаторов команд приложения</param>
            <param name="Visible">Отображать при запуске</param>
        </member>
        <member name="M:TFlex.Plugin.CreateMainBarPanel(System.String,System.Int32[],System.Guid,System.Boolean)">
            <summary>Создать панель инструментов</summary>
            <param name="caption">Название панели</param>
            <param name="cmdIDs">Массив идентификаторов команд приложения</param>
            <param name="panelGuid">GUID панели, которую необходимо присоединить к MainBar-у</param>
            <param name="showDefaultSet">флаг, который отвечает за показ/скрытие набора иконок основных команд</param>
        </member>
        <member name="M:TFlex.Plugin.CreateToolbar(System.String,System.Int32[])">
            <summary>Создать панель инструментов</summary>
            <param name="Caption">Название панели</param>
            <param name="CmdIDs">Массив идентификаторов команд приложения</param>
        </member>
        <member name="M:TFlex.Plugin.RegisterAutomenuCommand(System.Int32,System.String,System.Drawing.Icon)">
            <summary>Регистрация команды автоменю</summary>
            <param name="id">Идентификатор команды автоменю</param>
            <param name="hint">Комментарии, отображающиеся при наведении курсора на иконку команды автоменю и в статусной строке</param>
            <param name="icon">Иконка команды автоменю (16х16 пикселей)</param>
        </member>
        <member name="M:TFlex.Plugin.RegisterObjectCommand(System.Int32,System.String,System.Drawing.Icon,System.Drawing.Icon)">
            <summary>Регистрация команды объекта</summary>
            <param name="id">Идентификатор команды объекта. Он должен быть уникальным в пределах приложения и не требует проверки на несовпадение с командами других приложения и самого T-FLEX CAD</param>
            <param name="prompt">Название команды объекта</param>
            <param name="smallIcon">Маленькая иконка команды (16х16 пикселей)</param>
            <param name="largeIcon">Большая иконка команды (24х24 пикселя)</param>
        </member>
        <member name="M:TFlex.Plugin.RegisterCommand(System.Int32,TFlex.Command.CommandParameters)">
            <summary>Регистрации команды приложения</summary>
            <param name="id">Идентификатор команды. Он должен быть уникальным в пределах приложения и не требует проверки
на несовпадение с командами других приложения и самого T-FLEX CAD</param>
            <param name="parameters">Параметры команды</param>
        </member>
        <member name="M:TFlex.Plugin.RegisterCommand(System.Int32,System.String,System.Drawing.Icon,System.Drawing.Icon)">
            <summary>Регистрации команды приложения</summary>
            <param name="id">Идентификатор команды. Он должен быть уникальным в пределах приложения и не требует проверки на несовпадение с командами других приложения и самого T-FLEX CAD</param>
            <param name="prompt">Название команды</param>
            <param name="smallIcon">Маленькая иконка команды (16х16 пикселей)</param>
            <param name="largeIcon">Большая иконка команды (24х24 пикселя)</param>
        </member>
        <member name="M:TFlex.Plugin.OnExited">
            <summary>Событие после закрытия главного окна</summary>
        </member>
        <member name="M:TFlex.Plugin.OnExiting(System.ComponentModel.CancelEventArgs)">
            <summary>Событие перед закрытием главного окна. Закрытие окна может быть отменено.</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.OnSessionInitialized(TFlex.SessionInitializedEventArgs)">
            <summary>Событие возникает, когда инициализация T-FLEX CAD завершена</summary>
            <param name="args">Аргументы события</param>
        </member>
        <member name="M:TFlex.Plugin.OnCreateTools">
            <summary>В данной функции приложение должно создать свои панели инструментов, зарегистрировать свои пункты меню, а также создать другие средства пользовательского интерфейса (немодальные окна и др.).</summary>
        </member>
        <member name="M:TFlex.Plugin.OnInitialize">
            <summary>Функция инициализации приложения.
Приложение должно переопределить данную функцию для того, чтобы получить управление в момент его запуска.</summary>
        </member>
        <member name="P:TFlex.Plugin.Name">
            <summary>Название приложения</summary>
        </member>
        <member name="P:TFlex.Plugin.ID">
            <summary>Глобальный уникальный идентификатор приложения (GUID)</summary>
        </member>
        <member name="M:TFlex.Plugin.#ctor(TFlex.PluginFactory)">
            <summary>Конструктор</summary>
            <param name="Factory">Объект класса регистрации приложения</param>
        </member>
        <member name="T:TFlex.Plugin">
            <summary>Данный класс реализует функциональность приложения для T-FLEX CAD.
Он обеспечивает свою регистрацию, регистрацию своих команд, создание панелей инструментов и формирование текстового меню.</summary>
        </member>
        <member name="T:TFlex.FloatingWindowParameters">
            <summary>Начальные параметры плавающего окна.</summary>
        </member>
        <member name="F:TFlex.FloatingWindowParameters.HideFromWindowList">
            <summary>Окно не отображается в списке окон приложения.</summary>
        </member>
        <member name="F:TFlex.FloatingWindowParameters.Hidden">
            <summary>Окно скрыто.</summary>
        </member>
        <member name="F:TFlex.FloatingWindowParameters.DockToMainGroup">
            <summary>Окно закреплено к основной группе окон.</summary>
        </member>
        <member name="F:TFlex.FloatingWindowParameters.Floating">
            <summary>Окно не закреплено.</summary>
        </member>
        <member name="P:TFlex.Command.CommandParameters.Bitmap">
            <summary>Отображаемое в расширенной всплывающей подсказке изображение</summary>
        </member>
        <member name="P:TFlex.Command.CommandParameters.LargeIcon">
            <summary>Большая иконка команды (24х24 пикселя)</summary>
        </member>
        <member name="P:TFlex.Command.CommandParameters.SmallIcon">
            <summary>Маленькая иконка команды (16х16 пикселей)</summary>
        </member>
        <member name="P:TFlex.Command.CommandParameters.ExtendedDescription">
            <summary>Отображаемое в расширенной всплывающей подсказке описание команды</summary>
        </member>
        <member name="P:TFlex.Command.CommandParameters.Description">
            <summary>Отображаемое во всплывающей подсказке описание команды</summary>
        </member>
        <member name="P:TFlex.Command.CommandParameters.Prompt">
            <summary>Название команды</summary>
        </member>
        <member name="T:TFlex.Command.CommandParameters">
            <summary>Параметры команды приложения</summary>
        </member>
        <member name="M:TFlex.Menu.GetSubMenu(System.Int32)">
            <summary>Получить подменю по её порядковому номеру в меню</summary>
            <param name="index">Порядковый номер подменю</param>
        </member>
        <member name="M:TFlex.Menu.Insert(System.Int32,System.Int32,System.String,TFlex.Plugin)">
            <summary>Вставить пункт меню</summary>
            <param name="index">Номер пункта меню </param>
            <param name="command">Идентификатор зарегестрированной в приложении команды</param>
            <param name="caption">Название пунтка меню</param>
            <param name="plugin">Объект приложения</param>
        </member>
        <member name="M:TFlex.Menu.AppendSubMenu(System.String)">
            <summary>Добавить подменю</summary>
            <param name="caption">Название подменю</param>
        </member>
        <member name="M:TFlex.Menu.GetCount">
            <summary>Получить общее количество пунктов меню</summary>
        </member>
        <member name="M:TFlex.Menu.GetCaption(System.Int32)">
            <summary>Получить название пункта меню команды по её порядковому номеру</summary>
            <param name="index">Порядковый номер пункта меню команды</param>
        </member>
        <member name="M:TFlex.Menu.GetCommand(System.Int32)">
            <summary>Получить идентификатор команды по её порядковому номеру в меню</summary>
            <param name="index">Порядковый номер команды</param>
        </member>
        <member name="M:TFlex.Menu.DeleteByCommand(System.Int32)">
            <summary>Удалить команду по идентификатору</summary>
            <param name="command">Идентификатор команды</param>
        </member>
        <member name="M:TFlex.Menu.DeleteByIndex(System.Int32)">
            <summary>Удалить команду по порядковому номеру</summary>
            <param name="index">Порядковый номер команды</param>
        </member>
        <member name="M:TFlex.Menu.AppendSeparator">
            <summary>Добавить разделитель в меню</summary>
        </member>
        <member name="M:TFlex.Menu.AppendSystemCommand(System.Int32,System.String)">
            <summary>Добавить пункт меню</summary>
            <param name="CommandID">Идентификатор системной команды</param>
            <param name="Caption">Название пункта меню</param>
        </member>
        <member name="M:TFlex.Menu.AppendSystemCommand(System.Int32)">
            <summary>Добавить пункт меню</summary>
            <param name="CommandID">Идентификатор системной команды</param>
        </member>
        <member name="M:TFlex.Menu.Append(System.Int32,System.String,System.Boolean,System.Boolean,TFlex.Plugin)">
            <summary>Добавить пункт меню</summary>
            <param name="command">Идентификатор зарегестрированной в приложении команды</param>
            <param name="caption">Название пунтка меню</param>
            <param name="enable">Доступность пункта меню</param>
            <param name="check">Устанавливает галочку напротив пункта меню</param>
            <param name="plugin">Объект приложения</param>
        </member>
        <member name="M:TFlex.Menu.Append(System.Int32,System.String,TFlex.Plugin)">
            <summary>Добавить пункт меню</summary>
            <param name="command">Идентификатор зарегестрированной в приложении команды</param>
            <param name="caption">Название пунтка меню</param>
            <param name="plugin">Объект приложения</param>
        </member>
        <member name="M:TFlex.Menu.CreatePopup">
            <summary>Создать контекстное меню</summary>
        </member>
        <member name="M:TFlex.Menu.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Menu.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Menu">
            <summary>Класс меню</summary>
        </member>
        <member name="M:TFlex.MainWindow.Close">
            <summary>Закрыть главное окно</summary>
        </member>
        <member name="M:TFlex.MainWindow.ProcessCommand(System.Int32)">
            <summary>Выполнить команду</summary>
        </member>
        <member name="M:TFlex.MainWindow.BringToForeground">
            <summary>На передний план</summary>
        </member>
        <member name="M:TFlex.MainWindow.EndWaitCursor">
            <summary>Сбрасывает курсор ожидания</summary>
        </member>
        <member name="M:TFlex.MainWindow.StartWaitCursor">
            <summary>Устанавливает курсор ожидания</summary>
        </member>
        <member name="M:TFlex.MainWindow.InsertPluginSubMenu(System.String,TFlex.MainWindow.InsertMenuPosition,TFlex.Plugin)">
            <summary>Вставить подменю приложения</summary>
            <param name="caption">Название подменю</param>
            <param name="position">Место для вставки</param>
            <param name="plugin">Объект приложения</param>
        </member>
        <member name="M:TFlex.MainWindow.InsertPluginSubMenu(System.String,TFlex.Menu,System.Int32,TFlex.Plugin)">
            <summary>Вставить подменю приложения</summary>
            <param name="caption">Название подменю</param>
            <param name="menu">Объект подменю</param>
            <param name="mainMenuPosition">Номер позиции для вставки</param>
            <param name="plugin">Объект приложения</param>
        </member>
        <member name="M:TFlex.MainWindow.InsertPluginSubMenu(System.String,TFlex.Menu,TFlex.MainWindow.InsertMenuPosition,TFlex.Plugin)">
            <summary>Вставить подменю приложения</summary>
            <param name="caption">Название подменю</param>
            <param name="menu">Объект подменю</param>
            <param name="position">Место для вставки</param>
            <param name="plugin">Объект приложения</param>
        </member>
        <member name="M:TFlex.MainWindow.InsertPluginMenuItem(System.Int32,System.String,TFlex.MainWindow.InsertMenuPosition,TFlex.Plugin)">
            <summary>Вставить пункт меню приложения</summary>
            <param name="command">Идентификатор зарегестрированной в приложении команды</param>
            <param name="caption">Текст пункта меню</param>
            <param name="position">Место для вставки</param>
            <param name="plugin">Объект приложения</param>
        </member>
        <member name="F:TFlex.MainWindow.InsertMenuPosition.EndOfTools">
            <summary>В конец меню Сервис</summary>
        </member>
        <member name="F:TFlex.MainWindow.InsertMenuPosition.BeginOfTools">
            <summary>В начало меню Сервис</summary>
        </member>
        <member name="F:TFlex.MainWindow.InsertMenuPosition.PluginSamples">
            <summary>В меню примеров приложений</summary>
        </member>
        <member name="T:TFlex.MainWindow.InsertMenuPosition">
            <summary>Место для добавления меню приложения</summary>
        </member>
        <member name="P:TFlex.MainWindow.MessagesBar">
            <summary>Получить область сообщений</summary>
        </member>
        <member name="P:TFlex.MainWindow.StatusBar">
            <summary>Получить статусную строку</summary>
        </member>
        <member name="P:TFlex.MainWindow.RibbonBar">
            <summary>Получить ленту</summary>
        </member>
        <member name="P:TFlex.MainWindow.Maximized">
            <summary>Окно развернуто</summary>
        </member>
        <member name="P:TFlex.MainWindow.Bounds">
            <summary>Прямоугольник границ окна</summary>
        </member>
        <member name="P:TFlex.MainWindow.Handle">
            <summary>Дескриптор окна</summary>
        </member>
        <member name="M:TFlex.MainWindow.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.MainWindow">
            <summary>Главное окно системы T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.MessagesBarMessage.Tag">
            <summary>Пользовательские данные</summary>
        </member>
        <member name="P:TFlex.MessagesBarMessage.ButtonClicked">
            <summary>Обработчик события нажатия на кнопки</summary>
        </member>
        <member name="P:TFlex.MessagesBarMessage.Buttons">
            <summary>Кнопки</summary>
        </member>
        <member name="P:TFlex.MessagesBarMessage.Document">
            <summary>Связанный документ</summary>
        </member>
        <member name="P:TFlex.MessagesBarMessage.Text">
            <summary>Сообщение</summary>
        </member>
        <member name="P:TFlex.MessagesBarMessage.Title">
            <summary>Заголовок</summary>
        </member>
        <member name="T:TFlex.MessagesBarMessage">
            <summary>Описание сообщения выводимого в MessagesBar</summary>
        </member>
        <member name="M:TFlex.MessagesBar.CloseMessage(System.IntPtr)">
            <summary>Закрыть сообщение</summary>
            <param name="messageId">Идентификатор сообщения</param>
        </member>
        <member name="M:TFlex.MessagesBar.AddMessage(TFlex.MessagesBarMessage)">
            <summary>Добавить сообщение</summary>
            <param name="message">Сообщение</param>
        </member>
        <member name="M:TFlex.MessagesBar.AddMessage(System.String,System.String,TFlex.Model.Document,System.Collections.Generic.List`1{TFlex.MessagesBarButton},System.EventHandler`1{TFlex.MessagesBarClickEventArgs},System.IntPtr)">
            <summary>Добавить сообщение</summary>
            <param name="title">Заголовок</param>
            <param name="text">Сообщение</param>
            <param name="document">Связанный документ</param>
            <param name="buttons">Кнопки</param>
            <param name="buttonClicked">Обработчик события нажатия на кнопки</param>
            <param name="tag">Пользовательские данные</param>
        </member>
        <member name="M:TFlex.MessagesBar.AddMessage(System.String,System.String,TFlex.Model.Document)">
            <summary>Добавить сообщение</summary>
            <param name="title">Заголовок</param>
            <param name="text">Сообщение</param>
            <param name="document">Связанный документ</param>
        </member>
        <member name="T:TFlex.MessagesBar">
            <summary>Область сообщений T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.MessagesBarClickEventArgs.Tag">
            <summary>Пользовательские даные</summary>
        </member>
        <member name="P:TFlex.MessagesBarClickEventArgs.ButtonId">
            <summary>Идентификатор кнопки</summary>
        </member>
        <member name="P:TFlex.MessagesBarClickEventArgs.MessageId">
            <summary>Идентификатор сообщения</summary>
        </member>
        <member name="T:TFlex.MessagesBarClickEventArgs">
            <summary>Аргументы события клика в кнопку в область сообщений</summary>
        </member>
        <member name="P:TFlex.MessagesBarButton.ToolTip">
            <summary>Подсказка</summary>
        </member>
        <member name="P:TFlex.MessagesBarButton.Text">
            <summary>Текст</summary>
        </member>
        <member name="P:TFlex.MessagesBarButton.Id">
            <summary>Идентификатор кнопки</summary>
        </member>
        <member name="T:TFlex.MessagesBarButton">
            <summary>Описание кнопки, которая будет отображаться в сообщении выводимом в MessagesBar</summary>
        </member>
        <member name="M:TFlex.StatusBar.UnlockProgress">
            <summary>Разблокировать отображение индикации состояния</summary>
        </member>
        <member name="M:TFlex.StatusBar.LockProgress">
            <summary>Заблокировать отображение индикации состояния</summary>
        </member>
        <member name="M:TFlex.StatusBar.EndProgress">
            <summary>Закрыть индикатор состояния</summary>
        </member>
        <member name="M:TFlex.StatusBar.StepProgress">
            <summary>Выполнить один шаг индикатора состояния</summary>
        </member>
        <member name="M:TFlex.StatusBar.StartProgress(System.UInt32,System.UInt32)">
            <summary>Запустить индикатор состояния</summary>
            <param name="total">Длина диапазона</param>
            <param name="step">Величина шага</param>
        </member>
        <member name="M:TFlex.StatusBar.StartProgress(System.UInt32)">
            <summary>Запустить индикатор состояния</summary>
            <param name="total">Длина диапазона</param>
        </member>
        <member name="P:TFlex.StatusBar.Prompt">
            <summary>Установить строку подсказки</summary>
        </member>
        <member name="P:TFlex.StatusBar.Command">
            <summary>Установить строку команды</summary>
        </member>
        <member name="T:TFlex.StatusBar">
            <summary>Статусная строка T-FLEX CAD</summary>
        </member>
        <member name="M:TFlex.LibraryConfigurations.Enumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.LibraryConfigurations.Enumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.LibraryConfigurations.Enumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.LibraryConfigurations.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.LibraryConfigurations.SetActive(System.Int32)">
            <summary>Установить активную конфигурацию</summary>
            <param name="index">Номер конфигурации</param>
        </member>
        <member name="P:TFlex.LibraryConfigurations.Active">
            <summary>Получить активную конфигурацию</summary>
        </member>
        <member name="M:TFlex.LibraryConfigurations.Close(System.Int32)">
            <summary>Закрыть конфигурацию с указанным номером</summary>
            <param name="index">Номер конфигурации</param>
        </member>
        <member name="M:TFlex.LibraryConfigurations.Close(TFlex.LibraryConfiguration)">
            <summary>Закрыть конфигурацию</summary>
            <param name="configuration">Конфигурация для закрытия</param>
        </member>
        <member name="M:TFlex.LibraryConfigurations.Add(TFlex.LibraryConfiguration)">
            <summary>Добавить конфигурацию</summary>
            <param name="configuration">Конфигурация для добавления</param>
        </member>
        <member name="M:TFlex.LibraryConfigurations.Open(System.String)">
            <summary>Открыть конфигурацию</summary>
            <param name="path">Путь к конфигурации</param>
        </member>
        <member name="M:TFlex.LibraryConfigurations.GetLibraryConfiguration(System.Int32)">
            <summary>Получить конфигурацию по номеру</summary>
            <param name="index">Номер конфигурации</param>
        </member>
        <member name="P:TFlex.LibraryConfigurations.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="M:TFlex.LibraryConfigurations.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.LibraryConfigurations">
            <summary>Конфигурации библиотек</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.GroupsEnumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.GroupsEnumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.LibraryConfiguration.GroupsEnumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.LibrariesEnumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.LibrariesEnumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.LibraryConfiguration.LibrariesEnumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.GetLibrariesWithoutGroup">
            <summary>Получить перечислитель библиотек, не входящих ни в одну группу.</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.GetGroups">
            <summary>Получить перечислитель групп</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.GetEnumerator">
            <summary>Получить перечислитель библиотек</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.SaveAs(System.String)">
            <summary>Сохранить конфигурацию как</summary>
            <param name="path">Путь для сохранения</param>
        </member>
        <member name="M:TFlex.LibraryConfiguration.Save">
            <summary>Сохранить конфигурацию</summary>
        </member>
        <member name="P:TFlex.LibraryConfiguration.Name">
            <summary>Имя конфигурации библиотеки</summary>
        </member>
        <member name="P:TFlex.LibraryConfiguration.Path">
            <summary>Путь к конфигурации</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.GetGroup(System.Int32)">
            <summary>Получить группу по индексу</summary>
            <param name="index" />
        </member>
        <member name="P:TFlex.LibraryConfiguration.GroupsCount">
            <summary>Количество групп</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.GetLibrary(System.Int32)">
            <summary>Получить библиотеку по индексу</summary>
            <param name="index" />
        </member>
        <member name="P:TFlex.LibraryConfiguration.Count">
            <summary>Количество библиотек</summary>
        </member>
        <member name="M:TFlex.LibraryConfiguration.#ctor(System.String,System.String)">
            <summary>Конструктор</summary>
            <param name="name">Имя конфигурации библиотеки</param>
            <param name="path">Путь к конфигурации</param>
        </member>
        <member name="T:TFlex.LibraryConfiguration">
            <summary>Класс конфигурации библиотек. Данный класс является набором библиотек и групп библиотек</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.GroupsEnumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.GroupsEnumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.LibraryGroup.GroupsEnumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.LibrariesEnumerator.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.LibrariesEnumerator.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.LibraryGroup.LibrariesEnumerator.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.GetGroups">
            <summary>Получить перечислитель групп</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.GetLibraries">
            <summary>Получить перечислитель библиотек</summary>
        </member>
        <member name="P:TFlex.LibraryGroup.Name">
            <summary>Имя группы</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.GetGroup(System.Int32)">
            <summary>Получить группу по индексу</summary>
            <param name="index" />
        </member>
        <member name="P:TFlex.LibraryGroup.GroupsCount">
            <summary>Количество групп</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.GetLibrary(System.Int32)">
            <summary>Получить библиотеку по индексу</summary>
            <param name="index" />
        </member>
        <member name="P:TFlex.LibraryGroup.LibrariesCount">
            <summary>Количество библиотек</summary>
        </member>
        <member name="M:TFlex.LibraryGroup.#ctor(System.String)">
            <summary>Конструктор</summary>
            <param name="name">Имя группы библиотек</param>
        </member>
        <member name="T:TFlex.LibraryGroup">
            <summary>Класс группы библиотек. Данный класс является набором библиотек и других групп библиотек</summary>
        </member>
        <member name="M:TFlex.Library.IsDocumentExcluded(System.String)">
            <summary>Является ли документ исключенным</summary>
            <param name="documentName">Имя документа</param>
        </member>
        <member name="P:TFlex.Library.FullPath">
            <summary>Полный путь к библотеке</summary>
        </member>
        <member name="P:TFlex.Library.Name">
            <summary>Название библиотеки</summary>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Library.Path">
            <summary>Относительный путь к библиотеке</summary>
        </member>
        <member name="M:TFlex.Library.FindLibraryByName(System.String)">
            <summary>Поиск библиотеки по имени</summary>
        </member>
        <member name="M:TFlex.Library.#ctor(System.String,System.String)">
            <summary>Конструктор</summary>
            <param name="name">Название библиотеки</param>
            <param name="path">Относительный путь к библиотеке</param>
        </member>
        <member name="T:TFlex.Library">
            <summary>Класс библиотеки</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.ProtectionLicense">
            <summary>Тип лицензии, который необходимо использовать при инициализации</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.License.FurnitureAdministrator">
            <summary>FurnitureAdministrator</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.License.TFlexAPI">
            <summary>TFlexAPI</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.License.TFlexDOCs">
            <summary>TFlexDOCs</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.License.TFlex3D">
            <summary>TFlex3D</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.License.TFlexSE">
            <summary>TFlexSE</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.License.TFlex2D">
            <summary>TFlex2D</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.License.TFlexLT">
            <summary>TFlexLT</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.License.Auto">
            <summary>Auto</summary>
        </member>
        <member name="T:TFlex.ApplicationSessionSetup.License">
            <summary>Тип лицензии, который необходимо использовать при инициализации</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.DOCsLanguage">
            <summary>Язык продукта T-FLEX DOCs, с которым необходимо установить интеграцию</summary>
            <remarks>Используйте значение <see href="TFlex::Application::Language::Default" /> для интеграции с
T-FLEX DOCs той же языковой версии, что и T-FLEX CAD</remarks>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.DOCsRegistryKeyName">
            <summary>Ключ реестра продукта T-FLEX DOCs, с которым необходимо установить интеграцию</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.DOCsProductName">
            <summary>Название продукта T-FLEX DOCs, с которым необходимо установить интеграцию</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.DOCsAPIVersion">
            <summary>Номер версии T-FLEX DOCs, с которой нужно установить интеграцию</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.DOCsVersion.Version13">
            <summary>T-FLEX DOCs 2012</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.DOCsVersion.Version12">
            <summary>T-FLEX DOCs 2010</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.DOCsVersion.Version11">
            <summary>T-FLEX DOCs 11</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.DOCsVersion.Version10">
            <summary>T-FLEX DOCs 10</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.DOCsVersion.Version9">
            <summary>T-FLEX DOCs 9</summary>
        </member>
        <member name="F:TFlex.ApplicationSessionSetup.DOCsVersion.Undefined">
            <summary>Неопределено</summary>
        </member>
        <member name="T:TFlex.ApplicationSessionSetup.DOCsVersion">
            <summary>Номер версии T-FLEX DOCs, с которой нужно установить интеграцию</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.EnableDOCs">
            <summary>Разрешить интеграцию с T-FLEX DOCs</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.PromptToSaveModifiedDocuments">
            <summary>Разрешить появление вопроса о необходимости сохранения изменённого документа</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.EnableMacros">
            <summary>Разрешить работу макросов</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.Enable3D">
            <summary>Загрузить модуль работы с 3D информацией</summary>
        </member>
        <member name="P:TFlex.ApplicationSessionSetup.ReadOnly">
            <summary>Режим работы "Только чтение"</summary>
            <remarks>Невозможно создание новых объектов и сохранение изменённого файла</remarks>
        </member>
        <member name="M:TFlex.ApplicationSessionSetup.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.ApplicationSessionSetup">
            <summary>Параметры инициализации сессии по работе с OpenAPI из другого приложения</summary>
        </member>
        <member name="P:TFlex.Application.Strings">
            <summary>Доступ к строкам локализации приложения</summary>
        </member>
        <member name="P:TFlex.Application.DisableSubstituteFontDialog">
            <summary>Блокировать диалог замены ненайденного шрифта</summary>
            <remarks>Когда блокировка больше не требуется, необходимо вернуть предыдущее состояние</remarks>
        </member>
        <member name="P:TFlex.Application.RegistryName">
            <summary>Путь в реестре для настроек пользователя</summary>
        </member>
        <member name="M:TFlex.Application.AddResourceFile(System.String,System.String)">
            <summary>Загружает строковые ресурсы из указанного файла в формате Microsoft ResX для использования в неуправляемом коде</summary>
            <param name="directory">Путь к директории, содержащей файл ресурсов, или 'null', если файл расположен в
директории T-FLEX CAD</param>
            <remarks>Данные загружаются из файла "&lt;directory&gt;\&lt;baseName&gt;.&lt;language&gt;.resx", где
"&lt;language&gt;" -- двухбуквенное обозначение языка T-FLEX CAD (например, "en" для английской версии, "de"
для немецкой и т.п.). Если файл с таким именем отсутствует, то часть имени файла с обозначением языка
отбрасывается и попытка загрузки повторяется для файла "&lt;directory&gt;\&lt;baseName&gt;.resx".</remarks>
        </member>
        <member name="M:TFlex.Application.AddResourceFile(System.String)">
            <summary>Загружает строковые ресурсы из указанного файла в формате Microsoft ResX для использования в неуправляемом коде</summary>
        </member>
        <member name="M:TFlex.Application.GetShortPathName(System.String,System.String)">
            <summary>Получение короткого пути относительно папки</summary>
        </member>
        <member name="M:TFlex.Application.FindLibraryName(System.String)">
            <summary>Поиск библиотечного пути</summary>
        </member>
        <member name="M:TFlex.Application.FindPathName(System.String,System.String)">
            <summary>Полный путь к файлу</summary>
        </member>
        <member name="M:TFlex.Application.FindPathName(System.String)">
            <summary>Полный путь к файлу</summary>
        </member>
        <member name="M:TFlex.Application.OpenFileDialog(System.String,System.String)">
            <summary>Диалог выбора файла из папки или библиотеки</summary>
            <param name="type" />
            <param name="title" />
        </member>
        <member name="M:TFlex.Application.RunSystemCommand(System.String,TFlex.Model.ModelObject[],TFlex.SystemCommandFinishedCallback)">
            <summary>Выполнить команду с ожиданием её завершения</summary>
        </member>
        <member name="M:TFlex.Application.TerminateAllCommands">
            <summary>Завершить все активные комманды</summary>
        </member>
        <member name="M:TFlex.Application.EnableNotRespondingDialog(System.Boolean)">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Application.GetCustomLicenseStatus(System.UInt32)">
            <summary>Получить статус лицензии пользователя</summary>
            <param name="license">Номер лицензии</param>
        </member>
        <member name="M:TFlex.Application.InitializeCustomLicense(System.UInt32)">
            <summary>Активировать лицензию пользователя</summary>
            <param name="license">Номер лицензии</param>
        </member>
        <member name="M:TFlex.Application.HideEmbeddedHelp">
            <summary>Убрать раздел справочного руководства</summary>
        </member>
        <member name="M:TFlex.Application.ShowEmbeddedHelpTopic(System.String)">
            <summary>Показать раздел справочного руководства</summary>
            <param name="url">Адрес страницы справочного руководства</param>
        </member>
        <member name="M:TFlex.Application.ShowHelp">
            <summary>Показать справочное руководство</summary>
        </member>
        <member name="P:TFlex.Application.BOMSectionsDatabase">
            <summary>Путь к файлу базы данных, в котором храниться структура разделов спецификации</summary>
        </member>
        <member name="P:TFlex.Application.IsDOCsEnabled">
            <summary>Включена ли интеграция с T-FLEX DOCs</summary>
        </member>
        <member name="M:TFlex.Application.EnableDOCs">
            <summary>Разрешить интеграцию с T-FLEX DOCs</summary>
        </member>
        <member name="P:TFlex.Application.IsMacrosEnabled">
            <summary>Разрешить выполнение макросов</summary>
        </member>
        <member name="M:TFlex.Application.AddDocumentsSearchFolder(System.String)">
            <summary>Назначить папку для поиска указанного типа файлов, если при работе с системой она не была задана явно</summary>
            <param name="folder">Папка для поиска</param>
        </member>
        <member name="M:TFlex.Application.AddMacrosIndirectAssembly(System.String)">
            <summary>Добавить ссылку на сборку в макрос</summary>
            <param name="assemblyPath">Путь к файлу сборки</param>
        </member>
        <member name="M:TFlex.Application.DoEvents">
            <summary>Обрабатывает все сообщения Windows, которые в данный момент находятся в очереди сообщений.</summary>
            <remarks>Метод позволяет приложению обрабатывать другие события, которые могут возникнуть при выполнии кода</remarks>
        </member>
        <member name="M:TFlex.Application.ExitSession">
            <summary>Завершить работу c API</summary>
            <remarks>Вызывается при необходимости завершения работы с API в активном приложении. При завершении работы приложения вызывается автоматически. Вызывается в паре с методом <see cref="M:TFlex.Application.InitSession(TFlex.ApplicationSessionSetup)" /></remarks>
        </member>
        <member name="M:TFlex.Application.IdleSession">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Application.InitSession(TFlex.ApplicationSessionSetup)">
            <summary>Инициализация API</summary>
            <param name="setup">Параметры инициализации сессии</param>
            <remarks>Данный метод необходимо вызвать при инициализации API
в случае использования его в отдельном приложении (EXE). При необходимости завершения работы
с API до закрытия приложения нужно вызывать метод <see cref="M:TFlex.Application.ExitSession" /></remarks>
            <returns>true в случае успешного завершения</returns>
        </member>
        <member name="M:TFlex.Application.PickPoint(TFlex.PickPointParameters)">
            <summary>Получить точку в одном из видов активного документа</summary>
            <param name="parameters">Параметры ввода точки</param>
            <returns>Результат ввода точки</returns>
            <example>
                <code name="Выбор объекта в окне">
using System;
using System.Windows.Forms;

using TFlex;
using TFlex.Model;
using TFlex.Model.Model2D;
using TFlex.Model.Model3D;

namespace NewMacroNamespace
{
   public class NewMacroClass
   {
       public static void PickPoint()
       {
           PickPointParameters par = new PickPointParameters();

           //выбор только размеров
           SelectionFilter filter = new SelectionFilter();
           filter.Enable(ObjectType.Dimension);
           par.Filter = filter;

           par.Prompt = "Выбрать размер";
           par.MouseMove += new TFlex.PickPointMouseMove(PickPointMouseMove);//событие перемещения мыши
           PickPointResult res = TFlex.Application.PickPoint(par);//получить точку в одном из видов активного документа

           string mess = "Объект не выбран";
           if (res.SelectedObject != null)
           {
               mess = string.Empty;
               string val = string.Empty;

               ObjectProperty[] arr = res.SelectedObject.GetProperties();//массив свойств выбранного объекта
               for (int i = 0; i &lt; arr.Length; i++)
               {
                   switch (arr[i].Type)
                   {
                       case (ObjectPropertyType.IntProperty):
                           val = res.SelectedObject.GetIntProperty(arr[i].Name).Value.ToString();
                           break;

                       case (ObjectPropertyType.RealProperty):
                           val = res.SelectedObject.GetRealProperty(arr[i].Name).Value.ToString();
                           break;

                       case (ObjectPropertyType.TextProperty):
                           val = res.SelectedObject.GetTextProperty(arr[i].Name);
                           break;
                   }

                   mess += arr[i].Name + ": " + val + "\r\n";
               }
           }

           MessageBox.Show(mess);
       }

       static public void PickPointMouseMove(Object sender, PickPointEventArgs e)
       {
       }
   }
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Application.PickPoint(TFlex.Model.Document,TFlex.PickPointParameters)">
            <summary>Получить точку в одном из видов документа</summary>
            <param name="document">Документ</param>
            <param name="parameters">Параметры ввода точки</param>
            <returns>Результат ввода точки</returns>
        </member>
        <member name="M:TFlex.Application.GetSystemFilePath(System.String,System.Boolean)">
            <summary>Полный путь к системному файлу</summary>
            <param name="strFileName">Document</param>
            <param name="bReadOnly" />
        </member>
        <member name="P:TFlex.Application.SystemPath">
            <summary>Полный системный путь</summary>
        </member>
        <member name="P:TFlex.Application.ActiveMainWindow">
            <summary>Активное главное окно системы</summary>
        </member>
        <member name="P:TFlex.Application.Window">
            <summary>Главное окно системы</summary>
        </member>
        <member name="P:TFlex.Application.LibraryConfigurations">
            <summary>Открытые конфигурации библиотек</summary>
        </member>
        <member name="P:TFlex.Application.FileLinksAutoRefresh">
            <summary>Режим обновления файловых ссылок</summary>
            <remarks>Работает только в режиме пользовательского приложения. См. метод <see cref="M:TFlex.Application.InitSession(TFlex.ApplicationSessionSetup)" /></remarks>
        </member>
        <member name="F:TFlex.Application.FileLinksRefreshMode.DoNotRefresh">
            <summary>Не обновлять</summary>
        </member>
        <member name="F:TFlex.Application.FileLinksRefreshMode.AutoRefresh">
            <summary>Обновлять автоматически</summary>
        </member>
        <member name="F:TFlex.Application.FileLinksRefreshMode.ShowQuestion">
            <summary>Спросить об обновлении при открытии или закрытии документа</summary>
        </member>
        <member name="F:TFlex.Application.FileLinksRefreshMode.SystemDefault">
            <summary>Брать значение по умолчанию</summary>
        </member>
        <member name="T:TFlex.Application.FileLinksRefreshMode">
            <summary>Режим обновления файловых ссылок</summary>
        </member>
        <member name="M:TFlex.Application.GetDocumentIcon(System.String,System.Int32)">
            <summary>Возвращает иконку документа с указанным размером, если она есть</summary>
            <param name="fileName">Имя файла документа</param>
            <param name="iconSize">Размер иконки</param>
        </member>
        <member name="M:TFlex.Application.GetDocumentIcon(System.String)">
            <summary>Возвращает иконку документа, если она есть</summary>
            <param name="fileName">Имя файла документа</param>
        </member>
        <member name="P:TFlex.Application.ActiveViewDocument">
            <summary>Текущий (активный) документ активного вида</summary>
        </member>
        <member name="P:TFlex.Application.ActiveDocument">
            <summary>Текущий (активный) документ системы</summary>
        </member>
        <member name="M:TFlex.Application.GetDocumentExternalFileLinks(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Возвращает все имеющиеся в модели ссылки на внешние файлы</summary>
            <param name="fileName">Имя файла документа</param>
            <param name="includeModelFilesOnly" />
            <param name="includeLibraryLinks" />
            <param name="recursive" />
        </member>
        <member name="M:TFlex.Application.OpenAsDocument(System.String,System.Boolean,System.Boolean)">
            <summary>Открыть документ или импортировать файл</summary>
            <param name="fileName">Имя файла</param>
            <param name="visible">Указывает, должен ли открытый документ быть видимым</param>
            <param name="readOnly">Открыть документ только для чтения</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenAsDocument(System.String,System.Boolean)">
            <summary>Открыть документ или импортировать файл</summary>
            <param name="fileName">Имя файла</param>
            <param name="visible">Указывает, должен ли открытый документ быть видимым</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenAsDocument(System.String)">
            <summary>Открыть документ или импортировать файл</summary>
            <param name="fileName">Имя файла</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenFragmentDocument(System.String,System.Boolean,System.Boolean)">
            <summary>Открыть документ фрагмента для чтения</summary>
            <param name="fileName">Имя файла документа</param>
            <param name="with3D" />
            <param name="recalculate" />
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenFragmentDocument(System.String)">
            <summary>Открыть документ фрагмента для чтения</summary>
            <param name="fileName">Имя файла документа</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenDocumentFromDOCs(System.Int32,System.Boolean,System.Boolean)">
            <summary>T-FLEX DOCs 11 больше не поддерживается</summary>
        </member>
        <member name="M:TFlex.Application.OpenDocumentFromDOCs(System.Int32,System.Boolean)">
            <summary>T-FLEX DOCs 11 больше не поддерживается</summary>
        </member>
        <member name="M:TFlex.Application.OpenDocument(TFlex.Model.FileLink,System.Boolean,System.Boolean)">
            <summary>Открыть документ</summary>
            <param name="link">Ссылка на файл документа</param>
            <param name="visible">Указывает, должен ли открытый документ быть видимым</param>
            <param name="readOnly">Открыть документ только для чтения</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenDocument(TFlex.Model.FileLink,System.Boolean)">
            <summary>Открыть документ</summary>
            <param name="link">Ссылка на файл документа</param>
            <param name="visible">Указывает, должен ли открытый документ быть видимым</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenDocument(TFlex.Model.FileLink)">
            <summary>Открыть документ</summary>
            <param name="link">Ссылка на файл документа</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenDocument(System.String,TFlex.OpenDocumentOptions)">
            <summary>Открыть документ</summary>
            <param name="fileName">Имя файла</param>
            <param name="options">Параметры открытия файла</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenDocument(System.String,System.Boolean,System.Boolean)">
            <summary>Открыть документ</summary>
            <param name="fileName">Имя файла документа</param>
            <param name="visible">Указывает, должен ли открытый документ быть видимым</param>
            <param name="readOnly">Открыть документ только для чтения</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenDocument(System.String,System.Boolean)">
            <summary>Открыть документ</summary>
            <param name="fileName">Имя файла документа</param>
            <param name="visible">Указывает, должен ли открытый документ быть видимым</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.OpenDocument(System.String)">
            <summary>Открыть документ</summary>
            <param name="fileName">Имя файла документа</param>
            <returns>Открытый документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.NewAnnotation(System.String,TFlex.Annotation)">
            <summary>Создать новую аннотацию для указанного файла документа</summary>
            <param name="documentFileName">Путь к файлу аннотируемого документа</param>
            <param name="annotation">Параметры создаваемой аннотации с указанием пути к файлу</param>
            <returns>Созданный документ аннотации или <c>null</c> в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.CreateAnnotation(System.String,TFlex.Annotation)">
            <summary>Создать новую аннотацию для указанного файла документа</summary>
            <param name="documentFileName">Путь к файлу аннотируемого документа</param>
            <param name="annotation">Параметры создаваемой аннотации с указанием пути к файлу</param>
            <returns>
                <c>true</c> в случае успешного создания аннотации, иначе <c>false</c></returns>
        </member>
        <member name="M:TFlex.Application.NewDocument(System.String,System.Boolean)">
            <summary>Создать новый документ на основе указанного файла прототипа</summary>
            <param name="prototype">Путь к файлу прототипа</param>
            <param name="visible">Указывает, должен ли новый документ быть видимым</param>
            <returns>Созданный документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.NewDocument(System.String)">
            <summary>Создать новый документ на основе указанного файла прототипа</summary>
            <param name="prototype">Путь к файлу прототипа</param>
            <returns>Созданный документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.NewDocument(System.Boolean,System.Boolean)">
            <summary>Создать новый документ</summary>
            <param name="b3D">В случае, если параметр равен true, новый документ создаётся на основе 3D прототипа</param>
            <param name="visible">Указывает, должен ли новый документ быть видимым</param>
            <returns>Созданный документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.NewDocument(System.Boolean)">
            <summary>Создать новый документ</summary>
            <param name="b3D">В случае, если параметр равен true, новый документ создаётся на основе 3D прототипа</param>
            <returns>Созданный документ или null в случае ошибки</returns>
        </member>
        <member name="M:TFlex.Application.NewDocument">
            <summary>Создать новый документ</summary>
            <returns>Созданный документ или null в случае ошибки</returns>
        </member>
        <member name="P:TFlex.Application.Units">
            <summary>Единицы измерения приложения</summary>
        </member>
        <member name="P:TFlex.Application.Settings">
            <summary>Установки приложения</summary>
        </member>
        <member name="P:TFlex.Application.Options">
            <summary>Установки приложения</summary>
        </member>
        <member name="P:TFlex.Application.Documents">
            <summary>Перечислитель открытых в T-FLEX CAD документов</summary>
        </member>
        <member name="P:TFlex.Application.StudentVersion">
            <summary>Свойство, возвращающее true, если версия T-FLEX CAD учебная</summary>
        </member>
        <member name="P:TFlex.Application.EvaluationVersion">
            <summary>Свойство, возвращающее true, если версия T-FLEX CAD ознакомительная</summary>
        </member>
        <member name="P:TFlex.Application.Product">
            <summary>Конфигурация T-FLEX CAD</summary>
        </member>
        <member name="F:TFlex.Application.ProductType.Viewer">
            <summary>T-Flex Viewer</summary>
        </member>
        <member name="F:TFlex.Application.ProductType.FurnitureAdministrator">
            <summary>T-Flex Мебель Администратор</summary>
        </member>
        <member name="F:TFlex.Application.ProductType.Salon">
            <summary>T-Flex Салон</summary>
        </member>
        <member name="F:TFlex.Application.ProductType.Furniture">
            <summary>T-Flex Мебель</summary>
        </member>
        <member name="F:TFlex.Application.ProductType.TFlexCad2D">
            <summary>T-Flex CAD 2D</summary>
        </member>
        <member name="F:TFlex.Application.ProductType.TFlexCadSE">
            <summary>T-Flex CAD SE</summary>
        </member>
        <member name="F:TFlex.Application.ProductType.TFlexCad3D">
            <summary>T-Flex CAD 3D</summary>
        </member>
        <member name="T:TFlex.Application.ProductType">
            <summary>Конфигурация T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.Application.MeasuringSystem">
            <summary>Система измерения T-FLEX CAD</summary>
        </member>
        <member name="F:TFlex.Application.Measure.Inch">
            <summary>Неметрическая система измерения</summary>
        </member>
        <member name="F:TFlex.Application.Measure.Metric">
            <summary>Метрическая система измерения</summary>
        </member>
        <member name="T:TFlex.Application.Measure">
            <summary>Система измерения T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.Application.InterfaceLanguage">
            <summary>Язык интерфейса T-FLEX CAD</summary>
        </member>
        <member name="F:TFlex.Application.Language.Czech">
            <summary>Чешская</summary>
        </member>
        <member name="F:TFlex.Application.Language.Japanese">
            <summary>Японская</summary>
        </member>
        <member name="F:TFlex.Application.Language.Korean">
            <summary>Корейская</summary>
        </member>
        <member name="F:TFlex.Application.Language.Polish">
            <summary>Польская</summary>
        </member>
        <member name="F:TFlex.Application.Language.Italian">
            <summary>Итальянская</summary>
        </member>
        <member name="F:TFlex.Application.Language.Chinese">
            <summary>Китайская</summary>
        </member>
        <member name="F:TFlex.Application.Language.German">
            <summary>Немецкая</summary>
        </member>
        <member name="F:TFlex.Application.Language.English">
            <summary>Английская</summary>
        </member>
        <member name="F:TFlex.Application.Language.Russian">
            <summary>Русская</summary>
        </member>
        <member name="F:TFlex.Application.Language.Default">
            <summary>По умолчанию</summary>
        </member>
        <member name="T:TFlex.Application.Language">
            <summary>Язык интерфейса T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.Application.Version">
            <summary>Версия T-FLEX CAD</summary>
        </member>
        <member name="M:TFlex.Application.#cctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Application">
            <summary>Объект данного класса обеспечивает доступ к объектам T-FLEX CAD</summary>
            <remarks>К таким объектам относятся документы, команды, главное окно приложения и прочее.</remarks>
        </member>
        <member name="P:TFlex.StringManager.default(System.String)">
            <summary>Получить или установить строку локализации</summary>
        </member>
        <member name="M:TFlex.StringManager.SetString(System.String,System.String)">
            <summary>Установить строку локализации</summary>
        </member>
        <member name="M:TFlex.StringManager.GetString(System.String)">
            <summary>Получает строку локализации</summary>
            <returns>Переведённая строка, либо key если не найдена</returns>
        </member>
        <member name="M:TFlex.StringManager.GetString(System.String,System.String@)">
            <summary>Получает строку локализации</summary>
        </member>
        <member name="M:TFlex.StringManager.LoadResourceFile(System.String,System.String)">
            <summary>Загружает строки из файла в формате Microsoft ResX</summary>
            <param name="baseName">Название файла локализации</param>
            <param name="path">Путь к файлу .resx</param>
            <remarks>
Загружает строки из файла "path/baseName.LC.resx" в формате Microsoft ResX.
Здесь LC - двухбуквенное обозначение текущего языка. Если файл с таким именем отсутствует,
будет произведена попытка загрузки с именем без обозначения кода языка.
</remarks>
        </member>
        <member name="M:TFlex.StringManager.LoadResourceFile(System.String)">
            <summary>Загружает строки из файла в формате Microsoft ResX</summary>
            <param name="fullPath">Полный путь к .resx файлу</param>
        </member>
        <member name="T:TFlex.StringManager">
            <summary>Менеджер строк для локализации</summary>
        </member>
        <member name="P:TFlex.OpenDocumentOptions.ForceNewObject">
            <summary>Создавать новый объект <see cref="T:TFlex.Model.Document" />, даже если файл уже открыт</summary>
        </member>
        <member name="P:TFlex.OpenDocumentOptions.Visible">
            <summary>Указывает, должен ли открытый документ быть видимым</summary>
        </member>
        <member name="P:TFlex.OpenDocumentOptions.ThrowOnError">
            <summary>Выбрасывать исключение при возникновении ошибок</summary>
        </member>
        <member name="P:TFlex.OpenDocumentOptions.ReadOnly">
            <summary>Открыть документ только для чтения</summary>
        </member>
        <member name="P:TFlex.OpenDocumentOptions.Import">
            <summary>Импортировать файлы в форматах сторонних приложений</summary>
        </member>
        <member name="T:TFlex.OpenDocumentOptions">
            <summary>Параметры открытия документов</summary>
        </member>
        <member name="P:TFlex.Annotation.Visible">
            <summary>
                <c>true</c>, если эта аннотация должна быть видна при работе с аннотируемым документом, иначе
<c>false</c></summary>
        </member>
        <member name="P:TFlex.Annotation.Version">
            <summary>Версия аннотации</summary>
        </member>
        <member name="P:TFlex.Annotation.FileName">
            <summary>Путь к файлу аннотации относительно файла аннотируемого документа</summary>
        </member>
        <member name="P:TFlex.Annotation.UserName">
            <summary>Имя пользователя, создавшего аннотацию</summary>
        </member>
        <member name="P:TFlex.Annotation.Comment">
            <summary>Комментарий к аннотации</summary>
        </member>
        <member name="M:TFlex.Annotation.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Annotation.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Annotation">
            <summary>Класс аннотации T-FLEX CAD</summary>
        </member>
        <member name="M:TFlex.Documents.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Documents.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Documents">
            <summary>Перечислитель документов T-FLEX CAD</summary>
        </member>
        <member name="P:TFlex.Options.DOCsIntegrationRule">
            <summary>Название правила настройки интеграции в T-FLEX DOCs</summary>
        </member>
        <member name="P:TFlex.Options.BOMPrototypesPath">
            <summary>Путь к папке с прототипами спецификаций</summary>
        </member>
        <member name="P:TFlex.Options.ProductStructureSchemesPath">
            <summary>Путь к папке с типами состава изделия</summary>
        </member>
        <member name="P:TFlex.Options.ReportTemplateFolderPath">
            <summary>Путь к папке с шаблонами отчётов для состава изделия</summary>
        </member>
        <member name="P:TFlex.Options.AutoUpdateNomenclature">
            <summary>Обновлять состав изделия в PDM системе при сохранении документа</summary>
        </member>
        <member name="T:TFlex.Options">
            <summary>Установки приложения</summary>
        </member>
        <member name="P:TFlex.CircuitLinkSplitMergeEventArgs.SecondaryLink">
            <summary>ЛС, которая будет удалена после объединения, либо новая ЛС после разделения</summary>
        </member>
        <member name="P:TFlex.CircuitLinkSplitMergeEventArgs.PrimaryLink">
            <summary>ЛС, которая останется после объединения, либо исходная ЛС до разделения</summary>
        </member>
        <member name="T:TFlex.SessionInitializedEventArgs">
            <summary>Класс, содержащий данные о событии, возникающем в момент завершения инициализации T-FLEX CAD</summary>
        </member>
        <member name="T:TFlex.HelpWindowOpeningEventArgs">
            <summary>Класс, содержащий данные о событии, возникающем в момент открытия окна справки</summary>
        </member>
        <member name="T:TFlex.AlterColorButtonPressedEventArgs">
            <summary>Класс, содержащий данные о событии, возникающем в момент нажатия кнопки выбора альтернативного цвета</summary>
        </member>
        <member name="P:TFlex.PlaneCreateEventArgs.Origin">
            <summary>Точка, через которую проходит плоскость</summary>
        </member>
        <member name="T:TFlex.PlaneCreateEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем в данном виде документа</summary>
        </member>
        <member name="P:TFlex.Coords.Coord(System.Int32)">
            <summary>X-координата точки, через которую проходит плоскость</summary>
        </member>
        <member name="T:TFlex.Coords">
            <summary>Трёхмерные координаты</summary>
        </member>
        <member name="P:TFlex.PlaneEventArgs.Offset">
            <summary>Смещение</summary>
        </member>
        <member name="T:TFlex.PlaneEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем в данном виде документа</summary>
        </member>
        <member name="P:TFlex.FileDroppedEventArgs.FileLibraryPath">
            <summary>Получить имя файла с именем библиотеки</summary>
        </member>
        <member name="P:TFlex.FileDroppedEventArgs.FilePath">
            <summary>Получить имя файла</summary>
        </member>
        <member name="T:TFlex.FileDroppedEventArgs">
            <summary>Класс, содержащий данные о событии, возникающем файл перетаскивается в одно из окон документа</summary>
        </member>
        <member name="P:TFlex.DynamicAnalysisEventArgs.CurrentStage">
            <summary>Текущий шаг решения задачи</summary>
        </member>
        <member name="F:TFlex.DynamicAnalysisEventArgs.Stage.Finished">
            <summary>Завершение решения задачи</summary>
        </member>
        <member name="F:TFlex.DynamicAnalysisEventArgs.Stage.Stepped">
            <summary>Решение задачи на промежуточном шаге</summary>
        </member>
        <member name="F:TFlex.DynamicAnalysisEventArgs.Stage.Started">
            <summary>Начало решения задачи</summary>
        </member>
        <member name="T:TFlex.DynamicAnalysisEventArgs.Stage">
            <summary>Стадия решения задачи динамического анализа</summary>
        </member>
        <member name="T:TFlex.DynamicAnalysisEventArgs">
            <summary>Класс, содержащий данные о событии, возникающем при решении задач динамического анализа</summary>
        </member>
        <member name="P:TFlex.ImportExportDialogShownEventArgs.FilterId">
            <summary>Получить идентификатор фильтра импортируемого или экспортируемого файла</summary>
        </member>
        <member name="P:TFlex.ImportExportDialogShownEventArgs.FilePath">
            <summary>Получить имя импортируемого или экспортируемого файла</summary>
        </member>
        <member name="T:TFlex.ImportExportDialogShownEventArgs">
            <summary>Класс, содержащий данные о событии, возникающем когда диалог импорта или экспорта открыт</summary>
        </member>
        <member name="M:TFlex.ShowingImportExportDialogEventArgs.AddFilter(System.String,System.Int32,System.String,System.String)">
            <summary>Добавить фильтр к текущему диалогу</summary>
            <param name="filter">Тип импортируемого или экспортируемого файла</param>
            <param name="filterID">Идентификатор фильтра</param>
            <param name="description">Описание формата</param>
            <param name="group">Группа в которую будет помещен фильтр</param>
        </member>
        <member name="M:TFlex.ShowingImportExportDialogEventArgs.AddFilter(System.String,System.Int32)">
            <summary>Добавить фильтр к текущему диалогу</summary>
            <param name="filter">Тип импортируемого или экспортируемого файла</param>
            <param name="filterID">Идентификатор фильтра</param>
        </member>
        <member name="M:TFlex.ShowingImportExportDialogEventArgs.AddFilter(System.String)">
            <summary>Добавить фильтр к текущему диалогу</summary>
            <param name="filter">Тип импортируемого или экспортируемого файла</param>
        </member>
        <member name="T:TFlex.ShowingImportExportDialogEventArgs">
            <summary>Класс, содержащий данные о событии, возникающем перед открытием диалога импорта или экспорта</summary>
        </member>
        <member name="P:TFlex.DrawingDocumentEventArgs.Page">
            <summary>Активная страница, которая рисуется в данный момент</summary>
        </member>
        <member name="P:TFlex.DrawingDocumentEventArgs.Graphics">
            <summary>Графический контекст перерисовки</summary>
        </member>
        <member name="T:TFlex.DrawingDocumentEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем при прорисовке документа</summary>
        </member>
        <member name="P:TFlex.CopyPropertiesCommandEventArgs.ObjectTypeFilter">
            <summary>Тип объекта</summary>
        </member>
        <member name="P:TFlex.CopyPropertiesCommandEventArgs.ApplyToDefaults">
            <summary>Применить также к параметрам по умолчанию</summary>
        </member>
        <member name="T:TFlex.CopyPropertiesCommandEventArgs">
            <summary>Класс, содержащий данные о событии - вызвана команда получения параметров объекта</summary>
        </member>
        <member name="P:TFlex.PluginCommandEventArgs.Command">
            <summary>Имя команды</summary>
        </member>
        <member name="T:TFlex.PluginCommandEventArgs">
            <summary>Класс, содержащий данные о событии - вызвана локальная команда из контекстного меню линейки вида</summary>
        </member>
        <member name="P:TFlex.WorkplaneCommandEventArgs.Count">
            <summary>Количество создаваемых плоскостей</summary>
        </member>
        <member name="P:TFlex.WorkplaneCommandEventArgs.Step">
            <summary>Шаг плоскостей или расстояние между двумя плоскостями</summary>
        </member>
        <member name="P:TFlex.WorkplaneCommandEventArgs.IsUseStep">
            <summary>true, если должно быть использовано значение шага</summary>
        </member>
        <member name="P:TFlex.WorkplaneCommandEventArgs.Command">
            <summary>Идентификатор команды</summary>
        </member>
        <member name="T:TFlex.WorkplaneCommandEventArgs.LocalCommands">
            <summary>Локальные команды</summary>
        </member>
        <member name="T:TFlex.WorkplaneCommandEventArgs">
            <summary>Класс, содержащий данные о событии - вызвана команда управления рабочими плоскостями</summary>
        </member>
        <member name="P:TFlex.ViewRulerContextMenuCommandEventArgs.Command">
            <summary>Идентификатор команды</summary>
        </member>
        <member name="T:TFlex.ViewRulerContextMenuCommandEventArgs">
            <summary>Класс, содержащий данные о событии - вызвана локальная команда из контекстного меню линейки вида</summary>
        </member>
        <member name="P:TFlex.CommandEventArgs.DeselectAll">
            <summary>Сбросить селекцию всех объектов</summary>
        </member>
        <member name="P:TFlex.CommandEventArgs.CommandID">
            <summary>Идентификатор команды</summary>
        </member>
        <member name="T:TFlex.CommandEventArgs">
            <summary>Класс, содержащий данные о событии - вызвана команда</summary>
        </member>
        <member name="P:TFlex.TrackingContextPopupMenuEventArgs.Menu">
            <summary>Текущее меню</summary>
        </member>
        <member name="P:TFlex.TrackingContextPopupMenuEventArgs.Object">
            <summary>Объект модели связанный с событием</summary>
        </member>
        <member name="P:TFlex.TrackingContextPopupMenuEventArgs.View">
            <summary>Окно (Вид), связанное с событием</summary>
        </member>
        <member name="T:TFlex.TrackingContextPopupMenuEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем при вызове контекстного меню</summary>
        </member>
        <member name="P:TFlex.RegenerateDocumentEventArgs.UpdateFileLinksMode">
            <summary>Обновить файловые ссылки</summary>
        </member>
        <member name="F:TFlex.RegenerateDocumentEventArgs.UpdateFileLinks.All">
            <summary>Обновлять все файлы</summary>
        </member>
        <member name="F:TFlex.RegenerateDocumentEventArgs.UpdateFileLinks.NonActual">
            <summary>Обновлять неактуальные файлы</summary>
        </member>
        <member name="F:TFlex.RegenerateDocumentEventArgs.UpdateFileLinks.None">
            <summary>Не обновлять</summary>
        </member>
        <member name="T:TFlex.RegenerateDocumentEventArgs.UpdateFileLinks">
            <summary>Перечислитель режимов обновления файловых ссылок</summary>
        </member>
        <member name="P:TFlex.RegenerateDocumentEventArgs.Is3DRegeneration">
            <summary>Класс, содержащий данные о событии, возникшем при пересчете модели</summary>
        </member>
        <member name="P:TFlex.RegenerateDocumentEventArgs.IsFullRegeneration">
            <summary>true если была произведена полная регенерация модели</summary>
        </member>
        <member name="T:TFlex.RegenerateDocumentEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем при пересчете модели</summary>
        </member>
        <member name="T:TFlex.ProductStructureUpdatingEventArgs">
            <summary />
        </member>
        <member name="T:TFlex.MoveSelectedObjectsEventArgs">
            <summary />
        </member>
        <member name="M:TFlex.DeletingObjectParentsEventArgs.AddParent(TFlex.Model.ModelObject)">
            <summary>Добавляет зависимый объект для удаления</summary>
        </member>
        <member name="T:TFlex.DeletingObjectParentsEventArgs">
            <summary>Класс, содержащий данные о событии, происходящем перед удалением объекта модели для получания дополнтиельных зависимых объектов для удаления</summary>
        </member>
        <member name="P:TFlex.BlockChangesEventArgs.Name">
            <summary>Имя блока изменений</summary>
        </member>
        <member name="T:TFlex.BlockChangesEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем в данном виде документа</summary>
        </member>
        <member name="P:TFlex.ObjectPropertiesDialogCompletedEventArgs.OldObject">
            <summary>Предыдуший объект</summary>
        </member>
        <member name="T:TFlex.ObjectPropertiesDialogCompletedEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем после редактирования объекта с помощью модального окна параметров</summary>
        </member>
        <member name="P:TFlex.ObjectEventArgs.Object">
            <summary>Объект, связанный с данным событием</summary>
        </member>
        <member name="T:TFlex.ObjectEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем в данном виде документа</summary>
        </member>
        <member name="P:TFlex.ViewEventArgs.View">
            <summary>Вид (окно) в котором произошло данное событие</summary>
        </member>
        <member name="T:TFlex.ViewEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем в данном виде документа</summary>
        </member>
        <member name="P:TFlex.DocumentEventArgs.Document">
            <summary>Документ, в котором произошло данное событие</summary>
        </member>
        <member name="T:TFlex.DocumentEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем в документе</summary>
        </member>
        <member name="P:TFlex.PluginEventArgs.Cancel">
            <summary>true, если действие было отменено пользователем или системой</summary>
        </member>
        <member name="T:TFlex.PluginEventArgs">
            <summary>Класс, содержащий данные о событии, возникшем в приложении</summary>
        </member>
        <member name="P:TFlex.Drawing.Rectangle.Center">
            <summary>Центр прямоугольника</summary>
        </member>
        <member name="P:TFlex.Drawing.Rectangle.Height">
            <summary>Высота прямоугольника</summary>
        </member>
        <member name="P:TFlex.Drawing.Rectangle.Width">
            <summary>Ширина прямоугольника</summary>
        </member>
        <member name="P:TFlex.Drawing.Rectangle.Top">
            <summary>Координата Y верхней границы прямоугольника</summary>
        </member>
        <member name="P:TFlex.Drawing.Rectangle.Bottom">
            <summary>Координата Y нижней границы прямоугольника</summary>
        </member>
        <member name="P:TFlex.Drawing.Rectangle.Right">
            <summary>Координата Х правой границы прямоугольника</summary>
        </member>
        <member name="P:TFlex.Drawing.Rectangle.Left">
            <summary>Координата Х левой границы прямоугольника</summary>
        </member>
        <member name="M:TFlex.Drawing.Rectangle.#ctor(TFlex.Drawing.Point,TFlex.Drawing.Point)">
            <summary>Конструктор с параметрами - координатами левой верхней и правой нижней
точек прямоугольника</summary>
            <param name="topLeft">Координаты левой верхней точки</param>
            <param name="bottomRight">Координаты правой нижней точки</param>
        </member>
        <member name="M:TFlex.Drawing.Rectangle.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор с параметрами - координатами границ прямоугольника</summary>
            <param name="Left">Координата Х левой границы прямоугольника</param>
            <param name="Bottom">Координата Y нижней границы прямоугольника</param>
            <param name="Right">Координата Х правой границы прямоугольника</param>
            <param name="Top">Координата Y верхней границы прямоугольника</param>
        </member>
        <member name="T:TFlex.Drawing.Rectangle">
            <summary>Класс содержит прямоугольник с вещественными координатами</summary>
        </member>
        <member name="P:TFlex.Drawing.Size.cy">
            <summary>Высота</summary>
        </member>
        <member name="P:TFlex.Drawing.Size.cx">
            <summary>Ширина</summary>
        </member>
        <member name="M:TFlex.Drawing.Size.#ctor(System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="cx">Ширина</param>
            <param name="cy">Высота</param>
        </member>
        <member name="T:TFlex.Drawing.Size">
            <summary>Класс определяет размер</summary>
        </member>
        <member name="P:TFlex.Drawing.Point.Y">
            <summary>Координата Y</summary>
        </member>
        <member name="P:TFlex.Drawing.Point.X">
            <summary>Координата Х</summary>
        </member>
        <member name="M:TFlex.Drawing.Point.#ctor(System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="x">Координата Х</param>
            <param name="y">Координата Y</param>
        </member>
        <member name="T:TFlex.Drawing.Point">
            <summary>Класс хранит точку с вещественными координатами</summary>
        </member>
        <member name="M:TFlex.Model.ObjectTypeExtension.GetNameForType(System.Int32)">
            <summary>Получить локализованное имя типа объекта или null если имя не задано</summary>
        </member>
        <member name="M:TFlex.Model.ObjectTypeExtension.GetAsString(TFlex.Model.ObjectType)">
            <summary>Получить локализованное имя типа объекта или null если имя не задано</summary>
        </member>
        <member name="T:TFlex.Model.ObjectTypeExtension">
            <summary>Класс, содержащий расширения для ObjectType</summary>
        </member>
        <member name="T:TFlex.Model.ObjectType">
            <summary>Тип объекта модели</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Model3DObjectGroup">
            <summary>Группа объектов 3D модели.</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CircuitBus">
            <summary>Шина</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CircuitLinkSymbol">
            <summary>Условное обозначение линии связи</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Harness2D">
            <summary>Жгут 2D (cборочный чертёж кабельного изделия)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CircuitMultiLinksGroup">
            <summary>Групповая линия связи с разрывом</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CircuitLinksGroup">
            <summary>Групповая линия связи</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CircuitMultiLink">
            <summary>Линия связи с разрывом</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CircuitLink">
            <summary>Линия связи</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.StructureElementLink">
            <summary>Связь структурных элементов</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.StructureElementLinkDescriptor">
            <summary>Описание связи структурных элементов</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.StructureElement">
            <summary>Структурный элемент</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.StructureElementType">
            <summary>Тип структурного элемента</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Scenario">
            <summary>Сценарий разборки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Primitive">
            <summary>3D Примитив</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ProductStruct">
            <summary>Состав изделия</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ProductStructRowElem">
            <summary>Элемент состава изделия</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.TwoPathesIntersectionNode3D">
            <summary>3D узел</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ReferenceNode3D">
            <summary>Внешний 3D узел</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Harness3D">
            <summary>Класс пути трубопровода</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.PipePath3D">
            <summary>Класс пути трубопровода</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ScaleVectorTransformation">
            <summary>Класс преобразования масштабирования вдоль вектора</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.MoveVectorTransformation">
            <summary>Класс преобразования перемещения вдоль вектора</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.RotateVectorTransformation">
            <summary>Класс преобразования поворота вокруг вектора</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ImportedTransformation">
            <summary>Класс внешнего преобразования</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.MoveRotateTransformation">
            <summary>Класс преобразования перемещения/поворота</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.SpatialWorkSurface">
            <summary>Базовый класс для всех типов специальных координатных поверхностей</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.FillHole">
            <summary>Заполнения области</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ExtendSurface">
            <summary>Заполнения области</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.MaterialOperation">
            <summary>Операция наложения материала</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Simplification">
            <summary>Операция удаления лишних геометрических элементов упрощения геометрии</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.FaceTransform">
            <summary>Операция перемещения граней</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.FaceChange">
            <summary>Операция изменения граней</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.FaceReplace">
            <summary>Операция замены граней</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.FaceDelete">
            <summary>Операция удаления граней</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Imprint">
            <summary>Операция разделения граней</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.BodyTaper">
            <summary>Операция уклона тела</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.GraphLaw">
            <summary>График</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.MeshNode3D">
            <summary>3D узел</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.SymmetryOperation2">
            <summary>Операция симметрии</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CopyOperation2">
            <summary>Операция копирования (3D)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Restraint">
            <summary>Граничное условие задачи</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.EventFatigue">
            <summary>Событие</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Sensor">
            <summary>Датчик</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.DynamicStudy">
            <summary>Задача Динамического анализа</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CAEStudy">
            <summary>Задача КЭА </summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Topol">
            <summary>Топологический элемент: грань, цикл, ребро, вершина</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Face">
            <summary>Грань</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Loop">
            <summary>Цикл</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Edge">
            <summary>Ребро</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Vertex">
            <summary>Вершина</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Weld">
            <summary>Сварной шов</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.WeldType">
            <summary>Тип сварного шва</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Body">
            <summary>Тело</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Mate">
            <summary>Сопряжение</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ExternalOperation">
            <summary>Внешняя операция (приложения)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.WorkSurface">
            <summary>Рабочая поверхность</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Operation">
            <summary>3D операция</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Thread">
            <summary>Операция резьбы</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Sew">
            <summary>Операция сшивки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ImportedOperation">
            <summary>Операция импорта</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Taper">
            <summary>Операция уклона</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Shell">
            <summary>Операция оболочки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Separation">
            <summary>Операция разделения</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ReferenceWorkplane">
            <summary>Ссылочная рабочая плоскость</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Workplane">
            <summary>Рабочая плоскость</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Projection">
            <summary>2D проекция</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Swept">
            <summary>Операция по траектории</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.SpatialSurface">
            <summary>Рабочая поверхность</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Profile">
            <summary>3D профиль</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Node3D">
            <summary>3D узел</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Path3D">
            <summary>3D путь</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Boolean">
            <summary>Булева операция</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Rotation">
            <summary>Операция вращения</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Extrusion">
            <summary>Операция выталкивания</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.PathArray">
            <summary>Массив по пути (3D)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.NodeArray">
            <summary>Массив по точкам (3D)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CircularArray">
            <summary>Круговой массив (3D)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.LinearArray">
            <summary>Линейный массив (3D)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ParametricArray">
            <summary>Параметрический массив (3D)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Material">
            <summary>Материал</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.LCS">
            <summary>ЛСК</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ThreeFaceBlending">
            <summary>Операция сглаживания трёх граней</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.FaceBlending">
            <summary>Операция сглаживания граней</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.EdgeBlending">
            <summary>Операция сглаживания рёбер</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Loft">
            <summary>Операция по сечениям</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Camera">
            <summary>Камера</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Spiral">
            <summary>Операция "спираль"</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Spring">
            <summary>Операция "пружина"</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.SheetMetalFeature">
            <summary>Операция выштамповки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Hole">
            <summary>Операция отверстия</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Pipe">
            <summary>Операциия трубопровода</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Section">
            <summary>3D сечение</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.InternalFragment3D">
            <summary>Внутренний 3D фрагмент</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Fragment3D">
            <summary>3D фрагмент</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CopyOperation">
            <summary>Операция копирования (3D) в T-Flex CAD до версии 11</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Picture3D">
            <summary>3D картинка</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Light">
            <summary>Источник света</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.SymmetryOperation">
            <summary>Операция симметрии в T-Flex CAD до версии 11</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.CutOperation">
            <summary>Операция отсечения</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Bend">
            <summary>Операция гибки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Rebend">
            <summary>Операция повторной гибки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Unbend">
            <summary>Операция разгибки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.SheetMetalPart">
            <summary>Заготовка листовой штамповки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Copy">
            <summary>Операция копирования или массив (2D)</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Report">
            <summary>Отчёт</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Database">
            <summary>База данных</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.ViewSymbol">
            <summary>Обозначение вида</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Control">
            <summary>Элемент управления</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.DrawingView">
            <summary>Чертёжный вид</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.FormlimitsSymbol">
            <summary>Обозначение допуска формы или расположения</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.RoughnessSymbol">
            <summary>Обозначение шероховатости</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Dimension">
            <summary>Размер</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.LeaderNote">
            <summary>Надпись</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Connector">
            <summary>Коннектор</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.FixingVector">
            <summary>Вектор привязки</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Picture">
            <summary>Картинка или OLE объект</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Fragment">
            <summary>Фрагмент</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Text">
            <summary>Текст</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Area">
            <summary>Штриховка или заливка</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.External">
            <summary>Объект приложения</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Variable">
            <summary>Переменная</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Outline">
            <summary>Линия изображения</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Node">
            <summary>Узел</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Construction">
            <summary>Линия построения</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Page">
            <summary>Страница</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Layer">
            <summary>Слой</summary>
        </member>
        <member name="F:TFlex.Model.ObjectType.Undefined">
            <summary>Неопределённый тип</summary>
        </member>
        <member name="T:TFlex.KeyCode">
            <summary>Перечислитель кодов клавиш клавиатуры</summary>
        </member>
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:PreciseGeometryUtils.RemoveKnots(System.Boolean,System.Int32,std.vector<TFPoint,std.allocator<TFPoint>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<System.Double,std.allocator<System.Double>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<System.Double,std.allocator<System.Double>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<System.Double,std.allocator<System.Double>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Geometry.Interval.ParameterOn0Period(System.Double,System.Boolean)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Geometry.Interval.IntervalOn0Period(RGK.Geometry.Interval!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<RGK.Geometry.Interval,std.allocator<RGK.Geometry.Interval>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Math.Vector3D.Max(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Math.Vector3D.Min(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Math.BoundingBox.Move(RGK.Math.Vector3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Generators.TesselationEvent.#ctor(System.UInt64,System.UInt64)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Geometry.Curve.MakeReversed(RGK.Common.Context*,std.shared_ptr<RGK.Geometry.Curve!System.Runtime.CompilerServices.IsConst>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Point2D.op_LessThan(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Geometry.NURBSCurve.RefineKnots(RGK.Common.Context*,std.vector<System.Double,std.allocator<System.Double>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Geometry.NURBSCurve.InsertKnot(RGK.Common.Context*,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.shared_ptr<RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Geometry.NURBSCurve.RemoveKnot(RGK.Common.Context*,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,std.shared_ptr<RGK.Geometry.NURBSCurve!System.Runtime.CompilerServices.IsConst>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Geometry.NURBSCurve.MakeReversed(RGK.Common.Context*,std.shared_ptr<RGK.Geometry.Curve!System.Runtime.CompilerServices.IsConst>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGK.Geometry.NURBSCurve.FindPoints(RGK.Common.Context*,RGK.Geometry.NURBSCurve.CharPointsReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Spline2D.CreateOpenInterpolationSpline(RGPlatform.Geometry.Context*,std.vector<RGPlatform.Geometry.Point2D,std.allocator<RGPlatform.Geometry.Point2D>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<System.Double,std.allocator<System.Double>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32,System.Boolean,<unknown type>,RGPlatform.Geometry.Spline2D*!System.Runtime'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Spline2D.CreateOpenInterpolationSpline(RGPlatform.Geometry.Context*,std.vector<RGPlatform.Geometry.Point2D,std.allocator<RGPlatform.Geometry.Point2D>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<System.Double,std.allocator<System.Double>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,<unknown type>,<unknown type>,System.Double,System.Int32,System.Boolean,<unknown type>,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Spline2D.CreateInterpolationSpline(RGPlatform.Geometry.Context*,std.vector<RGPlatform.Geometry.Point2D,std.allocator<RGPlatform.Geometry.Point2D>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<System.Double,std.allocator<System.Double>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Int32,System.Boolean,System.Boolean,System.Boolean,<unknown type>,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Spline2D.InsertKnot(RGPlatform.Geometry.Context*,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Spline2D.RemoveKnot(RGPlatform.Geometry.Context*,System.Double,System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,RGPlatform.Geometry.Spline2D*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Spline2D.FindCharacteristicPoints(RGPlatform.Geometry.Context*,RGPlatform.Geometry.Spline2D.CharPointsReport*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Spline2D.ConvertPoint(RGPlatform.Geometry.Point2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:RGPlatform.Geometry.Spline2D.ConvertPointArray(std.vector<RGPlatform.Geometry.Point2D,std.allocator<RGPlatform.Geometry.Point2D>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector<RGK.Math.Vector3D,std.allocator<RGK.Math.Vector3D>>*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'M:TFlex.Model.ObjectId.ToString(System.String,System.IFormatProvider)'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.CircuitLinkSplitMergeEventArgs.IsMerge'. -->
        <!-- Discarding badly formed XML document comment for member 'P:TFlex.Model.Document.IsCommandRunning'. -->
    </members>
</doc>