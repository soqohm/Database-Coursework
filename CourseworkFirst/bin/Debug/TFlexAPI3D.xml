<?xml version="1.0"?>
<doc>
    <assembly>
        "TFlexAPI3D"
    </assembly>
    <members>
        <member name="M:ENI_Path.IdentifyOneEdgeWire(System.Int32)">
Идентификация проволоочного тела из одного ребра
</member>
        <member name="M:TFlex.Model.Model3D.Geometry.WireFromCurvesGenerator.Run">
            <summary>Функция генерации проволочных тел</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.WireFromCurvesGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.WireFromCurvesGenerator.Segment[])">
            <summary>Конструктор для задания проволочного тела по набору кривых</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="segments">Множество сегментов</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.WireFromCurvesGenerator.Segment.#ctor(TFlex.Model.Model3D.Geometry.BaseCurve,TFlex.Model.Model3D.Geometry.BaseInterval,System.UInt32)">
            <summary>Конструктор сегмента проволочного тела</summary>
            <param name="curve">Кривая, на которой лежит сегмент пути</param>
            <param name="interval">Параметрический интервал кривой, на котором лежит сегмент пути</param>
            <param name="id">Идентификатор сегмента, уникальный в границах каждого 3D объекта внешнего приложения</param>
            <remarks>Использование уникальных и воспроизводимых при каждом пересчете объекта идентификаторов сегментов, позволяет обеспечить ассоциативность модели на уровне отдельных элементов топологии</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.WireFromCurvesGenerator.Segment">
            <summary>Сегмент проволочного тела</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.WireFromCurvesGenerator">
            <summary>Генератор проволочных тел по набору кривых</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.WireFromEdgesGenerator.Run">
            <summary>Функция генерации проволочных тел</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.WireFromEdgesGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.BaseEdge[])">
            <summary>Конструктор для задания проволочного тела по набору рёбер с разных тел</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="edges">Множество рёбер</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.WireFromEdgesGenerator">
            <summary>Генератор проволочных тел по набору рёбер с разных тел</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ShellGenerator.Run">
            <summary>Функция генерации оболочки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ShellGenerator.AddPiercedFace(TFlex.Model.Model3D.Geometry.BaseTopol)">
            <summary>Функция задаёт пробиваемые грани</summary>
            <param name="face">Грань, которая должна быть удалена в оболочке</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ShellGenerator.AddFace(TFlex.Model.Model3D.Geometry.BaseTopol,System.Double)">
            <summary>Функция задаёт параметры отступа индивидуально для грани</summary>
            <param name="face">Грань, для которой устанавливается отступ</param>
            <param name="dist">величина отступа в метрах</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ShellGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.Body,System.Boolean,System.Double)">
            <summary>Конструктор для задания базовых объектов построения оболочки</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="body">Тело на котором строится оболочка</param>
            <param name="isEquid">Параметр режима построения оболочка или эквидистантное тело</param>
            <param name="defDist">Толщина стенки по умолчанию в метрах</param>
            <remarks>3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ShellGenerator">
            <summary>Генератор сглаживания рёбер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.EdgeBlendingGenerator.Run">
            <summary>Функция генерации сглаживания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.EdgeBlendingGenerator.AddVariableBlendData(TFlex.Model.Model3D.Geometry.BaseTopol,System.Double,System.Double,System.Int32,System.Int32,System.Double[],System.Double[],System.Double[],System.Double[])">
            <summary>Функция задаёт параметры для сглаживания ребра переменного радиуса</summary>
            <param name="entity">Ребро для установки параметров сглаживания</param>
            <param name="szvardata">Количество точек для задания радиус-функции</param>
            <param name="varBlndParam">Массив значений параметров на ребре в процентах</param>
            <param name="vradDataL">Массив значений радиусов/смещений по "левой" грани (по направлению ребра)</param>
            <param name="vradDataR">Массив значений радиусов/смещений по "правой" грани (по направлению ребра)</param>
            <param name="vradDataRHO">Массив значений параметров параметров формы сечения сглаживания на ребре
(0. - круговое, ]0,0.5[ - эллиптическое, 0.5 - параболическое, ]0.5,1.[ - гиперболическое</param>
            <param name="startsetback">Смещение от вершины в начале ребра для создания "чемоданного угла"</param>
            <param name="endsetback">Смещение от вершины в конце ребра для создания "чемоданного угла"</param>
            <param name="BlndStatus">Параметр режима сглаживания</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.EdgeBlendingGenerator.AddConstantBlendData(TFlex.Model.Model3D.Geometry.BaseTopol,System.Double,System.Double,System.Double,System.Double,System.Int32)">
            <summary>Функция задаёт параметры для сглаживания ребра постоянного радиуса</summary>
            <param name="entity">Топологический элемент для установки параметров сглаживания (ребро, грань, цикл или вершина)</param>
            <param name="RF">Радиус сглаживания/смещение по первой грани для фаски</param>
            <param name="RS">Смещение по второй грани для фаски</param>
            <param name="startsetback">Смещение от вершины в начале ребра для создания "чемоданного угла"</param>
            <param name="endsetback">Смещение от вершины в конце ребра для создания "чемоданного угла"</param>
            <param name="BlndStatus">Параметр режима сглаживания</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.EdgeBlendingGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.Body)">
            <summary>Конструктор для задания базовых объектов сглаживания</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="body">Тело на котором строится сглаживание</param>
            <remarks>3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.EdgeBlendingGenerator">
            <summary>Генератор сглаживания рёбер</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFEdgeBlendMode.TFblchamfering">
            <summary>	TFblchamfering делать фаску</summary>
            <summary>	TFblrounding  делать скругление постоянного радиуса</summary>
            <summary>	TFblvarblending делать скругление переменного радиуса</summary>
            <summary>	TFblvblending делать вершинное сглаживание</summary>
            <summary>	TFblstartoblique делать сглаживание с отступом в начале ребра</summary>
            <summary>	TFblendoblique делать сглаживание с отступом в конце ребра</summary>
            <summary>	Prefthis использовать установки заданные для данного ребра</summary>
            <summary>	TFblchamplength интерпретировать второе смещение в фаске как угол (режим фаски смащение-угол)</summary>
            <summary>	TFblvertexyshape использовать режим Y формы в вершинном сглаживании</summary>
            <summary>	TFblprop продолжать сглаживание вдоль касательных рёбер</summary>
            <summary>	далее опции обработки перекрытий </summary>
            <summary>	TFblsmoothovany учитывать гладкие сопряжения</summary>
            <summary>	TFblcliffovany сохранять острые рёбра</summary>
            <summary>	TFblnotchovyes использовать вырез</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.LabelEventArgs.#ctor(TFlex.Model.Model3D.Visual.Label,TFlex.Model.Model3D.View3D,System.Int32,System.Int32,TFlex.Model.Model3D.Visual.VisualEventArgs.ActionType)">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.LabelEventArgs">
            <summary>Параметры событий меток</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SheetFromFaces.Run">
            <summary>Функция генерации листового тела</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SheetFromFaces.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.BaseFace[])">
            <summary>Конструктор для задания листового тела по набору граней</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="faces">Множество граней</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SheetFromFaces">
            <summary>Генератор листового тела по набору граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface.Run">
            <summary>Функция генерации листового тела</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.BaseSurface,TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface.Lump[])">
            <summary>Конструктор для задания листового тела на поверхности по набору параметрических составных кривых</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="surface">Поверхность, на которой лежит листовое тело</param>
            <param name="lumps">Множество связанных областей</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface.Lump.#ctor(TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface.Lump.Loop[],System.UInt32)">
            <summary>Конструктор для связанной области</summary>
            <param name="loops">Множество составных кривых, образующих границы связанной области</param>
            <param name="id">Идентификатор грани, уникальный в границах каждого 3D объекта внешнего приложения</param>
            <remarks>Использование уникальных и воспроизводимых при каждом пересчёте объекта идентификаторов граней, позволяет обеспечить ассоциативность модели на уровне отдельных элементов топологии.
Только одна составная кривая включает все остальные.
Все кривые лежащие внутри не могут включать друг друга.
Не допускается пересечение или касание между кривыми.
Внешний цикл ориентирован против часовой стрелки. Внутренние циклы ориентированы по часовой стрелке</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface.Lump.Loop.#ctor(TFlex.Model.Model3D.Geometry.BaseBody,System.UInt32)">
            <summary>Конструктор сегмента проволочного тела</summary>
            <param name="wire">Составная кривая, образующая одну из границ листового тела</param>
            <param name="id">Идентификатор цикла, уникальный в границах каждого 3D объекта внешнего приложения</param>
            <remarks>Использование уникальных и воспроизводимых при каждом пересчёте объекта идентификаторов циклов, позволяет обеспечить ассоциативность модели на уровне отдельных элементов топологии.
Параметрическая область плоскость совпадает с плоскостью XY. Следовательно, составная кривая лежит в плоскости XY.
Составная кривая должна быть замкнутая и не должна иметь самопересечений.
Предполагается, что кривая получена в результате использования генератора WireFromCurvesGenerator</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface.Lump.Loop">
            <summary>Одна из границ связанной области</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface.Lump">
            <summary>Связанная область</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SheetFromTrimmedSurface">
            <summary>Генератор листового тела на поверхности, обрезанной набором параметрических составных кривых</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SewGenerator.Run">
            <summary>Функция генерации сшивки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SewGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.Body[],System.Double)">
            <summary>Конструктор для задания сшивки</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="sheets">Множество сшиваемых листовых тел</param>
            <param name="gap">Минимальное значение ширины щели</param>
            <remarks>Все параметры обязятельные.
3D объект внешнего приложения должен быть связан с внешним объектом.</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SewGenerator">
            <summary>Генератор сшивки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Scale">
            <summary>Получить закон масштабирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Twist">
            <summary>Получить закон кручения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Spline">
            <summary>Сплайновая функция для типов задания Curve и Inv</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.LawSet">
            <summary>Получить табличную функцию для типа задания Discrete</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.default(System.UInt32)">
            <summary>Пара по номеру</summary>
            <param name="index">Номер пары</param>
            <remarks>Пары нумеруются от нуля. Если индекс отрицательный или превышает количество пар, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.DeleteAll">
            <summary>Удалить все пары</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Delete(System.UInt32)">
            <summary>Удалить пару по номеру</summary>
            <param name="index">Номер пары</param>
            <remarks>Пары нумеруются от нуля. Если индекс отрицательный или превышает пар, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Add(TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Association)">
            <summary>Добавить пару в конец списка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Insert(System.UInt32,TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Association)">
            <summary>Вставить пару перед номером</summary>
            <param name="index">Номер пары</param>
            <remarks>Пары нумеруются от нуля. Если индекс отрицательный или превышает количество пар, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Length">
            <summary>Количество пар</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Association.#ctor(TFlex.Model.Model3D.Geometry.Vertex,System.Double)">
            <summary>Конструктор зависимости значения функции от вершины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Association.Value">
            <summary>Значение функции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Association.Vertex">
            <summary>Вершина</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete.Association">
            <summary>Зависимость значения функции от вершины</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.Discrete">
            <summary>Табличная функция : вершина траектории и значение закона в ней. Возможно перечисление значений с использованием конструкции foreach</summary>
            <remarks>Можно задавать любой набор пар вершина траектории / значение. То есть не обязательно задавать закон во всех точках.
Порядок задания пар несущественен за исключением замкнутой траектории. В последнем случае первое вхождение в список вершины ассоциируется с начальным значением функции. Второй вхождение - с конечным значением функции.
Существует два специальных варианта интерпретации закона :
- Если в таблице только одна пара, то функция считается константной;
- Если в таблице две пары, соответственно для начальной вершины и конечной вершины траектории, то используется линейная интерполяция.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.LawType">
            <summary>Тип задания закона</summary>
            <remarks>По умолчанию закон не используется</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.LawTypeSet.Inv">
            <summary>Закон задаётся непрерывной скалярной фукнцией пропорционально длине вдоль траектории.
Закон задаётся одномерной сплайновой кривой, обратной к задающей функции.
То есть кривая параметризована на интервале значений, принимаемых законом и область значений кривой лежит в иентрале от 0.0 до 1.0</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.LawTypeSet.Curve">
            <summary>Закон задаётся непрерывной скалярной фукнцией пропорционально длине вдоль траектории.
Закон задаётся одномерной сплайновой кривой, параметризованной от 0.0 до 1.0.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.LawTypeSet.Discrete">
            <summary>Интерполяция таблично заданной функции. Значения функции задаются в вершинах траектории</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.LawTypeSet.None">
            <summary>Закон не используется</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator.Law.LawTypeSet">
            <summary>Тип задания закона</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator.Law">
            <summary>Класс хранения законов кручения и масштабирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Ignorable">
            <summary>Получить множество игнорируемых вершин траектории.</summary>
            <remarks>В некоторых случаях при формировании граней можно в местах сочленения сегментов тела, соответсвующих вершинам траектории, избежать построения рёбер, сшивая грани в одну.
Если не задан тип разбиения результирущего тела на грани Grid, то такая обработка выполняется автоматически. Если задан тип Grid, то можно задать набор вершин траектории, для которых будет выполняться такая обработка.
В данный список нельзя добавлять первую и последнюю вершины размкутой траектории или вершины, где смежные рёбра траектории не G1 - непрерывны</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.default(System.UInt32)">
            <summary>Вершина по номеру</summary>
            <param name="index">Номер вершины</param>
            <remarks>Вершины нумеруются от нуля. Если индекс отрицательный или превышает количество вершин, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.DeleteAll">
            <summary>Удалить все вершины</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.Delete(System.UInt32)">
            <summary>Удалить вершину</summary>
            <param name="index">Номер вершины</param>
            <remarks>Вершины нумеруются от нуля. Если индекс отрицательный или превышает количество вершин, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.Add(TFlex.Model.Model3D.Geometry.Vertex)">
            <summary>Добавить вершину</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices.Length">
            <summary>Количество вершин</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator.IgnorableVertices">
            <summary>Класс хранения множества игнорируемых вершин траектории. Возможно перечисление вершин с использованием конструкции foreach</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.ScalePoint">
            <summary>Точка масштабирования для способов масштабирования Posn и Size</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.ScaleType">
            <summary>Способ масштабирования</summary>
            <remarks>По умолчанию установлен тип Both</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.ScaleTypeSet.Both">
            <summary>Масштабирование положения профиля относительно траектории и размера профиля</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.ScaleTypeSet.Size">
            <summary>Масштабирование размера профиля с сохранением положения профиля относительно траектории</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.ScaleTypeSet.Posn">
            <summary>Масштабирование положения профиля относительно траектории с сохранением размера профиля</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator.ScaleTypeSet">
            <summary>Способ масштабирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.AllowRationals">
            <summary>Параметр построения боковых поверхностей в форме рациональных сплайнов</summary>
            <remarks>По умолчанию параметр установлен</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.MinimiseTolerance">
            <summary>Параметр минимизации точности, где это возможно</summary>
            <remarks>По умолчанию параметр не установлен</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Tolerance">
            <summary>Точность геометрии</summary>
            <remarks>По умолчанию 1.0e-5</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Fair">
            <summary>Параметр улучшения формы результирующего тела в случае пространственной траектории</summary>
            <remarks>По умолчанию параметр установлен</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.TopologyForm">
            <summary>Тип разбиения</summary>
            <remarks>По умолчанию установлен тип Minimal</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.TopologyFormType.Grid">
            <summary> Решётка граней. Каждому ребру образующего контура соответствует набор граней в направлении траектории.
Количество граней больше или равно по сравнению с типом разбиения Columns,
так как дополнительные рёбра создаются для каждой вершины траектории,
за исключением вершин, добавленных в список игнорируемых вершин.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.TopologyFormType.Columns">
            <summary>Столбики граней, соответствующие рёбрам образующего контура</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.TopologyFormType.Minimal">
            <summary>Минимальное количество граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator.TopologyFormType">
            <summary>Тип разбиения результирующего тела на грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Simplify">
            <summary>Параметр упрощения геометрии</summary>
            <remarks>По умолчанию параметр упрощения установлен</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweepGenerator.Alignment">
            <summary>Ориентация контура</summary>
            <remarks>По умолчанию установлен тип Normal</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.AlignmentType.Parallel">
            <summary>Параллельно самому себе</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SweepGenerator.AlignmentType.Normal">
            <summary>Перпендикулярно пути</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator.AlignmentType">
            <summary>Тип ориентации контура</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.Run">
            <summary>Функция генерации тела по траектории</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweepGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.Body,TFlex.Model.Model3D.Geometry.Body,TFlex.Model.Model3D.Geometry.Vertex)">
            <summary>Конструктор для задания тела по траектории</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="profile">Образующий контур. Этот контур превращается в тело по траектории и возращается в списке резльтирующих тел или удаляется</param>
            <param name="path">Траектория</param>
            <param name="start">Стартовая точка на траектории</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweepGenerator">
            <summary>Генератор тела по траектории</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.BoxManipulatorBase.Reset(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection,System.Double,System.Double,System.Double)">
            <summary>Устанавливает параметры настраиваемого параллелепипеда</summary>
            <param name="origin">координаты одной из вершин параллелепипеда</param>
            <param name="xDirection">направление локальной оси X</param>
            <param name="yDirection">направление локальной оси Y</param>
            <param name="zDirection">направление локальной оси Z</param>
            <param name="offsetX">размер параллелепипеда вдоль локальной оси Z</param>
            <param name="offsetY">размер параллелепипеда вдоль локальной оси Z</param>
            <param name="offsetZ">размер параллелепипеда вдоль локальной оси Z</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Manipulators.BoxManipulatorBase">
            <summary>Манипулятор для настройки размеров параллелепипеда</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ParametricSweep.Parametric">
            <summary>Общие свойства параметрических объектов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ParametricSweep.ParamType">
            <summary>Cпособ задания параметризации</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ParametricSweep.ParametricType">
            <summary>Способ задания параметризации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ParametricSweep.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания параметрической операции</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ParametricSweep">
            <summary>Параметрическая операция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Manipulators.AngularSizeManipulator.ViewUnit">
            <summary>Единицы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Manipulators.AngularSizeManipulator.Radius">
            <summary>Радиус</summary>
        </member>
        <member name="T:CTFSimplifyOper.Version">
Версия пересчета
</member>
        <member name="F:OnlyEdges.result">
Грани могут быть не заданы
</member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.Run">
            <summary>Функция генерации сглаживания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetTolerance(System.Double)">
            <summary>Функция задаёт точность аппроксимации</summary>
            <param name="tolerance">Величина допуска в метрах (не меньше 1e-9)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetThicken(System.Double,System.Double)">
            <summary>Функция задаёт величины отступов для создания оболочечного тела</summary>
            <param name="FrontOffset">Величина фронтального отступа в метрах</param>
            <param name="BackOffset">Величина обратного отступа в метрах</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetType(TFlex.Model.Model3D.Geometry.LoftType)">
            <summary>Функция задаёт тип лофтинга (линейчатый или сплайновый)</summary>
            <param name="t">Требуемый тип лофтинга</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetSyncVertex(TFlex.Model.Model3D.Geometry.BaseTopol,System.Int32,System.Int32)">
            <summary>Функция устанавливает вершину соответствия между профилями</summary>
            <param name="vert">Существующая вершина</param>
            <param name="nSyncPoint">Порядковый номер</param>
            <param name="nProfile">порядковый номер профиля к которому отностится вершина</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetSmodul(System.Double)">
            <summary>Функция устанавливает модуль касательных в конце лофтинга</summary>
            <param name="m">Модуль касательных в конце лофтинга</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetFmodul(System.Double)">
            <summary>Функция устанавливает модуль касательных в начале лофтинга</summary>
            <param name="m">Модуль касательных в начале лофтинга</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetPath(TFlex.Model.Model3D.Geometry.BaseBody)">
            <summary>Функция устанавливает "осевой" путь для выполнения лофтинга с путём</summary>
            <param name="p">Путь, который используется для вычисления траекторий точек лофтинга</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetSApexDir(TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Функция устанавливает задающию нормаль к касательной плоскости вершинного лофтинга</summary>
            <param name="p">Точка в которую "смотрит" нормаль из конечной точки лофтинга</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetFApexDir(TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Функция устанавливает задающию нормаль к касательной плоскости вершинного лофтинга</summary>
            <param name="p">Точка в которую "смотрит" нормаль из начальной точки лофтинга</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetSApex(TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Функция устанавливает точку завершения лофтинга в качестве последнего профиля</summary>
            <param name="p">Точка которой заканчивается лофтинг</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetFApex(TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Функция устанавливает точку начала лофтинга в качестве первого профиля</summary>
            <param name="p">Точка в которой начинается лофтинг</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetSimpl(System.Boolean)">
            <summary>Функция задаёт режим упрощения результирующей геометрии</summary>
            <param name="toset">Параметр необходимости упрощения</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetCondType(TFlex.Model.Model3D.Geometry.TFBoundCondType,System.Boolean,TFlex.Model.Model3D.Geometry.BaseBody)">
            <summary>Функция задаёт граничное условие в начале-конце лофтинга</summary>
            <param name="t">Тип граничного условия</param>
            <param name="isFirst">Параметр отвечающий за то для какого профиля (первого или последнего) задано условие</param>
            <param name="sheet">Тело с которого берётся граничное условие</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetClose(System.Boolean)">
            <summary>Функция задаёт замкнутось лофтинга в направлении V</summary>
            <param name="cl">Параметр замкнутости</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetLastBody(TFlex.Model.Model3D.Geometry.BaseBody,System.Double)">
            <summary>Функция тело с которого берутся касательные для конечного профиля</summary>
            <param name="b">Твёрдое тело с которого берутся касательные</param>
            <param name="sc">Коэффициент масштабирования касательного вектора</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetFirstBody(TFlex.Model.Model3D.Geometry.BaseBody,System.Double)">
            <summary>Функция тело с которого берутся касательные для начального профиля</summary>
            <param name="b">Твёрдое тело с которого берутся касательные</param>
            <param name="sc">Коэффициент масштабирования касательного вектора</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetProfileV(TFlex.Model.Model3D.Geometry.BaseBody,System.Int32,System.Boolean)">
            <summary>Функция задаёт профиль в направлении V</summary>
            <param name="prf">Тело профиля (листовое тело или проволока)</param>
            <param name="num">Номер профиля в списке</param>
            <param name="orient">Ориентация с которой профиль входит в генератор</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.SetProfileU(TFlex.Model.Model3D.Geometry.BaseBody,System.Int32,System.Boolean)">
            <summary>Функция задаёт профиль в направлении U</summary>
            <param name="prf">Тело профиля (листовое тело или проволока)</param>
            <param name="num">Номер профиля в списке</param>
            <param name="orient">Ориентация с которой профиль входит в генератор</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LoftGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D)">
            <summary>Конструктор для задания базовых объектов</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <remarks>3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.LoftGenerator">
            <summary>Генератор лофтинга</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.LoftType">
            <summary>Тип генерируемой поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoftType.Splined">
            <summary>Splined - сплайновая поверхность</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoftType.Ruled">
            <summary>Ruled - линейчатая поверхность</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TFBoundCondType">
            <summary>Тип граничных условий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBoundCondType.ClampedCurvature">
            <summary>ClampedCurvature - непрерывность по кривизне</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBoundCondType.ZeroCurvature">
            <summary>ZeroCurvature - нулевая кривизна</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBoundCondType.TangentToFace">
            <summary>TangentToFace - касание к грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBoundCondType.Direction">
            <summary>Direction - условия заданные векторами</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.CoordSystemManipulator.GetCommitedOrigin">
Значения в метрах
Создаются новые объекты, необходимо не забывать вызывать Dispose()
</member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.CoordSystemManipulator.ResetCoordSystem(TFlex.Model.Model3D.Geometry.Point3D,TFlex.Model.Model3D.Geometry.Direction,TFlex.Model.Model3D.Geometry.Direction,TFlex.Model.Model3D.Geometry.Direction)">
            <summary>Устанавливает параметры настраиваемой системы координат</summary>
            <param name="origin">точка отсчёта системы координат</param>
            <param name="xDirection">направление оси X</param>
            <param name="yDirection">направление оси Y</param>
            <param name="zDirection">направление оси Z</param>
            <remarks>Значения в метрах</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Manipulators.CoordSystemManipulator">
            <summary>Манипулятор для настройки локальной прямоугольной системы координат</summary>
        </member>
        <member name="M:SheetFeature.GetFragmentPath(System.Boolean)">
получить путь к документу фрагмента
</member>
        <member name="F:CUnbendOper._res_body">
Тело получаемое в результате разгибки
</member>
        <member name="F:figure2D._breaks">
Координаты линии разрыва
</member>
        <member name="F:figure2D._key">
Информация для идентификации в новых проекциях
</member>
        <member name="M:figure2D.MergeConnectedSegments">
Склейка интервалов. Используется в режиме проецирования с выводом информациии о регионах для построения штриховок на разрезах и сечениях
</member>
        <member name="T:thread2D">
thread2D.hpp *
</member>
        <member name="M:edge2D.MergeConnectedSegments">
Склейка интервалов. Используется в режиме проецирования с выводом информациии о регионах для построения штриховок на разрезах и сечениях
</member>
        <member name="P:TFlex.VariablesControl3D.ControlBaseSize">
            <summary>Минимальный размер, который необходим контролу</summary>
        </member>
        <member name="P:TFlex.VariablesControl3D.ProductVersion">
            <summary>Версия визульного элемента управления</summary>
        </member>
        <member name="P:TFlex.VariablesControl3D.ProductName">
            <summary>Название визуального элемента управления</summary>
        </member>
        <member name="P:TFlex.VariablesControl3D.Fragment">
            <summary>Фрагмент, для которого выполняется редактирование внешних переменных</summary>
        </member>
        <member name="M:TFlex.VariablesControl3D.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.VariablesControl3D">
            <summary>Класс визуального элемента управления, позволяющего редактировать внешние переменные фрагмента в окне приложения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.RotationManipulator.GetPendingAngle">
            <summary>Получить динамическое значение угла в градусах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.RotationManipulator.GetCommitedAngle">
            <summary>Получить фиксированное значение угла в градусах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.RotationManipulator.ResetAngle(System.Double)">
            <summary>Перезадать значение угла в градусах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.RotationManipulator.SetAxis(TFlex.Model.Model3D.Geometry.Axis)">
            <summary>Задать ось</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Manipulators.PointOnPathManipulator.ModelSize">
            <summary>в модельных единицах (миллиметры, дюймы)</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.PointOnPathManipulator.GetCommitedOffset">
            <summary>Значения в пользовательских единицах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.PointOnPathManipulator.ResetOffset(System.Double,TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Установить смещение в пользовательских единицах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.PointOnPathManipulator.SetPath(TFlex.Model.Model3D.Geometry.Wire)">
            <summary>Установить путь</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TorqueForce.Torque">
            <summary>Крутящий момент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TorqueForce.Type">
            <summary>Тип нагрузки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TorqueForce">
            <summary>Биполярный силовой элемент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BipolarElement.Stretching">
            <summary>Ограничение силы на растяжение (если элемент работает в режиме привода)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BipolarElement.Compression">
            <summary>Ограничение силы на сжатие (если элемент работает в режиме привода)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BipolarElement.Control">
            <summary>Управляемое значение (если элемент работает в режиме привода)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BipolarElement.Force">
            <summary>Сила (если элемент работает в режиме пружины)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BipolarElement.Type">
            <summary>Тип нагрузки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BipolarElement">
            <summary>Биполярный силовой элемент</summary>
        </member>
        <member name="M:AddPictureToIScene(ImportPicture3D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFlex.Scene.ID,TFlex.Scene.IScene*,System.Boolean)">
Функция для прогрузки картинки в IScenу
</member>
        <member name="M:ImportPicture3D.Data.TransformTextureCoordinates">
Пересчитываем текстурные координаты с учетом трансформаций
</member>
        <member name="M:ImportPicture3D.Data.Init0">
Начальная инициализация, центрирование + масштаб
</member>
        <member name="M:ImportPicture3D.CopyDataFromOperation(TFlex.Scene.IOperation*)">
Копирование данных из операции в картинку
</member>
        <member name="M:ImportPicture3D.SetMaterial(System.Int32,TFlex.Scene.IMaterial*)">
Работа с материалами
</member>
        <member name="M:ImportPicture3DAnimator.NextFrame">
Переход по кадрам
</member>
        <member name="M:ImportPicture3DAnimator.BeginFrame">
Установка текущего кадра
</member>
        <member name="M:DRAW_SPLINE.PreprocessTangentsLegacy">
            <summary>  Метод для создания производных по узлам на краях, применяется при конверитации страх данных в новые </summary>
        </member>
        <member name="M:DRAW_SPLINE.PreprocessOldVersions">
            <summary>  Обработать старую версию сплайна </summary>
        </member>
        <member name="M:DRAW_SPLINE.GetData">
            <summary>  Получить указатель на данные для построения DRAW_SPLINE </summary>
        </member>
        <member name="T:Section.SectionSide">
Способ расчета положения проекции
</member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.LinearSizeManipulator.GetPendingLinearSize">
            <summary>Получить динамическое значение линейного размера в модельных единицах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.LinearSizeManipulator.GetCommitedLinearSize">
            <summary>Получить фиксированное значение линейного размера в модельных единицах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.LinearSizeManipulator.ResetLinearSize(System.Double)">
            <summary>Перезадать линейный размер в модельных единицах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.LinearSizeManipulator.SetAxis(TFlex.Model.Model3D.Geometry.Axis)">
            <summary>Задать ось</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointForce.Force">
            <summary>Сила</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointForce.Type">
            <summary>Тип нагрузки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.PointForce">
            <summary>Точечная сила</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectedAngularDimension.SetLeaderNote(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNode1">Первый узел привязки, задаёт положение размерной линии</param>
            <param name="offset1">Смещение размерной линии относительно начала первой выносной линии (используется, если fixNode1 не задан)</param>
            <param name="fixLeaderNode">Второй узел привязки, задаёт положение выносной полки</param>
            <param name="dX">Смещение по горизонтали конца выносной полки относительно середины размерной линии (используется, если fixLeaderNode не задан)</param>
            <param name="dY">Смещение по вертикали конца выносной полки относительно середины размерной линии (используется, если fixLeaderNode не задан)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectedAngularDimension.SetOffsets(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNode1">Первый узел привязки, задаёт положение размерной линии</param>
            <param name="offset1">Смещение размерной линии относительно начала первой выносной линии (используется, если fixNode1 не задан)</param>
            <param name="fixNode2">Второй узел привязки, задаёт положение размерного числа</param>
            <param name="offset2">Смещение размерного числа относительно середины размерной линии (используется, если fixNode2 не задан)</param>
            <param name="fixNode3">Третий узел привязки, задаёт положения конца полки размера</param>
            <param name="offset3">Смещение длины полки размера (используется, если fixNode3 не задан)</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectedAngularDimension.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectedAngularDimension">
            <summary>Спроецированный угловой размер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.AngularDimension3D.CreateProjected(TFlex.Model.Model3D.Projection)">
            <summary>Создание проекции размера</summary>
            <param name="projection">Проекция, на которую проецируется размер</param>
        </member>
        <member name="M:TFlex.Model.Model3D.AngularDimension3D.SetLeaderNote(System.Double,System.Double,System.Double)">
            <summary>Установка привязок размера по относительным смещениям</summary>
            <param name="Offset1">Смещение размерной линии относительно начала первой выносной линии</param>
            <param name="dX">Смещение по горизонтали конца выносной полки относительно середины размерной линии</param>
            <param name="dY">Смещение по вертикали конца выносной полки относительно середины размерной линии</param>
        </member>
        <member name="M:TFlex.Model.Model3D.AngularDimension3D.SetOffsets(System.Double,System.Double,System.Double)">
            <summary>Установка привязок размера по относительным смещениям</summary>
            <param name="Offset1">Смещение размерной линии относительно начала первой выносной линии</param>
            <param name="Offset2">Смещение размерного числа относительно середины размерной линии</param>
            <param name="Offset3">Смещение - длина полки размера</param>
        </member>
        <member name="M:TFlex.Model.Model3D.AngularDimension3D.SetElements(TFlex.Model.Model3D.Object3D,TFlex.Model.Model3D.Dimension3DElementType,TFlex.Model.Model3D.Object3D,TFlex.Model.Model3D.Dimension3DElementType,TFlex.Model.Model3D.DimensionUVCoords)">
            <summary>Установка привязок размера к 3D элементам</summary>
            <param name="Element1">1-й элемент размера (грань, ребро, узел)</param>
            <param name="Element1Type">Тип 1-го элемента размера</param>
            <param name="Element2">2-й элемент размера (грань, ребро, узел)</param>
            <param name="Element2Type">Тип 2-го элемента размера</param>
            <param name="Coords">Координаты для определения привязки размера</param>
        </member>
        <member name="P:TFlex.Model.Model3D.AngularDimension3D.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.AngularDimension3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ углового размера</param>
        </member>
        <member name="T:TFlex.Model.Model3D.AngularDimension3D">
            <summary>Угловой размер на 3D</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectedCircularDimension.SetDiametralDimensionType(TFlex.Model.Model2D.DiametralDimensionType)">
            <summary>Установка размера, как диаметрального</summary>
            <param name="type">Тип отрисовки диаметрального размера</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectedCircularDimension.SetRadialDimensionType(TFlex.Model.Model2D.RadialDimensionType)">
            <summary>Установка размера, как радиального</summary>
            <param name="type">Тип отрисовки радиального размера</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectedCircularDimension.SetOffsets(TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка положения размера на окружности</summary>
            <param name="fixNode">Узел привязки размерной стрелки</param>
            <param name="angle">Угол, на котором находится размерная стрелка (используется, если отсутствует fixNode)</param>
            <param name="offset">Расстояние от размерного числа до окружности (используется, если отсутствует fixNode)</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectedCircularDimension.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectedCircularDimension">
            <summary>Спроецированный размер на окружности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CircularDimension3D.CreateProjected(TFlex.Model.Model3D.Projection)">
            <summary>Создание проекции размера</summary>
            <param name="projection">Проекция, на которую проецируется размер</param>
        </member>
        <member name="M:TFlex.Model.Model3D.CircularDimension3D.SetDiametralDimensionType(TFlex.Model.Model2D.DiametralDimensionType)">
            <summary>Установка размера, как диаметрального</summary>
            <param name="type">Тип отрисовки диаметрального размера</param>
        </member>
        <member name="M:TFlex.Model.Model3D.CircularDimension3D.SetRadialDimensionType(TFlex.Model.Model2D.RadialDimensionType)">
            <summary>Установка размера, как радиального</summary>
            <param name="type">Тип отрисовки радиального размера</param>
        </member>
        <member name="M:TFlex.Model.Model3D.CircularDimension3D.SetOffsets(System.Double,System.Double)">
            <summary>Установка положения размера на окружности</summary>
            <param name="angle">Угол, на котором находится размерная стрелка (используется, если отсутствует fixNode)</param>
            <param name="offset">Расстояние от размерного числа до окружности (используется, если отсутствует fixNode)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.CircularDimension3D.SetElement(TFlex.Model.Model3D.Object3D,TFlex.Model.Model3D.DimensionUVCoords,System.Boolean,System.Double,System.Double)">
            <summary>Установка привязок размера к 3D элементам</summary>
            <param name="CircleElement">Элемент для привязки размера (грань, ребро)</param>
            <param name="Coords">Координаты для определения привязки размера</param>
            <param name="Diameter">Ставим диаметр, если true, иначе - радиус</param>
            <param name="Angle">Угол, на котором находится размерная стрелка</param>
            <param name="Offset">Расстояние от размерного числа до окружности</param>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularDimension3D.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CircularDimension3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ размера на окружности</param>
        </member>
        <member name="T:TFlex.Model.Model3D.CircularDimension3D">
            <summary>Размер на окружности на 3D</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectedLinearDimension.SetLeaderNote(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNode1">Первый узел привязки, задаёт положение размерной линии</param>
            <param name="offset1">Смещение размерной линии относительно начала первой выносной линии (используется, если fixNode1 не задан)</param>
            <param name="fixLeaderNode">Второй узел привязки, задаёт положение выносной полки</param>
            <param name="dX">Смещение по горизонтали конца выносной полки относительно середины размерной линии (используется, если fixLeaderNode не задан)</param>
            <param name="dY">Смещение по вертикали конца выносной полки относительно середины размерной линии (используется, если fixLeaderNode не задан)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectedLinearDimension.SetOffsets(TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double,TFlex.Model.Model2D.Node,System.Double)">
            <summary>Установка привязок размера к узлам, либо по относительным смещениям</summary>
            <param name="fixNode1">Первый узел привязки, задаёт положение размерной линии</param>
            <param name="offset1">Смещение размерной линии относительно начала первой выносной линии (используется, если fixNode1 не задан)</param>
            <param name="fixNode2">Второй узел привязки, задаёт положение размерного числа</param>
            <param name="offset2">Смещение размерного числа относительно середины размерной линии (используется, если fixNode2 не задан)</param>
            <param name="fixNode3">Третий узел привязки, задаёт положения конца полки размера</param>
            <param name="offset3">Смещение длины полки размера (используется, если fixNode3 не задан)</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectedLinearDimension.SubType">
            <summary>Подтип размера</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectedLinearDimension">
            <summary>Спроецированный линейный размер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearDimension3D.CreateProjected(TFlex.Model.Model3D.Projection)">
            <summary>Создание проекции размера</summary>
            <param name="projection">Проекция, на которую проецируется размер</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearDimension3D.SetLeaderNote(System.Double,System.Double,System.Double)">
            <summary>Установка привязок размера по относительным смещениям</summary>
            <param name="Offset1">Смещение размерной линии относительно начала первой выносной линии</param>
            <param name="dX">Смещение по горизонтали конца выносной полки относительно середины размерной линии</param>
            <param name="dY">Смещение по вертикали конца выносной полки относительно середины размерной линии</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearDimension3D.SetOffsets(System.Double,System.Double,System.Double)">
            <summary>Установка привязок размера по относительным смещениям</summary>
            <param name="Offset1">Смещение размерной линии относительно начала первой выносной линии</param>
            <param name="Offset2">Смещение размерного числа относительно середины размерной линии</param>
            <param name="Offset3">Смещение - длина полки размера</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearDimension3D.CreateBaseDimensions(TFlex.Model.Model3D.DimensionUVCoords,System.Collections.Generic.List`1{TFlex.Model.Model3D.DimensionsChainElement},TFlex.Model.Model3D.Object3D,System.Collections.Generic.List`1{TFlex.Model.Model3D.LinearDimension3D})">
            <summary>Создание цепочки размеров от базы</summary>
            <param name="Coords">Координаты для определения привязки размера</param>
            <param name="Elements">Элементы, на которых строятся размеры от базы. Первый элемент (база) не должен быть точкой</param>
            <param name="Plane">Плоская грань или рабочая плоскость для задания ориентации размеров</param>
            <param name="CreatedDimensions">Список созданных размеров</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearDimension3D.SetOrientationPlane(TFlex.Model.Model3D.Object3D)">
            <summary>Установка плоскости ориентации 3D размера</summary>
            <param name="Plane">Плоская грань или рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearDimension3D.SetElements(TFlex.Model.Model3D.Object3D,TFlex.Model.Model3D.Dimension3DElementType,TFlex.Model.Model3D.Object3D,TFlex.Model.Model3D.Dimension3DElementType,TFlex.Model.Model3D.DimensionUVCoords)">
            <summary>Установка привязок размера к 3D элементам</summary>
            <param name="Element1">1-й элемент размера (грань, ребро, узел)</param>
            <param name="Element1Type">Тип 1-го элемента размера</param>
            <param name="Element2">2-й элемент размера (грань, ребро, узел)</param>
            <param name="Element2Type">Тип 2-го элемента размера</param>
            <param name="Coords">Координаты для определения привязки размера</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearDimension3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор по умолчанию</summary>
            <param name="Doc">Документ, в котором создаётся размер</param>
        </member>
        <member name="T:TFlex.Model.Model3D.LinearDimension3D">
            <summary>Линейный размер на 3D</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionsChainElement.ElementType">
            <summary>Тип 3D объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionsChainElement.Element">
            <summary>3D объект</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.DimensionsChainElement.#ctor(TFlex.Model.Model3D.Object3D,TFlex.Model.Model3D.Dimension3DElementType)">
DimensionsChainElement();				
<summary>Конструктор</summary><param name="Element">3D объект</param><param name="ElementType">Тип 3D объекта</param></member>
        <member name="T:TFlex.Model.Model3D.DimensionsChainElement">
            <summary>Элемент размерной цепи</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionUVCoords.V_max">
            <summary>Максимальная граница UV области по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionUVCoords.V_min">
            <summary>Минимальная граница UV области по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionUVCoords.U_max">
            <summary>Максимальная граница UV области по U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionUVCoords.U_min">
            <summary>Минимальная граница UV области по U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionUVCoords.UV_2">
            <summary>Координата 2 на UV области</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionUVCoords.UV_1">
            <summary>Координата 1 на UV области</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DimensionUVCoords.UV_0">
            <summary>Координата 0 на UV области</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.DimensionUVCoords.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="UV_0">Координата 0 на UV области</param>
            <param name="UV_1">Координата 1 на UV области</param>
            <param name="UV_2">Координата 2 на UV области</param>
            <param name="U_min">Минимальная граница UV области по U</param>
            <param name="U_max">Максимальная граница UV области по U</param>
            <param name="V_min">Минимальная граница UV области по V</param>
            <param name="V_max">Максимальная граница UV области по V</param>
        </member>
        <member name="M:TFlex.Model.Model3D.DimensionUVCoords.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.DimensionUVCoords">
            <summary>Координаты на элементе для привязки размера</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Dimension3DElementType">
            <summary>Типы объектов для 3D размеров</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.AxisZ">
            <summary>Ось Z (для ЛСК)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.AxisY">
            <summary>Ось Y (для ЛСК)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.AxisX">
            <summary>Ось X (для ЛСК)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.Circle">
            <summary>Окружность (для циллиндрических, сферических и тороидальных граней, ребер-окружностей)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.Point">
            <summary>Точка (для узлов)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.Axis">
            <summary>Ось (для ребер, циллиндрических граней, ребер-окружностей)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.Plane">
            <summary>Плоскость (для плоских граней и плоских ребер)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.Wrong">
            <summary>Тип не совпадает с объектом</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Dimension3DElementType.Undefined">
            <summary>Не задан</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ScenarioTransformations.AddRotateTransf(TFlex.Model.Model3D.TransformationCoordinate,System.Double)">
            <summary>Добавить трансформацию "Вращение" к группе трансформаций</summary>
            <param name="axis">ось, вокруг которой производится вращение</param>
            <param name="angle">угол вращения</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ScenarioTransformations.AddMoveTransf(TFlex.Model.Model3D.TransformationCoordinate,System.Double)">
            <summary>Добавить трансформацию "Перемещение" к группе трансформаций</summary>
            <param name="direction">Ось, по которой производится перемещение</param>
            <param name="offset">отступ перемещения</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.ObjectRepresentation">
Класс дает доступ к изображению модельного объекта в сцене.
Также класс служит для управления декорациями и манипуляторами, связанными с объектом.
</member>
        <member name="T:TFUnitsS">
            <summary>Structured Units</summary>
        </member>
        <member name="T:TFUnits">
            <summary>Units</summary>
        </member>
        <member name="T:TFUnitTypes">
            <summary>Unit Types</summary>
        </member>
        <member name="T:TFUnitsEnumS">
            <summary>Structured Units Enum</summary>
        </member>
        <member name="T:TFUnitsEnum">
            <summary>Units Enum</summary>
        </member>
        <member name="T:TFUnitTypesEnum">
            <summary>Unit Types Enum</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.PointRotationManipulator.GetPendingAngle">
            <summary>Получить динамическое значение угла в градусах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.PointRotationManipulator.GetCommitedAngle">
            <summary>Получить фиксированное значение угла в градусах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.PointRotationManipulator.ResetAngle(System.Double)">
            <summary>Перезадать значение угла в градусах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.PointRotationManipulator.SetAxis(TFlex.Model.Model3D.Geometry.Axis,TFlex.Model.Model3D.Geometry.Axis,TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Задать ось</summary>
        </member>
        <member name="T:vertex2D">
vertex2D.hpp *
</member>
        <member name="T:TPoint">
TPoint.hpp *
</member>
        <member name="T:IKSharedObject">
ik_shar.hpp *
</member>
        <member name="T:point2D">
point2D.hpp *
</member>
        <member name="T:vector2D">
geomdefs.hpp *

vector2D.hpp *
</member>
        <member name="D:Real">
ik_defs.hpp *
</member>
        <member name="T:DIMENSION.DistanceChirality">
Полупространство
</member>
        <member name="M:DIMENSION.GetStatusCode">
Данные для решателя ограничений
</member>
        <member name="M:DIMENSION.ReplaceCharacteristicDataReferences(CharacteristicDataToReplace!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Заменить ссылки на характерные данные других объектов </summary>
            <remarks> Если входящие данные не находят соответствия как-либо ссылке, то она просто пропускается. </remarks>
            <param name="iData"> Входящие данные для замены ссылок </param>
            <returns> false, если хотя бы одна ссылка была удалена, true - иначе </returns>
        </member>
        <member name="T:Constraints2D.GeometryCode.Codes">
Коды результатов поиска решений на ограничениях
</member>
        <member name="T:Constraints2D.GeometryCode">
Диагностика результатов поиска решения на геометрии
</member>
        <member name="T:Constraints2D.ConstraintCode.Codes">
Коды результатов поиска решений на ограничениях
</member>
        <member name="T:Constraints2D.ConstraintCode">
Диагностика результатов поиска решения ограничений
</member>
        <member name="T:Constraints2D.SystemCode.Codes">
Общие коды результатов
</member>
        <member name="T:Constraints2D.SystemCode">
Общий код результата
</member>
        <member name="M:LinearBy3PointsDIMENSIONConstraints2D.GetCoincident2">
Совпадение второй точки с прямой
</member>
        <member name="M:LinearBy3PointsDIMENSIONConstraints2D.GetCoincident1">
Совпадение первой точки с прямой
</member>
        <member name="M:LinearBy3PointsDIMENSIONConstraints2D.GetLine">
Линия, на которой лежат две точки. Размер строится между этой линией и третьей точкой
</member>
        <member name="T:LinearBy3PointsDIMENSIONConstraints2D">
Данные для решателя ограничений. Размер по трём точкам
</member>
        <member name="M:CurveLengthDIMENSIONConstraints2D.GetEquation">
Линейное уравнение, связывающее значение суммарной длины составной кривой и сумму переменных, задающих длины отдельных кривых
</member>
        <member name="M:CurveLengthDIMENSIONConstraints2D.GetID2Length">
Массив ограничений на длину каждой кривой
</member>
        <member name="T:CurveLengthDIMENSIONConstraints2D">
Данные для решателя ограничений
</member>
        <member name="T:SplineDistanceDIMENSIONConstraints2D">
Данные для решателя ограничений
</member>
        <member name="T:DIMENSIONConstraints2D">
Данные для решателя ограничений
</member>
        <member name="T:DIMENSIONConstraints2DBase">
Данные для решателя ограничений
</member>
        <member name="M:CUndoRedoNamedReference.#ctor(CTfw32Doc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,IdentifyElem*,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Переименование элемента
</member>
        <member name="M:CUndoRedoNamedReference.#ctor(CTfw32Doc!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,IdentifyElem*,System.Boolean)">
Добавление/удаление именованной ссылки на геометрический элемент
</member>
        <member name="T:CUndoRedoEnrichment">
Действие по изменению обогащения
</member>
        <member name="M:image2D.GetOwner">
Метод возвращает проекцию или 2D фрагмент в качестве владельца
</member>
        <member name="T:IKObject">
ik_obj.hpp *
</member>
        <member name="M:image3D.GetOwner">
Метод возвращает проекцию или 2D фрагмент в качестве владельца
</member>
        <member name="M:IMAGE.SetConstraintPoint(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Редактирование кривой перемещением точки, лежащей на кривой
</member>
        <member name="M:IMAGE.IsFixedForConstraint">
Линия фиксирована в решателе ограничений
</member>
        <member name="M:IMAGE.GetDistance(RGPlatform.Geometry.Context*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить расстояние от точки до кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPointInPageCs"> Точка с учётом масштаба страницы, от которой ищется расстояние </param>
            <param name="oDistance"> Найденное расстояние </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:IMAGE.FindNearestPoint(RGPlatform.Geometry.Context*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Получить параметр точки на кривой, ближайшей к передаваемой точке </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPointInPageCs"> Точка с учётом масштаба страницы, для которой ищется ближайшая точка на кривой </param>
            <param name="oParameter"> Найденный параметр ближайшей точки на кривой </param>
            <param name="iTolerance"> Точность, с которой ищется ближайшая точка </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:IMAGE.EvaluatePoint(RGPlatform.Geometry.Context*,System.Double,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить значение кривой по параметру </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iParameter"> Параметр на кривой, в котором вычисляется значение </param>
            <param name="oPointInPageCs"> Вычисленное значение с учётом масштаба страницы </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:IMAGE.Parameterise(RGPlatform.Geometry.Context*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double,System.Boolean)">
            <summary> Определить параметр точки, лежащей на кривой </summary>
            <param name="iContext"> Контекст геометрии </param>
            <param name="iPointInPageCs"> Точка на кривой с учётом масштаба страницы </param>
            <param name="ioParameter"> Найденный параметр на кривой (на входе может содержать начальное приближение) </param>
            <param name="iUseGuess"> Использовать ли начальное приближение </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:SplineIMAGEConstraints2D.GetStartTangentLine">
Данные для решателя ограничений
Касательные условия на концах
</member>
        <member name="T:SplineIMAGEConstraints2D">
Данные для решателя ограничений
</member>
        <member name="D:IMAGEConstraints2D.CharacteristicPoints">
Фиксированные характерные точки линии изображения. Например, центр эллипса или окружности, построенной по линии построения или на проекции
</member>
        <member name="M:IMAGEConstraints2D.ResetConstraintPoint">
Редактирование кривой перемещением точки, лежащей на кривой
</member>
        <member name="M:IMAGEConstraints2D.GetConstraintGeometry">
Данные для решателя ограничений
</member>
        <member name="T:IMAGEConstraints2D">
Данные для решателя ограничений
</member>
        <member name="P:TFlex.Model.Model3D.Harness3D.ItemCount">
            <summary>Количество элементов в жгуте</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Harness3D.GetItem(System.UInt32)">
            <summary>Получить элемент из жгута</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Harness3D.RemoveItem(System.UInt32)">
            <summary>Удаляет элемент из жгута</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Harness3D.AddItem(TFlex.Model.Model3D.Construction3D)">
            <summary>Добавляет элемент в жгут</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Harness3D.ExistsItem(TFlex.Model.Model3D.Construction3D,System.Boolean)">
            <summary>Проверяет наличие элемента в жгуте</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Harness3D.CanAddItem(TFlex.Model.Model3D.Construction3D)">
            <summary>Проверяет возможность вставить элемент в жгут, критерий: нет входит в текущий жгут и поджгуты, не принадлежит другим жгутам</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Harness3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового жгута</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Harness3D">
            <summary>Класс 3D жгутов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceConductorSet.Owner">
Владелец ссылочного объекта
</member>
        <member name="T:TFlex.Model.Model3D.ReferenceConductorSet">
            <summary>Класс внешнего кабельного изделия</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ConductorSet">
            <summary>Класс кабельного изделия</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ConductorSetBase">
            <summary>Базовый класс кабельного изделия</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BaseHarness3D">
            <summary>Базовый класс для 3D жгутов и кабельных изделий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PerspectiveCamera.HeightAngle">
            <summary>Высотный угол камеры</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PerspectiveCamera.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для перспективной камеры</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.PerspectiveCamera">
            <summary>Класс перспективной камеры</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OrthographicCamera.Height">
            <summary>Высота камеры</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.OrthographicCamera.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для ортографической камеры</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.OrthographicCamera">
            <summary>Класс ортографической камеры</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.RotateOrder">
            <summary>Порядок применения поворотов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.RotateZ">
            <summary>Поворот вокруг оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.RotateY">
            <summary>Поворот вокруг оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.RotateX">
            <summary>Поворот вокруг оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.OffsetZ">
            <summary>Смещение по оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.OffsetY">
            <summary>Смещение по оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.OffsetX">
            <summary>Смещение по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.Active">
            <summary>Активна ли камера</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.NearDistance">
            <summary>Растояние до ближней плоскости отсечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.AutoClip">
            <summary>Включен или нет режим автоматической обрезки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.Walk">
            <summary>Находится ли камера в режиме прогулки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Camera.OriginLCS">
            <summary>Система координат камеры</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Camera">
            <summary>Базовый класс камеры</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.AttachFlag">
            <summary>Объединять с существующим телом</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операции "Заполнение области"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.ContourArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.ContourArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.ContourArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.ContourArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.ContourArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.ContourArray.Clear">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.ContourArray.RemoveAt(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.ContourArray.Add">
            <summary>Добавить элемент в конец списка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.ContourArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FillHole.ContourArray">
            <summary>Массив контуров заполняемых отверстий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.Contour.FillTopology">
            <summary>Минимизация топологии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.Contour.FillPreferenceMode">
            <summary>Форма поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.Contour.FillMethod">
            <summary>Способ заполнения области</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.Contour.Edges">
            <summary>Рёбра, задающие контур области</summary>
            <remarks>Контур образуемый рёбрами должен быть замкнутым</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.FillHole.Contour">
            <summary>Контур заполняемого отверстия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.EdgesArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.EdgesArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.EdgesArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.EdgesArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.EdgesArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.EdgesArray.Clear">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.EdgesArray.RemoveAt(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.FillHole.EdgesArray.Add(TFlex.Model.Model3D.Geometry.ModelEdge)">
            <summary>Добавить элемент в конец списка</summary>
            <param name="item">Добавляемый элемент</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FillHole.EdgesArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FillHole.EdgesArray">
            <summary>Массив рёбер заполнения отверстий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FillHole.FillTopologyType.Minimal">
            <summary>Минимизировать топологию</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FillHole.FillTopologyType.Multiple">
            <summary>Множественная топология</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FillHole.FillTopologyType">
            <summary>Минимизация топологии</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FillHole.FillPreferenceModeType.PlaneOnly">
            <summary>Обязательно плоскость</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FillHole.FillPreferenceModeType.PreferPlane">
            <summary>Предпочтительно плоскость</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FillHole.FillPreferenceModeType.Smooth">
            <summary>Непрерывная</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FillHole.FillPreferenceModeType">
            <summary>Форма</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FillHole.FillMethodType.CreatePatch">
            <summary>Создать заплатку</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FillHole.FillMethodType.TrimToSheet">
            <summary>Обрезать по поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FillHole.FillMethodType.TrimToHole">
            <summary>Обрезать по области</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FillHole.FillMethodType">
            <summary>Способ заполнения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FillHole">
            <summary>Заполнение области</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TorusWorkSurface.MinorRadius">
            <summary>Второй радиус тора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TorusWorkSurface.MajorRadius">
            <summary>Первый радиус тора</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TorusWorkSurface.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания сферической поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся параметрическая область тороидальной поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TorusWorkSurface.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания тороидальной поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Параметрическая область тороидальной поверхности создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.TorusWorkSurface">
            <summary>Тороидальная рабочая поверхность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CylinderWorkSurface.Param">
            <summary>Тип параметризации по U</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CylinderWorkSurface.ParamType.Angular">
            <summary>Угловые единицы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CylinderWorkSurface.ParamType.Linear">
            <summary>Линейные единицы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.CylinderWorkSurface.ParamType">
            <summary>Тип параметризации по U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CylinderWorkSurface.Radius">
            <summary>Радиус цилиндра</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CylinderWorkSurface.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания цилиндрической поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся параметрическая область цилиндрической поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.CylinderWorkSurface.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания цилиндрической поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Параметрическая область цилиндрической поверхности создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.CylinderWorkSurface">
            <summary>Цилиндрическая рабочая поверхность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SphereWorkSurface.Radius">
            <summary>Радиус сферы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SphereWorkSurface.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания сферической поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся параметрическая область сферической поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.SphereWorkSurface.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сферической поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Параметрическая область сферической поверхности создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.SphereWorkSurface">
            <summary>Сферическая рабочая поверхность</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SpatialWorkSurface.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания нового пути</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся параметрическая область рабочей поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.SpatialWorkSurface.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового пути</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Параметрическая область рабочей поверхности создаётся на активной странице</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.BoundQuadrant">
            <summary>Квадрант границы рабочей поверхности, если границы задаются одним узлом и границами листа</summary>
            <remarks>Квадранты нумеруются от 1 до 4.
По умолчанию первый угол задаётся точкой привязки</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.SecondBoundCorner">
            <summary>Второй угол границы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.FirstBoundCorner">
            <summary>Первый угол границы</summary>
            <remarks>По умолчанию первый угол задаётся точкой привязки</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.LCS">
            <summary>Локальная система координат, в которой задаётся рабочая поверхость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.Orientation">
            <summary>Соответствие координатных осей и параметров</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.SpatialWorkSurface.OrientationType">
            <summary>Cоответствие координатных осей и параметров</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.SecondUVBoxCorner">
            <summary>Вторая граница области</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.FirstUVBoxCorner">
            <summary>Начало координат параметрической области</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.Geometry">
            <summary>Получить геометрические данные специальных координатных поверхностей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.GeometryData.Surface">
            <summary>Получить поверхность</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::ModelSurface, хранящий поверхность и ссылку на эти геометрические данные рабочей поверхности</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.GeometryData.Sheet">
            <summary>Для сферической и тороидальной поверхностей можно получить листовое тело</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::Sheet, хранящий листовое тело и ссылку на эти геометрические данные рабочей поверхности</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.GeometryData.Point">
            <summary>Для сферической и тороидальной поверхностей можно получить точку симметрии</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::Point, хранящий координаты точки и ссылку на эти геометрические данные рабочей поверхности</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.GeometryData.Plane">
            <summary>Для тороидальной поверхности можно получить плоскость симметрии</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::ModelPlane, хранящий координаты плоскости и ссылку на эти геометрические данные рабочей поверхности</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.GeometryData.Axis">
            <summary>Для цилиндрической и тороидальной поверхностей можно получить ось симметрии</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::ModelAxis, хранящий координаты оси и ссылку на эти геометрические данные рабочей поверхности</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.SpatialWorkSurface.GeometryData.Direction">
            <summary>Для цилиндрической и тороидальной поверхностей можно получить ось симметрии</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::ModelDirection, хранящий координаты вектора и ссылку на эти геометрические данные рабочей поверхности</returns>
        </member>
        <member name="T:TFlex.Model.Model3D.SpatialWorkSurface.GeometryData">
            <summary>Множество геометрических данных специальных координатных поверхностей</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.SpatialWorkSurface">
            <summary>Базовый класс для всех типов специальных координатных поверхностей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Simplification.Check">
            <summary>Проверка корректности модели и частичная корректировка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Simplification.EvTopolArrayAfterDeleteAll">
            <summary>Обработчики событий при измененении </summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Simplification.Local">
            <summary>Упрощять геометрию отдельно для каждого элемента</summary>
            <remarks>Имеет смысл, если список упрощаемых граней пустой, то есть упрощение геометрии выполняется на всех гранях.
Имеет смысл, если включен режим упрощения геометрии.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Simplification.SimplifyGeometry">
            <summary>Упрощять геометрию</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Simplification.DeleteRedundant">
            <summary>Удалять лишние геометрические элементы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Simplification.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Simplification.Topols">
            <summary>Множество геометрических элементов для удаления</summary>
            <remarks>Если множество геометрических элементов пусто, то удаление выполняется на всех элементах.
Все элементы должны относится к одной операции, которая возвращается в свойстве Operation</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Simplification.Faces">
            <summary>Множество граней, для которых выполняется упрощение геометрии</summary>
            <remarks>Если множество граней пусто, то упрощение геометрии выполняется на всех гранях.
Все грани должны относится к одной операции, которая возвращается в свойстве Operation</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Simplification.Operation">
            <summary>Операция, для которой выполняется упрощение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Simplification.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операции удаления лишних геометрических элементов упрощения геометрии</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Simplification">
            <summary>Операция удаления лишних геометрических элементов упрощения геометрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceChange.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceChange.RelativeParameter">
            <summary>Флаг относительного изменения размеров</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceChange.CommonParameter2">
            <summary>Второй общий параметр (используется для граней с установленным флагом commonParameter)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceChange.CommonParameter1">
            <summary>Первый общий параметр (используется для граней с установленным флагом commonParameter)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceChange.FaceCount">
            <summary>Получить число граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceChange.RemoveAllFaces">
            <summary>Удалить все грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceChange.GetFace(System.Int32,TFlex.Model.Model3D.Geometry.ModelFace@,TFlex.Model.Parameter@,TFlex.Model.Parameter@,System.Boolean@)">
            <summary>Получить грань и параметры</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceChange.AddFace(TFlex.Model.Model3D.Geometry.ModelFace,TFlex.Model.Parameter,TFlex.Model.Parameter,System.Boolean)">
            <summary>Задать грань и параметры</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceChange.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операция "Изменение граней"</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceChange">
            <summary>Операция изменения граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.FacesTransformation">
            <summary>Трансформация</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.Transformation">
            <summary>Трансформация</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.Faces">
            <summary>Перемещаемые грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операция "Разбиение граней"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.RemoveAllTransf">
            <summary>Удалить все преобразования</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.AddRotateTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Parameter)">
            <summary>Добавить трансформацию "Вращение"</summary>
            <param name="direction">ось, вокруг которой производится вращение</param>
            <param name="angle">arc of rotation</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.AddMoveTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Parameter)">
            <summary>Добавить трансформацию "Перемещение"</summary>
            <param name="direction">ось, по которой производится перемещение</param>
            <param name="offset">отступ перемещения</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.CoordinatSystem">
            <summary>Система координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.Type">
            <summary>Тип исходной системы координат преобразования</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.CoordinatSystemType.OnLCS">
            <summary>Задаваямая система координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.CoordinatSystemType.OnFaces">
            <summary>Система координат грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.CoordinatSystemType.OnBody">
            <summary>Система координат тела</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer.CoordinatSystemType">
            <summary>Тип исходной системы координат трансформаций</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceTransform.FacesTransformationsContainer">
            <summary>Контейнер хранения преобразований для граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.Clear">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.RemoveAt(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.Add(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить элемент в конец списка</summary>
            <param name="item">Добавляемый элемент</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceTransform.TransformFacesArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceTransform.TransformFacesArray">
            <summary>Массив удаляемых граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceTransform">
            <summary>Операция перемещения граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceReplace.Sheet">
            <summary>Заменяющее листовое тело. Заданные грани заменяются гранями листового тела.</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceReplace.FaceCount">
            <summary>Число пар "заменяемая грань-заменяющая поверхность"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceReplace.RemoveAllFaces">
            <summary>Удалить все пары "заменяемая грань-заменяющая поверхность"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceReplace.GetFace(System.Int32,TFlex.Model.Model3D.Geometry.ModelFace@,TFlex.Model.Model3D.Geometry.ModelSurface@,System.Boolean@)">
            <summary>Получить пару "заменяемая грань-заменяющая поверхность"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceReplace.AddFace(TFlex.Model.Model3D.Geometry.ModelFace,TFlex.Model.Model3D.Geometry.ModelSurface,System.Boolean)">
            <summary>Задать пару "заменяемая грань-заменяющая поверхность"</summary>
            <remarks>surface должно быть равно 0 если задано листовое тело</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceReplace.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceReplace.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операция "Трансформация граней"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceReplace">
            <summary>Операция замены граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.BottomFaceCount">
            <summary>Получить число нижних граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.RemoveAllBottomFaces">
            <summary>Удалить все нижние грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.GetBottomFace(System.Int32,TFlex.Model.Model3D.Geometry.ModelFace@)">
            <summary>Получить нижнюю грань</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.AddBottomFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить нижнюю грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.TopFaceCount">
            <summary>Получить число верхних граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.RemoveAllTopFaces">
            <summary>Удалить все верхние грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.GetTopFace(System.Int32,TFlex.Model.Model3D.Geometry.ModelFace@)">
            <summary>Получить верхнюю грань</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.AddTopFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить верхнюю грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.KeepSourceBody">
            <summary>Оставлять исходное тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.ConcaveRadius">
            <summary>Радиус исправления внутренних углов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.Concave">
            <summary>Исправление внутренних углов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.Corner">
            <summary>Обработка стыкующихся углов уклоняемых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.Miter">
            <summary>Двухстороннее соединение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.Method">
            <summary>Метод</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.BottomEdgeCount">
            <summary>Получить число нижних рёбер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.RemoveAllBottomEdges">
            <summary>Удалить все нижние рёбра</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.GetBottomEdge(System.Int32,TFlex.Model.Model3D.Geometry.ModelEdge@,System.Boolean@,System.Boolean@,TFlex.Model.Model3D.BodyTaper.MethodType@)">
            <summary>Получить нижнее ребро</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.AddBottomEdge(TFlex.Model.Model3D.Geometry.ModelEdge,System.Boolean,System.Boolean,TFlex.Model.Model3D.BodyTaper.MethodType)">
            <summary>Добавить нижнее ребро</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.TopEdgeCount">
            <summary>Получить число верхних рёбер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.RemoveAllTopEdges">
            <summary>Удалить все верхние рёбра</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.GetTopEdge(System.Int32,TFlex.Model.Model3D.Geometry.ModelEdge@,System.Boolean@,System.Boolean@,TFlex.Model.Model3D.BodyTaper.MethodType@)">
            <summary>Получить верхнее ребро</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.AddTopEdge(TFlex.Model.Model3D.Geometry.ModelEdge,System.Boolean,System.Boolean,TFlex.Model.Model3D.BodyTaper.MethodType)">
            <summary>Добавить верхнее ребро</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.BottomAngle">
            <summary>Нижний угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.TopAngle">
            <summary>Верхний угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.DirectionReverse">
            <summary>Реверс направления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.Point2">
            <summary>Вторая точка задающая направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.Point1">
            <summary>Первая точка задающая направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.Direction">
            <summary>Направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.PartingSheet">
            <summary>Разделящее листовое тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.PartingBody">
            <summary>Разделящее тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.SourceBody">
            <summary>Исходное тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyTaper.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyTaper.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операция "Изменение граней"</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.ConcaveType.Mix">
            <summary>Смешанный</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.ConcaveType.Plane">
            <summary>Создавать плоские соединения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.ConcaveType.Radius">
            <summary>Создавать цилиндрические скругления</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.ConcaveType.None">
            <summary>Нет</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.CornerType.Plane">
            <summary>Создавать плоскость</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.CornerType.Extend">
            <summary>Расширять поверхность</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BodyTaper.CornerType">
            <summary>Тип соединения уклоняемых граней</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.MiterType.AtOpen">
            <summary>Оба</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.MiterType.ToFace">
            <summary>От грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.MiterType.OnRef">
            <summary>От ребра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.MiterType.No">
            <summary>Только удалить (без обработки)</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BodyTaper.MiterType">
            <summary>Тип соединения в угол</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.MethodType.Default">
            <summary>Только для рёбер. Используется метод операции</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.MethodType.Surface">
            <summary>По поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.MethodType.Curve">
            <summary>По кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyTaper.MethodType.Isocline">
            <summary>Стандартный</summary>
            <remarks>Produces ruled isocline surfaces satisfying the
taper condition. If the angle between the taper
direction and the curve tangent happens to be
smaller than the taper angle anywhere along the
curve, this method will fail to construct the
taper surface.
This method produces taper surfaces for mould
design</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.BodyTaper.MethodType">
            <summary>Метод построения уклона</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BodyTaper">
            <summary>Операция уклона тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.EndLimitValue">
            <summary>Значение задающее ограничение конца резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.StartLimitValue">
            <summary>Значение задающее ограничение начала резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.EndLimitMeasure">
            <summary>Единицы измерения ограничения конца резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.StartLimitMeasure">
            <summary>Единицы измерения ограничения начала резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.EndLimitPlane">
            <summary>Плоскость задающая ограничение конца резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.EndLimitDirection">
            <summary>Геометрическое направление задающее ограничение конца резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.EndLimitPoint">
            <summary>Точка задающая ограничение конца резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.StartLimitPlane">
            <summary>Плоскость задающая ограничение начала резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.StartLimitDirection">
            <summary>Геометрическое направление задающее ограничение начала резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.StartLimitPoint">
            <summary>Точка задающая ограничение начала резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.EndLimitType">
            <summary>Ограничение конца резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.StartLimitType">
            <summary>Ограничение начала резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.Step">
            <summary>Шаг резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.Diameter">
            <summary>Диаметер резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.Standard">
            <summary>Стандарт резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.Standards">
            <summary>Коллекция стандартов резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.Spec">
            <summary>Спецификация резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Thread.Faces">
            <summary>Массив граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Thread.#ctor(TFlex.Model.Document)">
            <summary>Конструктор резьбы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Thread">
            <summary>Резьба</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadFacesArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadFacesArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadFacesArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadFacesArray.Current">
            <summary>Вернуть текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadFacesArray.GetEnumerator">
            <summary>Вернуть перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadFacesArray.Clear">
            <summary>Удалить все операнды</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadFacesArray.RemoveAt(System.Int32)">
            <summary>Удалить операнд по номеру</summary>
            <param name="index">Номер операции</param>
            <remarks>Операнды нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadFacesArray.Add(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить операнд в конец списка</summary>
            <param name="item">Добавляемый операнд</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadFacesArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadFacesArray">
            <summary>Коллекция граней на которые накладывается резьба</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadLimitsMeasure">
            <summary>Единицы измерения пределов резьбы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadLimitsMeasure.Percents">
            <summary>В процентах</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadLimitsMeasure.Units">
            <summary>Основные единицы измерения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadEndLimit">
            <summary>Тип конца резьбы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadEndLimit.FromObject">
            <summary>От объекта</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadEndLimit.FromStart">
            <summary>От начала</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadEndLimit.FromThread">
            <summary>От резьбы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadEndLimit.FromEnd">
            <summary>От конца</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadStartLimit">
            <summary>Тип начала резьбы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadStartLimit.FromObject">
            <summary>От объекта</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadStartLimit.FromStart">
            <summary>От начала</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadSpecification.Notation">
            <summary>Обозначение резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadSpecification.Side">
            <summary>Сторона</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadSpecification.Direction">
            <summary>Направление резьбы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadSpecification">
            <summary>Спецификация резьбы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadDirection">
            <summary>Направление резьбы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadDirection.LeftHand">
            <summary>Левосторонняя</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadDirection.RightHand">
            <summary>Правосторонняя</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandardCollection.OperationGet">
            <summary>Установить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <param name="item">Добавляемый элемент</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandardCollection.default(System.Int32)">
            <summary>Получить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadStandardCollection.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadStandardCollection.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandardCollection.Current">
            <summary>Вернуть текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadStandardCollection.GetEnumerator">
            <summary>Вернуть перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandardCollection.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadStandardCollection">
            <summary>Коллекция стандартов резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandard.Class(TFlex.Model.Model3D.ThreadSide,System.Int32)">
            <summary>Получить класс точности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandard.NumClasses(TFlex.Model.Model3D.ThreadSide)">
            <summary>Число классов точности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandard.Diameters">
            <summary>Коллекция диаметров</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandard.Name">
            <summary>Получить обозначение стандарта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStandard.Id">
            <summary>Идентификатор стандарта в базе данных</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadStandard">
            <summary>Стандарт резьбы</summary>
            <remarks>Данные предоставляемые классом берутся из базы данных</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameterCollection.default(System.Int32)">
            <summary>Получить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadDiameterCollection.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadDiameterCollection.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameterCollection.Current">
            <summary>Вернуть текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadDiameterCollection.GetEnumerator">
            <summary>Вернуть перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameterCollection.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadDiameterCollection">
            <summary>Коллекция диаметров резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameter.Steps">
            <summary>Коллекция шагов резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameter.Nominal">
            <summary>Обозначение диаметра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameter.Unrecommended">
            <summary>Нерекомендуемый диаметер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameter.Row">
            <summary>Ряд</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameter.Value">
            <summary>Диаметр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadDiameter.Id">
            <summary>Идентификатор диаметра в базе данных</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadDiameter">
            <summary>Параметры диаметра резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStepCollection.default(System.Int32)">
            <summary>Получить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadStepCollection.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadStepCollection.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStepCollection.Current">
            <summary>Вернуть текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreadStepCollection.GetEnumerator">
            <summary>Вернуть перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStepCollection.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadStepCollection">
            <summary>Коллекция значений шага резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.WorkLength">
            <summary>Рабочая длина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.MainPlaneExternal">
            <summary />
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.MainPlaneInternal">
            <summary />
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.CustomNotation">
            <summary>Обозначение резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.Unrecommended">
            <summary>Нерекомендуемый шаг резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.Step">
            <summary>Шаг резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.Main">
            <summary>Главный ли шаг резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.Depth">
            <summary>Глубина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadStep.Value">
            <summary>Шаг резьбы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadStep">
            <summary>Параметры шага резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadClass.Id">
            <summary>Идентификатор</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadClass.Name">
            <summary>Имя</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreadClass.Side">
            <summary>Сторона резьбы (наружная/внутренняя)</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadClass">
            <summary>Класс точности резьбы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreadSide">
            <summary>Сторона резьбы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadSide.Inner">
            <summary>Внутренняя</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadSide.Outer">
            <summary>Внешняя</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreadSide.Auto">
            <summary>Автоопределение при создании</summary>
        </member>
        <member name="M:Thread3D.CorrectThreadToAttribs(System.Int32)">
Коррекция данных о резьбе на гранях тела в случае локальной модификации типа склейка или упрощение
</member>
        <member name="M:Thread3D.CorrectThreadToAttribs(TFlex.Thread.Specifications.ThreadInfoEx*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Коррекция данных о резьбе на грани в случае локальной модификации типа склейка или упрощение
</member>
        <member name="M:TFlex.Model.Model3D.ProjectionOutline.GetBodyObjectID">
            <summary>Идентификатор операции, в которой создан элемент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionOutline.ParentObject3D">
            <summary>Получение родительского объекта, от которого построена линия</summary>
            <returns>Родительский объект 3D</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionOutline.Projection">
            <summary>Получение родительского объекта проекции</summary>
            <returns>Родительский объект (2D проекция)</returns>
            <remarks>В 2D версии системы данный метод возвращает 0</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionOutline.SubType">
            <summary>Подтип линии изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionOutline">
            <summary>Класс линии изображения, принадлежащей 2D проекции</summary>
            <remarks>Линия изображения данного класса может быть создана только при проецировании
трёхмерных элементов и не может быть создана приложением</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionAreaArray.Reset">
            <summary>Переинициализация итератора - переход на начало массива</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionAreaArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
            <returns>Возвращает false если массив исчерпан, true - в противном случае</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionAreaArray.Current">
            <summary>Текущий элемент массива</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionAreaArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionAreaArray.#ctor(TFlex.Model.Model3D.Projection)">
            <summary>Конструктор итератора по массиву штриховок проекции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionAreaArray.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionAreaArray">
            <summary>Множество линий изображения проекции. Возможно перечисление линий с использованием конструкции foreach</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionOutlineArray.Item(System.Int32)">
            <summary>Получить элемент по номеру</summary>
            <param name="Index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionOutlineArray.Reset">
            <summary>Переинициализация итератора - переход на начало массива</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionOutlineArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
            <returns>Возвращает false если массив исчерпан, true - в противном случае</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionOutlineArray.Current">
            <summary>Текущий элемент массива</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionOutlineArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionOutlineArray.#ctor(TFlex.Model.Model3D.Projection)">
            <summary>Конструктор итератора по массиву линий проекции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionOutlineArray.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionOutlineArray">
            <summary>Множество линий изображения проекции. Возможно перечисление линий с использованием конструкции foreach </summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionLineType">
            <summary>Типы линий проекций</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionLineType.ThreadLine">
            <summary>Линия резьбы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionLineType.AxisLine">
            <summary>Осевая</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionLineType.Smooth">
            <summary>Линия между гладко сопряжёнными поверхностями</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionLineType.Hidden">
            <summary>Невидимая</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionLineType.BaseVisible">
            <summary>Основная видимая</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ElementProjection.RemoveAllObjects">
            <summary>Удалить все заданные для проецирования объекты из проекции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ElementProjection.AddGeometry(TFlex.Model.Model3D.Geometry.ModelTopol)">
            <summary>Добавить геометрический объект (грань, ребро, цикл) для проецирования</summary>
            <param name="g">Добавляемый объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ElementProjection.AddBody(TFlex.Model.Model3D.Operation)">
            <summary>Добавить операцию как тело для проецирования</summary>
            <param name="operation">Добавляемая операция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ElementProjection.AddObject(TFlex.Model.Model3D.Object3D)">
            <summary>Добавить модельный объект (путь, профиль, операцию) для проецирования</summary>
            <param name="o">Добавляемый объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ElementProjection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся проекция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ElementProjection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Проекция создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.ElementProjection">
            <summary>Класс создания проекции набора топологических элементов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrowProjection.Arrow">
            <summary>Стрелка взгляда</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrowProjection.BaseProjection">
            <summary>Проекция на которой расположена стрелка взгляда</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ArrowProjection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся проекция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ArrowProjection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Проекция создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.ArrowProjection">
            <summary>Класс создания проекции по стрелке</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LocalSectionProjection.TiePoint3D">
            <summary>Точка по которой определяется положение секущей плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LocalSectionProjection.TieNode2D">
            <summary>Узел по которому определяется положение секущей плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LocalSectionProjection.LocalProjection">
            <summary>Проекция на которой определяется положение узла привязки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LocalSectionProjection.BaseProjection">
            <summary>Проекция на базе которой строится локальная проекция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LocalSectionProjection.SectionArea">
            <summary>Штриховка задающая область вырыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LocalSectionProjection.HatchScale">
            <summary>Масштаб штриховки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LocalSectionProjection.Complete">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LocalSectionProjection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся проекция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LocalSectionProjection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Проекция создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.LocalSectionProjection">
            <summary>Класс видов проекций с местными видами</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionWithSection.HatchPrecision">
            <summary>Точность поиска штриховки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionWithSection.HatchScale">
            <summary>Масштаб штриховки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionWithSection.UseHatch">
            <summary>Штриховать ли разрез</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionWithSection.TypeOfSection">
            <summary>Тип сечения применяемый на проекции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionWithSection.ViewSection">
            <summary>Установить сечение задающее направление взгляда</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionWithSection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся проекция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionWithSection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Проекция создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionWithSection">
            <summary> Класс видов проекций с применёнными сечениями</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.NonStandardProjection.Center">
            <summary>Проекция позиционируется по центру ограничивающиего прямоугольника</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.NonStandardProjection.ViewPlane">
            <summary>Топологический элемент для определения направления проецирования.
Поддерживаются два типа элементов грани и вершины.
Элемент для опеределения направления проецирования.</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.NonStandardProjection.ViewTiePoint3D">
            <summary>Привязка проекции к 3d точке</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.NonStandardProjection.SetViewPoint(System.Double,System.Double,System.Double)">
            <summary>Установить координаты точки проецирования</summary>
            <remarks>Направление проецирования - вектор из заданной точки в (0., 0., 0.)</remarks>
            <param name="xvp">Значение координаты x</param>
            <param name="yvp">Значение координаты y</param>
            <param name="zvp">Значение координаты z</param>
        </member>
        <member name="M:TFlex.Model.Model3D.NonStandardProjection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся проекция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.NonStandardProjection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Проекция создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.NonStandardProjection">
            <summary> Класс видов проекций с произвольной точкой взгляда</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.Perspective">
            <summary>Перспективная проекция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.ThreadLineColor">
            <summary>Цвет линий резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.ThreadLineWidth">
            <summary>Толщина линий резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.ThreadLineScale">
            <summary>Масштаб линий резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.ThreadLineName">
            <summary>Имя типа линий резьбы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.AxisLineColor">
            <summary>Цвет осевых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.AxisLineWidth">
            <summary>Толщина осевых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.AxisLineScale">
            <summary>Масштаб осевых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.AxisLineName">
            <summary>Имя типа осевых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.SmoothLineColor">
            <summary>Цвет линий гладких сопряжений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.SmoothLineWidth">
            <summary>Толщина линий гладких сопряжений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.SmoothLineScale">
            <summary>Масштаб линий гладких сопряжений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.SmoothLineName">
            <summary>Имя типа видимых линий гладких сопряжений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.HiddenLineColor">
            <summary>Цвет невидимых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.HiddenLineWidth">
            <summary>Толщина невидимых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.VisibleLineColor">
            <summary>Цвет видимых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.VisibleLineWidth">
            <summary>Толщина видимых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.VisibleLineScale">
            <summary>Масштаб видимых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.VisibleLineName">
            <summary>Имя типа видимых линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.ProjectPrecision">
            <summary>Получить значение точности проецирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.RegenerationMode">
            <summary>Режим регенерации проекции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.Monochrome">
            <summary>Признак использования одного цвета на всей проекции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.OverlapBodies">
            <summary>Режим учёта перекрытия тел при проецировании</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.CreateTangentEdges">
            <summary>Режим создания изображений с показом гладких сопряжений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.CreateHidden">
            <summary>Признак режима создания изображений с невидимыми линиями</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.CreateThreads">
            <summary>Признак режима создания изображений резьб</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.ConvertPolylinesToSplines">
            <summary>Признак режима конвертации полилиний в сплайны</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.RecognizeCircles">
            <summary>Признак режима распознавания дуг окружностей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.RecognizeLines">
            <summary>Признак режима распознавания отрезков</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.AxisCreate">
            <summary>Признак режима создания осей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.Explode">
            <summary>Признак режима разборки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SimpleDrawingProjection.GetOutlineMode">
            <summary>Опрос режима отрисовки очерка в растровых проекциях</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SimpleDrawingProjection.GetEdgeMode">
            <summary>Опрос режима отрисовки рёбер в растровых проекциях</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SimpleDrawingProjection.ProjectionClass">
            <summary>Тип проекции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SimpleDrawingProjection.RemoveAllOperations">
            <summary>Сбросить все проецируемые операции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SimpleDrawingProjection.AddBody(TFlex.Model.Model3D.Operation)">
            <summary>Добавить операцию как тело для проецирования</summary>
            <param name="operation">Добавляемая операция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.SimpleDrawingProjection.AddOperation(TFlex.Model.Model3D.Operation)">
            <summary>Добавить операцию для проецирования</summary>
            <param name="oper">Добавляемая операция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.SimpleDrawingProjection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся проекция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.SimpleDrawingProjection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Проекция создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.SimpleDrawingProjection">
            <summary>Класс стандартных видов проекций </summary>
        </member>
        <member name="T:TFlex.Model.Model3D.SectionType">
            <summary>Тип сечения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.SectionType.DevelopedSection">
            <summary>Развёртка сечения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.SectionType.AlignedSecion">
            <summary>Разрез с разворотом</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.SectionType.SectionOnly">
            <summary>Сечение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.SectionType.Section">
            <summary>Разрез</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.RegenerationMode">
            <summary>Режимы обновления</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.RegenerationMode.ManualOnly">
            <summary>Обновление по запросу</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.RegenerationMode.Manual">
            <summary>Обновление по запросу и при полном пересчёте модели</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.RegenerationMode.Automatic">
            <summary>Автоматическое обновление</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.RegenerationMode.None">
            <summary>Не обновлять</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.Layers">
            <summary>Множество слоёв</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.LayersType.Exclude">
            <summary>Исключить из списка элементы с выбранных в списке слоёв</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.LayersType.Include">
            <summary>Проецировать элементы с выбранных в списке слоёв</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Projection.LayersType">
            <summary>Способ обработки проецируемых элементов по слоям</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.LayersArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.LayersArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.LayersArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.LayersArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.LayersArray.DeleteAll">
            <summary>Удалить все слои</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.LayersArray.Delete(System.Int32)">
            <summary>Удалить слой по номеру</summary>
            <param name="index">Номер слоя</param>
            <remarks>Слои нумеруются от нуля. Если индекс отрицательный или превышает количество слоёв, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.LayersArray.Add(System.String)">
            <summary>Добавить слой в конец списка</summary>
            <param name="layer">Слой</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.LayersArray.Insert(System.Int32,System.String)">
            <summary>Вставить слой перед номером</summary>
            <param name="index">Номер слоя</param>
            <param name="layer">Вставляемый слой</param>
            <remarks>Слои нумеруются от нуля. Если индекс отрицательный или превышает количество слоёв, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.LayersArray.Length">
            <summary>Количество слоёв</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Projection.LayersArray">
            <summary>Множество слоёв</summary>
            <remarks>Возможно перечисление слоёв с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.Explode">
            <summary>Разрушить проекцию</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.Regenerate(System.Boolean)">
            <summary>Пометить объект как изменённый</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.SetEnd(System.Int32,TFlex.Model.Parameter)">
            <summary>Установка конечного отступа разрыва</summary>
            <param name="i">Номер разрыва</param>
            <param name="end">Значение конечного отступа разрыва</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.SetBegin(System.Int32,TFlex.Model.Parameter)">
            <summary>Установка начального отступа разрыва</summary>
            <param name="i">Номер разрыва</param>
            <param name="begin">Значение начального отступа разрыва</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.SetNormal(System.Int32,System.Boolean)">
            <summary>Установка ориентации разрыва</summary>
            <param name="i">Номер разрыва</param>
            <param name="norm">Ориентация разрыва</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.DeleteAllBreaks">
            <summary>Удаление всех разрывов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.DeleteBreak(System.Int32)">
            <summary>Удаление разрыва</summary>
            <param name="i">Номер разрыва</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.AddBreak(System.Boolean,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Метод для добавления информации о новом разрыве в список</summary>
            <param name="norm">Ориентация разрыва</param>
            <param name="begin">Параметр начала разрыва</param>
            <param name="end">Параметр конца разрыва</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.GetBrokenSize">
            <summary>Метод для получения размера массива разрывов</summary>
            <returns>Получить количество разрывов</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenVAlign">
            <summary>Тип вертикального выравнивания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenHAlign">
            <summary>Тип горизонтального выравнивания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenMetric">
            <summary>Единицы измерения величины разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenLength">
            <summary>Длина полупериода волны линии разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenAmplitude">
            <summary>Амплитуда линии разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenType">
            <summary>Тип линии разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenBorder">
            <summary>Длина выносной линии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenLineDistance">
            <summary>Расстояние между линиями разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenAngle">
            <summary>Угол поворота набора линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenLineColor">
            <summary>Цвет линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenLineWidth">
            <summary>Толщина линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenLineScale">
            <summary>Масштаб линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BrokenLineName">
            <summary>Имя типа линий разрыва</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.Bind">
            <summary>Проекция с которой берётся проекционная связь</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.Angle">
            <summary>Угол поворота проекции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.FromFile(System.String,System.String)">
            <summary>Создание проекции из файла</summary>
            <returns>Возвращает true - если файл по указанному пути может быть использован для проецирования</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.ScaleFitToPageSize(System.Double,System.Double)">
            <summary>Подбор масшатаба для проекции, чтобы умещаться на странице</summary>
            <returns>Возвращает отрицательное значение, если не удалось подобрать масштаб</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.Save3DDim">
            <summary>Сохранять информацию для 3D размеров</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.Scale">
            <summary>Масштаб проекции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.GetProjectedPoint(TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Функция возвращает 3D точку по точке на проекции</summary>
            <returns>Функция возвращает NULL когда проекция не рассчитана</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.ProjectPoint(TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Функция проецирует данную точку на проекцию</summary>
            <returns>Функция возвращает NULL когда проекция не рассчитана</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.GetProjectionTransform">
            <summary>Функция возвращает матрицу преобразования точки в 3d пространстве в систему координат проекции</summary>
            <returns>Функция возвращает NULL когда проекция не рассчитана</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.SetTieNode(TFlex.Model.Model2D.Node)">
            <summary>Установить привязку проекции в соответствующий узел страницы</summary>
            <param name="nfix">Узел привязки проекции</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.SetTiePoint(System.Double,System.Double)">
            <summary>Установить привязку проекции в соответствующую точку страницы</summary>
            <param name="x1">Координата x точки привязки проекции</param>
            <param name="y1">Координата y точки привязки проекции</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.GetViewPoint">
            <summary>Опросить координаты точки проецирования</summary>
            <returns>Функция возвращает false когда точка взгляда проекции не рассчитана</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.SetViewWorkplane(TFlex.Model.Model3D.Workplane)">
            <summary>Установить направление проецирования как нормаль к рабочей плоскости</summary>
            <param name="wp">Рабочая плоскость для задания направления проецирования</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.SetViewType(TFlex.Model.Model3D.ProjectionType)">
            <summary>Установить направление проецирования для стандартных видов</summary>
            <param name="type">Значение направления проецирования</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.BoundRect">
            <summary>Ограничивающий прямоугольник проекции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElementsType.All">
            <summary>Все типы проекций</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElementsType.Topols">
            <summary>Все типы геометрических элементов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElementsType.Lcs">
            <summary>Все типы ЛКС</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElementsType.Axis">
            <summary>Все типы путей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElementsType.Profile">
            <summary>Все типы профилей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElementsType.Weld">
            <summary>Все типы сварных швов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElementsType.Operation">
            <summary>Все типы операций</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Projection.ProjectionsElementsType">
            <summary>Типы проецируемых элементов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllWithTheExceptionOfSelectedSomeElements">
            <summary>Все элементы за исключением выбранных</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OnlySelectedSomeElements">
            <summary>Выбранные элементы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllSomeElements">
            <summary>Все элементы одного из типов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.ProjectionsElementsAllTypes">
            <summary>Все типы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.ProjectionsElementsNewTypes">
            <summary>Все новые типы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.TopolsAllTypes">
            <summary>Геометрические элементы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.LcsAllTypes">
            <summary>Все типы систем координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllWithTheExceptionOfSelectedLcs">
            <summary>Все системы координат за исключением выбранных систем координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OnlySelectedLcs">
            <summary>Все выбранные системы координат ( по умолчанию )</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllLcs">
            <summary>Все системы координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AxisAllTypes">
            <summary>Все типы осей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllWithTheExceptionOfSelectedAxis">
            <summary>Все оси за исключением выбранных осей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OnlySelectedAxis">
            <summary>Все выбранные оси ( по умолчанию )</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllAxis">
            <summary>Все оси</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.PathAllTypes">
            <summary>Все типы путей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllWithTheExceptionOfSelectedPaths">
            <summary>Все пути за исключением выбранных путей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OnlySelectedPaths">
            <summary>Все выбранные пути ( по умолчанию )</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllPaths">
            <summary>Все пути</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.ProfileAllTypes">
            <summary>Все типы профилей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllWithTheExceptionOfSelectedProfiles">
            <summary>Все профили за исключением выбранных профилей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OnlySelectedProfiles">
            <summary>Все выбранные профили ( по умолчанию )</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllProfiles">
            <summary>Все профили</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.WeldAllTypes">
            <summary>Все типы сварных швов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OperationWelds">
            <summary>Также как в операциях</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllWithTheExceptionOfSelectedWelds">
            <summary>Все сварные швы за исключением выбранных сварных швов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OnlySelectedWelds">
            <summary>Все выбранные сварные швы ( по умолчанию )</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllWelds">
            <summary>Все сварные швы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OperationAllTypes">
            <summary>Все типы операций</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.File">
            <summary>Тела из файла</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllWithTheExceptionOfSelectedOperations">
            <summary>Все операции за исключением выбранных операций</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.OnlySelectedElements">
            <summary>Все выбранные элементы ( по умолчанию )</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Projection.ProjectionsElements.AllOperations">
            <summary>Все операции</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Projection.ProjectionsElements">
            <summary>Выбор проецируемых элементов или элементов, к которым применяется сечение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся проекция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой проекции</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Проекция создаётся на активной странице</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Projection.Complete">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Projection.Page">
            <summary>Страница</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model3D.Projection">
            <summary>Базовый класс для всех типов проекций</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BrokenBinding">
            <summary>Тип выравнивания линий разрыва (только для расстояний в единицах модели)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BrokenBinding.Right">
            <summary>Правое</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BrokenBinding.Center">
            <summary>По центру</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BrokenBinding.Left">
            <summary>Левое</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BrokenMetric">
            <summary>Тип единиц измерения положение линий разрыва</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BrokenMetric.Model">
            <summary>Единицы модели</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BrokenMetric.Percent">
            <summary>Проценты от ограничивающего прямоугольника</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BrokenType">
            <summary>Типы линии разрыва</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BrokenType.Zigzag">
            <summary>Ломаная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BrokenType.Wave">
            <summary>Синусоида</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BrokenType.Line">
            <summary>Прямая</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionClass">
            <summary>Типы проекций с невидимыми линиями</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionClass.DrawOutlines">
            <summary>Рисовать очерки при работе с растровыми проекциями</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionClass.DrawEdge">
            <summary>Рисовать рёбра при работе с растровыми проекциями</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionClass.QuickHidden">
            <summary>Удаление невидимых линий с использованием растрового алгоритма</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionClass.RenderImage">
            <summary>Тоновая закраска c материалами</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionClass.ShadedImage">
            <summary>Тоновая закраска без материалов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionClass.AllVisible">
            <summary>Вид без удаления невидимых линий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionClass.HiddenRemoved">
            <summary>Вид с удалёнными невидимыми линиями</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionType">
            <summary>Типы проекций</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionType.AxonometricProjection">
            <summary>Аксонометрический вид</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionType.BottomProjection">
            <summary>Вид снизу</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionType.TopProjection">
            <summary>Вид сверху</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionType.RightProjection">
            <summary>Вид справа</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionType.LeftProjection">
            <summary>Вид слева</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionType.BackProjection">
            <summary>Вид сзади</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ProjectionType.FrontProjection">
            <summary>Вид спереди</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PlaneSection.Plane">
            <summary>Плоскость сечения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PlaneSection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сечения по плоскости</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.PlaneSection">
            <summary>Сечение по плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.NodeSection.Nodes">
            <summary>Множество узлов. Ломанная, построенная на последовательности этих узлов образуют контур сечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.NodeSection.NodesArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="Index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество узлов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeSection.NodesArray.DeleteAll">
            <summary>Удалить все узлы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeSection.NodesArray.Delete(System.Int32)">
            <summary>Удалить узел по номеру</summary>
            <param name="Index">Номер точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeSection.NodesArray.Add(TFlex.Model.Model2D.Node)">
            <summary>Добавить узел в конец списка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeSection.NodesArray.Insert(System.Int32,TFlex.Model.Model2D.Node)">
            <summary>Вставить узел перед номером</summary>
            <param name="Index">Номер точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.NodeSection.NodesArray.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.NodeSection.NodesArray">
            <summary>Множество 2D узлов. Возможно перечисление узлов с использованием конструкции foreach</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeSection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания сечения по 2D узлам</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся сечение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeSection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сечения по 2D узлам</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.NodeSection">
            <summary>Сечение по 2D узлам</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Section2DSection.Section2D">
            <summary>Обозначение вида</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Section2DSection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания сечения по обозначению вида</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся сечение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Section2DSection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сечения по обозначению вида</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Section2DSection">
            <summary>Сечение по обозначению вида</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DSection.Path2D">
            <summary>2D путь</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DSection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания сечения по 2D пути</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся сечение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DSection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сечения по 2D пути</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Path2DSection">
            <summary>Сечение по 2D пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Model2DSection.Projection">
            <summary>Проекция</summary>
            <remarks>Ориентация контура сечения в пространстве задаётся двумя взаимоисключающими методами : рабочей плоскостью или проекцией</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Model2DSection.Workplane">
            <summary>Рабочая плоскость</summary>
            <remarks>Ориентация контура сечения в пространстве задаётся двумя взаимоисключающими методами : рабочей плоскостью или проекцией</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Model2DSection.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания нового сечения</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся сечение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Model2DSection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового сечения</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Сечение создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Model2DSection">
            <summary>Сечение, построенное по 2D</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ViewSection.Normal">
            <summary>Получить вектор номали к экранной плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ViewSection.Origin">
            <summary>Получить точку, лежащую на экранной плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ViewSection.Points">
            <summary>Множество точек. Ломанная, построенная на последовательности проекций этих точек на плоскость сечения образуют контур сечения</summary>
            <remarks>В настоящей версии в качестве точки можно выбирать только 3D узлы и вершины. В остальных случаях сечение строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ViewSection.ViewPointsArray.default(System.Int32)">
            <summary>Получить элемент по номеру</summary>
            <param name="Index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ViewSection.ViewPointsArray.DeleteAll">
            <summary>Удалить все точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ViewSection.ViewPointsArray.Delete(System.Int32)">
            <summary>Удалить точку по номеру</summary>
            <param name="Index">Номер точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ViewSection.ViewPointsArray.Add(TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Добавить точку в конец списка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ViewSection.ViewPointsArray.Insert(System.Int32,TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Вставить точку перед номером</summary>
            <param name="Index">Номер точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ViewSection.ViewPointsArray.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ViewSection.ViewPointsArray">
            <summary>Множество точек. Возможно перечисление точек с использованием конструкции foreach</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ViewSection.Coords.#ctor(TFlex.Model.Model3D.ViewSection,TFlex.Model.Model3D.ViewSection.Coords.CoordsType)">
            <summary>Конструктор</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ViewSection.Coords.Z">
            <summary>Z-координата точки или вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ViewSection.Coords.Y">
            <summary>Y-координата точки или вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ViewSection.Coords.X">
            <summary>X-координата точки или вектора</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ViewSection.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сечения по 3D узлам и экранной плоскости</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ViewSection">
            <summary>Сечение по 3D узлам и экранной плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Section3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового сечения</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.Page">
            <summary>Страница</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.Orientation">
            <summary>Направление сечения</summary>
            <remarks>По умолчанию значение ориентации false</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.ShowOn3D">
            <summary>Признак рисования сечения в 3D сцене</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.UseColorFromBody">
            <summary>Признак использования цвета с тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.Geometry">
            <summary>Получить геометрические данные сечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.GeometryData.Curve">
            <summary>Кривая простого (из одного ребра) контура сечения</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::ModelCurve, хранящий кривую и ссылку на эти геометрические данные сечения</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.GeometryData.Surface">
            <summary>Поверхность простого (из одной грани) сечения</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::ModelSurface, хранящий поверхность и ссылку на эти геометрические данные сечения</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.GeometryData.Sheet">
            <summary>Поверхность сечения</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::Sheet, хранящий листовое тело и ссылку на эти геометрические данные сечения</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.GeometryData.Wire">
            <summary>Контур сечения</summary>
            <returns>Объект класса TFlex::Model::Model3D::Geometry::Wire, хранящий границы и ссылку на эти геометрические данные сечения</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.GeometryData.Contour">
            <summary>Контур сечения</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelContour" />, хранящий контуры и ссылку на эти геометрические данные сечения</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.GeometryData.Plane">
            <summary>Плоскость контура сечения</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelPlane" />, хранящий координаты плоскости и ссылку на эти геометрические данные сечения</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.GeometryData.Direction">
            <summary>Нормаль к плоскости контура сечения</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelDirection" />, хранящий координаты вектора и ссылку на эти геометрические данные сечения</returns>
        </member>
        <member name="T:TFlex.Model.Model3D.Section3D.GeometryData">
            <summary>Множество геометрических данных сечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Section3D.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Section3D">
            <summary>Базовый класс для всех типов сечений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.Method">
            <summary>Метод</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.SmoothFlag">
            <summary>Параметр учёта гладкости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.StepEdges">
            <summary>Тип рёбер ступенчатого уклона</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.AnalyzeFlag">
            <summary>Параметр разбиения грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.CoprocessingFlag">
            <summary>Параметр совместной обработки граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.GetStepPath(System.Int32)">
            <summary>Получить путь связанный с уклоняемой гранью</summary>
            <param name="faceIndex">Номер уклоняемой грани</param>
            <returns>Путь</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.SetStepPath(System.Int32,TFlex.Model.Model3D.Path3D)">
            <summary>Задать путь связанный с уклоняемой гранью</summary>
            <param name="faceIndex">Номер уклоняемой грани</param>
            <param name="path">Путь</param>
            <remarks>Путь не может быть задан, если задано ступенчатое ребро</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.NumberOfStepEdges">
            <summary>Получить число рёбер</summary>
            <returns>Число рёбер</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.GetStepEdge(System.Int32)">
            <summary>Получить ребро</summary>
            <param name="stepEdgeIndex">индекс ребра</param>
            <returns>Ребро</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.RemoveAllStepEdges">
            <summary>Удалить все рёбра</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.RemoveStepEdge(System.Int32)">
            <summary>Удалить ребро</summary>
            <param name="stepEdgeIndex">Номер ребра</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.AddStepEdge(TFlex.Model.Model3D.Geometry.ModelEdge)">
            <summary>Добавить ребро задающее шаг</summary>
            <param name="edge">Ребро</param>
            <remarks>Рёбра не могут быть добавлены, если задан путь</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.OffsetFace">
            <summary>Грань смещения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.FixedPlane">
            <summary>Плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.ReverseFlag">
            <summary>Реверс угла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.Angle">
            <summary>Угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.NumberOfFaces">
            <summary>Получить число уклоняемых граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.RemoveAllFaces">
            <summary>Удалить все грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.AddFace(TFlex.Model.Model3D.Geometry.ModelEdge,TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить пару опорное ребро - уклоняемая грань</summary>
            <param name="referenceEdge">Ребро используемое в качестве опоры для поворота уклоняемой грани</param>
            <param name="draftFace">Уклоняемая грань</param>
            <remarks>Ребро должно принадлежать уклоняемой грани</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.AddFace(TFlex.Model.Model3D.Geometry.ModelFace,TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить пару опорная грань - уклоняемая грань</summary>
            <param name="referenceFace">Грань используемая в качестве опоры для поворота уклоняемой грани</param>
            <param name="draftFace">Уклоняемая грань</param>
            <remarks>Грани должны иметь общее ребро</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Taper.Direction">
            <summary>Направление</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Taper.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Уклона</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="F:TFlex.Model.Model3D.Taper.TaperMethod.OffsetMethod">
            <summary>По смещению</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Taper.TaperMethod.SurfaceMethod">
            <summary>По поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Taper.TaperMethod.CurveMethod">
            <summary>По кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Taper.TaperMethod.IsoclineMethod">
            <summary>Стандартный (по умолчанию)</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Taper.TaperMethod">
            <summary>Метод построения уклона</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Taper.StepEdgesType.NormalStepEdges">
            <summary>Нормальные рёбра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Taper.StepEdgesType.TaperedStepEdges">
            <summary>Уклоняемые рёбра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Taper.StepEdgesType">
            <summary>Тип рёбер задающих ступенчатый уклон</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Taper">
            <summary>Уклон</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.Outside">
            <summary>Параметр построения оболочки наружу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.StoreSourceBody">
            <summary>Параметр сохранения исходного тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.EquidistantBody">
            <summary>Параметр создания эквидистантного тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.PierceSmoothingSurfaces">
            <summary>Пробивать касательные грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.OffsetFaceCount">
            <summary>Число особых граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Shell.GetOffsetFace(System.Int32,TFlex.Model.Model3D.Geometry.ModelFace@,TFlex.Model.Parameter@)">
            <summary>Получить особую грань</summary>
            <param name="faceIndex">Номер грани</param>
            <param name="face">Грань</param>
            <param name="offset">Толщина особой грани</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Shell.RemoveAllOffsetFaces">
            <summary>Удалить все особые грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Shell.RemoveOffsetFace(System.Int32)">
            <summary>Удалить особую грань</summary>
            <param name="faceIndex">Номер грани</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Shell.AddOffsetFace(TFlex.Model.Model3D.Geometry.ModelFace,TFlex.Model.Parameter)">
            <summary>Добавить грань с особой толщиной</summary>
            <param name="face">Грань</param>
            <param name="offset">Толщина грани</param>
            <remarks>Все грани задаваемые в операции должны быть с одного тела</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.Offset">
            <summary>Толщина оболочки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Shell.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Оболочки</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.PierceFacesArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Shell.PierceFacesArray.Clear">
            <summary>Удалить все операнды</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Shell.PierceFacesArray.RemoveAt(System.Int32)">
            <summary>Удалить операнд по номеру</summary>
            <param name="index">Номер операции</param>
            <remarks>Операнды нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Shell.PierceFacesArray.Add(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить операнд в конец списка</summary>
            <param name="operand">Добавляемый операнд</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Shell.PierceFacesArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Shell.PierceFacesArray">
            <summary>Коллекция удаляемых граней оболочки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Shell">
            <summary>Оболочка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.PropagateFlag">
            <summary>Параметр "продолжить по касательной"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.Path">
            <summary>Путь</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.RightFaceReverse">
            <summary>Тип реверса для правых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.NumberOfRightFaces">
            <summary>Число правых граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.GetRightFace(System.Int32)">
            <summary>Получить правую грань</summary>
            <param name="faceIndex">Номер грани</param>
            <returns>Грань</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.RemoveAllRightFaces">
            <summary>Удалить все правые грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.RemoveRightFace(System.Int32)">
            <summary>Удалить правую грань</summary>
            <param name="faceIndex">Номер грани</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.AddRightFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить правой грань</summary>
            <param name="face">Грань</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.CenterFaceReverse">
            <summary>Тип реверса для центральных граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.NumberOfCenterFaces">
            <summary>Получить число центральных граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.GetCenterFace(System.Int32)">
            <summary>Получить центральную грань</summary>
            <param name="faceIndex">Номер грани</param>
            <returns>Грань</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.RemoveAllCenterFaces">
            <summary>Удалить все центральные грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.RemoveCenterFace(System.Int32)">
            <summary>Удалить центральную грань</summary>
            <param name="faceIndex">Номер грани</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.AddCenterFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить центральную грань</summary>
            <param name="face">Грань</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.LeftFaceReverse">
            <summary>Тип реверса для левых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.NumberOfLeftFaces">
            <summary>Число левых граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.GetLeftFace(System.Int32)">
            <summary>Получить левую грань</summary>
            <param name="faceIndex">Номер грани</param>
            <returns>Грань</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.RemoveAllLeftFaces">
            <summary>Удалить все левые грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.RemoveLeftFace(System.Int32)">
            <summary>Удалить левую грань</summary>
            <param name="faceIndex">Номер грани</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreeFaceBlending.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.AddLeftFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить левую грань</summary>
            <param name="face">Грань</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreeFaceBlending.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания объекта ThreeFaceBlending</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreeFaceBlending.FaceReverseType.Auto">
            <summary>Автоматический</summary>
            <remarks>Данный тип сглаживания может быть установлен только,
если все три грани взяты с одного тела</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreeFaceBlending.FaceReverseType.Reverse">
            <summary>Обратно нормали</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThreeFaceBlending.FaceReverseType.Normal">
            <summary>По нормали</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreeFaceBlending.FaceReverseType">
            <summary>Тип реверса грани</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreeFaceBlending">
            <summary>Сглаживание 3-х граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.OverflowNotch">
            <summary>Параметр "Вырез"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.OverflowCliff">
            <summary>Параметр "Сохранять острые рёбра"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.OverflowSmooth">
            <summary>Параметр "Учитывать гладкие перекрытия"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.Propagate">
            <summary>Параметр "Продолжить по касательной"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.RemoveTopologyFlag">
            <summary>Параметр "Удалять элементы"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.GetAttrib(System.Int32)">
            <summary>Получить атрибуты топологии</summary>
            <param name="topolIndex">Номер топологии</param>
            <remarks>Если атрибут равен 0, тогда топология использует общие атрибуты</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.SetAttrib(System.Int32,TFlex.Model.Model3D.EdgeBlending.Attribute)">
            <summary>Установить атрибуты топологии</summary>
            <param name="topolIndex">Номер топологии</param>
            <param name="attrib">Атрибуты</param>
            <remarks>Если attrib равно 0, тогда топология использует общие атрибуты.
Параметр Position для первой и последней позиции, не используется и изменяется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.CommonAttrib">
            <summary>Общие атрибуты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.AddEdgesByVertex(TFlex.Model.Model3D.Geometry.ModelVertex,TFlex.Model.Parameter,System.Boolean)">
            <summary>Для всех рёбер, инцидентных данной вершине, задаются отступы</summary>
            <param name="vertex">Вершина</param>
            <param name="distance">Значение отступа</param>
            <param name="common">Параметр установлен для всех вершин</param>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.TopolCount">
            <summary>Получить число топологий</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.getTopol(System.Int32)">
            <summary>Получить топологию</summary>
            <param name="topolIndex">Номер топологии</param>
            <returns>Топология</returns>
            <remarks>Топология может быть ребром, циклом или гранью</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.AddTopol(TFlex.Model.Model3D.Geometry.ModelTopol,TFlex.Model.Model3D.EdgeBlending.Attribute)">
            <summary>Добавить топологию со своими атрибутами</summary>
            <param name="topol">Топология</param>
            <remarks>Топология должна быть ребром, циклом или гранью.
Независимо от типа топологии, у топологии используются только рёбра.
Гладкосопряженные рёбра должны быть определены с одинаковыми атрибутами,
в противном случае результат не специфицирован</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.AddTopol(TFlex.Model.Model3D.Geometry.ModelTopol)">
            <summary>Добавить топологию с общими атрибутами</summary>
            <param name="topol">Топология</param>
            <remarks>Топология должна быть ребром, циклом или гранью</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сглаживания рёбер</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ChamferLengthAttribute.Angle">
            <summary>Угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ChamferLengthAttribute.Width">
            <summary>Ширина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ChamferLengthAttribute.Type">
            <summary>Тип свойства</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.ChamferLengthAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="width">Ширина фаски</param>
            <param name="angle">Угол фаски</param>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgeBlending.ChamferLengthAttribute">
            <summary>Класс для задания фаски с помощью ширины и угла</summary>
            <remarks>ChamferLengthAttribute является временным объектом используемым для облегчения задания свойств операции сглаживания</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ChamferAttribute.Offset2">
            <summary>Второе смещение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ChamferAttribute.Offset1">
            <summary>Первое смещение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ChamferAttribute.Type">
            <summary>Тип свойства</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.ChamferAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="offset1">Первое смещение</param>
            <param name="offset2">Второе смещение</param>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgeBlending.ChamferAttribute">
            <summary>ChamferAttribute - класс для задания фаски с помощью двух смещений</summary>
            <remarks>ChamferAttribute является временным объектом используемым для облегчения задания свойств операции сглаживания</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.SetbackEnd">
            <summary>Отступ от конца ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.SetbackStart">
            <summary>Отступ от начала ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.PositionCount">
            <summary>Число позиций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.GetPosition(System.Int32)">
            <summary>Добавить позицию</summary>
            <remarks>Удаляет позиции с номерами 1..PositionCount-2</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.SetPosition(System.Int32,TFlex.Model.Model3D.EdgeBlending.PositionData)">
            <summary>Установить данные позиции</summary>
            <param name="positionIndex">Номер позиции</param>
            <param name="data">Новые данные позиции</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.RemoveAllPositions">
            <summary>Добавить позицию</summary>
            <remarks>Удаляет позиции с номерами 1..PositionCount-2</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.RemovePosition(System.Int32)">
            <summary>Добавить позицию</summary>
            <param name="positionIndex">Номер позиции, должен быть в диапазоне 1..PositionCount-2</param>
            <remarks>Первая и последняя позиции не могут быть удалены</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.AddPosition(TFlex.Model.Model3D.EdgeBlending.PositionData)">
            <summary>Добавить позицию</summary>
            <param name="data">Данные позиции</param>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.Type">
            <summary>Тип свойства</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="radius1">1-й параметр</param>
            <param name="radius2">2-й параметр</param>
            <param name="rho">Параметр задающий кривизну:
меньше 0.5 - эллипс, 0.5 - парабола, больше 0.5 - гипербола</param>
            <param name="setbackStart">Отступ от начала ребра</param>
            <param name="setbackEnd">Отступ от конца ребра</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="radius1">1-й параметр</param>
            <param name="radius2">2-й параметр</param>
            <param name="rho">Параметр задающий кривизну:
меньше 0.5 - эллипс, 0.5 - парабола, больше 0.5 - гипербола</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="radius1">1-й радиус эллипса</param>
            <param name="radius2">2-й радиус эллипса</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute.#ctor(TFlex.Model.Model3D.EdgeBlending.PositionData,TFlex.Model.Model3D.EdgeBlending.PositionData)">
            <summary>Конструктор</summary>
            <param name="first">Параметры первой позиции</param>
            <param name="last">Параметры второй позиции</param>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgeBlending.VariableBlendAttribute">
            <summary>Класс для задания свойств с переменным радиусом скругления</summary>
            <remarks>VariableBlendAttribute является временным объектом используемым для облегчения задания свойств операции сглаживания</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ConstantBlendAttribute.SetbackEnd">
            <summary>Получить значение отступа от конца ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ConstantBlendAttribute.SetbackStart">
            <summary>Получить значение отступа от начала ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ConstantBlendAttribute.Radius">
            <summary>Получить значение радиуса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.ConstantBlendAttribute.Type">
            <summary>Тип свойств ребра</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.ConstantBlendAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="radius">Радиус скругления</param>
            <param name="setbackStart">Параметр используемый для задания чемоданного угла от начала ребра, может быть равен 0</param>
            <param name="setbackEnd">Параметр используемый для задания чемоданного угла от конца ребра, может быть равен 0</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.ConstantBlendAttribute.#ctor(TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="radius">Радиус скругления</param>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgeBlending.ConstantBlendAttribute">
            <summary>Класс для задания свойств с постоянным радиусом скругления</summary>
            <remarks>ConstantBlendAttribute является временным объектом используемым для облегчения задания свойств операции сглаживания</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.Attribute.Type">
            <summary>Тип</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgeBlending.Attribute">
            <summary>Aбстрактный класс используемый для задания свойств</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.PositionData.Rho">
            <summary>Кривизна</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.PositionData.Radius2">
            <summary>Второй радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.PositionData.Radius1">
            <summary>Первый радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgeBlending.PositionData.Position">
            <summary>Позиция</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.PositionData.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="position">Позиция, задаётся в диапазоне 0..100</param>
            <param name="radius1">1-й параметр</param>
            <param name="radius2">2-й параметр</param>
            <param name="rho">Параметр задающий кривизну кривой:
меньше 0.5 - эллипс, 0.5 - парабола, больше 0.5 - гипербола</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.PositionData.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="position">Позиция, задаётся в диапазоне 0..100</param>
            <param name="radius1">1-й радиус эллипса</param>
            <param name="radius2">2-й радиус эллипса</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgeBlending.PositionData.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="position">Позиция, задаётся в диапазоне 0..100</param>
            <param name="radius">Радиус окружности</param>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgeBlending.PositionData">
            <summary>Класс используемый для задания данных позиций в переменном сглаживании</summary>
            <remarks>VariableBlendAttribute является временным объектом используемым для облегчения задания свойств операции сглаживания</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.EdgeBlending.BlendType.ChamferLength">
            <summary>Фаска заданная с помощью длины и угла</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EdgeBlending.BlendType.Chamfer">
            <summary>Фаска заданная с помощью двух смещений</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EdgeBlending.BlendType.Variable">
            <summary>Сглаживание с переменным радиусом</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EdgeBlending.BlendType.Constant">
            <summary>Сглаживание с постоянным радиусом</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgeBlending.BlendType">
            <summary>Тип сглаживания</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgeBlending">
            <summary>Сглаживание рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.RadiusFromStartPoint">
            <summary>Параметр "Получить радиус по узлу"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.ProfileReverse">
            <summary>Параметр реверса профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.ProfileOrientation">
            <summary>Тип ориентации профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.CounterClockwise">
            <summary>Построение пружины против часовой стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.LengthMethod">
            <summary>Тип</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Spiral.SetEndSmooth(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установить параметры сглаживания конечных витков</summary>
            <param name="smooth">Число сглаживаемых витков</param>
            <param name="degree">Степень сглаживания</param>
            <remarks>Все значения должны быть нулевыми, или ненулевыми</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Spiral.SetStartSmooth(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Установить параметры сглаживания начальных витков</summary>
            <param name="smooth">Число сглаживаемых витков</param>
            <param name="degree">Число сглаживаемых витков</param>
            <remarks>Все значения должны быть нулевыми, или ненулевыми</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.EndRadius">
            <summary>Конечный радиус витка пружины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.StartRadius">
            <summary>Начальный радиус витка пружины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.Angle">
            <summary>Угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.Step">
            <summary>Шаг витка пружины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.Coils">
            <summary>Число витков</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.ContourSecondPoint">
            <summary>Вторая точка на профиле</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.ContourFirstPoint">
            <summary>Первая точка на профиле</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.Contour">
            <summary>Профиль, задающий сечение спирали</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.StartPoint">
            <summary>Установить стартовую точку</summary>
            <remarks>Параметр point может быть равен 0</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.SecondPoint">
            <summary>Вторая точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spiral.FirstPoint">
            <summary>Первая точка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Spiral.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Пружины</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="F:TFlex.Model.Model3D.Spiral.ProfileOrientationType.Ortogonal">
            <summary>Перпендикулярно</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Spiral.ProfileOrientationType.OrtogonalToAxis">
            <summary>Перпендикулярно оси</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Spiral.ProfileOrientationType.ParallelToAxis">
            <summary>Параллельно оси</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Spiral.ProfileOrientationType">
            <summary>Тип ориентации профиля</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Spiral.LengthType.CoilsAndStep">
            <summary>По числу витков и длине витка</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Spiral.LengthType.ByStep">
            <summary>По длине витка</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Spiral.LengthType.ByCoils">
            <summary>По числу витков</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Spiral.LengthType">
            <summary>Тип задания шага и длины пружины</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Spiral">
            <summary>Спираль</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.AlignAtEndPoint">
            <summary>Параметр выравнивания по конечному 3D-узлу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.AlignAtStartPoint">
            <summary>Параметр выравнивания по начальному 3D-узлу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.CounterClockwise">
            <summary>Параметр построения пружины против часовой стрелки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.LengthMethod">
            <summary>Тип</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.EndCut">
            <summary>Число шлифуемых конечных витков</summary>
            <remarks>endCut может быть равно 0</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.EndCompress">
            <summary>Число прижимаемых к концу витков</summary>
            <remarks>endCompress может быть равно 0</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.StartCut">
            <summary>Число шлифуемых начальных витков</summary>
            <remarks>startCut может быть равно 0</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.StartCompress">
            <summary>Число прижимаемых к началу витков</summary>
            <remarks>startCompress может быть равно 0</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.Segments">
            <summary>Число сегментов</summary>
            <remarks>Значение является целочисленным</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.EndRadius">
            <summary>Конечный радиус витка пружины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.StartRadius">
            <summary>Начальный радиус витка пружины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.Angle">
            <summary>Угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.CircleRadius">
            <summary>Радиус пружины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.Step">
            <summary>Шаг витка пружины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.Coils">
            <summary>Число витков</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.StartPoint">
            <summary>Стартовая точку</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.SecondPoint">
            <summary>Вторая точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Spring.FirstPoint">
            <summary>Первая точка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Spring.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Пружины</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="F:TFlex.Model.Model3D.Spring.LengthType.CoilsAndStep">
            <summary>По числу витков и длине витка</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Spring.LengthType.ByStep">
            <summary>По длине витка</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Spring.LengthType.ByCoils">
            <summary>По числу витков</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Spring.LengthType">
            <summary>Тип задания шага и длины пружины</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Spring">
            <summary>Пружина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CutOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CutOperation.Orientation">
            <summary>Направление сечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CutOperation.Offset">
            <summary>Значение отступа</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CutOperation.Workplane">
            <summary>Рабочая плоскость</summary>
            <remarks>Поверхость сечения может задаваться тремя взаимоисключающими путями :
    - набором секущих поверхностей;
    - рабочей плоскостью;
    - сечением.
</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.CutOperation.Section">
            <summary>Сечение</summary>
            <remarks>Поверхость сечения может задаваться тремя взаимоисключающими путями :
    - набором секущих поверхностей;
    - рабочей плоскостью;
    - сечением.
</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.CutOperation.Sheets">
            <summary>Множество секущих поверхностей</summary>
            <remarks>Поверхость сечения может задаваться тремя взаимоисключающими путями :
    - набором секущих поверхностей;
    - рабочей плоскостью;
    - сечением.
</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.CutOperation.Operation">
            <summary>Исходная операцию</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CutOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания отсечения</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.CutOperation">
            <summary>Операция отсечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sew.MakeSolid">
            <summary>Создавать твердое тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sew.Sheets">
            <summary>Множество сшиваемых тел</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Sew.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сшивки</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Sew">
            <summary>Операция сшивки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveAllCouplingPointVectors(System.Int32)">
            <summary>Удаляет все векторные условия в точках соответствия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetCouplingPointVectorCondition(System.Int32,System.Int32)">
            <summary>Получить векторное условие на направляющей</summary>
            <param name="couplingIndex">Индекс направляющей (начинается с нуля)</param>
            <param name="profileIndex">Номер профиля (начинается с нуля)</param>
            <returns>Векторное условие</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SetCouplingPointVector(System.Int32,System.Int32,TFlex.Model.Model3D.Loft.VectorDirection)">
            <summary>Задать векторное условие в точке соответствия</summary>
            <param name="couplingIndex">Индекс соответствия (начинается с нуля)</param>
            <param name="profileIndex">Номер профиля (начинается с нуля)</param>
            <param name="condition">Векторное граничное условие</param>
            <remarks>Векторные граничные условия не могут быть заданы, если для указанного профиля
задан другой тип граничного условия</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveAllGuideFaceConditions(System.Int32)">
            <summary>Удаляет все условия касания с гранью</summary>
            <param name="guideIndex">Индекс направляющей (начинается с нуля)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetGuideFaceConditionCount(System.Int32)">
            <summary>Получить число условий касаний с гранью</summary>
            <param name="guideIndex">Индекс направляющей (начинается с нуля)</param>
            <returns>Вектора заданный в точке</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetGuideFaceCondition(System.Int32,System.Int32)">
            <summary>Получить условие касания с гранью</summary>
            <param name="guideIndex">Индекс направляющей (начинается с нуля)</param>
            <param name="guideFaceConditionIndex">Индекс грани задающей каксательное условие</param>
            <returns>Граничное условие</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AddGuideFaceCondition(System.Int32,TFlex.Model.Model3D.Loft.FaceCondition)">
            <summary>Добавить условие касания с гранью</summary>
            <param name="guideIndex">Индекс направляющей (начинается с нуля)</param>
            <param name="condition">Граничное условие</param>
            <remarks>Грани должны стыковаться c направляющей.
Условия в виде граней не могут быть заданы, если для данной направляющей
задан другой тип граничного условия.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveAllGuideVectorConditions(System.Int32)">
            <summary>Удаляет все векторные условия</summary>
            <param name="guideIndex">Индекс направляющей</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetGuideVectorConditionCount(System.Int32)">
            <summary>Получить число векторных условий</summary>
            <param name="guideIndex">Индекс направляющей (начинается с нуля)</param>
            <returns>Число векторных условий</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetGuideVectorCondition(System.Int32,System.Int32)">
            <summary>Получить векторное условие на направляющей</summary>
            <param name="guideIndex">Индекс направляющей (начинается с нуля)</param>
            <param name="guideVectorConditionIndex">Номер векторного граничного условия</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AddGuideVectorCondition(System.Int32,TFlex.Model.Model3D.Loft.VectorCondition)">
            <summary>Добавить векторное условие на направляющей</summary>
            <param name="guideIndex">Индекс направляющей</param>
            <param name="condition">Векторное граничное условие</param>
            <remarks>Векторные граничные условия не могут быть заданы, если для данной направляющей 
задан другой тип граничного условия</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileFacesG2Condition(System.Int32)">
            <summary>Получить условие взятия 2-й производной с граней</summary>
            <param name="profileIndex">Индекс профиля</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SetProfileFacesG2Condition(System.Int32,System.Boolean)">
            <summary>Установить условие взятия 2-й производной с граней</summary>
            <param name="profileIndex">Индекс профиля</param>
            <param name="g2" />
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.CanSetProfileFacesG2Condition(System.Int32)">
            <summary>Узнать можно ли установить параметр взятия 2-й производной с граней</summary>
            <param name="profileIndex">Индекс профиля</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveAllProfileFaceConditions(System.Int32)">
            <summary>Удаляет все условия касания с гранью</summary>
            <param name="profileIndex">Индекс профиля</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileFaceConditionCount(System.Int32)">
            <summary>Получить число условий касаний с гранью</summary>
            <param name="profileIndex">Индекс профиля</param>
            <returns>Вектора заданный в точке</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileFaceCondition(System.Int32,System.Int32)">
            <summary>Получить условие касания с гранью</summary>
            <param name="profileIndex">Индекс профиля</param>
            <param name="profileFaceConditionIndex">Индекс профиля</param>
            <returns>Граничное условие</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AddProfileFaceCondition(System.Int32,TFlex.Model.Model3D.Loft.FaceCondition)">
            <summary>Добавить условие касания с гранью</summary>
            <param name="profileIndex">Индекс профиля (начинается нуля)</param>
            <param name="condition">Граничное условие</param>
            <remarks>Грани должны стыковаться к профилю.
Условия в виде граней не могут быть заданы, если для данного профиля
задан другой тип граничного условия.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveAllProfileVectorConditions(System.Int32)">
            <summary>Удаляет все векторные условия</summary>
            <param name="profileIndex">Индекс профиля (начинается нуля)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileVectorConditionCount(System.Int32)">
            <summary>Получить число векторных условий</summary>
            <param name="profileIndex">Индекс профиля</param>
            <returns>Число векторных условий заданных для профиля</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileVectorCondition(System.Int32,System.Int32)">
            <summary>Получить векторное условие на профиле</summary>
            <param name="profileIndex">Индекс профиля (начинается нуля)</param>
            <param name="profileVectorConditionIndex">Номер векторного граничного условия (начинается нуля)</param>
            <returns>Векторное условие на профиле</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AddProfileVectorCondition(System.Int32,TFlex.Model.Model3D.Loft.VectorCondition)">
            <summary>Добавить векторное условие на профиле</summary>
            <param name="profileIndex">Индекс профиля</param>
            <param name="condition">Векторное граничное условие</param>
            <remarks>Векторные граничные условия не могут быть заданы, если для данного профиля
задан другой тип граничного условия</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.LastDegenerateProfileCondition">
            <summary>Граничное условие для последнего вырожденного профиля, значение может быть равно 0</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.FirstDegenerateProfileCondition">
            <summary>Граничное условие для первого вырожденного профиля, значение может быть равно 0</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.LastEndProfileCondition">
            <summary>Специальное граничное условие для последнего профиля, condition может быть равно 0</summary>
            <remarks>Граниное условие для профиля может быть установлено, если:
Не задан первый вырожденный профиль.
Для профиля не задано векторное условие или условие касания с гранью.
Лофт не является периодическим.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.FirstEndProfileCondition">
            <summary>Cпециальное граничное условие для первого профиля, condition может быть равно 0</summary>
            <remarks>Граниное условие для профиля может быть установлено, если:
Не задан первый вырожденный профиль.
Для профиля не задано векторное условие или условие касания с гранью.
Лофт не является периодическим.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.KeepInitialSplitting">
            <summary>Сохранять исходное разбиение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.ThinWall">
            <summary>Тонкостенное построение</summary>
            <remarks>Если в качестве первого и/или последнего профиля выбрано листовое тело, то данная
опция позволяет построить Лофтинг без граней соответствующих первому и последнему профилю,
используя только их контуры.
Данная опция не может быть использована, если задано периодическое построение</remarks>
            <seealso cref="P:TFlex.Model.Model3D.Loft.Periodic" />
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.Linear">
            <summary>Линейчатая поверхность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.Periodic">
            <summary>Периодическое построение лофтинга</summary>
            <remarks>Данная опция не может быть использована, если задан вырожденный профиль,
или если задано граничное условие специфичное для первого или последнего профиля</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.CanSetPeriodic">
            <summary>Узнать можно ли установить параметр периодичности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.Tolerance">
            <summary>Точность</summary>
            <remarks>Для успешного посроения Лофтинга необходимо чтобы расстояние между профилями и
направляющими было меньше значения точности, и чтобы расстояния между вершинами контуров было
меньше 10 значений точности. Точность должна быть положительным числом, по умолчанию точность
равна 1E-5. В том случае если операция не складывается, можно попробовать увеличить или
уменьшить значение точности в 10 раз.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.ConvertAutomaticCouplingPoints">
            <summary>Конвертировать автоматические точки соответствия в типы PointVertex и PointEdge</summary>
            <remarks>После конвертации автоматических точек соответствия параметр установки
автоматических точек соответствия сбрасывается</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.IsAutomaticCouplingPointsSet">
            <summary>Получить параметр автоматических точек соответствия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SetAutomaticCouplingPoint">
            <summary>Установить автоматические точки соответствия</summary>
            <remarks>Автоматические точки соответствия позволяют автоматизировать
задание точек для простых профилей, для сложных профилей данную опцию
использовать не рекомендуется. Опция по умолчанию отключена.
Автоматические точки соответствия вычисляются каждый при изменении профилей
и зависят от установленных флагов реверса профилей.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.CanSetAutomaticCouplingPoint">
            <summary>Узнать можно ли установить автоматические точки соответствия</summary>
            <remarks>Автоматические точки соответствия могут быть установлены при выполнении
следующих условий:
1. Все контуры плоские.
2. Все контуры замкнуты.
3. Все или все кроме одного контуры профилей являются G1-непрерывными.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.ResetCouplingPoint(System.Int32,System.Int32)">
            <summary>Задать точку соответствия</summary>
            <param name="couplingIndex">Индекс последовательности точек соответствия</param>
            <param name="profileIndex">Индекс точки в последовательности точек соответствия.</param>
            <seealso cref="M:TFlex.Model.Model3D.Loft.RemoveCoupling(System.Int32)" />
            <seealso cref="M:TFlex.Model.Model3D.Loft.ResetCouplingPoint(System.Int32,System.Int32)" />
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetCouplingPoint(System.Int32,System.Int32)">
            <summary>Задать точку соответствия</summary>
            <param name="couplingIndex">Индекс последовательности точек соответствия</param>
            <param name="profileIndex">Индекс точки в последовательности точек соответствия.</param>
            <returns>Точка лежащая на соответствующем профиле</returns>
            <seealso cref="M:TFlex.Model.Model3D.Loft.RemoveCoupling(System.Int32)" />
            <seealso cref="M:TFlex.Model.Model3D.Loft.ResetCouplingPoint(System.Int32,System.Int32)" />
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SetCouplingPoint(System.Int32,System.Int32,TFlex.Model.Model3D.Loft.PointOnContour)">
            <summary>Задать точку соответствия</summary>
            <param name="couplingIndex">Индекс последовательности точек соответствия</param>
            <param name="profileIndex">Индекс точки в последовательности точек соответствия</param>
            <param name="point">Точка лежащая на соответствующем профиле</param>
            <seealso cref="M:TFlex.Model.Model3D.Loft.RemoveCoupling(System.Int32)" />
            <seealso cref="M:TFlex.Model.Model3D.Loft.ResetCouplingPoint(System.Int32,System.Int32)" />
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveCoupling(System.Int32)">
            <summary>Удалить последовательность точек соответсвия</summary>
            <param name="couplingIndex">Индекс последовательности точек соответствия</param>
            <remarks>Для 0-го соответствия (couplingIndex=0) эта операция интерпретируется как
удаление стартовых точек соответствия (они заменяются на стартовые точки
по умолчанию), само соответствие не удаляется</remarks>
            <seealso cref="M:TFlex.Model.Model3D.Loft.RemoveCoupling(System.Int32)" />
            <seealso cref="M:TFlex.Model.Model3D.Loft.ResetCouplingPoint(System.Int32,System.Int32)" />
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.InsertCoupling(System.Int32)">
            <summary>Вставить последовательность точек соответсвия</summary>
            <param name="couplingIndex">Индекс последовательности точек соответствия</param>
            <seealso cref="M:TFlex.Model.Model3D.Loft.RemoveCoupling(System.Int32)" />
            <seealso cref="M:TFlex.Model.Model3D.Loft.SetCouplingPoint(System.Int32,System.Int32,TFlex.Model.Model3D.Loft.PointOnContour)" />
            <remarks>Последовательность точек соответствия проходит через все невырожденные профили.
Всегда существует последовательность точек соответствия с нулевым индексом,
включающая стартовые точки по умолчанию со всех невырожденных профилей.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.Path">
            <summary>Путь</summary>
            <remarks>Путь не может бть установлен, если задана направляющая</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetGuideVectorScaleFlag(System.Int32)">
            <summary>Возвращает параметр интерпретации коэффициента касательного вектора</summary>
            <param name="guideIndex">Номер направляющей параметр которой возвращается</param>
            <remarks>Если параметр не установлен (по умолчанию), то коэффициент интерпретируется
как длина вектора, если параметр установлен то коэффициент интерпретируется как масштабный коэффициент</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SetGuideVectorScaleFlag(System.Int32,System.Boolean)">
            <summary>Устанавливает параметр использования коэффициента касательного вектора как масштабного</summary>
            <param name="guideIndex">Номер направляющей реверс которого возвращается</param>
            <param name="scale">true - интерпретировать значение как масштабный коэффициент,
false - интерпретировать значение как длину</param>
            <remarks>По умолчанию параметр отключен</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.GuideAutoReverse">
            <summary>Автореверс для направляющих</summary>
            <remarks>По умолчанию автореверс включен. Автореверс имеет смысл только для замкнутых направляющих
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetGuideReverse(System.Int32)">
            <summary>Возвращает реверс направляющей</summary>
            <param name="guideIndex">Номер направляющей (начинается с 0)</param>
            <returns>Параметр реверса данной направляющей</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SetGuideReverse(System.Int32,System.Boolean)">
            <summary>Установить реверс направляющей</summary>
            <param name="guideIndex">Номер направляющей (начинается с 0)</param>
            <param name="reverse">Параметр реверса для данной направляющей</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetGuideContourCount(System.Int32)">
            <summary>Возвращает число контуров направляющей</summary>
            <param name="guideIndex">Номер направляющей (начинается с 0)</param>
            <returns>Число контуров в профиле</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetGuideContour(System.Int32,System.Int32)">
            <summary>Возвращает контур направляющей</summary>
            <param name="guideIndex">Номер направляющей (начинается с 0)</param>
            <param name="contourIndex">Номер контура направляющей (начинается с 0)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveAllGuideContours(System.Int32)">
            <summary>Удалить все контуры направляющей</summary>
            <param name="guideIndex">Номер направляющей (начинается с 0)</param>
            <remarks>После вызова данной функции направляющая становится пустой</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveGuideContour(System.Int32,System.Int32)">
            <summary>Удалить контур направляющей</summary>
            <param name="guideIndex">Номер направляющей (начинается с 0)</param>
            <param name="contourIndex">Номер удаляемого контура (начинается с 0)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AddGuideContour(System.Int32,TFlex.Model.Model3D.Geometry.ModelContour)">
            <summary>Добавить контур к направляющей</summary>
            <param name="guideIndex">Номер направляющей (начинается с 0)</param>
            <param name="contour">Добавляемый контур</param>
            <remarks>Все контуры направляющей в списке одного типа: все листовые или все проволочные</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.GuideCount">
            <summary>Получить число направляющих</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveGuide(System.Int32)">
            <summary>Удалить направляющую из списка направляющих</summary>
            <param name="guideIndex">Номер удаляемой направляющей (начинается с 0)</param>
            <seealso cref="M:TFlex.Model.Model3D.Loft.InsertGuide(System.Int32,TFlex.Model.Model3D.Geometry.ModelContour)" />
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.InsertGuide(System.Int32,TFlex.Model.Model3D.Geometry.ModelContour)">
            <summary>Вставить направляющую в список направляющих</summary>
            <param name="guideIndex">Номер добавляемой направляющей (начинается с 0)</param>
            <remarks>После добавления направляющей её нужно наполнить контурами с помощью функции
AddGuideContour</remarks>
            <seealso cref="M:TFlex.Model.Model3D.Loft.RemoveGuide(System.Int32)" />
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AddGuide(TFlex.Model.Model3D.Geometry.ModelContour)">
            <summary>Добавить направляющую</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.LastDegenerateProfile">
            <summary>Последний вырожденный профиль</summary>
            <remarks>Вырожденный профиль представляет из себя точку</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.FirstDegenerateProfile">
            <summary>Первый вырожденный профиль</summary>
            <remarks>Вырожденный профиль представляет из себя точку</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileVectorScaleFlag(System.Int32)">
            <summary>Возвращает параметр интерпретации коэффициента касательного вектора</summary>
            <param name="profileIndex">Номер профиля для которого задаётся параметр</param>
            <remarks>Если параметр не установлен (по умолчанию), то коэффициент интерпретируется
как длина вектора, если параметр установлен то коэффициент интерпретируется как масштабный коэффициент</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SetProfileVectorScaleFlag(System.Int32,System.Boolean)">
            <summary>Устанавливает параметр использования коэффициента касательного вектора как масштабного</summary>
            <param name="profileIndex">Номер профиля реверс которого возвращается</param>
            <param name="scaleFlag">true - интерпретирвать значение как масштабный коэффициент
false - интерпретировать значение как длину</param>
            <remarks>По умолчанию параметр отключен</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.ProfileAutoReverse">
            <summary>Автореверс для профилей</summary>
            <remarks>По умолчанию автореверс включен. Автореверс имеет смысл только для замкнутых профилей.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileReverse(System.Int32)">
            <summary>Возвращает реверс профиля</summary>
            <param name="profileIndex">Номер профиля (начинается с 0)</param>
            <returns>Параметр реверса</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SetProfileReverse(System.Int32,System.Boolean)">
            <summary>Установить реверс профиля</summary>
            <param name="profileIndex">Номер профиля (начинается с 0)</param>
            <param name="reverse">Параметр реверса</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileContourCount(System.Int32)">
            <summary>Возвращает число контуров профиля</summary>
            <param name="profileIndex">Номер профиля (начинается с 0)</param>
            <returns>Число контуров в профиле</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.GetProfileContour(System.Int32,System.Int32)">
            <summary>Возвращает контур профиля</summary>
            <param name="profileIndex">Номер профиля (начинается с 0)</param>
            <param name="contourIndex">Номер контура профиля (начинается с 0)</param>
            <returns>Контур профиля</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveAllProfileContours(System.Int32)">
            <summary>Удалить все контуры профиля</summary>
            <param name="profileIndex">Номер профиля (начинается с 0)</param>
            <remarks>После вызова данной функции профиль становится пустым</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveProfileContour(System.Int32,System.Int32)">
            <summary>Удалить контур профиля</summary>
            <param name="profileIndex">Номер профиля (начинается с 0)</param>
            <param name="contourIndex">Номер удаляемого контура (начинается с 0)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AddProfileContour(System.Int32,TFlex.Model.Model3D.Geometry.ModelContour)">
            <summary>Добавить контур к профилю</summary>
            <param name="profileIndex">Номер профиля (начинается с 0)</param>
            <param name="contour">Добавляемый контур</param>
            <remarks>Все контуры профиля в списке одного типа: все листовые или все проволочные</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.ProfileCount">
            <summary>Получить число профилей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.RemoveProfile(System.Int32)">
            <summary>Удалить профиль из списка профилей</summary>
            <param name="profileIndex">Номер удаляемого профиля (начинается с 0)</param>
            <seealso cref="M:TFlex.Model.Model3D.Loft.InsertProfile(System.Int32,TFlex.Model.Model3D.Geometry.ModelContour)" />
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.InsertProfile(System.Int32,TFlex.Model.Model3D.Geometry.ModelContour)">
            <summary>Вставить профиль в список профилей</summary>
            <param name="profileIndex">Номер добавляемого профиля (начинается с 0)</param>
            <remarks>После добавления профиля его нужно наполнить контурами с помощью функции AddProfileContour.
Операция Лофтинга должна иметь как минимум один невырожденный профиль заданный с помощью контуров</remarks>
            <seealso cref="M:TFlex.Model.Model3D.Loft.AddProfile(TFlex.Model.Model3D.Geometry.ModelContour)" />
            <seealso cref="M:TFlex.Model.Model3D.Loft.RemoveProfile(System.Int32)" />
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AddProfile(TFlex.Model.Model3D.Geometry.ModelContour)">
            <summary>Добавить профиль</summary>
            <param name="contour">Контур с объекта модели</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Лофтинга</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.FaceCondition.Magnitude">
            <summary>Возвращает коэффициент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.FaceCondition.Face">
            <summary>Возвращает грань</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.FaceCondition.#ctor(TFlex.Model.Model3D.Geometry.ModelFace,TFlex.Model.Parameter)">
            <summary>Конструктор для создания условия касания с гранью</summary>
            <param name="face">Грань</param>
            <param name="magnitude">Коэффициент</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.FaceCondition">
            <summary>Класс для задания граничного условия касательного к грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.VectorCondition.Vector">
            <summary>Возвращает направление вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.VectorCondition.Point">
            <summary>Возвращает точку на контуре</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.VectorCondition.#ctor(TFlex.Model.Model3D.Loft.PointOnContour,TFlex.Model.Model3D.Loft.VectorDirection)">
            <summary>Конструктор для условия касания с гранью</summary>
            <param name="point">Точка на контуре</param>
            <param name="vector">Направление вектора</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.VectorCondition">
            <summary>Класс для задания векторного условия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.DirectionVector.Direction">
            <summary>Получить направление вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.DirectionVector.Magnitude">
            <summary>Получить коэффициент вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.DirectionVector.Type">
            <summary>Получить тип векторного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.DirectionVector.#ctor(TFlex.Model.Model3D.Geometry.ModelDirection,TFlex.Model.Parameter)">
            <summary>Конструктор для задания вектора с помощью направления</summary>
            <param name="direction">Направление вектора</param>
            <param name="magnitude">Величина коэффициента</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.DirectionVector">
            <summary>Класс для задания вектора с помощью направления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SecondPointVector.SecondPoint">
            <summary>Возвращает вторую точку вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SecondPointVector.Magnitude">
            <summary>Получить коэффициент вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SecondPointVector.Type">
            <summary>Получить тип векторного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SecondPointVector.#ctor(TFlex.Model.Model3D.Geometry.ModelPoint3D,TFlex.Model.Parameter)">
            <summary>Конструктор для задания вектора с помощью второй точки</summary>
            <param name="secondPoint">Вторая точка вектора</param>
            <param name="magnitude">Величина коэффициента</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.SecondPointVector">
            <summary>Класс для задания вектора с помощью второй точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SphereVector.LocalSystem">
            <summary>Получить локальную систему координат</summary>
            <remarks>Значение равно нулю если установлена глобальная система координат</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SphereVector.Theta">
            <summary>Возвращает координату Theta</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SphereVector.Phi">
            <summary>Возвращает координату Phi</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SphereVector.Magnitude">
            <summary>Получить коэффициент вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SphereVector.Type">
            <summary>Получить тип векторного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SphereVector.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Model3D.LCS)">
            <summary>Конструктор для задания вектора в сферических координат
заданных в локальной системе координат</summary>
            <param name="phi">Координата Phi в локальной системе координат</param>
            <param name="theta">Координата Theta в локальной системе координат</param>
            <param name="magnitude">Величина коэффициента</param>
            <param name="lcs">Локальная система координат</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SphereVector.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор для задания вектора в сферических координатах
заданных в локальной системе координат</summary>
            <param name="phi">Координата Phi в локальной системе координат</param>
            <param name="theta">Координата Theta в локальной системе координат</param>
            <param name="magnitude">Величина коэффициента</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.SphereVector">
            <summary>Класс для задания вектора в абсолютных или относительных сферических координатах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.XyzVector.LocalSystem">
            <summary>Получить локальную систему координат</summary>
            <remarks>Значение равно нулю если установлена глобальная система координат</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.XyzVector.Z">
            <summary>Возвращает координату Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.XyzVector.Y">
            <summary>Возвращает координату Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.XyzVector.X">
            <summary>Возвращает координату X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.XyzVector.Magnitude">
            <summary>Получить коэффициент вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.XyzVector.Type">
            <summary>Получить тип векторного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.XyzVector.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Model3D.LCS)">
            <summary>Конструктор для задания вектора с помощью координат X, Y, Z
заданных в локальной системе координат</summary>
            <param name="x">Координата X в локальной системе координат</param>
            <param name="y">Координата Y в локальной системе координат</param>
            <param name="z">Координата Z в локальной системе координат</param>
            <param name="magnitude">Величина коэффициента</param>
            <param name="lcs">Локальная система координат</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.XyzVector.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор для задания вектора с помощью координат X, Y, Z
заданных в локальной системе координат</summary>
            <param name="x">Координата X в локальной системе координат</param>
            <param name="y">Координата Y в локальной системе координат</param>
            <param name="z">Координата Z в локальной системе координат</param>
            <param name="magnitude">Величина коэффициента</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.XyzVector">
            <summary>Класс для задания векторного условия с помощью абсолютных или относительных координат X, Y, Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.VectorDirection.Type">
            <summary>Получить тип векторного условия</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.VectorDirection">
            <summary>Базовый класс для задания направления вектора для векторного граничного условия</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.VectorType.VectorGeomDirection">
            <summary>Направление вектора задаётся с геометрического направления</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.VectorType.VectorSecondPoint">
            <summary>Направление вектора задаётся с второй точки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.VectorType.VectorSphere">
            <summary>Направление вектора задаётся с помощью абсолютных или относительных сферических координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.VectorType.VectorXYZ">
            <summary>Направление вектора задаётся с помощью абсолютных или относительных X, Y, Z координат</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.VectorType">
            <summary>Тип векторного условия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.DirectionDegenerateProfileCondition.Magnitude">
            <summary>Получить коэффициент граничного условия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.DirectionDegenerateProfileCondition.Direction">
            <summary>Возвращает направление вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.DirectionDegenerateProfileCondition.Type">
            <summary>Получить тип граничного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.DirectionDegenerateProfileCondition.#ctor(TFlex.Model.Model3D.Geometry.ModelDirection,TFlex.Model.Parameter)">
            <summary>Конструктор для создания граничного условия c направления вектора</summary>
            <param name="direction">Направление</param>
            <param name="magnitude">Коэффициент граничного условия</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.DirectionDegenerateProfileCondition">
            <summary>Класс для задания граничного условия для вырожденного профиля с помощью геометрического направления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SecondPointDegenerateProfileCondition.Magnitude">
            <summary>Получить коэффициент граничного условия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SecondPointDegenerateProfileCondition.SecondPoint">
            <summary>Получить вторую точку</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.SecondPointDegenerateProfileCondition.Type">
            <summary>Получить тип граничного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.SecondPointDegenerateProfileCondition.#ctor(TFlex.Model.Model3D.Geometry.ModelPoint3D,TFlex.Model.Parameter)">
            <summary>Конструктор для создания граничного условия c помощью второй точки</summary>
            <param name="secondPoint">Вторая точка вектора</param>
            <param name="magnitude">Коэффициент граничного условия</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.SecondPointDegenerateProfileCondition">
            <summary>Класс для задания граничного условия для вырожденного профиля с помощью второй точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.DegenerateProfileCondition.Type">
            <summary>Получить тип граничного условия</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.DegenerateProfileCondition">
            <summary>Класс для задания граничного условия для вырожденного профиля</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.DegenerateProfileConditionType.Direction">
            <summary>Направление вектора задаётся геометрическим направлением</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.DegenerateProfileConditionType.SecondPoint">
            <summary>Направление вектора задаётся второй точкой</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.DegenerateProfileConditionType">
            <summary>Тип граничного условия для вырожденного профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.TangentOperationEndProfileCondition.Magnitude">
            <summary>Получить коэффициент граничного условия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.TangentOperationEndProfileCondition.Operation">
            <summary>Получить операцию</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.TangentOperationEndProfileCondition.Type">
            <summary>Получить тип граничного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.TangentOperationEndProfileCondition.#ctor(TFlex.Model.Model3D.Operation,TFlex.Model.Parameter)">
            <summary>Конструктор для создания условий касательных к граням операции</summary>
            <remarks>Формируется набор векторных условий, касательных к профилю и направленных по боковым граням операции.
Торцевая грань операции должна прилегать к профилю.</remarks>
            <param name="magnitude">Коэффициент граничного условия</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.TangentOperationEndProfileCondition">
            <summary>Класс для задания касательных условий к профилю берущихся с граней тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.NormalFirstToLastEndProfileCondition.Magnitude">
            <summary>Получить коэффициент граничного условия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.NormalFirstToLastEndProfileCondition.Type">
            <summary>Получить тип граничного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.NormalFirstToLastEndProfileCondition.#ctor(TFlex.Model.Parameter)">
            <summary>Конструктор для создания условия нормали к профилю</summary>
            <remarks>Нормальный вектор направлен от первого профилю к последнему</remarks>
            <param name="magnitude">Коэффициент граничного условия</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.NormalFirstToLastEndProfileCondition">
            <summary>Класс для задания граничного условия по нормали (от первого к последнему профилю) для первого или последнего профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.NormalOutsideEndProfileCondition.Magnitude">
            <summary>Получить коэффициент граничного условия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.NormalOutsideEndProfileCondition.Type">
            <summary>Получить тип граничного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.NormalOutsideEndProfileCondition.#ctor(TFlex.Model.Parameter)">
            <summary>Конструктор для создания условия нормали к профилю</summary>
            <remarks>Нормальный вектор направлен наружу</remarks>
            <param name="magnitude">Коэффициент граничного условия</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.NormalOutsideEndProfileCondition">
            <summary>Класс для задания граничного условия по нормали (наружу) для первого или последнего профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.TangentEndProfileCondition.Magnitude">
            <summary>Получить коэффициент граничного условия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.TangentEndProfileCondition.Type">
            <summary>Получить тип граничного условия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.TangentEndProfileCondition.#ctor(TFlex.Model.Parameter)">
            <summary>Конструктор для создания касательного условия к профилю</summary>
            <param name="magnitude">Коэффициент граничного условия</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.TangentEndProfileCondition">
            <summary>Класс для задания касательного граничного условия для первого или последнего профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.EndProfileCondition.Type">
            <summary>Получить тип граничного условия</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.EndProfileCondition">
            <summary>Базовый класс для задания граничного условия для первого или последнего профиля</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.EndProfileConditionType.TangentOperation">
            <summary>Касательные условия берутся с тела</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.EndProfileConditionType.NormalFirstToLast">
            <summary>По нормали в сторону от первого профиля к последнему (cовместимость с версией 7.2)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.EndProfileConditionType.NormalOutside">
            <summary>По нормали наружу</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.EndProfileConditionType.Tangent">
            <summary>По касательной к профилю</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.EndProfileConditionType">
{
double get();
}
{
double get();
}
{
double get();
}
<summary>Тип условия для первого или последнего профиля</summary></member>
        <member name="P:TFlex.Model.Model3D.Loft.AutomaticXyzPoint.Z">
            <summary>Возвращает координату Z точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.AutomaticXyzPoint.Y">
            <summary>Возвращает координату Y точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.AutomaticXyzPoint.X">
            <summary>Возвращает координату X точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.AutomaticXyzPoint.Type">
            <summary>Получить тип точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.AutomaticXyzPoint.#ctor(System.Double,System.Double,System.Double)">
            <summary>Конструктор для создания точки по абсолютным координатам</summary>
            <param name="x">Координата X</param>
            <param name="y">Координата Y</param>
            <param name="z">Координата Z</param>
            <remarks>Расстояние между координатами точки и контуром
должно быть меньше значения Tolerance.
Созданная точка в классе Loft сохраняется с типом PointVertex
если расстояние между координатами точки и ближайшей вершиной контура
меньше значения Tolerance или в тип PointEdge в противном случае</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.AutomaticXyzPoint">
            <summary>Класс автоматической точки соответствия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.EdgePoint.Value">
            <summary>Возвращает параметр задания точки на ребре</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.EdgePoint.Edge">
            <summary>Возвращает ребро на котором была построена точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.EdgePoint.Type">
            <summary>Получить тип точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.EdgePoint.#ctor(TFlex.Model.Model3D.Geometry.ModelEdge,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="edge">Ребро на котором создаётся точка</param>
            <param name="value">Значение от 0 до 1 характеризующее положение точки на ребре</param>
            <remarks>Направление обхода ребра совпадает с направлением обхода контура</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.EdgePoint">
            <summary>Класс для задания точки в вершине</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.VertexPoint.Vertex">
            <summary>Возвращает вершину которая используется в качестве точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.VertexPoint.Type">
            <summary>Тип точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.VertexPoint.#ctor(TFlex.Model.Model3D.Geometry.ModelVertex)">
            <summary>Конструктор</summary>
            <param name="vertex">Вершина в которой создаётся точка</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.VertexPoint">
            <summary>Класс для задания точки в вершине</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.NodePoint.Node">
            <summary>Узел, который используется в качестве точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.NodePoint.Type">
            <summary>Тип точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Loft.NodePoint.#ctor(TFlex.Model.Model3D.Node3D)">
            <summary>Конструктор</summary>
            <param name="node">3D Узел в котором создаётся точка</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.NodePoint">
            <summary>Класс для задания точки в 3D узле</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Loft.PointOnContour.Type">
            <summary>Способ задания точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.PointOnContour">
            <summary>Базовый класс для задания точки на контуре сечения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.PointType.PointAutomaticXYZ">
            <summary>Точка создана с помощью автоматической расстановки точек (данный тип возможен только для точек соответствия)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.PointType.PointEdge">
            <summary>Точка создана на ребре</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.PointType.PointVertex">
            <summary>Точка создана в вершине</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Loft.PointType.PointNode">
            <summary>Точка создана в 3D-узле</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft.PointType">
            <summary>Тип условия задания точки на контуре сечения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Loft">
            <summary>Операция "по сечениям"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.ScaleLaw">
            <summary>Табличная функция, задающая зависимость масштаба от положения на пути в процентах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.TwistLaw">
            <summary>Табличная функция, задающая зависимость угла кручения от положения на пути в процентах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.TwistLawType">
            <summary>Способ определения направления при задании закона кручения составным путём</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.ScaleLawType">
            <summary>Способ определения направления при задании закона масштабирования составным путём</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.LawType.ByOffset">
            <summary>По смещению</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.LawType.ByParameter">
            <summary>По параметру</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.LawType.PerpendicularToPath">
            <summary>Перпендикулярно пути</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.LawType.MinimalDistance">
            <summary>По минимальному расстоянию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Swept.LawType">
            <summary>Способы определения направления при задании законов составными путями</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.Scaling">
            <summary>Тип масштабирования</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.ScaleType.PositionAndSize">
            <summary>Масштабировать относительной положение образующего контура к пути и размер образующего контура</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.ScaleType.OnlySize">
            <summary>Масштабировать размер образующего контура, но сохранять относительное положение образующего контура к пути</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.ScaleType.OnlyPosition">
            <summary>Масштабировать относительной положение образующего контура к пути, но сохранять размер образующего контура</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Swept.ScaleType">
            <summary>Типы масштабирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.ScalePoint">
            <summary>Точка масштабирования</summary>
            <remarks>Точка масштабирования используется, если есть путь, задающий закон масштабирования</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.TwistSheet">
            <summary>Составной лист, задающий закон вращения</summary>
            <remarks>Закон кручения может задаваться тремя взаимоисключающими способами :
- Составным путём;
- Табличной функцией, задающей зависимость угла кручения от положения на пути в процентах;
- Составным листом, задающим закон кручения.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.ScalePath">
            <summary>Составной путь, задающий закон масштабирования</summary>
            <remarks>Закон масштабирования может задаваться двумя взаимоисключающими способами :
- Составным путём;
- Табличной функцией, задающей зависимость масштаба от положения на пути в процентах.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.TwistPath">
            <summary>Составной путь, задающий закон кручения</summary>
            <remarks>Закон кручения может задаваться тремя взаимоисключающими способами :
- Составным путём;
- Табличной функцией, задающей зависимость угла кручения от положения на пути в процентах;
- Составным листом, задающим закон кручения.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.GuidePath">
            <summary>Составной путь, задающий движение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Swept.CancelBinding">
            <summary>Отмена привязки контура к пути по точкам</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.ReferencePoint">
            <summary>Точка для задания поворота контура</summary>
            <remarks>Точка для задания поворота контура задаётся одновременно со второй точкой привязки</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.SecondPoint">
            <summary>Вторая точка для привязки контура</summary>
            <remarks>Вторая точка привязки задаётся одновременно с точкой для задания поворота контура</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.StartPoint">
            <summary>Точка для размещения контура в начало траектории</summary>
            <remarks>Если точка не задана, то начальное положение контура не изменяется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.Accuracy">
            <summary>Точность геометрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.Simplify">
            <summary>Параметр упрощения геометрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.Synchronize">
            <summary>Синхронизация начала пути с положением контура</summary>
            <remarks>Это свойство актуально для замкнутых путей, когда стартовая точка актуальна для получения правильного пути</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Swept.Orientation">
            <summary>Ориентация контура</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.Alignment.Parallel">
            <summary>Параллельно самому себе</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Swept.Alignment.Normal">
            <summary>Перпендикулярно пути</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Swept.Alignment">
            <summary>Тип ориентации контура</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Swept.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операции по траектории</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Swept">
            <summary>Операция по траектории</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SheetMetalFeature.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SheetMetalFeature.PathName">
            <summary>Получить путь к файлу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SheetMetalFeature.FileName">
            <summary>Имя файла штамповки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SheetMetalFeature.Contour">
            <summary>Контур</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SheetMetalFeature.#ctor(TFlex.Model.Document,System.String)">
            <summary>Конструктор для операции "Выштамповка"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="fileName">Имя файла выштамповки</param>
        </member>
        <member name="T:TFlex.Model.Model3D.SheetMetalFeature">
            <summary>Операция "Выштамповка"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SheetMetalPart.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SheetMetalPart.Type">
            <summary>Положение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.SheetMetalPart.ExtrusionType.Summary">
            <summary>В обе стороны</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.SheetMetalPart.ExtrusionType.Down">
            <summary>В низ</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.SheetMetalPart.ExtrusionType.Up">
            <summary>В вверх</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.SheetMetalPart.ExtrusionType">
            <summary>Тип позиции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SheetMetalPart.Thickness">
            <summary>Толщина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SheetMetalPart.Profiles">
            <summary>Образующие контуры</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SheetMetalPart.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Листовая заготовка"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.SheetMetalPart">
            <summary>Операция "Листовая заготовка"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Rebend.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Rebend.KeptPlanarFace">
            <summary>Неподвижная грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Rebend.CylindricalFaces">
            <summary>Цилиндрические поверхности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Rebend.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Повторная гибка"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Rebend">
            <summary>Операция "Повторная гибка"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Unbend.GetLengthArray">
            <summary>Получить список длин гибов</summary>
            <returns>Список длин гибов</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Unbend.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Unbend.NLF">
            <summary>Коэффициент нейтрального слоя</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Unbend.AutoNLF">
            <summary>Используется ли автоматический поиск коэффициента нейтрального слоя</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Unbend.KeptPlanarFace">
            <summary>Неподвижная грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Unbend.CylindricalFaces">
            <summary>Получить цилиндрические поверхности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Unbend.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Разгибка"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Unbend">
            <summary>Операция "Разгибка"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.AutoNLF">
            <summary>Используется ли автоматический поиск коэффициента нейтрального слоя</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.Position">
            <summary>Положение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.PositionType.Center">
            <summary>В центре</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.PositionType.End">
            <summary>В конце</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.PositionType.Start">
            <summary>В начале</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.PositionType.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Bend.PositionType">
            <summary>Тип позиции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.ReverseAngle">
            <summary>Направление отсчёта угла поворота(в сторону лицевой грани или от неё)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.CutTill">
            <summary>Ослабление насквозь</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.Shape">
            <summary>Тип выреза</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.TillShape.Square">
            <summary>Квадратный</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.TillShape.Round">
            <summary>Круглый</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.TillShape.None">
            <summary>Отсутствует</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.TillShape.Default">
            <summary>Из статуса</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Bend.TillShape">
            <summary>Тип выреза</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.Type">
            <summary>Тип операции</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.OperationType.CutAndBend">
            <summary>Отогнуть</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.OperationType.AttachFlange">
            <summary>Приклеить язычок</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Bend.OperationType.Bending">
            <summary>Согнуть</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Bend.OperationType">
            <summary>Тип операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.Offset">
            <summary>Отступ</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.CornerWidth">
            <summary>Ширина ослабления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.CornerDepth">
            <summary>Глубина ослабления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.RightOffset">
            <summary>Правый отступ</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.LeftOffset">
            <summary>Левый отступ</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.Length">
            <summary>Длина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.NLF">
            <summary>Коэффициент нейтрального слоя</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.Angle">
            <summary>Угол гиба</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.Radius">
            <summary>Радиус гиба</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.BendAxis">
            <summary>Ось гиба</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.BendAxisPoint2">
            <summary>Вторая точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.BendAxisPoint1">
            <summary>Первая точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Bend.Face">
            <summary>Отгибаемая грань</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Bend.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Гибка"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Bend">
            <summary>Операция "Гибка"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Separation.Source">
            <summary>Разделяемая операция</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Separation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Разделение"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Separation">
            <summary>Операция "Разделение"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Rotation.StartAngle">
            <summary>Начальный угол вращения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Rotation.Angle">
            <summary>Угол вращения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Rotation.SecondAnglePoint">
            <summary>Конечная точка вращения</summary>
            <remarks>Если задаются и начальная и конечная точки вращения, то угол определяется автоматически</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Rotation.FirstAnglePoint">
            <summary>Начальная точка вращения</summary>
            <remarks>Если задаются и начальная и конечная точки вращения, то угол определяется автоматически.
Если задаётся начальная точка вращения, то начальный угол также будет определён автоматически</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Rotation.SecondAxisPoint">
            <summary>Вторая точка, задающая ось вращения</summary>
            <remarks>Ось вращения в явном виде задаётся осью или двумя точками</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Rotation.FirstAxisPoint">
            <summary>Первая точка, задающая ось вращения</summary>
            <remarks>Ось вращения в явном виде задаётся осью или двумя точками</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Rotation.RotationAxis">
            <summary>Ось вращения</summary>
            <remarks>Ось вращения в явном виде задаётся осью или двумя точками</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Rotation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания вращения</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Rotation">
            <summary>Операция вращения</summary>
            <example>
                <code name="Вращение">
public static void Rotation()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("операция вращения");//Открытие блока изменений документа	
	
   //создание узлов
   FreeNode fn1 = new FreeNode(document, 10, 10);
   FreeNode fn2 = new FreeNode(document, 40, 30);
   FreeNode fn3 = new FreeNode(document, 70, 10);
   //соединяем их линиями	
   ConstructionOutline l1 = new ConstructionOutline(document, fn1, fn2);
   ConstructionOutline l2 = new ConstructionOutline(document, fn2, fn3);
   ConstructionOutline l3 = new ConstructionOutline(document, fn3, fn1);
   //рабочая плоскость
   StandardWorkplane swp = new StandardWorkplane(document, StandardWorkplane.StandardType.Left); 
   //профиль, построенный по эскизу
   SketchProfile sp = new SketchProfile(document);
   sp.WorkSurface = swp;//устновка поверхности, с которой берётся эскиз
   //создание 3D узла
   CoordinateNode3D node1 = new CoordinateNode3D(document); 
   node1.X = 0; node1.Y = 0; node1.Z = 0; 
   //операция вращения
   Rotation rotation = new Rotation(document);
   rotation.Profile.Add(sp.Geometry.SheetContour);//задание контура
   rotation.Angle = 180;//угол вращения
	
   /*ось вращения из системы координат
   PointsLCS lcs = new PointsLCS(document);//создание системы коориднат 
   lcs.PointToOrigin = node1.Geometry.Point;//начало системы коориднат
   rotation.RotationAxis = lcs.Geometry.AxisZ;//ось вращения - ось Z системы координат*/

   //ось вращения, заданная двумя точками
   CoordinateNode3D node2 = new CoordinateNode3D(document); 
   node1.X =20; node1.Y = 20; node1.Z = 0;
   rotation.FirstAxisPoint = node1.Geometry.Point;
   rotation.SecondAxisPoint = node2.Geometry.Point;

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model3D.DynamicStudy.Solve(TFlex.Model.Model3D.DynamicStudy.SolveCallback)">
            <summary>Рассчитать задачу с возможностью досрочной остановки расчёта</summary>
            <param name="callback">Функция, вызываемая в конце каждого шага симуляции. Возврат значения false сигнализирует о необходимости прервать расчёт</param>
            <remarks>Функция, переданная в параметре callback, не должна каким-либо образом изменять состояние относящихся к задаче объектов, так как это может привести к нежелательным последствиям</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.DynamicStudy.Solve">
            <summary>Рассчитать задачу</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.DynamicStudy.GetRestraint(System.Int32)">
            <summary>Получить нагружение по номеру</summary>
            <param name="index">Номер нагружения</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество элементов, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.DynamicStudy.RestraintCount">
            <summary>Количество нагружений</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.DynamicStudy.GetSensor(System.Int32)">
            <summary>Получить датчик по номеру</summary>
            <param name="index">Номер датчика</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество элементов, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.DynamicStudy.SensorCount">
            <summary>Количество датчиков</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DynamicStudy.Frame">
            <summary>Текущий кадр моделирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DynamicStudy.Time">
            <summary>Текущее время моделирования</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.DynamicStudy">
            <summary>Задача динамического анализа</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CAEStudy.Solve">
            <summary>Рассчитать задачу</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.CAEStudy">
            <summary>Задачи конечно-элементного анализа</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Study.Solve">
            <summary>Рассчитать задачу</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Study">
            <summary>Задачи Анализа</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExternalOperation.GroupType">
            <summary>Идентификатор типа объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExternalOperation.TypeID">
            <summary>Пользовательский идентификатор типа объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExternalOperation.PluginGuid">
            <summary>Guid плагина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExternalOperation.VolatileObject">
            <summary>3D операция внешнего приложения, встраиваемого в модель, для изменения её свойств</summary>
            <remarks>Разделение методов доступа к данным необходимо для работы механизма отката действий</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ExternalOperation.ConstObject">
            <summary>3D операция внешнего приложения, встраиваемого в модель, для опроса её свойств</summary>
            <remarks>Разделение методов доступа к данным необходимо для работы механизма отката действий</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ExternalOperation.#ctor(TFlex.Model.Model3D.ProxyOperation,TFlex.Model.Document,TFlex.Plugin)">
            <summary>Конструктор для создания внешней операции</summary>
            <param name="proxy">3D операция внешнего приложения</param>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="application">Плагин</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ProxyOperation.AttributesFromSource">
            <summary>Значение свойства "Атрибуты с исходной операции"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProxyOperation.AddSolid(TFlex.Model.Model3D.ProxyOperation.TexturedBody)">
            <summary>Добавить тело в список тел операции</summary>
            <param name="solid">Тело</param>
            <remarks>Вызывается только в функции MakeGeometry</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProxyOperation.TexturedBody.Complexity">
            <summary>Плотность сетки, если она задана</summary>
            <remarks>Плотность сетки задаётся значением в интервале от 0.0 до 1.0.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProxyOperation.TexturedBody.Color">
            <summary>Номер цвета, если он задан</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProxyOperation.TexturedBody.Material">
            <summary>Материал, если он задан</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProxyOperation.TexturedBody.Solid">
            <summary>Тело</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProxyOperation.TexturedBody.#ctor(TFlex.Model.Model3D.Geometry.BaseBody,TFlex.Model.Model3D.Material,System.Int32,System.Double)">
            <summary>Конструктор для задания тела с индивидуальными параметрами рисования</summary>
            <param name="solid">Тело</param>
            <param name="material">Материал</param>
            <param name="color">Цвет</param>
            <param name="complexity" />
        </member>
        <member name="M:TFlex.Model.Model3D.ProxyOperation.TexturedBody.#ctor(TFlex.Model.Model3D.Geometry.BaseBody)">
            <summary>Конструктор для задания тела с параметрами рисования из общих свойств внешней операции</summary>
            <param name="solid">Тело</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ProxyOperation.TexturedBody">
            <summary>Класс для задания параметров рисования тела</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProxyOperation.IsVirtualBody">
            <summary>Виртуальное тело в моделе, особенность представления тела операции в дереве модели (по аналогии с 3D фрагментом или массивом)</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ProxyOperation.AddToScene">
            <summary>Прогрузка операции в сцену</summary>
            <remarks>По умолчанию, прогружаются тела, полученные в MakeGeometry и добавленные в список тел при помощи AddSolid</remarks>
            <returns>Если операция реализует свою процедуру прогрузки, то нужно вернуть true</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.ProxyOperation.MakeGeometry">
            <summary>Пересчитать объект. Сформировать список тел в операции.</summary>
            <remarks>Тела добавлются с помощью функции AddSolid</remarks>
            <returns>Возвращается признак успешности выполнения пересчета</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.ProxyOperation.Operation">
            <summary>Внешняя операция, в которую агрегируется 3D операция внешнего приложения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ProxyOperation">
            <summary>Базовый класс для 3D операций внешнего приложения, встраиваемых в модель</summary>
            <remarks>Виртуальные методы, которые предлагается перекрыть, предназначены для вызова внешней операцией, в которую экземпляр класса агрегируется.
Эти методы вызываются системой автоматически и не должны вызываться приложением.</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.ProxyObject3D">
            <summary>Базовый класс для 3D объектов внешнего приложения, встраиваемых в модель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SpotLight.SpotAngle">
            <summary>Угол прожектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SpotLight.DropOffRate">
            <summary>Коэффициент бокового затухания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SpotLight.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для прожекторного источника света</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.SpotLight">
            <summary>Класс прожекторного источника света</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.DirectionalLight.Direction">
            <summary>Точка задающая направление источника света</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.DirectionalLight.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для направленного источника света</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.DirectionalLight">
            <summary>Класс направленного источника света</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PointLight.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для точечного источника света</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.PointLight">
            <summary>Класс точечного источника света</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Light.Intensivity">
            <summary>Интенсивность источника света</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Light.UseOnFragment">
            <summary>Использовать или нет источник света в сборочных документах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Light.ShowIcon">
            <summary>Показывать или нет обозначение источника света в сцене</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Light.Location">
            <summary>Точка задающая положение источника света</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Light">
            <summary>Класс источника света</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BoundedExtrusion.Bound2">
            <summary>Вторая граница</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BoundedExtrusion.Bound1">
            <summary>Первая граница</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BoundedExtrusion.Bound.Nearest">
            <summary>Для выталкивания до тела, если есть несколько пересечений с выталкиванием, берётся сечение, ближайшее к контуру по направлению</summary>
            <remarks>Для границы, заданной гранью, поверхностью или листовым телом, это свойство не определённо</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.BoundedExtrusion.Bound.Item">
            <summary>Граница выталкивания</summary>
            <remarks>Граница выталкивания может задаваться только отступом. 
В этом случае в качестве границы выталкивания берётся сам контур со смещением, 
задаваемым значением отступа в направлении выталкивания.
В качестве границы выталкивания могут передаваться только грани, 
поверхности, листовые и твёрдые тела. Остальные типы геометрии игнорируются.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.BoundedExtrusion.Bound.Offset">
            <summary>Значение отступа от границы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BoundedExtrusion.Bound.Intersection">
            <summary>Номер пересечения</summary>
            <remarks>Если граница имеет несколько пересечений с телом выталкивания, то можно явно задать номер сечения по направлению выталкивания.
Передаваемый номер выталкивания используется для привязки изменяющегося в параметрической модели номера сечения в границе.
В параметрической модели номер выталкивания может меняться. Поэтому его значения нельзя получить.
Для направления, противоположного направлению выталкивания, номер задаётся отрицательным числом.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.BoundedExtrusion.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания выталкивания</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.BoundedExtrusion">
            <summary>Операция выталкивания от границы до границы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThickenExtrusion.CoverThickness">
            <summary>Толщина крышки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThickenExtrusion.Cover">
            <summary>Параметр построения крышки</summary>
            <remarks>Толщина крышки должна задаваться положительным значением.
Крышка строится только для плоских листовых контуров при построении стенок ненулевой длины.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ThickenExtrusion.BedplateThickness">
            <summary>Получить толщину донышка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThickenExtrusion.Bedplate">
            <summary>Параметр построения донышка</summary>
            <remarks>Толщина донышка должна задаваться положительным значением.
Донышко строится только для плоских листовых контуров при построении стенок ненулевой длины.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ThickenExtrusion.BackwardLength">
            <summary>Длина выталкивания в обратном направлении</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThickenExtrusion.ForwardLength">
            <summary>Длина выталкивания в прямом направлении</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThickenExtrusion.LengthType">
            <summary>Способ определения длины выталкивания в прямом и обратном направлениях</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThickenExtrusion.LengthValue.UnlimitedByDirection">
            <summary>Контур выталкивается в заданном направлении на бесконечную длину.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThickenExtrusion.LengthValue.ValueSymmetric">
            <summary>В прямом направлении длина задаётся числовым значением или значением переменной.
В обратном направлении контур выталкивается на такое же значение, что и в прямом направлении.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThickenExtrusion.LengthValue.AutoSymmetric">
            <summary>Длина в прямом направлении берётся с вектора выталкивания. Если вектор выталкивания не задан или он не определяет длину
выталкивания, то длина задаётся числовым значением или значением переменной. В противном случае значение длины игнорируется.
В обратном направлении контур выталкивается на такое же значение, что и в прямом направлении.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThickenExtrusion.LengthValue.ValueNo">
            <summary>В прямом направлении длина задаётся числовым значением или значением переменной.
В обратном направлении контур не выталкивается.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThickenExtrusion.LengthValue.AutoNo">
            <summary>Длина в прямом направлении берётся с вектора выталкивания. Если вектор выталкивания не задан или он не определяет длину
выталкивания, то длина задаётся числовым значением или значением переменной. В противном случае значение длины игнорируется.
В обратном направлении контур не выталкивается.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThickenExtrusion.LengthValue.ValueValue">
            <summary>Длина в обоих направлениях задаётся числовыми значениями или значениями переменных</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThickenExtrusion.LengthValue.AutoValue">
            <summary>Длина в прямом направлении берётся с вектора выталкивания. Если вектор выталкивания не задан или он не определяет длину
выталкивания, то длина задаётся числовым значением или значением переменной. В противном случае значение длины игнорируется.
В обратном направлении длина задаётся числовым значением или значением переменной.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ThickenExtrusion.LengthValue.Unlimited">
            <summary>Контур выталкивается в обоих направлениях на бесконечную длину</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ThickenExtrusion.LengthValue">
            <summary>Способ определения длины выталкивания в прямом и обратном направлениях</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThickenExtrusion.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания выталкивания</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ThickenExtrusion">
            <summary>Операция выталкивания по вектору или приданием толщины</summary>
            <example>
                <code name="Выталкивание">
public static void ThickenExtrusion()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("операция выталкивания");//Открытие блока изменений документа

   FreeNode n1 = new FreeNode(document, 1, 1); 

   CircleConstruction circle = new CircleConstruction (document); 
   circle.SetCenterAndRadius(n1, 10); 

   Area ar = new Area (document); 
   TFlex.Model.Model2D.Contour cn = ar.AppendContour(); 

   ConstructionContourSegment seg1 = new ConstructionContourSegment(cn); 
   seg1.Construction = circle; 

   //построение профиля
   StandardWorkplane swp = new StandardWorkplane(document, StandardWorkplane.StandardType.Left); 
   AreaProfile pr3D = new AreaProfile(document); 
   pr3D.Area = ar; 
   pr3D.WorkSurface = swp; 

   ThickenExtrusion EXT = new ThickenExtrusion(document); 

   EXT.Thickness1 = 10; 
   EXT.LengthType = ThickenExtrusion.LengthValue.AutoValue; //Данный параметр должен быть выставлен! 
   EXT.ForwardLength = 50; 

   EXT.Profile.Add(pr3D.Geometry.SheetContour);

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.Extrusion.BackwardTaperAngle">
            <summary>Угол уклона в обратном направлении</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Extrusion.BackwardTaper">
            <summary>Получить параметр построения уклона в обратном направлении</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Extrusion.ForwardTaperAngle">
            <summary>Получить угол уклона в прямом направлении</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Extrusion.ForwardTaper">
            <summary>Параметр построения уклона в прямом направлении</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Extrusion.SecondPoint">
            <summary>Вторая точка, задающая направление выталкивания</summary>
            <remarks>Направление выталкивания для листовых контуров является необязательным параметром.
Вектор выталкивания в явном виде задаётся направлением или двумя точками.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Extrusion.FirstPoint">
            <summary>Первая точка, задающая направление выталкивания</summary>
            <remarks>Направление выталкивания для листовых контуров является необязательным параметром.
Вектор выталкивания в явном виде задаётся направлением или двумя точками.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Extrusion.Vector">
            <summary>Направление выталкивания</summary>
            <remarks>Направление выталкивания для листовых контуров является необязательным параметром.
Вектор выталкивания в явном виде задаётся направлением или двумя точками</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Extrusion.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания выталкивания</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Extrusion.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Extrusion">
            <summary>Базовая операция для всех типов выталкивания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.Reverse">
            <summary>Параметр реверсирования направления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.SideBlending">
            <summary>Сглаживание боковых рёбер</summary>
            <remarks>Если значение нулевое или отрицательное, то сглаживание не строится</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.SideFitting">
            <summary>Способ обработки боковых рёбер</summary>
            <remarks>Снятие фаски для боковых рёбер не поддерживается</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.BottomRadius">
            <summary>Радиус сглаживания или смещения для фаски на нижнем ребре</summary>
            <remarks>Если значение нулевое или отрицательное, то сглаживание не строится</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.BottomFitting">
            <summary>Способ обработки рёбер на нижней грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.TopRadius">
            <summary>Радиус сглаживания или смещения для фаски на верхнем ребре</summary>
            <remarks>Если значение нулевое или отрицательное, то сглаживание не строится</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.TopFitting">
            <summary>Способ обработки рёбер на верхней грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Fitting.Chamfer">
            <summary>Снятие фаски</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Fitting.Blend">
            <summary>Сглаживание ребра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Fitting.Border">
            <summary>Ребро не обрабатывается</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Sweep.Fitting">
            <summary>Типы обработки рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.Thickness2">
            <summary>Второе значение толщины стенок</summary>
            <remarks>Второе значение используется для задания толщины внутренней стенки в случае двусторонних стенок</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.Thickness1">
            <summary>Первое значение толщины стенок</summary>
            <remarks>Первое значение используется для задания толщины стенки в случае односторонних или симметричных стенок</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.GapFillType">
            <summary>Способ обработки разрывов</summary>
            <remarks>При построении тонкостенного выталкивания для плоского контура строится эквидистантный контур.
Для границ контуров, состоящих из нескольких рёбер или имеющих изломы в вершинах, возможно возникновение
разрывов между эквидистантами, построенными для каждого ребра. В этом случае задаётся способ обработки такого разрыва.
По умолчанию используется метод продолжения по кривой</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.GapFill.Natural">
            <summary>Продолжать по кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.GapFill.Linear">
            <summary>Продолжать по касательной</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.GapFill.Round">
            <summary>Скругление</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Sweep.GapFill">
            <summary>Обработка разрывов в случае придания толщины стенкам контуров</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.ThicknessType">
            <summary>Тип тонкостенного элемента</summary>
            <remarks>Допустимые типы тонкостенного элемента зависит от типа контура</remarks>
            <seealso cref="T:TFlex.Model.Model3D.Sweep.Thickness" />
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Thickness.DoubleSided">
            <summary>Стенки задаются разными толщинами снаружи и изнутри. Имеет смысл только для плоских контуров</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Thickness.Symmetrical">
            <summary>Стенки симметрично наружу и внутрь. Имеет смысл только для плоских контуров</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Thickness.Inward">
            <summary>Стенки изнутри контура. Имеет смысл только для плоских контуров</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Thickness.Outward">
            <summary>Стенки снаружи контура. Имеет смысл только для плоских контуров</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Thickness.Wall">
            <summary>Стенки нулевой толщины. Имеет смысл только для листовых контуров</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Sweep.Thickness.Side">
            <summary>Тонкостенный элемент не задаётся. Используется по умолчанию для всех типов контуров</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Sweep.Thickness">
            <summary>Тип тонкостенного элемента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sweep.Profile">
            <summary>Множество образующих контуров</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Sweep">
            <summary>Базовый класс для кинематических операций. Общим для всех порожденных из него классов является способ задания образующего контура</summary>
            <seealso cref="T:TFlex.Model.Model3D.Extrusion" />
            <seealso cref="T:TFlex.Model.Model3D.Rotation" />
            <seealso cref="T:TFlex.Model.Model3D.Swept" />
        </member>
        <member name="P:TFlex.Model.Model3D.TorqueActuator.Torque">
            <summary>Максимальный крутящий момент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TorqueActuator.AngVel">
            <summary>Угловая скорость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TorqueActuator.Type">
            <summary>Тип нагрузки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TorqueActuator">
            <summary>Вращательный привод</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Restraint.Type">
            <summary>Тип нагрузки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Restraint">
            <summary>Нагрузки и ограничения Анализа</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.RestraintType">
            <summary>Типы нагрузок и ограничений</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.RestraintType.TorqueActuator">
            <summary>Вращательный привод</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.RestraintType.TorqueForce">
            <summary>Крутящее усилие - система сил с нулевым главным вектором</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.RestraintType.PointForce">
            <summary>Сила приложенная в точке</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.RestraintType.BipolarElement">
            <summary>Биполярный силовой элемент (привод или пружина)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceDelete.IndependentHealing">
            <summary>Независимая обработка циклов</summary>
            <remarks>Если установлено в true, то каждый замкнутый цикл
образуемый гранями обрабатывается независимо. В противном случае обрабатываются
совместно.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceDelete.HealingMethod">
            <summary>Способ обработки граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceDelete.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceDelete.Faces">
            <summary>Удаляемые грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceDelete.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операция "Удаление граней"</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceDelete.HealingMethodType.Shrink">
            <summary>Удалить с усадкой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceDelete.HealingMethodType.GrowFromParent">
            <summary>Удалить с расширением родителей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceDelete.HealingMethodType.Cap">
            <summary>Удалить с затягиванием</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceDelete.HealingMethodType.No">
            <summary>Только удалить (без обработки)</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceDelete.HealingMethodType">
            <summary>Способ обработки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.Clear">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.RemoveAt(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.Add(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить элемент в конец списка</summary>
            <param name="item">Добавляемый элемент</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceDelete.DeleteFacesArray">
            <summary>Массив удаляемых граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceDelete">
            <summary>Операция удаления граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BooleanGenerator.Run">
            <summary>Функция генерации выталкивания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BooleanGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.Body,TFlex.Model.Model3D.Geometry.Body[],TFlex.Model.Model3D.BooleanOperation.FunctionType)">
            <summary>Конструктор для задания вытлакивания по направлению на заданные длины в прямом и обратном направлении</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="target">Тело, к котому применятся булева</param>
            <param name="tools">Массив тел, которые используются для модификации тела</param>
            <param name="function">Тип булевой</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BooleanGenerator">
            <summary>Генератор булевой операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.KeepFacesMaterial">
            <summary>Параметр "Сохранять материал граней"</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.SaveMaterialType.SaveTargetOperands">
            <summary>Объединение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.SaveMaterialType.SaveBothOperands">
            <summary>Сохранять текущий материал граней обоих операндов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.SaveMaterialType.NoSave">
            <summary>Не сохранять</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BooleanOperation.SaveMaterialType">
            <summary>Параметр "Сохранять материал граней"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.UsePatterning">
            <summary>Параметр "копирование по образцу"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.EdgeRadius">
            <summary>Получить радиус сглаживания или смщения для фаски на новом ребре</summary>
            <remarks>Если значение нулевое или отрицательное, то сглаживание не строится</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.EdgeFitting">
            <summary>Способ обработки новых рёбер</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.FittingType.Chamfer">
            <summary>Снятие фаски</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.FittingType.Blend">
            <summary>Сглаживание ребра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.FittingType.Border">
            <summary>Ребро не обрабатывается</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BooleanOperation.FittingType">
            <summary>Типы обработки новых рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.Function">
            <summary>Тип булевой операции</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.FunctionType.Unite">
            <summary>Объединение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.FunctionType.Subtract">
            <summary>Вычитание</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BooleanOperation.FunctionType.Intersect">
            <summary>Пересечение</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BooleanOperation.FunctionType">
            <summary>Функция булевой операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.SecondOperands">
            <summary>Множество вторых операндов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.FirstOperands">
            <summary>Множество первых операндов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.OperandsArray.default(System.Int32)">
            <summary>Получить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BooleanOperation.OperandsArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BooleanOperation.OperandsArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Clear">
            <summary>Удалить все операнды</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BooleanOperation.OperandsArray.RemoveAt(System.Int32)">
            <summary>Удалить операнд по номеру</summary>
            <param name="index">Номер операции</param>
            <remarks>Операнды нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Add(TFlex.Model.Model3D.BooleanOperation.OperandsArray.Operand)">
            <summary>Добавить операнд в конец списка</summary>
            <param name="operand">Добавляемый операнд</param>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Operand.Operation">
            <summary>Операция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Operand.KeepVisible">
            <summary>Параметр "оставлять операцию в сцене"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Operand.#ctor(TFlex.Model.Model3D.Operation,System.Boolean)">
            <summary>Конструктор для операнда</summary>
            <param name="operation">Добавляемая операция</param>
            <param name="keepVisible">Оставлять операцию в сцене</param>
        </member>
        <member name="T:TFlex.Model.Model3D.BooleanOperation.OperandsArray.Operand">
            <summary>Структура для хранения операнда</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BooleanOperation.OperandsArray">
            <summary>Операнды</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BooleanOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания булевых операций</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.BooleanOperation">
            <summary>Булева операция</summary>
            <example>
                <code name="Булева операция">
public static void BooleanOperation(Operation ext1, Operation ext2)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("булева операция");	//Открытие блока изменений документа

   BooleanOperation bo = new BooleanOperation(document);
		    
   BooleanOperation.OperandsArray.Operand op1 = new BooleanOperation.OperandsArray.Operand(ext1, false);
   BooleanOperation.OperandsArray.Operand op2 = new BooleanOperation.OperandsArray.Operand(ext2, false);

   bo.FirstOperands.Add(op1);
   bo.SecondOperands.Add(op2);

   //тип операции - объединение
   bo.Function = BooleanOperation.FunctionType.Unite;
   bo.Regenerate(true);

   document.EndChanges();//Закрытие блока изменений документа		
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ImprintConnect">
            <summary>Способ соединения рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ImprintOverlapping">
            <summary>Флаг обработки перекрытий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ExtendedFaceType">
            <summary>Тип расширения списка обрабатываемых граней при построении пересечений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ExtendedFace">
            <summary>Флаг расширения списка обрабатываемых граней при построении пересечений. Примечание: Это свойство устарело и было заменено на ExtendedFaceType</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ImprintExtend">
            <summary>Направление продления рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ImprintComplete">
            <summary>Завершение рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.Angle">
            <summary>Угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.DirectionReverse">
            <summary>Флаг реверса направления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.SecondPoint">
            <summary>Вторая точка задающая направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.FirstPoint">
            <summary>Первая точка задающая направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.Direction">
            <summary>Направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ToolFaces">
            <summary>Установить разделяющие грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ToolOperation">
            <summary>Разделяющая операция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.TargetFaces">
            <summary>Разделяемые грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.TargetOperation">
            <summary>Разделяемая операция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.Method">
            <summary>Установить способ разделения грани</summary>
            <remarks>При изменении метода параметры несовместимые с новым методом удаляются</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Imprint.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операция "Разбиение граней"</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintConnectType.SideAll">
            <summary>Соединять все видимые</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintConnectType.All">
            <summary>Соединять все рёбра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintConnectType.None">
            <summary>Не соединять</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Imprint.ImprintConnectType">
            <summary>Способ соединения участков рёбер</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintExtendFaceListType.All">
            <summary>Выбирать разделяемые и разделяющие</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintExtendFaceListType.Tool">
            <summary>Выбирать только разделяющие</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintExtendFaceListType.Target">
            <summary>Выбирать только разделяемые</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintExtendFaceListType.No">
            <summary>Не выбирать</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Imprint.ImprintExtendFaceListType">
            <summary>Варианты расширения списка обрабатываемых граней при построении пересечений. Определяют способ выбора соседних граней</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintExtendType.OrthBack">
            <summary>Продолжить рёбра в направлении обратном нормали</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintExtendType.OrthFwd">
            <summary>Продолжить рёбра в направлении нормали</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintExtendType.Tangent">
            <summary>Продолжить рёбра по касательной</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Imprint.ImprintExtendType">
            <summary>Способ продления рёбер</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintCompleteType.Edge">
            <summary>Продлевать рёбра до первого ребра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintCompleteType.Laminar">
            <summary>Продлевать рёбра до границы листового тела</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintCompleteType.No">
            <summary>Не продлевать рёбра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Imprint.ImprintCompleteType">
            <summary>Тип продления рёбер</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintMethod.CreateIsocline">
            <summary>Создание изоклин-кривых</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintMethod.ProjectionOutlineLines">
            <summary>Проецирование очерковой линий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintMethod.Intersection">
            <summary>Пересечение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintMethod.ProjectionByDirection">
            <summary>Проецирование по направлению</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Imprint.ImprintMethod.ProjectionByNormal">
            <summary>Проецирование по нормали</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Imprint.ImprintMethod">
            <summary>Способ разделения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.Clear">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.RemoveAt(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.Add(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить элемент в конец списка</summary>
            <param name="item">Добавляемый элемент</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Imprint.ImprintTargetFacesArray">
            <summary>Массив разделяемых граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Imprint">
            <summary>Операция разделения граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshWorkPlane.Enable">
            <summary>Включение сетки рабочих плоскостей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshWorkPlane.Inverse">
            <summary>Инверсия порядка возвращаемых узлов сетки, от дальних к ближним</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshWorkPlane.FindBoundBox">
            <summary>Границы множества точек пересечений рабочих плоскостей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshWorkPlane.Build">
            <summary>Обновление сетки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshWorkPlane.ActiveWorkplane">
            <summary>Активная рабочая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshWorkPlane.FindByCoords(TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Найти точку по её координатам</summary>
            <param name="point">Точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshWorkPlane.FindNearByLength(TFlex.Model.Model3D.Geometry.Axis,System.Double,System.Boolean)">
            <summary>Найти ближайшую точку с учётом длины вектора, задающего направление, включая точку на луче</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshWorkPlane.FindFar(TFlex.Model.Model3D.Geometry.Axis)">
            <summary>Найти удалённую точку по направлению</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshWorkPlane.FindNear(TFlex.Model.Model3D.Geometry.Axis)">
            <summary>Найти ближайшую точку по направлению</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshWorkPlane.FindNearPoint">
            <summary>Режим выбора ближайших к лучу точек</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshWorkPlane.FindMinMax(TFlex.Model.Model3D.Geometry.Axis,System.Boolean)">
            <summary>Найти минимальную или максимальную точку на луче</summary>
            <param name="axis">Геометрическая ось</param>
            <param name="max">true, если ищется максимальная точка, в противном случае false</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshWorkPlane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.MeshWorkPlane">
            <summary>Сетка из точек пересечения рабочих плоскостей</summary>
        </member>
        <member name="T:TFReference.SolidIterator">
Двунаправленный итератор
</member>
        <member name="M:GeometricBody.GetAttribBodyID">
получить ID тела с которого взяты некоторые "видимые" свойства
</member>
        <member name="M:GeometricBody.GetAttribOperationID">
получить ID операции с которой взяты некоторые "видимые" свойства
</member>
        <member name="M:GeometricBody.GetWireframe">
получить состояние о необходимости ребереного представления
</member>
        <member name="M:GeometricBody.GetTransparancy">
получить прозрачность тела
</member>
        <member name="M:GeometricBody.GetColorAsRGB">
получить тела цвет тела	в форме RGB
</member>
        <member name="M:GeometricBody.GetColor">
получить цвет тела как индекс в таблице цветов
</member>
        <member name="M:GeometricBody.GetFacetParams">
получить качество сетки
</member>
        <member name="M:GeometricBody.GetComplexity_Obsolete">
получить качество сетки (устаревшая функция)
</member>
        <member name="M:GeometricBody.InitGeometricData(GeometricBody*,GeometricBody*)">
Установить ссылки на геометрические данные в target из source
</member>
        <member name="T:GeometricBody.OperationInfo">
Расширенная информация об истории создания тела
</member>
        <member name="M:GeometricBody.GetTransformToExplode(CTFExplodeContext!System.Runtime.CompilerServices.IsConst*,TFM.SSE.Matrix4d*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Вычисление трансформации разборки
</member>
        <member name="T:GeometricBody.TolerantComparison">
Оператор сравнения двух double в пределах точности
</member>
        <member name="M:applio_open_rd_set_key(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
CRUTCH: read facet body
</member>
        <member name="T:BodyVisualProperty">
BodyVisualProperty "видимые" свойства тела
</member>
        <member name="M:LegacyExplodeTransform.SetExplodeTransform(GeometricBody*,System.Int32!System.Runtime.CompilerServices.IsConst)">
Установить собственную трансформация разборки для тела, время жизни transf контролирует вызывающий код
</member>
        <member name="M:LegacyExplodeTransform.GetExplodeTransform(GeometricBody*)">
Получить собственную трансформация разборки для тела
</member>
        <member name="M:LegacyExplodeTransform.RefinedExplode(GeometricBody*,TFM.SSE.Matrix4d*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Суммарная трансформация разборки, примененная после суммарной трансформации
</member>
        <member name="M:LegacyExplodeTransform.GetSummTransfToExplode(GeometricBody*,TFM.SSE.Matrix4d*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Суммарная трансформация с учетом трансформаций разборки родителей
</member>
        <member name="M:LegacyExplodeTransform.SetTransf(TFM.SSE.Matrix4d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Установить трансформацию разборки	
</member>
        <member name="M:LegacyExplodeTransform.GetTransf">
Собственная трансформация разборки
</member>
        <member name="T:LegacyExplodeTransform">
Преобразования разборки до 14 версии
</member>
        <member name="M:OrientedBox.Unite(OrientedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Объединение двух параллепипедов
</member>
        <member name="T:OrientedBox.ClashType">
Проверяем пересечение параллелипипедов
</member>
        <member name="M:OrientedBox.CheckIntersection(OrientedBox!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверяем пересечение параллелипипедов
</member>
        <member name="P:TFlex.Model.Model3D.ImportedOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedOperation.TargetLCS">
            <summary>Целевая система коодинат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedOperation.SourceLCS">
            <summary>Исходная система коодинат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedOperation.SaveGeometry">
            <summary>Значение свойства "Сохранять геометрию"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedOperation.MaterialsFromSource">
            <summary>Значение свойства "С учётом материалов"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ImportedOperation.OpenSource">
            <summary>Открыть файл-источник</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedOperation.SourcePath">
            <summary>Путь к файлу-источнику, из которого выгружена в обменный файл внешняя модель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedOperation.PathName">
            <summary>Путь к файлу внешней модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedOperation.FileName">
            <summary>Имя файла внешней модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ImportedOperation.Create(TFlex.Model.Document,TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конструктор для операции "Внешняя модель"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ImportedOperation.Create(TFlex.Model.Document,System.Collections.Generic.List`1{TFlex.Model.Model3D.Geometry.BaseCurve},System.Collections.Generic.List`1{TFlex.Model.Model3D.Geometry.BaseInterval},System.Collections.Generic.List`1{TFlex.Drawing.Point})">
            <summary>Конструктор для операции "Внешняя модель"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="curves">Коллекция кривых</param>
            <param name="intervals">Коллекция интервалов</param>
            <return>Операция "Внешняя модель"</return>
        </member>
        <member name="M:TFlex.Model.Model3D.ImportedOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Внешняя модель"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ImportedOperation">
            <summary>Операция "Внешняя модель"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Picture3D.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Picture3D.PathName">
            <summary>Получить путь к файлу 3D изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Picture3D.FileName">
            <summary>Имя файла 3D изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Picture3D.Workplane">
            <summary>Получить рабочую плоскость, используемую для привязки 3D изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Picture3D.TargetLCS">
            <summary>Получить целевую систему координат созданную в документе сборки, используемую для привязки 3D изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Picture3D.SourceLCSName">
            <summary>Получить имя системы координат созданной в документе фрагмента, используемой для привязки 3D изображения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Picture3D.FixByWorkplane(TFlex.Model.Model3D.Workplane)">
            <summary>Привязать 3D изображение по расположению соответствующего 2D фрагмента на Рабочей плоскости </summary>
            <param name="workplane">Рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Picture3D.FixByPictureLCS(System.String,TFlex.Model.Model3D.LCS)">
            <summary>Привязать 3D изображение по системе координат созданной в документе фрагмента в систему координат сборки </summary>
            <param name="sourceLCSName">Имя системы координат, созданной в документе фрагмента</param>
            <param name="targetLCS">Система координат, созданная в документе сборки</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Picture3D.Fixing">
            <summary>Получить способ привязки 3D изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Picture3D.FixingType.ByWorkplane">
            <summary>На основе расположения 2D фрагмента на Рабочей плоскости</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Picture3D.FixingType.ByPictureLCS">
            <summary>Система координат созданная в документе 3D изображения в систему координат сборки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Picture3D.FixingType.NoFixing">
            <summary>Не определён</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Picture3D.FixingType">
            <summary>Способ привязки 3D изображение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Picture3D.FileLink">
            <summary>Ссылка на файл картинки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Picture3D.#ctor(TFlex.Model.FileLink)">
            <summary>Конструктор с именем файла картинки</summary>
            <param name="link">Ссылка на файл картинки</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Picture3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции 3D изображения</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Picture3D">
            <summary>Операция "3D изображение"</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.UnknownTransformation">
            <summary> Класс заместитель для неизменяемых типов преобразований</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedTransformation.OriginType">
            <summary>Тип поиска системы координат, относительно которой производится преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ImportedTransformation.Matrix">
            <summary>Матрица преобразований</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ImportedTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания внешнего преобразования</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ImportedTransformation">
            <summary> Класс внешнего преобразования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ScaleTransformation.Origin">
            <summary>Точка, относительно которой производится преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ScaleTransformation.OriginType">
            <summary>Тип поиска системы координат, относительно которой производится преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ScaleTransformation.LCS">
            <summary>Система координат, относительно которой производится преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ScaleTransformation.ScaleZ">
            <summary>Значение масштаба вдоль оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ScaleTransformation.ScaleY">
            <summary>Значение масштаба вдоль оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ScaleTransformation.ScaleX">
            <summary>Значение масштаба вдоль оси X</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ScaleTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового преобразования масштабирования</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ScaleTransformation">
            <summary> Класс преобразования масштабирования</summary>
            <example>
                <code name="Преобразование масштабирования">
public static void ScaleTransformation(Operation operation, LCS lcs)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("масштабирование");	//Открытие блока изменений документа

   ScaleTransformation stf = new ScaleTransformation(document);				
   stf.ScaleX = 10;//Значение масштаба вдоль оси X
   stf.ScaleY = 0;//Значение масштаба вдоль оси Y
   stf.ScaleZ = 20;//Значение масштаба вдоль оси Z
   stf.LCS = lcs; //Система координат, относительно которой производится преобразование
		    
   operation.VolatileTransformations.Add(stf);//преобразование для операции   
                    
   document.EndChanges();//Закрытие блока изменений документа		
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.ScaleVectorTransformation.Scale">
            <summary>Значение масштаба</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ScaleVectorTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового преобразования масштабирования вдоль вектора</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ScaleVectorTransformation">
            <summary> Класс преобразования масштабирования вдоль вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RotateVectorTransformation.Angle">
            <summary>Значение угла поворота</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.RotateVectorTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового преобразования поворота вокруг вектора</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.RotateVectorTransformation">
            <summary> Класс преобразования поворота вокруг вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MoveVectorTransformation.Offset">
            <summary>Длина перемещения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MoveVectorTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового преобразования перемещения вдоль вектора</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.MoveVectorTransformation">
            <summary> Класс преобразования перемещения вдоль вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.VectorTransformation.SecondPoint">
            <summary>Вторая точка оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.VectorTransformation.FirstPoint">
            <summary>Первая точка оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.VectorTransformation.Axis">
            <summary>Ось</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.VectorTransformation">
            <summary> Базовый класс преобразований относительно оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FragmentTransformation.OriginType">
            <summary>Тип поиска системы координат, относительно которой производится преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FragmentTransformation.LCS">
            <summary>Система координат, относительно которой производится преобразование</summary>
            <remarks>Совпадает с исходной системой координат</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.FragmentTransformation.TargetLCS">
            <summary>Целевая система координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FragmentTransformation.SourceLCS">
            <summary>Исходная система координат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FragmentTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового преобразования перемещения из одной системы координат в другую</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.FragmentTransformation">
            <summary>Класс преобразования перемещения из одной системы координат в другую</summary>
            <example>
                <code name="Преобразования перемещения из одной системы координат в другую">
public static void FragmentTransformation(Operation operation, LCS lcs)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("перемещение");	//Открытие блока изменений документа

   FragmentTransformation ft = new FragmentTransformation(document);
   ft.AddRotation(StandardAxis.AxisX, 30);//поворот вокруг оси X
   ft.AddRotation(StandardAxis.AxisY, 10);//поворот вокруг оси Y
   ft.LCS = lcs;//Система координат, относительно которой производится преобразование
   ft.Offset_X = 100;//Значение свойства перемещения вдоль оси X
   ft.Offset_Y = 200;//Значение свойства перемещения вдоль оси Y
   ft.Offset_Z = 300;//Значение свойства перемещения вдоль оси Z
   operation.VolatileTransformations.Add(ft);//преобразование для операции  

   document.EndChanges();//Закрытие блока изменений документа		
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.LCSTransformation.TargetLCS">
            <summary>Целевая система координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCSTransformation.SourceLCS">
            <summary>Исходная система координат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LCSTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового преобразования перемещения  из одной системы координат в другую</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.LCSTransformation">
            <summary>Класс преобразования перемещения из одной системы координат в другую</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReflectTransformation.Plane">
            <summary>Плоскость симметрии</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ReflectTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового преобразования симметрии</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ReflectTransformation">
            <summary> Класс преобразования симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MoveRotateTransformation.OriginType">
            <summary>Тип поиска системы координат, относительно которой производится преобразование</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MoveRotateTransformation.LCS">
            <summary>Система координат, относительно которой производится преобразование</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MoveRotateTransformation.MoveRotation(System.Int32,TFlex.Model.Model3D.MoveType)">
            <summary>Переместить вращение вниз или вверх</summary>
            <param name="index">Индекс поворота</param>
            <param name="direction">Направление перемещения</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MoveRotateTransformation.AddRotation(TFlex.Model.Model3D.StandardAxis,TFlex.Model.Parameter)">
            <summary>Добавить поворот вокруг оси</summary>
            <param name="axis">Ocь поворота</param>
            <param name="param">Значение угла поворота</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MoveRotateTransformation.GetRotation(System.Int32,TFlex.Model.Model3D.StandardAxis@,TFlex.Model.Parameter@)">
            <summary>Получить параметры поворота по индексу</summary>
            <param name="index">Номер поворота</param>
            <param name="axisIndex">Если функция сработала успешно, то в неё помещается ось относительно которой производится поворот</param>
            <param name="param">Если функция сработала успешно, то в неё помещается значение угла поворота</param>
        </member>
        <member name="P:TFlex.Model.Model3D.MoveRotateTransformation.RotationsCount">
            <summary>Количество поворотов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MoveRotateTransformation.Scale">
            <summary>Значение свойства масштабирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MoveRotateTransformation.Offset_Z">
            <summary>Значение свойства перемещения вдоль оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MoveRotateTransformation.Offset_Y">
            <summary>Значение свойства перемещения вдоль оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MoveRotateTransformation.Offset_X">
            <summary>Значение свойства перемещения вдоль оси X</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MoveRotateTransformation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового преобразования перемещения поворота</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.MoveRotateTransformation">
            <summary>Класс преобразования перемещения/поворота</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.StandardAxis">
            <summary>Ось</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardAxis.AxisZ">
            <summary>Ось Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardAxis.AxisY">
            <summary>Ось Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardAxis.AxisX">
            <summary>Ось X</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OriginType">
            <summary>Тип поиска системы координат относительно которой производится преобразование</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OriginType.BoundBoxCenter">
            <summary>Центр охватывающего параллепипеда</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OriginType.Root">
            <summary>Основная система координат 3D элемента</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OriginType.Main">
            <summary>Основная система координат 3D элемента или центр охватывающего параллепипеда</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OriginType.LCS">
            <summary>Система координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Hole.HideConnectors">
            <summary>Скрывать коннекторы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Hole.GetTargetLCS(System.Int32)">
            <summary>Получение целевой системы координат, используемой для привязки отверстия</summary>
            <param name="hole">Индекс отверстия</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Hole.GetVariableValue(System.Int32,System.String,System.Boolean)">
            <summary>Получить переменную отверстия по имени</summary>
            <param name="hole">Индекс отверстия</param>
            <param name="name">Имя переменной отверстия</param>
            <param name="forSet">Признак необходимости изменения переменной</param>
            <returns>Переменная отверстия</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Hole.GetVariables(System.Int32)">
            <summary>Получить переменные по индексу отверстия</summary>
            <param name="hole">Индекс отверстия</param>
            <returns>Переменные отверстия</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Hole.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Hole.EndFace">
            <summary>Грань определяющая конец отверстия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Hole.End">
            <summary>Конец отверстия</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Hole.EndType.Custom">
            <summary>С заданием до какой грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Hole.EndType.Blind">
            <summary>Глухое отверстие</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Hole.EndType.ToLast">
            <summary>До последней грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Hole.EndType.ToFirst">
            <summary>До первой грани</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Hole.EndType">
            <summary>Тип задания конца отверстия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Hole.DeleteHole(System.Int32)">
            <summary>Удалить отверстие по индексу</summary>
            <param name="index">Индекс удаляемого отверстия</param>
            <returns>Успешно или нет добавлено отверстие</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Hole.HoleCount">
            <summary>Количество отверстий</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Hole.AddHole(TFlex.Model.Model3D.Geometry.ModelFace,TFlex.Model.Model3D.Node3D)">
            <summary>Добавить отверстие на грани</summary>
            <param name="face">Грань на которой строится отверстие</param>
            <param name="node">Точка задающая центр отверстия</param>
            <returns>Успешно или нет добавлено отверстие</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Hole.PathName">
            <summary>Путь файла 3D Фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Hole.FileName">
            <summary>Имя файла 3D Фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Hole.#ctor(System.String,TFlex.Model.Document)">
            <summary>Конструктор для создания 3D отверстия</summary>
            <param name="fileName">Имя документа отверстия</param>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Hole">
            <summary>Класс операции 3D отверстия</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExtendSurface.KeepSource">
            <summary>Оставлять исходное тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExtendSurface.Modify">
            <summary>Модифицировать исходные грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExtendSurface.ExtensionSmoothness">
            <summary>Сглаживание</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExtendSurface.Shape">
            <summary>Форма поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExtendSurface.Length">
            <summary>Величина продления грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExtendSurface.Edges">
            <summary>Рёбра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExtendSurface.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExtendSurface.Sheet">
            <summary>Листовое тело.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ExtendSurface.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операции "Заполнение области"</summary>
            <param name="doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="F:TFlex.Model.Model3D.ExtendSurface.ExtensionSmoothnessType.G1">
            <summary>G1-непрывная поверхность (где это возможно)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ExtendSurface.ExtensionSmoothnessType.G0">
            <summary>Без сглаживания</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ExtendSurface.ExtensionSmoothnessType">
            <summary>Сглаживание</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ExtendSurface.ShapeType.Reflective">
            <summary>Подобная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ExtendSurface.ShapeType.Soft">
            <summary>Исходной поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ExtendSurface.ShapeType.Linear">
            <summary>Линейчатая</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ExtendSurface.ShapeType">
            <summary>Форма поверхности</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ExtendSurface">
            <summary>Заполнения области</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.RotateGenerator.Run">
            <summary>Функция генерации вращения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.RotateGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.BaseAxis,TFlex.Model.Model3D.Geometry.Body,System.Double)">
            <summary>Конструктор для задания вращения</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="axis">Ось вращения</param>
            <param name="profile">Вращаемый контур. Этот контур превращается во вращение и возращается в списке результирующих тел или удаляется</param>
            <param name="angle">Угол поворота</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.RotateGenerator">
            <summary>Генератор вращения</summary>
        </member>
        <member name="M:TFlex.Scene.IDocumentScene.TemporyAuxScene">
Для временных сцен, которые решают конкретную задачу
Например сцена для экспорта
</member>
        <member name="P:TFlex.Model.Model3D.ParametricArrayOperation.GeneratrixOperation">
            <summary>Образующая операция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ParametricArrayOperation.Parametric">
            <summary>Общие свойства параметрических объектов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ParametricArrayOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ParametricArrayOperation.ParamType">
            <summary>Cпособ задания параметризации</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ParametricArrayOperation.ParametricType.DirectedGuidePathParam">
            <summary>Свойства объекта задаются классом MultipleGuidePathParametric</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ParametricArrayOperation.ParametricType.OneGuidePathParam">
            <summary>Свойства объекта задаются классом OneGuidePathParametric</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ParametricArrayOperation.ParametricType.VariableParam">
            <summary>Свойства объекта задаются классом VariableParametric</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ParametricArrayOperation.ParametricType">
            <summary>Способ задания параметризации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ParametricArrayOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Параметрический массив"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ParametricArrayOperation">
            <summary>Параметрический массив</summary>
            <remarks>В текущей версии можно копировать только операции</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PathArrayOperation.Usage">
            <summary>Тип использования пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PathArrayOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PathArrayOperation.Path">
            <summary>Путь</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PathArrayOperation.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.ArrayOperation.Type)">
            <summary>Конструктор для операции "Массив по пути"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="type">Тип копируемых элементов</param>
        </member>
        <member name="M:TFlex.Model.Model3D.PathArrayOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Массив по пути"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Тип копируемых объектов изначально не определён и определяется автоматически (как операции или элементы построения), при добавлении объектов</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.PathArrayOperation">
            <summary>Класс операции "Массив по пути"</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.PathUsage">
            <summary>Тип использования пути</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.PathUsage.Chord">
            <summary>По хорде</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.PathUsage.Offset">
            <summary>Со смещением</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.PathUsage.MinimalTwist">
            <summary>Минимальное кручение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.NodeArrayOperation.TargetPoints">
            <summary>Получить перечисление базовых элементов для построения массива</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeArrayOperation.RemoveTargetPoint(System.Int32)">
            <summary>Удалить целевую точку по индексу</summary>
            <param name="Index">Номер целевой точки, которую необходимо удалить</param>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeArrayOperation.GetTargetPoint(System.Int32)">
            <summary>Получить целевую точку массива по номеру</summary>
            <param name="Index">Номер целевой точки</param>
            <remarks>Целевые точки нумеруются с нуля. Если индекс отрицательный или превышает количество целевых точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.NodeArrayOperation.TargetPointCount">
            <summary>Получить количество целевых точек массива</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeArrayOperation.AddTargetPoint(TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Добавить целевую точку для построения массива</summary>
            <param name="Point">Целевая точка, которую необходимо добавить</param>
        </member>
        <member name="P:TFlex.Model.Model3D.NodeArrayOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.NodeArrayOperation.SourcePoint">
            <summary>Исходная точка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeArrayOperation.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.ArrayOperation.Type)">
            <summary>Конструктор для операции "Массив по точкам"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="type">Тип копируемых элементов</param>
        </member>
        <member name="M:TFlex.Model.Model3D.NodeArrayOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Массив по точкам"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Тип копируемых объектов изначально не определён и определяется автоматически (как операции или элементы построения), при добавлении объектов</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.NodeArrayOperation">
            <summary>Класс операции "Массив по точкам"</summary>
            <example>
                <code name="Массив по точкам">
using System;
using TFlex.Model;
using TFlex.Model.Model2D;
using TFlex.Model.Model3D;

namespace NewMacroNamespace
{
   public class NewMacroClass
   {
       //Создание массива по точкам
       public static void NodeArrayOperation()
       {
           Document document = TFlex.Application.ActiveDocument;//Получение активного документа

           document.BeginChanges("Массив по точкам");//Открытие блока изменений документа

           // Операция, из которой надо сделать массив (в общем случае получается из контейнера операций : document.GetOperations())
           Operation operation = CreateSimpleExtrusion(document);

           // Узлы для массива
           CoordinateNode3D node1 = new CoordinateNode3D(document) { X = 200, Y = 200, Z = 200 };
           CoordinateNode3D node2 = new CoordinateNode3D(document) { X = 250, Y = 300, Z = 300 };
           CoordinateNode3D node3 = new CoordinateNode3D(document) { X = 200, Y = 500, Z = 200 };

           NodeArrayOperation nao = new NodeArrayOperation(document);
           nao.Operations.Add(operation); //добавление операции в массив
           nao.SourcePoint = node1.Geometry.Point;

           nao.AddTargetPoint(node2.Geometry.Point);
           nao.AddTargetPoint(node3.Geometry.Point);

           document.EndChanges();//Закрытие блока изменений документа
       }

       // Создание простого выталкивание для использования при создании массива по точкам
       private static ThickenExtrusion CreateSimpleExtrusion(Document document)
       {
           FreeNode fn1 = new FreeNode(document, 10, 10);
           FreeNode fn2 = new FreeNode(document, 40, 30);
           FreeNode fn3 = new FreeNode(document, 70, 10);

           ConstructionOutline l1 = new ConstructionOutline(document, fn1, fn2);
           ConstructionOutline l2 = new ConstructionOutline(document, fn2, fn3);
           ConstructionOutline l3 = new ConstructionOutline(document, fn3, fn1);

           StandardWorkplane swp = new StandardWorkplane(document, StandardWorkplane.StandardType.Left);
           SketchProfile sp = new SketchProfile(document);
           sp.WorkSurface = swp;

           var extrusion = new ThickenExtrusion(document);
           extrusion.Thickness1 = 10;
           extrusion.LengthType = ThickenExtrusion.LengthValue.AutoValue;
           extrusion.ForwardLength = 50;
           extrusion.Profile.Add(sp.Geometry.SheetContour);
           return extrusion;
       }
   }
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.ParallelTransfer">
            <summary>Свойство "Параллельный перенос"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.OffsetType">
            <summary>Тип использования значений для перемещения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.OffsetByRadius">
            <summary>Использование перемещения по радиусу или оси при построении двумерного кругового массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.OffsetStepFromVector">
            <summary>Свойство "получать шаг перемещения кругового массива с вектора направления"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.OffsetLengthFromVector">
            <summary>Свойство "получать длину перемещения кругового массива с вектора направления"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.OffsetStep">
            <summary>Шаг перемещения кругового массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.OffsetLength">
            <summary>Длина перемещения кругового массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotateType">
            <summary>Тип использования значений для вращения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotateEndPoint">
            <summary>Конечная точка вращения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotateBeginPoint">
            <summary>Начальная точка вращения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotateStepFromVector">
            <summary>Свойство "получать угловой шаг кругового массива с точек, задающих начальную и конечную точку вращения"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotateAngleFromVector">
            <summary>Свойство "получать общий угол кругового массива с точек, задающих начальную и конечную точку вращения"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotateStep">
            <summary>Угловой шаг кругового массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotateAngle">
            <summary>Общий угол кругового массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.Axis">
            <summary>Ось кругового массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotatePoint2">
            <summary>Вторая точка, задающая ось кругового массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CircularArrayOperation.RotatePoint1">
            <summary>Первая точка, задающая ось кругового массива</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CircularArrayOperation.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.ArrayOperation.Type)">
            <summary>Конструктор для операции "Круговой массив"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="type">Тип копируемых элементов</param>
        </member>
        <member name="M:TFlex.Model.Model3D.CircularArrayOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Круговой массив"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Тип копируемых объектов изначально не определён и определяется автоматически (как операции или элементы построения), при добавлении объектов</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.CircularArrayOperation">
            <summary>Операция "Круговой массив"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2Type">
            <summary>Тип использования значений для второго направления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2StepFromVector">
            <summary>Свойство "получать шаг по второму направлению линейного массива с вектора направления"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2LengthFromVector">
            <summary>Свойство "получать длину по второму направлению линейного массива с вектора направления"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2Step">
            <summary>Шаг по второму направлению линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2Length">
            <summary>Длина по второму направлению линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2Number">
            <summary>Количество копий по второму направлению линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2">
            <summary>Второе направление линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2Point2">
            <summary>Вторая точка, задающая второе направление линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction2Point1">
            <summary>Первая точка, задающая второе направление линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1Type">
            <summary>Тип использования значений(длина,шаг,количество копий) для первого направления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1StepFromVector">
            <summary>Cвойство "получать шаг по первому направлению линейного массива с вектора направления"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1LengthFromVector">
            <summary>Свойство "получать длину по первому направлению линейного массива с вектора направления"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1Step">
            <summary>Шаг по первому направлению линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1Length">
            <summary>Длина по первому направлению линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1Number">
            <summary>Количество копий по первому направлению линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1">
            <summary>Первое направление линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1Point2">
            <summary>Вторая точка задающая первое направление линейного массива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LinearArrayOperation.Direction1Point1">
            <summary>Первая точка, задающая первое направление линейного массива</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearArrayOperation.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.ArrayOperation.Type)">
            <summary>Конструктор для операции "Линейный массив"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <param name="type">Тип копируемых элементов</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LinearArrayOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции "Линейный массив"</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Тип копируемых объектов изначально не определён и определяется автоматически (как операции или элементы построения), при добавлении объектов</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.LinearArrayOperation">
            <summary>Операция "Линейный" массив</summary>
            <example>
                <code name="Линейный массив">
public static void LinearArrayOperation(ThickenExtrusion ext)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("линейный массив");	//Открытие блока изменений документа

   CoordinateNode3D node1 = new CoordinateNode3D(document); 
   node1.X = 200; node1.Y = 200; node1.Z = 200;
   CoordinateNode3D node2 = new CoordinateNode3D(document); 
   node2.X = 250; node2.Y = 250; node2.Z = 250;

   LinearArrayOperation lao = new LinearArrayOperation(document);
   lao.Operations.Add(ext);//добавление операции, как элемента массива
		
   lao.Direction1Point1 = node1.Geometry.Point;
   lao.Direction1Point2 = node2.Geometry.Point;
   lao.Direction1Number = 4;//кол-во копий
   lao.Direction1StepFromVector = true;//нарпавление
   lao.Direction1Step= 80;//шаг
   lao.Direction1Length = 10;//длина

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model3D.ArrayDirectionType">
            <summary>Тип задания количества копий по направлению</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayDirectionType.NumberAndAngle">
            <summary>Количество копий и общий угол</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayDirectionType.NumberAndLength">
            <summary>Количество копий и общая длина</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayDirectionType.AngleAndStep">
            <summary>Общий угол и шаг</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayDirectionType.LengthAndStep">
            <summary>Общая длина и шаг</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayDirectionType.NumberAndStep">
            <summary>Количество копий и шаг</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.IncludeInBom">
            <summary>Включать в спецификацию</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.IncludeBase">
            <summary>Значение свойства "Включать исходную операцию"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.Separated">
            <summary>Значение свойства "Разделять на тела"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.Exclusions">
            <summary>Коллекция исключений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.Restrictions">
            <summary>Ограничения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.Loops">
            <summary>Коллекция циклов, используемых для выбора копируемых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.Edges">
            <summary>Коллекция рёбер, используемых для выбора копируемых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.Faces">
            <summary>Коллекция копируемых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.Constructions">
            <summary>Коллекция копируемых элементов построения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.Operations">
            <summary>Коллекция копируемых операций</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ArrayOperation.ObjectsType">
            <summary>Тип копируемых элементов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayOperation.Type.Faces">
            <summary>Грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayOperation.Type.Construction">
            <summary>Элементы построения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayOperation.Type.Bodies">
            <summary>Тела</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ArrayOperation.Type.Operations">
            <summary>Операции</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ArrayOperation.Type">
{
int get();
}
Имеет место быть пересечение многих членов класса с CopyBaseOperation
Единый базовый класс/интерфейс не используется, т.к. логически мы предполагаем, что массивы и копирование/симметрия - разные вещи
<summary>Тип копируемых элементов</summary></member>
        <member name="T:TFlex.Model.Model3D.ArrayOperation">
            <summary>Базовая операция для всех видов массивов</summary>
[System::Reflection::DefaultMember("Item")]
</member>
        <member name="P:TFlex.Model.Model3D.ExclusionCollection.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ExclusionCollection.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ExclusionCollection.MoveNext">
            <summary>Перейти к следующему операнду</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ExclusionCollection.Current">
            <summary>Получить текущий операнд</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ExclusionCollection.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ExclusionCollection.Clear">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ExclusionCollection.RemoveAt(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ExclusionCollection.Add(TFlex.Model.Model3D.Exclusion)">
            <summary>Добавить операнд в конец списка</summary>
            <param name="exclusion">Добавляемый элемент</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ExclusionCollection.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ExclusionCollection">
            <summary>Коллекция исключений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Exclusion.Periodical">
            <summary>Периодический</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Exclusion.FullColumn">
            <summary>Полный столбец</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Exclusion.FullRow">
            <summary>Полный ряд</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Exclusion.Column">
            <summary>Столбец</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Exclusion.Row">
            <summary>Ряд</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Exclusion">
            <summary>Исключение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OperationCollection.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.OperationCollection.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.OperationCollection.MoveNext">
            <summary>Перейти к следующему операнду</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OperationCollection.Current">
            <summary>Получить текущий операнд</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.OperationCollection.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.OperationCollection.Clear">
            <summary>Удалить все операнды</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.OperationCollection.RemoveAt(System.Int32)">
            <summary>Удалить операнд по номеру</summary>
            <param name="index">Номер операнда</param>
            <remarks>Операнды нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.OperationCollection.Add(TFlex.Model.Model3D.Operation)">
            <summary>Добавить операнд в конец списка</summary>
            <param name="operand">Добавляемый операнд</param>
        </member>
        <member name="P:TFlex.Model.Model3D.OperationCollection.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OperationCollection">
            <summary>Коллекция операций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Objects3D.Dispose">
            <summary>Освободить внутренние данные</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Objects3D.Reset">
            <summary>Начать перечисления заново</summary>
            <remarks>Функция предназначена для перебора 3D элементов</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Objects3D.MoveNext">
            <summary>Перейти на следующий 3D объект</summary>
            <returns>Успешно или нет выполнен переход</returns>
            <remarks>Функция предназначена для перебора 3D элементов</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Objects3D.Current">
            <summary>Получить текущий 3D объект</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Objects3D">
            <summary>Класс предназначенный для перечисления 3D объектов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SymmetryOperation2.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SymmetryOperation2.Plane">
            <summary>Плоскость симметрии</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SymmetryOperation2.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для Симметрии операций</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.SymmetryOperation2.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.CopyBaseOperation2.Type)">
            <summary>Конструктор для операции Симметрии</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="type">Тип копируемых элементов</param>
        </member>
        <member name="T:TFlex.Model.Model3D.SymmetryOperation2">
            <summary>Класс операции Симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyOperation2.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyOperation2.Symmetry">
            <summary>Плоскость симметрии</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyOperation2.SymmetryPlane.ZX">
            <summary>Плоскость ZX целевой системы координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyOperation2.SymmetryPlane.YZ">
            <summary>Плоскость YZ целевой системы координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyOperation2.SymmetryPlane.XY">
            <summary>Плоскость XY целевой системы координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyOperation2.SymmetryPlane.None">
            <summary>Симметрии нет</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyOperation2.SymmetryPlane">
            <summary>Плоскость симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyOperation2.TargetLCS">
            <summary>Целевая система коодинат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyOperation2.SourceLCS">
            <summary>Исходная система коодинат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CopyOperation2.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для Копирования операций</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.CopyOperation2.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.CopyBaseOperation2.Type)">
            <summary>Конструктор для операции Копирования</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="type">Тип копируемых элементов</param>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyOperation2">
            <summary>Класс операции Копирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation2.IncludeInBom">
            <summary>Включать в спецификацию</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation2.Loops">
            <summary>Коллекция циклов, используемых для выбора копируемых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation2.Edges">
            <summary>Коллекция рёбер, используемых для выбора копируемых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation2.Faces">
            <summary>Коллекция копируемых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation2.Constructions">
            <summary>Коллекция копируемых элементов построения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation2.Operations">
            <summary>Коллекция копируемых операций</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation2.CopyMode">
            <summary>Тип копирования</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CopyBaseOperation2.IsModeAvailable(TFlex.Model.Model3D.CopyBaseOperation2.Mode)">
            <summary>Определить, доступен ли указанный режим копирования для данной операции</summary>
            <param name="mode">Режим копирования</param>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyBaseOperation2.Mode.Union">
            <summary>Копирование с объединением</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyBaseOperation2.Mode.Copy">
            <summary>Копия</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyBaseOperation2.Mode.Move">
            <summary>Перемещение</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyBaseOperation2.Mode">
            <summary>Тип копирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation2.ObjectsType">
            <summary>Тип копируемых элементов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyBaseOperation2.Type.Faces">
            <summary>Грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyBaseOperation2.Type.Construction">
            <summary>Элементы построения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyBaseOperation2.Type.Bodies">
            <summary>Тела</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.CopyBaseOperation2.Type.Operations">
            <summary>Операции</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyBaseOperation2.Type">
            <summary>Тип копируемых элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyBaseOperation2">
            <summary>Базовый класс для операций Копирования и Симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ConstructionCollection.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ConstructionCollection.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ConstructionCollection.Clear">
            <summary>Удалить все операнды</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ConstructionCollection.RemoveAt(System.Int32)">
            <summary>Удалить операнд по номеру</summary>
            <param name="index">Номер операнда</param>
            <remarks>Операнды нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ConstructionCollection.Add(TFlex.Model.Model3D.Construction3D)">
            <summary>Добавить операнд в конец списка</summary>
            <param name="operand">Добавляемый операнд</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ConstructionCollection.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ConstructionCollection">
            <summary>Коллекция элементов построения</summary>
            <remarks>В целом, похоже на OperationCollection</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.SymmetryOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SymmetryOperation.Plane">
            <summary>Плоскость симметрии</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SymmetryOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции Симметрия</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Создание новых объектов класса SymmetryOperation не рекомендуется. Пожалуйста, используйте класс SymmetryOperation2</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.SymmetryOperation">
            <summary>Класс операции Симметрия в T-Flex CAD до версии 11</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyOperation.TargetLCS">
            <summary>Целевая система коодинат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyOperation.SourceLCS">
            <summary>Исходная система коодинат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CopyOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для операции Копирования</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
            <remarks>Создание новых объектов класса CopyOperation не рекомендуется. Пожалуйста, используйте класс CopyOperation2</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyOperation">
            <summary>Класс операции Копирования в T-Flex CAD до версии 11</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation.AttributesFromSource">
            <summary>Значение свойства "Атрибуты с исходной операции"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation.IsMove">
            <summary>Значение свойства "Перенос без дублирования"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyBaseOperation.Source">
            <summary>Исходная операция</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyBaseOperation">
            <summary>Базовый класс для операций Копирования и Симметрии в T-FLEX CAD до версии 11</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Piramida.InnerDiameter">
            <summary>Внутренний диаметр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Piramida.Side">
            <summary>Стороны</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Piramida.Height">
            <summary>Высота</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Piramida.Diameter2">
            <summary>Диаметр 2</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Piramida.Diameter">
            <summary>Диаметр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Piramida.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Пирамиды</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Piramida">
            <summary>Пирамида</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Prisma.InnerDiameter">
            <summary>Внутренний диаметр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Prisma.Side">
            <summary>Стороны</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Prisma.Height">
            <summary>Высота</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Prisma.Diameter">
            <summary>Диаметр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Prisma.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Призмы</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Prisma">
            <summary>Призма</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Cone.Height">
            <summary>Высота</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Cone.Diameter2">
            <summary>Диаметр 2</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Cone.SemiAngle">
            <summary>Угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Cone.Diameter">
            <summary>Диаметр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Cone.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Конуса</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Cone">
            <summary>Конус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Cylinder.Height">
            <summary>Высота</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Cylinder.Diameter">
            <summary>Диаметр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Cylinder.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Цилиндра</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Cylinder">
            <summary>Циллиндр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Torus.MajorDiameter">
            <summary>Диаметр 1</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Torus.MinorDiameter">
            <summary>Диаметр 2</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Torus.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Тора</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Torus">
            <summary>Тор</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sphere.Diameter">
            <summary>Диаметр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Sphere.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Сферы</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Sphere">
            <summary>Сфера</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Block.ZSize">
            <summary>Длина стороны вдоль Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Block.YSize">
            <summary>Длина стороны вдоль Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Block.XSize">
            <summary>Длина стороны вдоль X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Block.Cube">
            <summary>Создать куб</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Block.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания Параллелепипеда</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Block">
            <summary>Параллелепипед</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.BottomThickness">
            <summary>Толщина донышка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.UseBottomThickness">
            <summary>Использовать толщину донышка примитива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.CanBottomThicknessSet">
            <summary>Разрешено управлять толщиной крышки примитива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.TopThickness">
            <summary>Толщина крышки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.UseTopThickness">
            <summary>Использовать толщину крышки примитива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.CanTopThicknessSet">
            <summary>Разрешено управлять толщиной крышки примитива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.Thickness">
            <summary>Толщина стенок</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.ThicknessMethod">
            <summary>Способ задания толщины стенок</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Primitive.ThicknessType.Disable">
            <summary>Толщина стенок не задана, результат объемное тело</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Primitive.ThicknessType.Symmetric">
            <summary>Толщина стенок симметрично</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Primitive.ThicknessType.Inside">
            <summary>Толщина стенок внутрь</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Primitive.ThicknessType.Outside">
            <summary>Толщина стенок наружу</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Primitive.ThicknessType.None">
            <summary>Толщина стенок не задана, результат листовое тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.CanThicknessSet">
            <summary>Разрешено управлять толщиной стенок примитива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.Symmetry">
            <summary>Разрешено управлять симметрий примитива</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Primitive.CanSymmetrySet">
            <summary>Разрешено управлять симметрий примитива</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Primitive">
            <summary>3D Примитив</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.RadiusDragger.Step">
__property virtual double get_Scale() { return m_scale; }
__property virtual void set_Scale ( double scale ) { m_scale = scale; }
</member>
        <member name="P:TFlex.Model.Model3D.Visual.RadiusDragger.Value">
            <summary>Текущее значение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.RadiusDragger.Release">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.RadiusDragger.UpdatePosition(TFlex.Model.Model3D.View3D,System.Int32,System.Int32)">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.RadiusDragger.Activate(TFlex.Model.Model3D.View3D,System.Int32,System.Int32,System.Single)">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.RadiusDragger.Center">
            <summary>Центральная точка вложения двумерного диска в трёхмерное пространство</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.RadiusDragger.Direction">
            <summary>Ориентация вложения двумерного диска в трёхмерное пространство</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.RadiusDragger.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.RadiusDragger">
            <summary>Манипулятор для радиального изменения данных</summary>
            <remarks>
Манипулятор позволяет изменять данные с помощью перемещения декораций из заданной точки радиально по двумерному диску.
</remarks>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DraggerManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.Decoration" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.CircleDragger" />
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.CircleDragger.Value">
            <summary>Текущее значение</summary>
            <remarks>Угол измеряется в градусах</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.CircleDragger.Release">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.CircleDragger.UpdatePosition(TFlex.Model.Model3D.View3D,System.Int32,System.Int32)">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.CircleDragger.Activate(TFlex.Model.Model3D.View3D,System.Int32,System.Int32,System.Single)">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.CircleDragger.Axis">
            <summary>Ось вращения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.CircleDragger.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.CircleDragger">
            <summary>Манипулятор для изменения угловых данных</summary>
            <remarks>
Манипулятор позволяет изменять данные с помощью вращения декораций вокруг заданной оси.
</remarks>
            <remarks>Угол измеряется в градусах</remarks>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DraggerManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.Decoration" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.LineDragger" />
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.LineDragger.FromOrigin">
            <summary>Значение драггера считается от начальной точки или от точки клика</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.LineDragger.Value">
            <summary>Текущее значение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.LineDragger.Release">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.LineDragger.UpdatePosition(TFlex.Model.Model3D.View3D,System.Int32,System.Int32)">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.LineDragger.Activate(TFlex.Model.Model3D.View3D,System.Int32,System.Int32,System.Single)">
            <summary>Переопределённый метод класса Dragger</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.LineDragger.Origin">
            <summary>Начальная точка, от которой измеряется перемещение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.LineDragger.Direction">
            <summary>Направление, вдоль которого измеряется перемещение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.LineDragger.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.LineDragger">
            <summary>Манипулятор для линейного изменения данных</summary>
            <remarks>
Манипулятор позволяет изменять данные с помощью перемещения декораций вдоль заданной оси.
</remarks>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DraggerManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.Decoration" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.CircleDragger" />
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.DraggerManager.Owner">
            <summary>Возвращает документ, с которым связан диспетчер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DraggerManager.RemoveAllDraggers">
            <summary>Удаляет все манипуляторы</summary>
            <remarks>
После удаления манипулятора из диспетчера обращение к нему недопустимо.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DraggerManager.RemoveDragger(TFlex.Model.Model3D.Visual.Dragger)">
            <summary>Удаляет манипулятор</summary>
            <remarks>
После удаления манипулятора из диспетчера обращение к нему недопустимо.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DraggerManager.RemoveDragger(System.Int32)">
            <summary>Удаляет манипулятор с заданным идентификатором</summary>
            <param name="id">Идентификатор, возвращаемый методом AddDragger</param>
            <remarks>
После удаления манипулятора из диспетчера обращение к нему недопустимо.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DraggerManager.GetDragger(System.Int32)">
            <summary>Возвращает манипулятор с заданным идентификатором</summary>
            <param name="id">Идентификатор, возвращаемый методом AddDragger</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DraggerManager.AddDragger(TFlex.Model.Model3D.Visual.Dragger)">
            <summary>Регистрирует манипулятор</summary>
            <remarks>
Только после вызова этого метода манипулятор изображается в 3D окне и может выбираться.
Манипулятор может быть зарегистрирован только один раз в одном диспетчере.
</remarks>
            <returns>Идентификатор, который может быть использован в методах GetDragger и RemoveDragger</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DraggerManager.GetManager(TFlex.Model.Document)">
            <summary>Возвращает диспетчер манипуляторов, связанный с заданным документом</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DraggerManager">
            <summary>Диспетчер манипуляторов</summary>
            <remarks>
Для того, чтобы манипулятор изображался в 3D окне и мог выбираться, нужно зарегистрировать его в диспетчере соответствующего документа.
</remarks>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.Dragger" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Dragger.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Dragger.FindClosestPoint(TFlex.Model.Model3D.View3D,System.Int32,System.Int32,System.Single,TFlex.Model.Model3D.FloatVector@)">
            <summary>Поиск ближайшей точки на декорациях</summary>
            <remarks>
Этим методом рекомендуется пользоваться внутри перекрытого метода Activated для того, чтобы найти точку, в которой луч пересёк декорации.
</remarks>
            <param name="view">Активный 3D вид</param>
            <param name="x">Экранная координата X курсора</param>
            <param name="y">Экранная координата Y курсора</param>
            <param name="tolerance">Допустимое расстояние от курсора до декорации</param>
            <param name="closestPoint">Ближайшая найденная точка на декорации</param>
            <returns>Декорация, которой непосредственно принадлежит найденная точка, или 0 в случае ошибки</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.Addition">
            <summary>Дополнительная информация</summary>
            <remarks>
Рекомендуется в порождённых классах переопределять этот метод для получения данных
</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.Transparent">
            <summary>Возможность выбора объектов, скрытых манипулятором</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.Cursor">
            <summary>Курсор</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.Decoration">
            <summary>Связанная декорация</summary>
            <remarks>Клиент должен сам освободить ресурсы декорации по окончании использования, вызвав Dispose()</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.MinimalValue">
            <summary>Минимальное значение</summary>
            <remarks>Может поддерживаться не всеми порождёнными классами</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.MinimalValueEnabled">
            <summary>Использование минимального значения</summary>
            <remarks>Может поддерживаться не всеми порождёнными классами</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.MaximalValue">
            <summary>Максимальное значение</summary>
            <remarks>Может поддерживаться не всеми порождёнными классами</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.MaximalValueEnabled">
            <summary>Использование максимального значения</summary>
            <remarks>Может поддерживаться не всеми порождёнными классами</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.Step">
            <summary>Текущий шаг</summary>
            <remarks>
Рекомендуется в порождённых классах переопределять этот метод для получения шага
</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Dragger.Value">
            <summary>Текущее значение</summary>
            <remarks>
Рекомендуется в порождённых классах переопределять этот метод для получения данных
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Dragger.Release">
            <summary>Конец перемещения</summary>
            <remarks>
Метод вызывается, когда пользователь отпускает левую кнопку мыши при активном манипуляторе.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Dragger.UpdatePosition(TFlex.Model.Model3D.View3D,System.Int32,System.Int32)">
            <summary>Обновление положения</summary>
            <remarks>Метод вызывается, когда пользователь перемещает мышь с зажатой левой кнопкой при активном манипуляторе</remarks>
            <param name="view">Активный 3D вид</param>
            <param name="x">Экранная координата X курсора</param>
            <param name="y">Экранная координата Y курсора</param>
            <returns>Должен возвращать true в случае, когда перемещение вызвало изменение данных и/или необходимость перерисовать декорации</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Dragger.Activate(TFlex.Model.Model3D.View3D,System.Int32,System.Int32,System.Single)">
            <summary>Активизация манипулятора</summary>
            <param name="view">Активный 3D вид</param>
            <param name="x">Экранная координата X курсора</param>
            <param name="y">Экранная координата Y курсора</param>
            <param name="tolerance">Допустимое расстояние от курсора до декорации</param>
            <returns>Должен возвращать true в случае, когда манипулятор может активизироваться, иначе false</returns>
            <remarks>
Метод вызывается, когда пользователь нажал на кнопку мыши в тот момент, когда курсор находился над декорацией, ассоциированной с манипулятором.
Для определения ближайшей к курсору точки на декорации можно воспользоваться методом FindClosestPoint со входными параметрами данного метода
</remarks>
        </member>
        <member name="E:TFlex.Model.Model3D.Visual.Dragger.Released">
            <summary>Событие происходит после выхода из метода Release</summary>
        </member>
        <member name="E:TFlex.Model.Model3D.Visual.Dragger.Updated">
            <summary>Событие происходит после того, как метод UpdatePosition возвращает true</summary>
        </member>
        <member name="E:TFlex.Model.Model3D.Visual.Dragger.Activated">
            <summary>Событие происходит после того, как метод Activated возвращает true</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Dragger">
            <summary>Манипулятор</summary>
            <value>
Базовый класс для всех манипуляторов. В порождённом классе необходимо перекрыть методы Activate и UpdatePosition, при необходимости и Release.
После создания манипулятора нужно связать его с
<see cref="T:TFlex.Model.Model3D.Visual.Decoration" />, декорацией
и зарегистрировать в
<see cref="T:TFlex.Model.Model3D.Visual.DraggerManager" />, диспетчере.
</value>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DraggerEventArgs.#ctor(TFlex.Model.Model3D.Visual.Dragger,TFlex.Model.Model3D.View3D,System.Int32,System.Int32,TFlex.Model.Model3D.Visual.VisualEventArgs.ActionType)">
Конструктор
</member>
        <member name="T:TFlex.Model.Model3D.Visual.DraggerEventArgs">
            <summary>Параметры событий манипуляторов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.VisualEventArgs.#ctor(TFlex.Model.Model3D.View3D,System.Int32,System.Int32,TFlex.Model.Model3D.Visual.VisualEventArgs.ActionType)">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.VisualEventArgs.ActionType">
Тип события
</member>
        <member name="T:TFlex.Model.Model3D.Visual.VisualEventArgs">
            <summary>Параметры событий манипуляторов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetAssemblyContextData3D(TFlex.Model.Document)">
            <summary />
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetFacesByPoint(TFlex.Model.Document,TFlex.Model.Model3D.Geometry.BasePoint3D,System.Collections.Generic.IList`1{TFlex.Model.Model3D.Operation})">
            <summary>Получить коллекцию граней, расположенных наиболее близко к заданной точке</summary>
            <param name="point3D">Точка, относительно которой будет выполняться поиск</param>
            <param name="operations">Операции, для которых будет выполняться поиск</param>
            <returns>Коллекция граней</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetModel3DObjectGroups(TFlex.Model.Document)">
            <summary>Контейнер групп объектов 3D модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetHarnesses(TFlex.Model.Document)">
            <summary>Контейнер жгутов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetScenarios(TFlex.Model.Document)">
            <summary>Контейнер сценариев разборки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSensors(TFlex.Model.Document)">
            <summary>Контейнер датчиков</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetRestraints(TFlex.Model.Document)">
            <summary>Контейнер граничных условий</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetDynamicStudies(TFlex.Model.Document)">
            <summary>Контейнер динамических задач модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetCAEStudies(TFlex.Model.Document)">
            <summary>Контейнер конечно-элементных задач модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetMates(TFlex.Model.Document)">
            <summary>Контейнер всех сопряжений</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetOperations(TFlex.Model.Document)">
            <summary>Контейнер всех операций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetThreads(TFlex.Model.Document)">
            <summary>Контейнер операций "Резьба"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSews(TFlex.Model.Document)">
            <summary>Контейнер операций сшивки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetImportedOperations(TFlex.Model.Document)">
            <summary>Контейнер операций "Внешняя модель"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetTapers(TFlex.Model.Document)">
            <summary>Контейнер операций уклона</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetShells(TFlex.Model.Document)">
            <summary>Контейнер оболочек</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSeparations(TFlex.Model.Document)">
            <summary>Контейнер операций разделения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetReferenceWorkplanes(TFlex.Model.Document)">
            <summary>Контейнер ссылочных рабочих плоскостей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetWorkplanes(TFlex.Model.Document)">
            <summary>Контейнер рабочих плоскостей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetProjections(TFlex.Model.Document)">
            <summary>Контейнер проекций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSwepts(TFlex.Model.Document)">
            <summary>Контейнер операций "По траектории"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetWorkSurfaces(TFlex.Model.Document)">
            <summary>Контейнер рабочих поверхностей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetProfiles(TFlex.Model.Document)">
            <summary>Контейнер 3D профилей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetNodes3D(TFlex.Model.Document)">
            <summary>Контейнер 3D узлов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetPaths3D(TFlex.Model.Document)">
            <summary>Контейнер 3D путей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetBooleans(TFlex.Model.Document)">
            <summary>Контейнер булевых операций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetRotations(TFlex.Model.Document)">
            <summary>Контейнер операций вращения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetExtrusions(TFlex.Model.Document)">
            <summary>Контейнер операций выталкивания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetPathArrays(TFlex.Model.Document)">
            <summary>Контейнер операций "Массив по пути"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetNodeArrays(TFlex.Model.Document)">
            <summary>Контейнер операций "Массив по точкам"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetCircularArrays(TFlex.Model.Document)">
            <summary>Контейнер операций "Круговой массив"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetLinearArrays(TFlex.Model.Document)">
            <summary>Контейнер операций "Линейный массив"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetParametricArrays(TFlex.Model.Document)">
            <summary>Контейнер операций "Параметрических массив"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetMaterials(TFlex.Model.Document)">
            <summary>Контейнер материалов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetLCSs(TFlex.Model.Document)">
            <summary>Контейнер локальных систем координат (ЛСК)</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetThreeFaceBlendings(TFlex.Model.Document)">
            <summary>Контейнер операций сглаживания трёх граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetFaceBlendings(TFlex.Model.Document)">
            <summary>Контейнер операций сглаживания граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetEdgeBlendings(TFlex.Model.Document)">
            <summary>Контейнер операций сглаживания рёбер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetLofts(TFlex.Model.Document)">
            <summary>Контейнер операций "По сечениям"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetCameras(TFlex.Model.Document)">
            <summary>Контейнер камер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSpirals(TFlex.Model.Document)">
            <summary>Контейнер операций "Спираль"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSprings(TFlex.Model.Document)">
            <summary>Контейнер операций "Пружина"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSheetMetalFeatures(TFlex.Model.Document)">
            <summary>Контейнер операций выштамповки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetHoles(TFlex.Model.Document)">
            <summary>Контейнер отверстий</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetPipes(TFlex.Model.Document)">
            <summary>Контейнер операций "Трубопровод"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSections(TFlex.Model.Document)">
            <summary>Контейнер сечений</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetFragments3D(TFlex.Model.Document)">
            <summary>Контейнер 3D фрагментов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetCopyOperations2(TFlex.Model.Document)">
            <summary>Контейнер операций копирования</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetCopyOperations(TFlex.Model.Document)">
            <summary>Контейнер операций копирования в T-Flex CAD до версии 11</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetPictures3D(TFlex.Model.Document)">
            <summary>Контейнер 3D картинок</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetLights(TFlex.Model.Document)">
            <summary>Контейнер источников света</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSymmetryOperations2(TFlex.Model.Document)">
            <summary>Контейнер операций симметрии</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSymmetryOperations(TFlex.Model.Document)">
            <summary>Контейнер операций симметрии в T-Flex CAD до версии 11</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetCutOperations(TFlex.Model.Document)">
            <summary>Контейнер операций отсесения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetBends(TFlex.Model.Document)">
            <summary>Контейнер операций гибки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetRebends(TFlex.Model.Document)">
            <summary>Контейнер операций повторной гибки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetUnbends(TFlex.Model.Document)">
            <summary>Контейнер операций разгибания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Document3D.GetSheetMetalParts(TFlex.Model.Document)">
            <summary>Контейнер заготовок для гибки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AssemblyContextData3D.FragmentTransformation">
            <summary>Трансформация фрагмента</summary>
            <remarks>Финальная трансформация редактируемого документ в контексте документа сборки</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.AssemblyContextData3D">
            <summary>Данные редактирования документа в контексте 3D сборки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ScenarioStages.Insert(System.UInt32)">
            <summary>Вставляет этап по указанному индексу.</summary>
            <param name="index">Индекс, по которому должен быть вставлен этап.</param>
            <remarks>После вызова этого метода ранее полученные объекты Stage могут ссылаться на разные этапы.</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.ScenarioPlaybackType">
            <summary>Тип воспроизведения анимации</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ScenarioPlaybackType.Flash">
            <summary>Отсутствие анимации</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ScenarioPlaybackType.ReversRepeat">
            <summary>ptReversRepeat с повтором</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ScenarioPlaybackType.Revers">
            <summary>Анимация от конца к началу (сборка)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ScenarioPlaybackType.DirectRepeat">
            <summary>ptDirect с повтором</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ScenarioPlaybackType.Looped">
            <summary>Анимация от начала до конца, и обратно (от конца до начала) (разборка - сборка)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ScenarioPlaybackType.Direct">
            <summary>Анимация от начала до конца, и стоп (разборка) (по умолчанию)</summary>
        </member>
        <member name="M:IScenarioAnimationSupport.GetFrameCount">
Получение числа кадров
</member>
        <member name="M:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Run">
            <summary>Функция генерации выталкивания от границы до границы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.Body,TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound,TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound)">
            <summary>Конструктор для задания выталкивания от границы до границы</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="profile">Выталкиваемый контур. Этот контур превращается в выталкивание и возращается в списке резльтирующих тел или удаляется</param>
            <param name="vector">Вектор направления выталкивания</param>
            <param name="start">Первая граница выталкивания</param>
            <param name="end">Вторая граница выталкивания</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Disjoint">
            <summary>Результирующее тело может иметь несвязанные разбиения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.End">
            <summary>Вторая граница выталкивания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Start">
            <summary>Первая граница выталкивания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundDistance">
            <summary>Значение отступа</summary>
            <remarks>Граница может задаваться четырьмя взаимоисключающими способами : листовым или твёрдым телом, гранью, поверхностью, отступом.
Значение отступа можно задавать если выбран тип границы Distance.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundSurface">
            <summary>Граничная поверхность</summary>
            <remarks>Граница может задаваться четырьмя взаимоисключающими способами : листовым или твёрдым телом, гранью, поверхностью, отступом.
Граничную поверхность можно задавать если выбран тип границы Surface.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundFace">
            <summary>Граничная грань</summary>
            <remarks>Граница может задаваться четырьмя взаимоисключающими способами : листовым или твёрдым телом, гранью, поверхностью, отступом.
Граничную грань можно задавать если выбран тип границы Face.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundBody">
            <summary>Граничное тело</summary>
            <remarks>Граница может задаваться четырьмя взаимоисключающими способами : листовым или твёрдым телом, гранью, поверхностью, отступом.
Граничное тело можно задавать если выбран тип границы Body или Sheet. Соответсвенно тело должно быть заданного типа.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundType">
            <summary>Тип границы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundTypeSet.Sheet">
            <summary>Выталкивание ограничивается листовым телом</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundTypeSet.Solid">
            <summary>Выталкивание ограничивается твёрдым телом</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundTypeSet.Face">
            <summary>Выталкивание ограничивается гранью</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundTypeSet.Surf">
            <summary>Выталкивание ограничивается поверхностью</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundTypeSet.Distance">
            <summary>Выталкивание ограничивается копией профиля на заданную величину отступа от исходного профиля по направлению</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.BoundTypeSet">
            <summary>Тип границы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.Side">
            <summary>Какая сторона ограничивающего тела, пересекающая профиль, считается первым разбиением</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.Division">
            <summary>Номер разбиения. Разбиения нумеруются от 1</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.Nearest">
            <summary>Если true, то разбиения нумеруются начиная с первого и увеличиваясь в направлении движения от профиля.
Если false, то первое разбиение наиболее удалено от профиля и номер разбиения увеличивается в направлении движения к профилю.</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.Forward">
            <summary>Граница задаётся в направлении вектора выталкивания ( true ) или в обратном направлении ( false )</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.#ctor(System.Boolean,TFlex.Model.Model3D.Geometry.BaseSurface,System.Boolean,System.UInt32,TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.SideType)">
            <summary>Конструктор для задания границы поверхностью</summary>
            <param name="forward">Граница задаётся в направлении вектора выталкивания ( true ) или в обратном направлении ( false )</param>
            <param name="surface">Граничная поверхность</param>
            <param name="nearest">Если true, то разбиения нумеруются начиная с первого и увеличиваясь в направлении движения от профиля.
Если false, то первое разбиение наиболее удалено от профиля и номер разбиения увеличивается в направлении движения к профилю</param>
            <param name="division">Номер разбиения. Разбиения нумеруются от 1</param>
            <param name="side">Какая сторона поверхности, пересекающая профиль, считается первым разбиением</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.#ctor(System.Boolean,TFlex.Model.Model3D.Geometry.BaseFace,System.Boolean,System.UInt32,TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.SideType)">
            <summary>Конструктор для задания границы гранью</summary>
            <param name="forward">Граница задаётся в направлении вектора выталкивания ( true ) или в обратном направлении ( false )</param>
            <param name="face">Граничная грань</param>
            <param name="nearest">Если true, то разбиения нумеруются начиная с первого и увеличиваясь в направлении движения от профиля.
Если false, то первое разбиение наиболее удалено от профиля и номер разбиения увеличивается в направлении движения к профилю</param>
            <param name="division">Номер разбиения. Разбиения нумеруются от 1</param>
            <param name="side">Какая сторона ограничивающей грани, пересекающая профиль, считается первым разбиением. Для первого и последнего разбиений грани с твёрдого тела допустимыми значениями являются только In и Out</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.#ctor(System.Boolean,TFlex.Model.Model3D.Geometry.BaseBody,System.Boolean,System.UInt32,TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.SideType)">
            <summary>Конструктор для задания границы телом</summary>
            <param name="forward">Граница задаётся в направлении вектора выталкивания ( true ) или в обратном направлении ( false )</param>
            <param name="body">Граничное тело. Может быть листовым или твёрдым телом</param>
            <param name="nearest">Если true, то разбиения нумеруются начиная с первого и увеличиваясь в направлении движения от профиля.
Если false, то первое разбиение наиболее удалено от профиля и номер разбиения увеличивается в направлении движения к профилю</param>
            <param name="division">Номер разбиения. Разбиения нумеруются от 1</param>
            <param name="side">Какая сторона ограничивающего тела, пересекающая профиль, считается первым разбиением. Для первого и последнего разбиений твёрдого тела допустимыми значениями являются только In и Out</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.#ctor(System.Boolean,System.Double)">
            <summary>Конструктор для задания границы значением отступа</summary>
            <param name="forward">Граница задаётся в направлении вектора выталкивания ( true ) или в обратном направлении ( false )</param>
            <param name="distance">Расстояние до границы в заданном направлении. Расстояние должно задаваться неотрицательным значением</param>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.SideType.In">
            <summary>Внутренняя сторона может быть первым разбиением</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.SideType.Out">
            <summary>Внешнияя сторона может быть первым разбиением</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.SideType.Both">
            <summary>Обе стороны могут быть первым разбиением</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound.SideType">
            <summary>Какая сторона ограничивающего тела, пересекающая профиль, считается первым разбиением</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator.Bound">
            <summary>Класс задания границы</summary>
            <remarks>Граница может задаваться четырьмя взаимоисключающими способами : листовым или твёрдым телом, гранью, поверхностью, отступом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BoundedExtrusionGenerator">
            <summary>Генератор выталкивания от границы до границы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ThickenExtrusionGenerator.Run">
            <summary>Функция генерации придания толщины</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ThickenExtrusionGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.Body,System.Double,System.Double)">
            <summary>Конструктор для задания придания толщины</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="sheet">Листовое тело. Этот лист возращается в списке результирующих тел или удаляется</param>
            <param name="thickness">Величина толщины в лицевом направлении</param>
            <param name="backThickness">Величина толщины в изнаночном направлении</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ThickenExtrusionGenerator">
            <summary>Генератор придания толщины</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ExtrudeGenerator.Run">
            <summary>Функция генерации выталкивания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ExtrudeGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.Body,System.Double,System.Double)">
            <summary>Конструктор для задания выталкивания по направлению на заданные длины в прямом и обратном направлении</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="vector">Вектор направления выталкивания</param>
            <param name="profile">Выталкиваемый контур. Этот контур превращается в выталкивание и возращается в списке результирующих тел или удаляется</param>
            <param name="length">Величина длины выталкивания в прямом направлении</param>
            <param name="backLength">Величина длины выталкивания в обратном направлении</param>
            <remarks>Все параметры обязательные.
3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ExtrudeGenerator">
            <summary>Генератор выталкивания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.LinLinRatio">
            <summary>Передаточное отношение сопряжения типа LinLinTransmission</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.AngLinRatio">
            <summary>Шаг на оборот сопряжения типа AngLinTransmission</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.AngAngRatio2">
            <summary>Передаточное значение второго элемента сопряжения типа AngAngTransmission, натуральное число</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.AngAngRatio1">
            <summary>Передаточное значение первого элемента сопряжения типа AngAngTransmission, натуральное число</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.AngleValue">
            <summary>Угол для сопряжения типа Angle</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.DistanceValue">
            <summary>Расстояние для сопряжения типа Distance</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.ReversedNormal">
            <summary>Развернуть нормали (для сопряжения плоскостей на расстоянии)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.ReversedDirection">
            <summary>Развернуть направления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.Suppressed">
            <summary>Подавление сопряжения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.Operation2">
            <summary>Вторая сопрягаемая операция (если имеется)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.Operation1">
            <summary>Первая сопрягаемая операция (если имеется)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.Element2">
            <summary>Второй сопрягаемый элемент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.Element1">
            <summary>Первый сопрягаемый элемент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Mate.Type">
            <summary>Тип сопряжения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Mate.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового сопряжения</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.RectanglePipe.Orientation">
            <summary>Ориентация профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RectanglePipe.ProfileProps">
            <summary>Получить параметры профиля трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RectanglePipe.RectangleProfileProperties.EndAngle">
            <summary>Конечный угол поворота профиля (используется только при включенном Orientation)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RectanglePipe.RectangleProfileProperties.BeginAngle">
            <summary>Начальный угол поворота профиля (используется только при включенном Orientation)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RectanglePipe.RectangleProfileProperties.BlendRadius">
            <summary>Сглаживание</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RectanglePipe.RectangleProfileProperties.Width">
            <summary>Ширина профиля трубы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RectanglePipe.RectangleProfileProperties.Length">
            <summary>Длина профиля трубы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.RectanglePipe.RectangleProfileProperties">
            <summary>Параметры прямоугольного профиля трубопровода</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.RectanglePipe.#ctor(TFlex.Model.Document)">
            <summary>Создать трубопровод с прямоугольным сечением в документе</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.RectanglePipe">
            <summary>Прямоугольный трубопровод</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Pipe.ProfileProps">
            <summary>Получить параметры профиля трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Pipe.CircleProfileProperties.Diameter">
            <summary>Диаметр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Pipe.CircleProfileProperties.CreateOneBody">
            <summary>Объединять в одно тело</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Pipe.CircleProfileProperties">
            <summary>Параметры круглого профиля трубопровода</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Pipe.#ctor(TFlex.Model.Document)">
            <summary>Создать круглый трубопровод в документе</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Pipe">
            <summary>Круглый трубопровод</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeSegments">
            <summary>Возвращает информацию об участках трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.BaseProfileProperties.Thickness">
            <summary>Толщина стенок</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.BaseProfileProperties.WallThickness">
            <summary>Наличие стенок</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.BaseProfileProperties.AsInnerSection">
            <summary>Использовать параметры габаритов для задания внутреннего сечения профиля</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BasePipe.BaseProfileProperties">
            <summary>Базовый класс свойств трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeSegment.FractureInEnd">
            <summary>Возвращает true, если нарушены условия гладкости пути трубопровода в точке конца участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeSegment.FractureInStart">
            <summary>Возвращает true, если нарушены условия гладкости пути трубопровода в точке начала участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeSegment.Round">
            <summary>Возвращает информацию о скруглении или арки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeSegment.End">
            <summary>Точка конца участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeSegment.Start">
            <summary>Точка начала участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeSegment.Length">
            <summary>Длина участка трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeSegment.Type">
            <summary>Тип участка трубопровода</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BasePipe.PipeSegment">
            <summary>Участок трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeRoundParameters.Angle">
            <summary>Угол скругления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeRoundParameters.Raduis">
            <summary>Радиус скругления</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.PipeRoundParameters.Center">
            <summary>Точка центра скругления</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BasePipe.PipeRoundParameters">
            <summary>Параметры скругления участка трубопровода</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BasePipe.PipeSegmentType.Arc">
            <summary>Арка, часть окружности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BasePipe.PipeSegmentType.Rounded">
            <summary>Cкругление</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BasePipe.PipeSegmentType.Curve">
            <summary>Кривая</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BasePipe.PipeSegmentType.Line">
            <summary>Прямая</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BasePipe.PipeSegmentType">
            <summary>Тип участка трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.Accuracy">
            <summary>Точность геометрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.Simplify">
            <summary>Параметр упрощения геометрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.NotCreateSolids">
            <summary>Не создавать твёрдотельную геометрию</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.Wires">
            <summary>Путь трубопровода</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.GetMidPartVariables">
            <summary>Получить переменные середины трубы</summary>
            <returns>Переменные "середины" трубы</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.GetEndPartVariables">
            <summary>Получить переменные конца трубы</summary>
            <returns>Переменные "конца" трубы</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.GetBeginPartVariables">
            <summary>Получить переменные начала трубы</summary>
            <returns>Переменные "начала" трубы</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.CountCuttingItem">
            <summary>Количество операций "врезки"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.GetCuttingItem(System.Int32)">
            <summary>Возвращает операцию "врезки" по индексу</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.RemoveAllCuttingItem">
            <summary>Удаляет все операции "врезки"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.RemoveCuttingItem(System.Int32)">
            <summary>Удаляет операцию "врезки" по индексу</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.RemoveCuttingItem(TFlex.Model.Model3D.Operation)">
            <summary>Удаляет операцию "врезки"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.AddCuttingItem(TFlex.Model.Model3D.Operation)">
            <summary>Добавляет операцию для создание "врезки"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.MidPart">
            <summary>Специальная "середина" трубы</summary>
            <param>Входной параметр строка, в которой указан путь к файлу фрагмента. (Или абсолютный, или относительный, или библиотечный, или строковая переменная (префикс $))</param>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.EndPart">
            <summary>Специальное "окончание" трубы</summary>
            <param>Входной параметр строка, в которой указан путь к файлу фрагмента. (Или абсолютный, или относительный, или библиотечный, или строковая переменная (префикс $))</param>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.BeginPart">
            <summary>Специальное "окончание" трубы</summary>
            <param>Входной параметр строка, в которой указан путь к файлу фрагмента. (Или абсолютный, или относительный, или библиотечный, или строковая переменная (префикс $))</param>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.IsSetMidPart">
            <summary>Наличие специальной "середины" трубы, как адаптивный фрагмент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.IsSetEndPart">
            <summary>Наличие специального "окончания" трубы, как фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.IsSetBeginPart">
            <summary>Наличие специального "окончания" трубы, как фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.EndBorder">
            <summary>Конечная граница трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.BeginBorder">
            <summary>Начальная граница трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.Path">
            <summary>Путь, используется вместо Wires</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.BorderInfo.Point">
            <summary>Добавить / удалить геометрическое смещение границы трубопровода, допустимо заначени null. Все предыдущие параметрические и геометрические смещения будут удалены.</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.BorderInfo.Offset">
            <summary>Полное значение смещения границы трубопровода в единицах пользователя</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.BorderInfo.AddOffset(TFlex.Model.Parameter)">
            <summary>Добавить параметрическое смещение границы трубопровода</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.BorderInfo.GetOffsetList(System.Collections.Generic.List`1{TFlex.Model.Parameter}@)">
            <summary>Получить список всех параметрических смещений границы трубопровода</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.BorderInfo.RemoveOffset">
            <summary>Удалить все параметрические смещения границы трубопровода</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BasePipe.BorderInfo.Reset">
            <summary>Сбросить границу в значение по умолчанию, конечная граница в конце пути, начальная граница в начале</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BasePipe.BorderInfo">
            <summary>Класс описывает границу трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BasePipe.IsRevers">
            <summary>Возвращает true, если направление трубы (от начальной к конечной границе) не совпадает с направлением пути</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BasePipe">
            <summary>Базовая операция трубопровода</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceSeparate.TargetHealingMethod">
            <summary>Обработка отделяемых граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceSeparate.SourceHealingMethod">
            <summary>Обработка исходных граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceSeparate.Faces">
            <summary>Отделяемые грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceSeparate.#ctor(TFlex.Model.Document)">
Shrink (not supported by face separate)
<summary>Конструктор для создания операции "Отделения граней"</summary><param name="document">Документ, в котором создаётся новый объект</param></member>
        <member name="F:TFlex.Model.Model3D.FaceSeparate.HealingMethodType.GrowFromChild">
            <summary>Удалить с расширением потомков</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceSeparate.HealingMethodType.GrowFromParent">
            <summary>Удалить с расширением родителей</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceSeparate.HealingMethodType.Cap">
            <summary>Удалить с затягиванием</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceSeparate.HealingMethodType.No">
            <summary>Только удалить (без обработки)</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceSeparate.HealingMethodType">
            <summary>Способ обработки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.Clear">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.RemoveAt(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество операндов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.Add(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить элемент в конец списка</summary>
            <param name="item">Добавляемый элемент</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray.Count">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceSeparate.SeparateFacesArray">
            <summary>Массив отделяемых граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceSeparate">
            <summary>Операция отделения граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Sensor.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Sensor.getMeterage(System.String)">
            <summary>Получить значение датчика по ключу</summary>
            <param name="key">Текстовый ключ запрашиваемого измерения</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Sensor">
            <summary>Датчик</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.VerticesArray.default(System.Int32)">
            <summary>Вершина по номеру</summary>
            <param name="Index">Номер вершины</param>
            <remarks>Вершины нумеруются от нуля. Если индекс отрицательный или превышает количество вершин, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.VerticesArray">
            <summary>Множество модельных вершин</summary>
            <remarks>Возможно перечисление вершин с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelVertex.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelVertex.Point">
            <summary>Получить точку</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelVertex.Edges">
            <summary>Множество смежных рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelVertex.Loops">
            <summary>Множество смежных циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelVertex.Faces">
            <summary>Множество смежных граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelVertex.Geometry">
            <summary>Получить геометрические данные вершины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelVertex.GeometryData.Point">
            <summary>Получить точку</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelVertex.GeometryData">
            <summary>Множество геометрических данных вершины</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelVertex">
            <summary>Модельная вершина</summary>
            <example>
                <code name="Пример строит 3d-узел на всех вершинах грани(f)">
public static void ModelVertexSelect(ModelFace f)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Сплайн");//Открытие блока изменений документа

   foreach (ModelVertex v in f.Vertices)//цикл по вершинам грани f
   {
       //создание узла
       GeometryNode3D n1 = new GeometryNode3D(document);
       n1.BasePoint = v.Geometry.Point;
   }

   document.EndChanges();	//Закрытие блока изменений документа	
}
</code>
            </example>
public ref class Point;
public ref class Direction3D;
public ref class Surface3D;
public ref class Sheet3D;
public ref class Vertex;
public ref class Edge;
public ref class Face;
</member>
        <member name="M:TFlex.Model.Model3D.Geometry.Vertex.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Vertex.Edges">
            <summary>Множество смежных рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Vertex.Loops">
            <summary>Множество смежных циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Vertex.Faces">
            <summary>Множество смежных граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Vertex.Point">
            <summary>Получить точку</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Vertex">
            <summary>Геометрическая вершина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseVertex.Edges">
            <summary>Множество смежных рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseVertex.Loops">
            <summary>Множество смежных циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseVertex.Faces">
            <summary>Множество смежных граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseVertex.Point">
            <summary>Получить точку</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseVertex">
            <summary>Базовый интерфейс для геометрических и модельных вершин</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetMesh.Max">
            <summary>Максимальная точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetMesh.Min">
            <summary>Минимальная точка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FacetMesh.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FacetMesh.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetMesh.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FacetMesh.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetMesh.default(System.Int32)">
            <summary>Получить грань по номеру</summary>
            <param name="Index">Номер грани</param>
            <remarks>Грани нумеруются от нуля. Если индекс отрицательный или превышает количество граней, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetMesh.Count">
            <summary>Количество треугольников</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.FacetMesh">
            <summary>Множество треугольников</summary>
            <remarks>Возможно перечисление треугольников с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetTriangle.N3">
            <summary>Нормаль в третьей точке</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetTriangle.N2">
            <summary>Нормаль во второй точке</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetTriangle.N1">
            <summary>Нормаль в первой точке</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetTriangle.P3">
            <summary>Третья точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetTriangle.P2">
            <summary>Вторая точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FacetTriangle.P1">
            <summary>Первая точка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.FacetTriangle">
            <summary>Треугольник</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelVertices.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelVertices.default(System.Int32)">
            <summary>Получить вершину по номеру</summary>
            <param name="index">Номер вершины</param>
            <remarks>Вершины нумеруются от нуля. Если индекс отрицательный или превышает количество вершин, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelVertices">
            <summary>Множество модельных вершин</summary>
            <remarks>Возможно перечисление вершин с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Vertices.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Vertices.default(System.Int32)">
            <summary>Получить вершину по номеру</summary>
            <param name="Index">Номер вершины</param>
            <remarks>Вершины нумеруются от нуля. Если индекс отрицательный или превышает количество вершин, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Vertices">
            <summary>Множество геометрических вершин</summary>
            <remarks>Возможно перечисление вершин с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseVertices.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseVertices.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseVertices.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseVertices.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseVertices.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseVertices.default(System.Int32)">
            <summary>Получить вершину по номеру</summary>
            <param name="index">Номер вершины</param>
            <remarks>Вершины нумеруются от нуля. Если индекс отрицательный или превышает количество вершин, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseVertices.Length">
            <summary>Количество вершин</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseVertices">
            <summary>Множество вершин</summary>
            <remarks>Возможно перечисление вершин с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelEdges.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdges.default(System.Int32)">
            <summary>Получить ребро по номеру</summary>
            <param name="Index">Номер ребра</param>
            <remarks>Рёбра нумеруются от нуля. Если индекс отрицательный или превышает количество рёбер, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelEdges">
            <summary>Множество модельных рёбер</summary>
            <remarks>Возможно перечисление рёбер с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Edges.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Edges.default(System.Int32)">
            <summary>Получить ребро по номеру</summary>
            <param name="Index">Номер ребра</param>
            <remarks>Рёбра нумеруются от нуля. Если индекс отрицательный или превышает количество рёбер, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Edges">
            <summary>Множество геометрических рёбер</summary>
            <remarks>Возможно перечисление рёбер с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseEdges.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseEdges.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseEdges.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdges.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseEdges.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdges.default(System.Int32)">
            <summary>Получить ребро по номеру</summary>
            <param name="Index">Номер ребра</param>
            <remarks>Рёбра нумеруются от нуля. Если индекс отрицательный или превышает количество рёбер, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdges.Length">
            <summary>Количество рёбер</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseEdges">
            <summary>Множество рёбер</summary>
            <remarks>Возможно перечисление рёбер с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelLoops.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoops.default(System.Int32)">
            <summary>Получить цикл по номеру</summary>
            <param name="Index">Номер цикла</param>
            <remarks>Циклы нумеруются от нуля. Если индекс отрицательный или превышает количество циклов, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelLoops">
            <summary>Множество модельных циклов</summary>
            <remarks>Возможно перечисление модельных циклов с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Loops.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Loops.default(System.Int32)">
            <summary>Получить цикл по номеру</summary>
            <param name="Index">Номер цикла</param>
            <remarks>Циклы нумеруются от нуля. Если индекс отрицательный или превышает количество циклов, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Loops">
            <summary>Множество геометрических циклов</summary>
            <remarks>Возможно перечисление циклов с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseLoops.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseLoops.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseLoops.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseLoops.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseLoops.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseLoops.default(System.Int32)">
            <summary>Получить цикл по номеру</summary>
            <param name="Index">Номер цикла</param>
            <remarks>Циклы нумеруются от нуля. Если индекс отрицательный или превышает количество циклов, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseLoops.Length">
            <summary>Количество циклов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseLoops">
            <summary>Множество циклов</summary>
            <remarks>Возможно перечисление циклов с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ThreeFaceBlendGenerator.Run">
            <summary>Функция генерации сглаживания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ThreeFaceBlendGenerator.Spine">
            <summary>Направляющая кривая</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ThreeFaceBlendGenerator.AddFaceToRightWall(TFlex.Model.Model3D.Geometry.BaseTopol)">
            <summary>Функция добавляет грань в список для правой стенки</summary>
            <param name="face">Добавляемая грань</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ThreeFaceBlendGenerator.AddFaceToCenterWall(TFlex.Model.Model3D.Geometry.BaseTopol)">
            <summary>Функция добавляет грань в список для центральной стенки</summary>
            <param name="face">Добавляемая грань</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ThreeFaceBlendGenerator.AddFaceToLeftWall(TFlex.Model.Model3D.Geometry.BaseTopol)">
            <summary>Функция добавляет грань в список для левой стенки</summary>
            <param name="face">Добавляемая грань</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ThreeFaceBlendGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.Body,TFlex.Model.Model3D.Geometry.SenseOfFace,TFlex.Model.Model3D.Geometry.SenseOfFace,TFlex.Model.Model3D.Geometry.SenseOfFace,System.Boolean)">
            <summary>Конструктор для задания базовых объектов сглаживания</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="body">Тело на котором строится сглаживание</param>
            <param name="leftSense">Параметр ориентации левой стенки</param>
            <param name="centerSense">Параметр ориентации центральной стенки</param>
            <param name="rightSense">Параметр ориентации правой стенки</param>
            <param name="propagateBlend">Продолжать ли сглаживание на гладкую последовательность граней</param>
            <remarks>3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ThreeFaceBlendGenerator">
            <summary>Генератор трёхгранного сглаживания</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SenseOfFace">
            <summary>Признак ориентации граней стенок при сглаживании</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SenseOfFace.OppositeSide">
            <summary>OppositeSide - ориентация противоположна ориентации граней</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SenseOfFace.SameSide">
            <summary>SameSide - ориентация согласно ориентации граней</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SenseOfFace.AutoDetected">
            <summary>AutoDetected - использовать режим автоопределения подходящей ориентации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelFaces.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFaces.default(System.Int32)">
            <summary>Получить грань по номеру</summary>
            <param name="Index">Номер грани</param>
            <remarks>Грани нумеруются от нуля. Если индекс отрицательный или превышает количество граней, то результат неопределён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelFaces">
            <summary>Множество модельных граней</summary>
            <remarks>Возможно перечисление граней с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Faces.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Faces.default(System.Int32)">
            <summary>Получить грань по номеру</summary>
            <param name="Index">Номер грани</param>
            <remarks>Грани нумеруются от нуля. Если индекс отрицательный или превышает количество граней, то результат неопределён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Faces">
            <summary>Множество геометрических граней</summary>
            <remarks>Возможно перечисление граней с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseFaces.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseFaces.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseFaces.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFaces.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseFaces.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFaces.default(System.Int32)">
            <summary>Получить грань по номеру</summary>
            <param name="Index">Номер грани</param>
            <remarks>Грани нумеруются от нуля. Если индекс отрицательный или превышает количество граней, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFaces.Length">
            <summary>Количество граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseFaces">
            <summary>Множество граней</summary>
            <remarks>Возможно перечисление граней с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Manipulators.TranslationManipulator.ModelSize">
            <summary>в модельных единицах (миллиметры, дюймы)</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.TranslationManipulator.GetPendingOffset">
            <summary>Получить динамическое значение смещения в модельных единицах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.TranslationManipulator.GetCommitedOffset">
            <summary>Получить фиксированное значение смещения в модельных единицах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.TranslationManipulator.ResetOffset(System.Double)">
            <summary>Перезадать смещение в модельных единицах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Manipulators.TranslationManipulator.SetAxis(TFlex.Model.Model3D.Geometry.Axis)">
            <summary>Задать ось</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Manipulators.ManipulatorInvalidStateException">
            <summary>XXX</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Manipulators.ManipulatorDisposedException">
            <summary>XXX</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Manipulators.ManipulatorException">
            <summary>XXX</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.Manipulators.ManipulatorEventArgs.Cursor">
            <summary>Положение курсора мыши в экранных координатах</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Manipulators.ViewUnits">
            <summary>Единицы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Visual.Manipulators.ViewUnits.Model">
            <summary>В модельнных единицах</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Visual.Manipulators.ViewUnits.Screen">
            <summary>В экранных координатах</summary>
        </member>
        <member name="M:mnp3d.IApiManip.BaseCreateElems">
virtual void BaseCreateParts() = 0;
</member>
        <member name="M:BuildModelTreeOptions.GetSubTreeObjects">
Получить список объектов, для которых создаётся поддерево
</member>
        <member name="M:BuildModelTreeOptions.EditSubTreeObjects">
Редактировать список объектов, для которых создаётся поддерево
</member>
        <member name="M:BuildModelTreeOptions.GetModelTreeType">
Получить состав дерева модели
</member>
        <member name="M:BuildModelTreeOptions.SetModelTreeType(BuildModelTreeOptions.ModelTreeType)">
Установить состав дерева модели
</member>
        <member name="M:BuildModelTreeOptions.GetAddObjects">
Получить список дополнительных объектов, которые будут добавлены в дерево
</member>
        <member name="M:BuildModelTreeOptions.EditAddObjects">
Редактировать список дополнительных объектов, которые будут добавлены в дерево
</member>
        <member name="T:BuildModelTreeOptions.ModelTreeType">
Состав дерева модели
</member>
        <member name="T:BuildModelTreeOptions">
Параметры построения дерева
</member>
        <member name="M:RegenerateModelTreeOptions.IsNestedRegeneration">
Проверить режим вложенного пересчета(например, параметрические копии)
</member>
        <member name="M:RegenerateModelTreeOptions.SetNestedRegeneration(System.Boolean)">
Установить режим вложенного пересчета(например, параметрические копии)
</member>
        <member name="M:RegenerateModelTreeOptions.IsOnly2D">
Проверить режим 2D пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.SetOnly2D(System.Boolean)">
Установить режим 2D пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.IsCompress">
Проверить режим компактизации представления 3D данных
</member>
        <member name="M:RegenerateModelTreeOptions.SetCompress(System.Boolean)">
Установить режим компактизации представления 3D данных
</member>
        <member name="M:RegenerateModelTreeOptions.IsShowGauge">
Проверить режим мониторинга процесса пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.SetShowGauge(System.Boolean)">
Установить режим мониторинга процесса пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.IsFullRegeneration">
Проверить режим полного пересчета
</member>
        <member name="M:RegenerateModelTreeOptions.SetFullRegeneration(System.Boolean)">
Установить режим полного пересчета
</member>
        <member name="T:RegenerateModelTreeOptions">
Параметры пересчета дерева
</member>
        <member name="P:TFlex.Model.Model3D.MaterialParameter.Name">
            <summary>Имя материала</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameter.Material">
            <summary>Материал</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameter.Variable">
            <summary>Ссылка на переменную</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialParameter.#ctor(System.String)">
            <summary>Конструктор для создания параметра, заданного именем материала</summary>
            <param name="Name">Имя материала</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialParameter.#ctor(TFlex.Model.Model3D.Material)">
            <summary>Конструктор для создания параметра, заданного материалом</summary>
            <param name="Mat">Материал</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialParameter.#ctor(TFlex.Model.Variable)">
            <summary>Конструктор для создания параметра, заданного переменной</summary>
            <param name="Var">Переменная</param>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialParameter">
            <summary>Класс для хранения ссылки на материал</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.SetMappingCoordSystem(System.Int32,TFlex.Model.Model3D.LCS)">
            <summary>Установить систему координат наложения текстуры для данной группы граней</summary>
            <remarks>Система координат определена для наложения проецированием на плоскость, цилиндр, сферу, параллелепипед</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.SetMappingCoordSystem(System.Int32,TFlex.Model.Model3D.Geometry.Point3D,TFlex.Model.Model3D.Geometry.Direction,TFlex.Model.Model3D.Geometry.Direction,TFlex.Model.Model3D.Geometry.Direction)">
            <summary>Установить систему координат наложения текстуры для данной группы граней</summary>
            <remarks>Система координат определена для наложения проецированием на плоскость, цилиндр, сферу, параллелепипед. Цепочка преобразований будет состоять из трёх сдвигов и трёх поворотов.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.GetMappingCoordSystem(System.Int32,TFlex.Model.Model3D.Geometry.Point3D@,TFlex.Model.Model3D.Geometry.Direction@,TFlex.Model.Model3D.Geometry.Direction@,TFlex.Model.Model3D.Geometry.Direction@)">
            <summary>Получить систему координат наложения текстуры для данной группы граней</summary>
            <remarks>Система координат определена для наложения проецированием на плоскость, цилиндр, сферу, параллелепипед</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.SetMappingType(System.Int32,TFlex.Model.Model3D.MaterialOperation.MappingType)">
            <summary>Установить способ наложения текстуры материала для заданной группы граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.GetMappingType(System.Int32)">
            <summary>Получить способ наложения текстуры материала для заданной группы граней</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialOperation.MappingType.AlongSurfaceIsolines">
            <summary>Вдоль координат поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialOperation.MappingType.BoxProjection">
            <summary>Проекция на параллелепипед</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialOperation.MappingType.SphereProjection">
            <summary>Проекция на сферу</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialOperation.MappingType.CylinderProjection">
            <summary>Проекция на цилиндр</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialOperation.MappingType.PlaneProjection">
            <summary>Проекция на плоскость</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialOperation.MappingType.MaterialDefault">
            <summary>Способ наложения исходного материала</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialOperation.MappingType">
            <summary>Способ наложения текстуры материала</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialOperation.GroupCount">
            <summary>Число групп граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.RemoveGroup(System.Int32)">
            <summary>Удалить заданную группу граней из наложению материала</summary>
            <remarks>Невозможно удалить все группы граней, нулевая группа граней есть всегда</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.AddGroup">
            <summary>Добавить новую пустую группу граней к наложению материала</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.GetFaceMaterial(System.Int32,System.Int32)">
            <summary>Получить материал грани из заданной группы граней по индексу</summary>
            <param name="Index">Индекс грани</param>
            <param name="Group">Индекс группы граней</param>
            <returns>Грань</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.GetFace(System.Int32,System.Int32)">
            <summary>Получить грань из заданной группы граней по индексу</summary>
            <param name="Index">Индекс грани</param>
            <param name="Group">Индекс группы граней</param>
            <returns>Грань</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.GetFaceMaterial(System.Int32)">
            <summary>Получить материал грани по индексу</summary>
            <param name="Index">Индекс грани</param>
            <returns>Грань</returns>
            <remarks>Возвращается грань из нулевой группы</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.GetFace(System.Int32)">
            <summary>Получить грань по индексу</summary>
            <param name="Index">Индекс грани</param>
            <returns>Грань</returns>
            <remarks>Возвращается грань из нулевой группы</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.GetFaceCount(System.Int32)">
            <summary>Число граней в заданной группе</summary>
            <param name="Group">Индекс группы граней</param>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialOperation.Count">
            <summary>Число граней</summary>
            <remarks>Число граней в нулевой группе</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.RemoveFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Исключить грань из операции наложения материала</summary>
            <param name="Face">Грань</param>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialOperation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.AddFace(System.Int32,TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить грань к наложению материала</summary>
            <param name="Group">Индекс группы граней</param>
            <param name="Face">Грань</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.AddFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить грань к наложению материала</summary>
            <param name="Face">Грань</param>
            <remarks>Грань добавляется в нулевую группу граней</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialOperation.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialOperation">
            <summary>Операция наложения материала</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.RemoveMaterial(System.Int32)">
            <summary>Удалить материал из библиотеки</summary>
            <param name="Index">Индекс материала</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.AddMaterial(TFlex.Model.Model3D.MaterialParameters)">
            <summary>Добавить материал в библиотеку</summary>
            <param name="Parameters">Параметры материала</param>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialLibrary.Count">
            <summary>Получить количество материалов в библиотеке</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.GetMaterial(System.Int32)">
            <summary>Получить параметры материала по индексу</summary>
            <param name="Index">Индекс материала</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.GetOpenedLibraries">
            <summary>Получить открытые библиотеки</summary>
            <returns>Библиотеки материалов</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.Load(System.String)">
            <summary>Загрузить библиотеку материалов</summary>
            <param name="FileName">Имя файла</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.Save(System.String)">
            <summary>Сохранить библиотеку материалов</summary>
            <param name="FileName">Имя файла</param>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialLibrary.PathName">
            <summary>Путь библиотеки материалов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialLibrary.FileName">
            <summary>Имя файла библиотеки материалов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.#ctor(System.String)">
            <summary>Конструктор с именем файла</summary>
            <param name="FileName">Имя файла</param>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialLibrary.Default">
            <summary>Библиотека материалов по умолчанию</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialLibrary.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialLibrary">
            <summary>Класс библиотеки материалов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Material.GetFromLibrary(TFlex.Model.Document,System.String)">
            <summary>Получить объект "Материал" с указанным именем из библиотеки</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="name">Имя материала</param>
            <returns>Материал</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Material.AddToLibrary">
            <summary>Добавить объект "Материал" в библиотеку</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Material.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Material.CopyParameters(TFlex.Model.Model3D.MaterialParameters)">
            <summary>Копировать свойства материала</summary>
            <param name="parameters">Параметры материала</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Material.Parameters">
            <summary>Получить свойства материала</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Material.#ctor(TFlex.Model.Document,System.String)">
            <summary>Создать объект "Материал" из материала библиотеки</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="name">Имя материала</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Material.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.MaterialParameters)">
            <summary>Конструктор для объекта "Материал"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="parameters">Параметры материала</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Material.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для объекта "Материал"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Material">
            <summary>Объект "Материал"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TemperatureCondition">
            <summary>Температуропроводность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.ThermalCondition">
            <summary>Теплопроводность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Expansion">
            <summary>Коэффициент линейного расширения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Stress">
            <summary>Допустимое напряжение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Puasson">
            <summary>Коэффициент Пуассона</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Elasticity">
            <summary>Модуль упругости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.ExportInfo">
            <summary>Дополнительные параметры фотореалистичного изображения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.PatternScale">
            <summary>Масштаб штриховки на сечениях</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Pattern">
            <summary>Имя шаблона штриховки на сечениях</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Density">
            <summary>Плотность материала</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialParameters.GetProperty(TFlex.Model.Model3D.MaterialParameters.PhysicalProperty)">
            <summary>Чтение физических параметров материала</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MaterialParameters.SetProperty(TFlex.Model.Model3D.MaterialParameters.PhysicalProperty,TFlex.Model.Parameter)">
            <summary>Установка физических параметров материала</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ThermalExansion">
            <summary>Температуропроводность</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.SpecificHeat">
            <summary>Удельная теплоемкость</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.YieldStress">
            <summary>Предел текучести</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.CompressiveStrength">
            <summary>Предел прочности на сжатие</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.TensileStrength">
            <summary>Предел прочности на разрыв</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ThermalConductivityZ">
            <summary>Теплопроводность вдоль оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ThermalConductivityY">
            <summary>Теплопроводность вдоль оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ThermalConductivityX">
            <summary>Теплопроводность вдоль оси X</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ThermalExpansionZ">
            <summary>Коэффициент линейного расширения вдоль оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ThermalExpansionY">
            <summary>Коэффициент линейного расширения вдоль оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ThermalExpansionX">
            <summary>Коэффициент линейного расширения вдоль оси X</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ShearModulusXZ">
            <summary>Модуль сдвига в плоскости XZ</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ShearModulusYZ">
            <summary>Модуль сдвига в плоскости YZ</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ShearModulusXY">
            <summary>Модуль сдвига в плоскости XY</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.PoissonRatioZ">
            <summary>Коэффициент Пуассона вдоль оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.PoissonRatioY">
            <summary>Коэффициент Пуассона вдоль оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.PoissonRatioX">
            <summary>Коэффициент Пуассона вдоль оси X</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ElasticModulusZ">
            <summary>Модуль упругости вдоль оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ElasticModulusY">
            <summary>Модуль упругости вдоль оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.ElasticModulusX">
            <summary>Модуль упругости вдоль оси X</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty.Density">
            <summary>Плотность материала</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialParameters.PhysicalProperty">
            <summary>Физические параметры материала</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.DirectionT">
            <summary>Направление оси T координат текстуры</summary>
            <remarks>Используется только в режиме отображения "проекция на плоскость"</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.DirectionS">
            <summary>Направление оси S координат текстуры</summary>
            <remarks>Используется только в режиме отображения "проекция на плоскость"</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.CoordFunction">
            <summary>Режим отображения текстуры</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.Function.Plane">
            <summary>Проекция на плоскость</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.Function.Environment">
            <summary>Окружение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.Function.DefaultCoord">
            <summary>По умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialParameters.Function">
            <summary>Режимы отображения текстуры</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TextureCenterT">
            <summary>Координата Т центра вращения текстуры</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TextureCenterS">
            <summary>Координата S центра текстуры</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TextureScaleT">
            <summary>Масштаб текстуры по оси T</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TextureScaleS">
            <summary>Масштаб текстуры по оси S</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TextureRotate">
            <summary>Угол поворота текстуры</summary>
            <remarks>Измеряется в градусах</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TextureTranslateT">
            <summary>Перенос текстуры по оси T</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TextureTranslateS">
            <summary>Перенос текстуры по оси S</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.BlendColor2">
            <summary>Цвет, используемый в смешанной модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.MappingModel">
            <summary>Модель совмещения цвета текстуры и грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.MapModel.Blend">
            <summary>Смешанная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.MapModel.Decal">
            <summary>Гравюрная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.MapModel.Modulate">
            <summary>Задающая</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialParameters.MapModel">
            <summary>Модель совмещения цвета текстуры и грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.WrapT">
            <summary>Тип наложения текстуры по оси T</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.WrapS">
            <summary>Тип наложения текстуры по оси S</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.WrapTexture.Clamped">
            <summary>Растягивание</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MaterialParameters.WrapTexture.Repeat">
            <summary>Повторение</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialParameters.WrapTexture">
            <summary>Тип наложения текстуры на грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Folder">
            <summary>Папка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Name">
            <summary>Имя материала</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.TextureFileName">
            <summary>Имя файла текстуры</summary>
            <remarks>Пустое имя означает отсутствие текстуры. Поддерживаются форматы файлов: GIF, JPEG, BMP, PNG. Для возможности экспорта в формат VRML рекомендуется использовать JPEG или PNG</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Transparency">
            <summary>Прозрачность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.Shininess">
            <summary>Уровень блеска</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.EmissiveColor2">
            <summary>Излучающий цвет</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.SpecularColor2">
            <summary>Отражающий цвет</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.DiffuseColor2">
            <summary>Рассеивающий цвет</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MaterialParameters.AmbientColor2">
            <summary>Окружающий цвет</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MaterialParameters">
            <summary>Параметры материала</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Virtual">
            <summary>Виртуальное тело, состоит из одной операции - типа 3D фрагмент или массив(копия, симметрия)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Active">
            <summary>Активное тело, не использовано в как заготовка в других телах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyPart.GetOperationChain(System.UInt32)">
            <summary>Получить операцию из цепочки тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.CountOperationChain">
            <summary>Количество операций в цепочке тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.BaseOperation">
            <summary>Базовая операция в теле</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.TopOperation">
            <summary>Верхняя операция в теле</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.BodyPart.CreatePart(TFlex.Model.Model3D.BodyPart.CreatePartOptions)">
            <summary>Создать деталь</summary>
            <param name="options">Параметры</param>
            <returns>Новый документ детали</returns>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyPart.CreatePartOptions.DocumentPath">
            <summary>Путь</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyPart.CreatePartOptions.DocumentTitle">
            <summary>Заголовок</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyPart.CreatePartOptions.Mode">
            <summary>Режим создания детали</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.BodyPart.CreatePartOptions.SilentMode">
            <summary>Не показывать диалог</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.BodyPart.CreatePartOptions">
            <summary>Параметры создания детали</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.UseBodyAttributes">
            <summary>Установлены атрибуты</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.MeshDensity">
            <summary>Плотность сетки в диапазоне 0.0-1.0</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Suppression">
            <summary>Свойство подавленности операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.CoatingMaterial">
            <summary>Покрытие</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Material">
            <summary>Материал</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Wireframe">
            <summary>Признак рёберной отрисовки операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Level">
            <summary>Уровень</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Color">
            <summary>Цвет</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.BodyPart.Name">
            <summary>Имя тела</summary>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model3D.BodyPart">
            <summary>Класс тела в структуре модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LoopsArray.default(System.Int32)">
            <summary>Цикл по номеру</summary>
            <param name="Index">Номер цикла</param>
            <remarks>Циклы нумеруются от нуля. Если индекс отрицательный или превышает количество циклов, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.LoopsArray">
            <summary>Множество модельных циклов</summary>
            <remarks>Возможно перечисление циклов с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoop.LoopType">
            <summary>Тип цикла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoop.Vertices">
            <summary>Множество вершин, принадлежащих циклу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoop.Edges">
            <summary>Множество рёбер, образующих цикл</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoop.Faces">
            <summary>Грань, которой принадлежит цикл</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoop.Geometry">
            <summary>Получить геометрические данные цикла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoop.GeometryData.Wire">
            <summary>Получить проволочный контур из рёбер, образующих цикл</summary>
            <returns>Объект, хранящий проволочные контуры и ссылку на геометрические данные цикла</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoop.GeometryData.Contour">
            <summary>Получить контур</summary>
            <returns>Объект, хранящий контуры и ссылку на геометрические данные цикла</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLoop.GeometryData.Plane">
            <summary>Если цикл с плоской грани, то можно получить эту плоскость</summary>
            <returns>Объект, содержащий координаты плоскости и ссылку на геометрические данные цикла</returns>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelLoop.GeometryData">
            <summary>Множество геометрических данных цикла</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelLoop">
            <summary>Модельный цикл</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Loop.LoopType">
            <summary>Тип цикла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Loop.Vertices">
            <summary>Множество вершин, принадлежащих циклу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Loop.Edges">
            <summary>Множество рёбер, образующих цикл</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Loop.Faces">
            <summary>Грань, которой принадлежит цикл</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Loop">
            <summary>Геометрический цикл</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseLoop.LoopType">
            <summary>Тип цикла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseLoop.Vertices">
            <summary>Множество вершин, принадлежащих циклу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseLoop.Edges">
            <summary>Множество рёбер, образующих цикл</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseLoop.Faces">
            <summary>Грань, которой принадлежит цикл</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseLoop">
            <summary>Базовый интерфейс для геометрических и модельных циклов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.LoopType">
            <summary>Тип цикла</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.Error">
            <summary>неверный цикл или сбой алгоритма</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.Unclear">
            <summary>цикл, который делит периодическую вырожденную поверхность на две (содержит только один полюс)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.LikelyInner">
            <summary>подобен дырке на дважды замкнутой поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.LikelyOuter">
            <summary>подобен внешнему циклу на дважды замкнутой поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.InnerSing">
            <summary>цикл, который представляет собой дырку вокруг поверхностной сингулярности, например, отсечение вершины конуса</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.Winding">
            <summary>витой цикл периодической поверхности, например, окружность на циллиндре или торе</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.Inner">
            <summary>обычный внутренний цикл</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.Outer">
            <summary>обычный внешний цикл</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.Wire">
            <summary>цикл, без внутренности, например, от проволочного тела</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.LoopType.Vertex">
            <summary>цикл без ребёр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.DirectedGuidePathParametric.#ctor(TFlex.Model.Model3D.Object3D)">
            <summary>Конструктор для создания свойств параметрического объекта</summary>
            <param name="object">Параметрический объект, для которого задаются свойства</param>
        </member>
        <member name="P:TFlex.Model.Model3D.DirectedGuidePathParametric.YSurface">
            <summary>Последовательность поверхностей, определяющих направление оси Y</summary>
            <remarks>Направление оси Y задаётся одним из двух способов: путём (касательная к пути в точке) или последовательностью поверхностей (нормаль к поверхности в точке)</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.DirectedGuidePathParametric.XSurface">
            <summary>Последовательность поверхностей, определяющих направление оси X</summary>
            <remarks>Направление оси X задаётся одним из двух способов: путём (касательная к пути в точке) или последовательностью поверхностей (нормаль к поверхности в точке).
Это обязательный параметр</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.DirectedGuidePathParametric.YPath">
            <summary>Множество проволочных моделей, образующих составной путь для определения направления оси Y</summary>
            <remarks>Направление оси Y задаётся одним из двух способов: путём (касательная к пути в точке) или последовательностью поверхностей (нормаль к поверхности в точке)</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.DirectedGuidePathParametric.XPath">
            <summary>Множество проволочных моделей, образующих составной путь для определения направления оси X</summary>
            <remarks>Направление оси X задаётся одним из двух способов: путём (касательная к пути в точке) или последовательностью поверхностей (нормаль к поверхности в точке).
Это обязательный параметр</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.DirectedGuidePathParametric.Direction">
            <summary>Способ определения направления осей</summary>
            <remarks>По умолчанию, направление оси X задаётся по минимальному расстоянию</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.DirectedGuidePathParametric.DirectionType.ByOffset">
            <summary>По смещению</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.DirectedGuidePathParametric.DirectionType.ByParameter">
            <summary>По параметру</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.DirectedGuidePathParametric.DirectionType.Perpendicular">
            <summary>Перпендикулярно пути</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.DirectedGuidePathParametric.DirectionType.MinimalDistance">
            <summary>По минимальному расстоянию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.DirectedGuidePathParametric.DirectionType">
            <summary>Способ определения направления осей, заданных путём</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.DirectedGuidePathParametric">
            <summary>Класс для описания системы координат копии по путям и последовательностям поверхностей</summary>
            <remarks>Форма и положение копий в параметрическом объекте задаётся несколькими путями и последовательностями поверхностей.
Один путь определяет начало локальной системы координат. Положение начала системы координат задаётся параметром (нормализованный параметр [0.0, 1.0]) или смещением от начала пути (натуральная параметризация).
Параметр, как правило, задаётся функцией от переменной номера копии.
Направление оси X задаётся одним из двух способов: путём (касательная к пути в точке) или последовательностью поверхностей (нормаль к поверхности в точке).
Направление оси Y задаётся одним из двух способов: путём (касательная к пути в точке) или последовательностью поверхностей (нормаль к поверхности в точке).
Ось Z определяется как векторное произведение осей X и Y.
Если ось Z не задана, то ось Z совпадает с касательной к первому пути в точке. Ось Y в этом случае определяется как вектороное произведение осей Z и X.
Пересчёт выполняется в несколько этапов:
<list class="bullet"><item>определяется локальная система координат;</item><item>координаты локальной системы координат передаются в переменные, от которых может зависеть форма копируемого объекта;</item><item>пересчитывается объект;</item><item>к полученному результату применяется преобразование из системы координат для первой копии или ЛСК (если задана) в систему координат для текущей копии. Таким образом, первый элемент массива остаётся на месте</item></list></remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.OneGuidePathParametric.#ctor(TFlex.Model.Model3D.Object3D)">
            <summary>Конструктор для создания свойств параметрического объекта</summary>
            <param name="object">Параметрический объект, для которого задаются свойства</param>
        </member>
        <member name="P:TFlex.Model.Model3D.OneGuidePathParametric.Direction">
            <summary>Способ определения направления оси X</summary>
            <remarks>По умолчанию, направление оси X задаётся по вектору кривизны</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.OneGuidePathParametric.DirectionType.Curvature">
            <summary>По вектору кривизны</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OneGuidePathParametric.DirectionType.MinimalRotation">
            <summary>Минимальное кручение</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OneGuidePathParametric.DirectionType">
            <summary>Способ определения направления оси X</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OneGuidePathParametric">
            <summary>Класс для описания системы координат копии по пути</summary>
            <remarks>Форма и положение копий в параметрическом объекте задаётся одним путём.
Он определяет локальную систему координат. Положение начала системы координат задаётся параметром (нормализованный параметр [0.0, 1.0]) или смещением от начала пути (натуральная параметризация).
Параметр, как правило, задаётся функцией от переменной номера копии.
Направление оси Z совпадает с касательной к пути в точке.
Направление оси X совпадает с вектором кривизны или вычисляется по закону минимального кручения.
Ось Y в этом случае определяется как векторное произведение осей Z и X.
Пересчёт выполняется в несколько этапов:
<list class="bullet"><item>определяется локальная система координат;</item><item>координаты локальной системы координат передаются в переменные, от которых может зависеть форма копируемого объекта;</item><item>пересчитывается объект;</item><item>к полученному результату применяется преобразование из системы координат для первой копии или ЛСК (если задана) в систему координат для текущей копии. Таким образом, первый элемент массива остаётся на месте</item></list></remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.GuidePathParametric.#ctor(TFlex.Model.Model3D.Object3D)">
            <summary>Конструктор для создания свойств параметрического объекта</summary>
            <param name="object">Параметрический объект, для которого задаются свойства</param>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.ParamFunction">
            <summary>Функция параметра (нормализованный параметр [0.0, 1.0])</summary>
            <remarks>Как правило, эта функция зависит от переменной номера копии.
Положение начала системы координат задаётся параметром (нормализованный параметр [0.0, 1.0]) или смещением от начала пути (натуральная параметризация)</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.OffsetFunction">
Управляющие параметры
<summary>Функция смещения от начала пути (натуральная параметризация)</summary><remarks>Как правило, эта функция зависит от переменной номера копии.
Положение начала системы координат задаётся параметром (нормализованный параметр [0.0, 1.0]) или смещением от начала пути (натуральная параметризация).
Один из этих переменных должна быть обязательно задана</remarks></member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.GuidePath">
            <summary>Множество проволочных моделей, образующих составной путь</summary>
            <remarks>Это обязательный параметр</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.ParamValue">
            <summary>Переменная, в которую записывается расcчитанное значение параметра(нормализованный параметр [0.0, 1.0])</summary>
            <remarks>Поскольку параметр изменяется в процессе пересчёта, то переменная может быть только независимой.
Положение начала системы координат задаётся параметром (нормализованный параметр [0.0, 1.0]) или смещением от начала пути (натуральная параметризация).
Тем не менее, значения параметра и смещения могут также использоваться в переменных, от которых зависит форма копируемого объекта</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.OffsetValue">
            <summary>Переменная, в которую записывается расcчитанное значение смещения от начала пути (натуральная параметризация)</summary>
            <remarks>Поскольку смещение изменяется в процессе пересчёта, то переменная может быть только независимой.
Положение начала системы координат задаётся параметром (нормализованный параметр [ 0.0, 1.0 ]) или смещением от начала пути (натуральная параметризация).
Тем не меннее, значения параметра и смещения могут также использоваться в переменных, от которых зависит форма копируемого объекта</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.AxisZ">
            <summary>Переменные, в которые записывается ориентация оси Z системы координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.AxisY">
            <summary>Переменные, в которые записывается ориентация оси Y системы координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.AxisX">
            <summary>Переменные, в которые записывается ориентация оси X системы координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.Origin">
Управляемые параметры
<summary>Переменные, в которые записывается положение системы координат</summary></member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.Coords.Z">
            <summary>Переменная, в которую записывается расcчитанное значение Z-координаты точки или вектора</summary>
            <remarks>Поскольку координата изменяется в процессе пересчета, то переменная может быть только независимой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.Coords.Y">
            <summary>Переменная, в которую записывается расcчитанное значение Y-координаты точки или вектора</summary>
            <remarks>Поскольку координата изменяется в процессе пересчета, то переменная может быть только независимой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.GuidePathParametric.Coords.X">
            <summary>Переменная, в которую записывается расcчитанное значение X-координаты точки или вектора</summary>
            <remarks>Поскольку координата изменяется в процессе пересчета, то переменная может быть только независимой</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.GuidePathParametric">
            <summary>Класс для описания свойств проволочной модели (пути) параметрического объекта</summary>
            <remarks>Форма и положение копий в параметрическом объекте задаётся проволочной моделью (путём).
Она определяет локальную систему координат. Положение начала системы координат задаётся параметром (нормализованный параметр [ 0.0, 1.0 ]) или смещением от начала пути (натуральная параметризация).
Параметр, как правило, задаётся функцией от переменной номера копии.
Направление осей задаётся в производных классах.
Пересчёт выполняется в несколько этапов:
<list class="bullet"><item>oпределяется локальная система координат;</item><item>координаты локальной системы координат передаются в переменные, от которых может зависеть форма копируемого объекта;</item><item>пересчитывается объект;</item><item>к полученному результату применяется преобразование из системы координат для первой копии или ЛСК (если задана) в систему координат для текущей копии. Таким образом, первый элемент массива остаётся на месте.</item></list></remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.VariableParametric.AxisZ">
            <summary>Функции, задающие ориентацию оси Z системы координат копии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.VariableParametric.AxisY">
            <summary>Функции, задающие ориентацию оси Y системы координат копии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.VariableParametric.AxisX">
            <summary>Функции, задающие ориентацию оси X системы координат копии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.VariableParametric.Origin">
            <summary>Функции, задающие положение системы координат копии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.VariableParametric.Coords.Z">
            <summary>Функция Z-координаты точки или вектора</summary>
            <remarks>Функция может быть константой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.VariableParametric.Coords.Y">
            <summary>Функция Y-координаты точки или вектора</summary>
            <remarks>Функция может быть константой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.VariableParametric.Coords.X">
            <summary>Функция X-координаты точки или вектора</summary>
            <remarks>Функция может быть константой</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.VariableParametric.Coords">
            <summary>Класс координат управляющих параметров копии объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.VariableParametric">
            <summary>Класс определения свойств параметрических объектов, в котором положение копий задаётся набором явных функциональных зависимостей от номера копии</summary>
            <remarks>Положение копии задаётся локальной системой координат. Нулевая точка и направление осей такой системы координат определяются функциями.
К каждой копии применяется преобразование из системы координат для первой копии или ЛСК (если задана) в систему координат для текущей копии. Таким образом, первый элемент массива остаётся на месте.
Если для системы координат функциональные зависимости не заданы, то, по умолчанию, она совпадает с глобальной системой координат и трансформация не выполняется.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Parametric.#ctor(TFlex.Model.Model3D.Object3D)">
            <summary>Конструктор для создания свойств параметрического объекта</summary>
            <param name="object">Параметрический объект, для которого задаются свойства</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Parametric.SourceLCS">
            <summary>Исходная система координат</summary>
            <remarks>К каждой копии применяется преобразование из исходной системы координат в текущую, которая может быть расчитана по пути или задана явными функциональными зависимостями от номера копии.
Исходная система координат может быть задана явно. Если исходная ЛСК не задана, то в качестве исходной ЛСК используется ЛСК первой копии</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Parametric.Number">
            <summary>Переменная номера копии</summary>
            <remarks>Значение для переменной устанавливается в процессе пересчёта от единицы до требуемого количества копий.
Как правило, от переменной в номере копии зависит форма и положение исходного объекта.
Поскольку номер копии изменяется в процессе пересчёта, то переменная может быть только независимой.
Это обязательный параметр</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Parametric.Quantity">
            <summary>Количество копий</summary>
            <remarks>Количество копий должно быть больше одного.
Количество копий округляется до ближайшего целого, меньшего заданного</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Parametric">
            <summary>Базовый класс определения общих свойств параметрических объектов</summary>
        </member>
        <member name="F:gfFragment3DPoint">
Привязка 3D фрагмента по точкам
</member>
        <member name="P:TFlex.Model.Model3D.TransformationGroupContainer.SourceCSType">
            <summary>Тип исходной системы координат преобразования</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupContainer.MoveBaseTransfGroupDown(TFlex.Model.Model3D.TransformationGroup)">
            <summary>Переместить базовую группу трансформаций на 1 позицию вниз. В случае успеха transfGroup становится устаревшей (IsValid == false).</summary>
            <param name="transfGroup">перемещаемая группа</param>
            <returns>возвращает обновленную группу преобразований.</returns>
            <remarks>после вызова этого метода полученные ранее объекты групп трансформаций TransformationGroup могут ссылаться на другие группы.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupContainer.MoveBaseTransfGroupUp(TFlex.Model.Model3D.TransformationGroup)">
            <summary>Переместить базовую группу трансформаций на 1 позицию вверх. В случае успеха transfGroup становится устаревшей (IsValid == false).</summary>
            <param name="transfGroup">перемещаемая группа</param>
            <returns>возвращает обновленную группу преобразований.</returns>
            <remarks>после вызова этого метода полученные ранее объекты групп трансформаций TransformationGroup могут ссылаться на другие группы.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupContainer.DeleteAllBaseTransfGroups">
            <summary>Удалить все группы базовых трансформаций из контейнера.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupContainer.DeleteBaseTransfGroup(System.Int32)">
            <summary>Удалить группу базовых трансформаций из контейнера.</summary>
            <param name="index">индекс удаляемой группы</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupContainer.AddBaseTransfGroup">
            <summary>Добавить новую группу базовых трансформаций в конец контейнера.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupContainer.GetBaseTransfGroups">
            <summary>Получить список всех групп базовых трансформаций в контейнере.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupContainer.GetBaseTransfGroupAt(System.Int32)">
            <summary>Получить группу базовых трансформаций в контейнере с индексом index.</summary>
            <param name="index">индекс требуемой группы транформаций</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupContainer.GetBaseTransfCount">
            <summary>Получить общее число базовых трансформаций в контейнере.</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TransformationGroupContainer.Owner">
            <summary>Объект, которому принадлежит контейнер.</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TransformationGroupContainer">
            <summary>Контейнер групп трансформаций.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroup.SetLCS(TFlex.Model.Model3D.LCS,System.Boolean)">
            <summary>Задать ЛСК группы трансформации</summary>
            <param name="lcs">задаваемая ЛСК</param>
            <param name="recalcCoords">пересчитать текущие координаты объекта с учётом новой ЛСК</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroup.GetLCS">
            <summary>Получить ЛСК группы трансформации</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TransformationGroup.IndexInContainer">
            <summary>Индекс группы трансформации в контейнере</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TransformationGroup">
            <summary>Группа трансформаций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddSetAxisTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.Geometry.ModelAxis)">
            <summary>Добавить трансформацию "Совместить ось полностью" к группе трансформаций.</summary>
            <param name="axisType">Поворачиваемая ось</param>
            <param name="axis">Ось, с которым должна совпасть поворачиваемая ось</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddSetAxisDirectionTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.Geometry.ModelDirection)">
            <summary>Добавить трансформацию "Повернуть параллельно направлению" к группе трансформаций.</summary>
            <param name="axis">Поворачиваемая ось</param>
            <param name="direction">Направление, с которым должна совпасть ось</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddDirectAxisByAxisToDirectionTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.Geometry.ModelDirection)">
            <summary>Добавить трансформацию "Повернуть ось вокруг оси по направлению" к группе трансформаций.</summary>
            <param name="stationaryAxis">неподвижная ось</param>
            <param name="rotatingAxis">направляемая ось</param>
            <param name="direction">направление для rotatingAxis</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddDirectAxisByAxisToPointTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Добавить трансформацию "Повернуть ось вокруг оси по направлению к точке" к группе трансформаций.</summary>
            <param name="stationaryAxis">неподвижная ось</param>
            <param name="rotatingAxis">направляемая ось</param>
            <param name="point">точка, на которую направляется rotatingAxis ось</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddDirectAxisToPointTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Добавить трансформацию "Направить ось на точку" к группе трансформаций.</summary>
            <param name="axis">направляемая ось</param>
            <param name="point">точка, на которую направляется ось</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddMoveToNodeTransf(TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Добавить трансформации "Перемещение до точки" к группе трансформаций. Трансформации добавляются для всех осей.</summary>
            <param name="point">точка, до которой производится перемещение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddMoveToNodeTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Добавить трансформацию "Перемещение до точки" к группе трансформаций</summary>
            <param name="axis">ось, вдоль которой производится перемещение</param>
            <param name="point">точка, до которой производится перемещение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddMoveToCurveTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.Geometry.ModelCurve)">
            <summary>Добавить трансформацию "Перемещение до кривой" к группе трансформаций</summary>
            <param name="axis">ось, вдоль которой производится перемещение</param>
            <param name="curve">кривая, до которой производится перемещение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddMoveToSurfaceTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Model3D.Geometry.ModelSurface)">
            <summary>Добавить трансформацию "Перемещение до плоскости" к группе трансформаций</summary>
            <param name="axis">ось, вдоль которой производится перемещение</param>
            <param name="surface">плоскость, до которой производится перемещение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddMap(TFlex.Model.Model3D.Geometry.AffineTransformation)">
            <summary>Добавить матрицу преобразований к группе трансформаций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddRotateTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Parameter)">
            <summary>Добавить трансформацию "Вращение" к группе трансформаций</summary>
            <param name="direction">ось, вокруг которой производится вращение</param>
            <param name="angle">угл вращения</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationGroupBase.AddMoveTransf(TFlex.Model.Model3D.TransformationCoordinate,TFlex.Model.Parameter)">
            <summary>Добавить трансформацию "Перемещение" к группе трансформаций</summary>
            <param name="direction">Ось, по которой производится перемещение</param>
            <param name="offset">отступ перемещения</param>
        </member>
        <member name="P:TFlex.Model.Model3D.TransformationGroupBase.Name">
            <summary>Имя группы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TransformationGroupBase.Suppressed">
            <summary>Параметр подавления группы трансформаций. Если больше 0 - группа подавлена.</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TransformationGroupBase.IsValid">
            <summary>true - группа трансформаций все еще находится в контейнере трансформаций. false - объект устарел. Использование приведет к исключениям.</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TransformationGroupBase.TransfContainer">
            <summary>Контейнер групп трансформаций, которому принадлежит данная группа</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TransformationGroupBase">
            <summary>Базовый класс групп трансформаций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Transformation.GetTransformationMatrix">
            <summary>Получаем карту преобразования</summary>
            <returns>Карта преобразования</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Transformation.Name">
            <summary>Имя преобразования</summary>
            <remarks>Имя преобразования уникальное для элемента содержащего это преобразование</remarks>
            <example>
                <code name="Пример использования свойства Name">
public static void SetName(String name) 
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   //получение объекта по имени
   ModelObject ob = document.GetObjectByName("x");
   if(ob!= null)
   {
    //назначить имя объекту
    ob.Name = "a1";
   }

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.Transformation.OnlyForExplode">
            <summary>Значение свойства "Только для разборки"</summary>
            <remarks>Свойство "Только для разборки" предназначено для того чтобы иcпользовать преобразование только в режиме разборки</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Transformation.Suppressed">
            <summary>Значение свойства исключения преобразования</summary>
            <remarks>Свойство подавления предназначено для исключения учёта данного преобразования для преобразования элемента</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Transformation">
            <summary>Базовый класс для всех 3D преобразований</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.MoveAt(System.Int32,TFlex.Model.Model3D.MoveType)">
            <summary>Переместить преобразование вниз или вверх в контейнере преобразований</summary>
            <param name="index">Индекс в контейнере преобразований объекта</param>
            <param name="direction">Тип перемещения преобразования</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.Count">
            <summary>Количество трансформаций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.RemoveAll">
            <summary>Удалить все преобразования</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.RemoveAt(System.Int32)">
            <summary>Удалить преобразование по индексу</summary>
            <param name="index">Индекс в контейнере преобразований объекта</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.GetAt(System.Int32)">
            <summary>Получить преобразование по индексу</summary>
            <returns>Преобразование, находящееся в контейнере преобразований объекта с указанным индексом. 0 в случае ошибки</returns>
            <param name="index">Индекс в контейнере преобразований объекта</param>
Функция возвращает объект, находящийся в контейнере преобразований элемента по указанному индексу.
</member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.Add(TFlex.Model.Model3D.Transformation)">
            <summary>Добавить новое преобразование</summary>
            <param name="transf">Индекс в контейнере выбранных объектов</param>
Функция добавляет преобразование в конец списка преобразований элемента модели.
</member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.Dispose">
            <summary>Освободить данные</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.Reset">
            <summary>Начать перебор преобразований с начала</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TransformationContainer.MoveNext">
            <summary>Перейти на следующее преобразование в списке</summary>
            <returns>Успешно или нет выполнен переход</returns>
            <remarks>Функция предназначена для перебора преобразований 3D элементов</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.TransformationContainer.Current">
            <summary>Получить очередное преобразование</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TransformationContainer">
            <summary> Контейнер преобразований 3D элемента</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TransformationLCSType">
            <summary>Тип исходной системы координат контейнера трансформаций</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.TransformationLCSType.CenterOfBoundBox">
            <summary>СК в центре обрамляющего параллелепипеда</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.TransformationLCSType.Global">
            <summary>Глобальная СК</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.TransformationLCSType.Fragment">
            <summary>Исходная система координат фрагмента</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.TransformationLCSType.Undefined">
            <summary>Не определён</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TransformationCoordinate">
            <summary> Тип направления перемещения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MoveType">
public ref class FaceTransform;
<summary>Тип перемещения преобразования</summary></member>
        <member name="F:TFlex.Model.Model3D.MoveType.Down">
            <summary>Вниз</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.MoveType.Up">
            <summary>Вверх</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SheetsArray.default(System.Int32)">
            <summary>Листовая модель по номеру</summary>
            <param name="Index">Номер листовой модели</param>
            <remarks>Листовые модели нумеруются от нуля. Если индекс отрицательный или превышает количество листовых моделей, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SheetsArray">
            <summary>Множество листовых моделей</summary>
            <remarks>Возможно перечисление листовых моделей с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.WiresArray.default(System.Int32)">
            <summary>Проволочная модель по номеру</summary>
            <param name="Index">Номер проволочной модели</param>
            <remarks>Проволочные модели нумеруются от нуля. Если индекс отрицательный или превышает количество проволочных моделей, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.WiresArray">
            <summary>Множество проволочных моделей</summary>
            <remarks>Возможно перечисление проволочных моделей с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ContoursArray.default(System.Int32)">
            <summary>Контур по номеру</summary>
            <param name="Index">Номер контура</param>
            <remarks>Контуры нумеруются от нуля. Если индекс отрицательный или превышает количество контуров, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ContoursArray">
            <summary>Множество контуров</summary>
            <remarks>Возможно перечисление контуров с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PointsArray.default(System.Int32)">
            <summary>Точка по номеру</summary>
            <param name="Index">Номер точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.PointsArray">
            <summary>Множество модельных точек</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.GeometricArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.GeometricArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.GeometricArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.GeometricArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.GeometricArray.DeleteAll">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.GeometricArray.Delete(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество элементов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.GeometricArray.Add(TFlex.Model.Model3D.Geometry.Geometry)">
            <summary>Добавить элемент в конец списка</summary>
            <param name="geom">Добавляемый элемент</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.GeometricArray.Insert(System.Int32,TFlex.Model.Model3D.Geometry.Geometry)">
            <summary>Вставить элемент перед номером</summary>
            <param name="index">Номер элемента</param>
            <param name="geom">Элемент</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество элементов, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.GeometricArray.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.GeometricArray">
            <summary>Множество геометрических данных</summary>
            <remarks>Возможно перечисление элементов с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointOnPath.Segment">
            <summary>Возвращает сегмент пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.PointOnPath.SetPositionOnPath(TFlex.Model.Model3D.Coordinate,TFlex.Model.Parameter)">
            <summary>Устанавливает позицию точки на пути по оси</summary>
            <remarks>U = X, V = Y, R = Z</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.PointOnPath.GetPositionOnPath(TFlex.Model.Model3D.Coordinate)">
            <summary>Возвращает позицию точки на пути по оси</summary>
            <remarks>U = X, V = Y, R = Z</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointOnPath.PositionOnPath">
            <summary>Возвращает позицию точки на пути</summary>
            <remarks>U = X, V = Y, R = Z</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointOnPath.Position">
            <summary>Возвращает позицию точки на пути в ГСК</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointOnSurface.Segment">
            <summary>Возвращает сегмент пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.PointOnSurface.SetPositionOnSurface(TFlex.Model.Model3D.Coordinate,TFlex.Model.Parameter)">
            <summary>Устанавливает позицию точки на поверхности по оси</summary>
            <remarks>U = X, V = Y, Z = не используется</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.PointOnSurface.EditPositionOnSurface(TFlex.Model.Model3D.Coordinate,TFlex.Model.Parameter,System.Boolean)">
            <summary>Редактирует позицию точки на поверхности по оси, или добавляет смещение</summary>
            <remarks>U = X, V = Y, Z = не используется</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.PointOnSurface.GetPositionOnSurface(TFlex.Model.Model3D.Coordinate)">
            <summary>Возвращает позицию точки на поверхности по оси</summary>
            <remarks>U = X, V = Y, Z = не используется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointOnSurface.PositionOnSurface">
            <summary>Управляет позицией точки на поверхности</summary>
            <remarks>U = X, V = Y, Z = не используется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointSplineToPolyline.Segment">
            <summary>Возвращает сегмент пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointSplineToPoint.Segment">
            <summary>Возвращает сегмент пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointSplineToPoint.TangentOverride">
            <summary>Разрешает пользовательскую касательную в точке</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.PointSplineToPoint.GetTangent(TFlex.Model.Model3D.Geometry.Point3D@,TFlex.Model.Parameter@)">
            <summary>Возвращает касательную в точке, если TangentOverride</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.PointSplineToPoint.SetLeftRightTangent(TFlex.Model.Model3D.Geometry.Point3D,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Устанавливает левостороннюю и правостороннюю касательную в точке</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.PointSplineToPoint.SetTangent(TFlex.Model.Model3D.Geometry.Point3D,TFlex.Model.Parameter)">
            <summary>Устанавливает касательную в точке</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointPolyline.Segment">
            <summary>Возвращает сегмент пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointPolyline.RadiusOverride">
            <summary>Включает pадиус скругления в точке</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.PointPolyline.Radius">
            <summary>Радиус скругления в точке</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePoint3D.SetLCS(TFlex.Model.Model3D.LCS,System.Boolean)">
            <summary>Управляет ЛСК в точке</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePoint3D.IsSetLCS">
            <summary>Установлена ЛСК</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePoint3D.IsIntegratedPosition">
            <summary>Поизиция точки носит интегрированный характер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePoint3D.SetPosition(TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Устанавливает положение точки по ModelPoint</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePoint3D.SetPosition(TFlex.Model.Model3D.Coordinate,TFlex.Model.Parameter)">
            <summary>Устанавливает положение точки на оси</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePoint3D.EditPosition(TFlex.Model.Model3D.Coordinate,TFlex.Model.Parameter,System.Boolean)">
            <summary>Редактирует положение точки на оси, либо добавляет дополнительное смещение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePoint3D.GetPosition(TFlex.Model.Model3D.Coordinate)">
            <summary>Положение точки на оси, либо nullptr, если IsIntegratedPosition</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.BasePoint3D.Position">
            <summary>Управление координатами</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePointInOffset.SetBasePoint(TFlex.Model.Model3D.PipePath3D.BasePointInOffset)">
            <summary>Управление базовой точкой</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePointInOffset.CanSetBasePoint">
            <summary>Допустимо ли установить базовую точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePointInOffset.IsSetBasePoint">
            <summary>Если установлена базовая точка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.PipePath3D.BasePointInOffset">
            <summary>Базовый класс точки, заданной в смещениях относительно базовой точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BasePoint.Equal(TFlex.Model.Model3D.PipePath3D.BasePoint)">
            <summary>Сравнить два точки</summary>
            <remarks>Если оба объекта представляют одну и туже сущность (точка пути) вернет "истину"</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.BasePoint.Position">
            <summary>Вовзращает позицию точку в ГСК</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.PipePath3D.BasePoint">
            <summary>Базовый класс точки пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentOnPath.CorrectPoint">
            <summary>Корректирует коордианты точек участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.SegmentOnPath.Path">
            <summary>Управляет путем участка пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.SegmentOnPath.Equidistant">
            <summary>Управляет расстоянием до пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.SegmentOnSurface.Surface">
            <summary>Управляет поверхностью участка пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.SegmentOnSurface.Equidistant">
            <summary>Управляет расстоянием до поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPolyline.Degree">
            <summary>Управляет степенью сплайна</summary>
            <remarks>Диапазон значений от 1 до 2</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.Degree">
            <summary>Управляет степенью сплайна</summary>
            <remarks>Диапазон значений от 3 до 5</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.GetEndPoint">
            <summary>Вернуть последнюю точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.GetPrevPoint(TFlex.Model.Model3D.PipePath3D.PointSplineToPoint)">
            <summary>Вернуть предыдущую точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.GetNextPoint(TFlex.Model.Model3D.PipePath3D.PointSplineToPoint)">
            <summary>Вернуть следующую точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.GetBeginPoint">
            <summary>Вернуть первую точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.GetPoint(System.Int32)">
            <summary>Вернуть точку по индексу</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.InsertPoint_before(TFlex.Model.Model3D.PipePath3D.PointSplineToPoint)">
            <summary>Вставить новую точку перед точки pPoint</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.InsertPoint_after(TFlex.Model.Model3D.PipePath3D.PointSplineToPoint)">
            <summary>Вставить новую точку после точки pPoint</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.AddPoint_end">
            <summary>Добавить точку в конец</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentSplineToPoint.AddPoint_begin">
            <summary>Добавить точку в начало</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.Radius">
            <summary>Управляет радиусом скругления</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.GetEndPoint">
            <summary>Вернуть последнюю точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.GetPrevPoint(TFlex.Model.Model3D.PipePath3D.PointPolyline)">
            <summary>Вернуть предыдущую точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.GetNextPoint(TFlex.Model.Model3D.PipePath3D.PointPolyline)">
            <summary>Вернуть следующую точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.GetBeginPoint">
            <summary>Вернуть первую точку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.GetPoint(System.Int32)">
            <summary>Вернуть точку по индексу</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.InsertPoint_before(TFlex.Model.Model3D.PipePath3D.PointPolyline)">
            <summary>Вставить новую точку перед точки pPoint</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.InsertPoint_after(TFlex.Model.Model3D.PipePath3D.PointPolyline)">
            <summary>Вставить новую точку после точки pPoint</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.AddPoint_end">
            <summary>Добавить точку в конец</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.SegmentPolyline.AddPoint_begin">
            <summary>Добавить точку в начало</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.BaseSegment.Reverse">
            <summary>Разворачивает участок пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.SetEndTangent(System.Double,System.Boolean)">
            <summary>Управление акмплитудой касательной в конце участка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.SetEndTangent(System.Boolean,System.Boolean)">
            <summary>Управление касательной в конце участка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.IsEndTangentPossible(System.Boolean)">
            <summary>Возможность касательной в конце участка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.SetBeginTangent(System.Double,System.Boolean)">
            <summary>Управление акмплитудой касательной в начале участка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.SetBeginTangent(System.Boolean,System.Boolean)">
            <summary>Управление касательной в начале участка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.IsBeginTangentPossible(System.Boolean)">
            <summary>Возможность касательной в начале участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.BaseSegment.CountPoints">
            <summary>Количество точке в участке</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.RemovePoint(System.Int32)">
            <summary>Удалить точку по индексу</summary>
            <remarks>Индекс indexPoint должен лежать в интервале от 0 до CountPoints</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.RemovePoint(TFlex.Model.Model3D.PipePath3D.BasePoint)">
            <summary>Удалить точку</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.BaseSegment.Type">
            <summary>Тип участка пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BaseSegment.Equal(TFlex.Model.Model3D.PipePath3D.BaseSegment)">
            <summary>Сравнить два сегмента</summary>
            <remarks>Если оба объекта представляют одну и туже сущность (участок пути) вернет "истину"</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.PipePath3D.BaseSegment">
            <summary>Базовый класс участок пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.EndEdit">
            <summary>Закончить редактирование объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.GetEndPoint">
            <summary>Получить объект которым заканчивается путь</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.GetStartPoint">
            <summary>Получить объект с которого начинается путь</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.BeginEdit">
            <summary>Подготавливает объект к редактированию</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.MakeSmoothness">
            <summary>Делает сглаживание</summary>
            <remarks>Создает гладкие межсегментные участки</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.Smoothness">
            <summary>Управляет сглаживанием</summary>
            <remarks>После установки сглаживания выполнить MakeSmoothness</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.TubeRadius">
            <summary>Управляет радиусом трубы</summary>
            <remarks>Используется только в режиме пользовательского редактирования</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.Tube">
            <summary>Управляет опцией трубы</summary>
            <remarks>Использовать совместно с TubeRadius.
Используется только в режиме пользовательского редактирования</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.GetEndSegment">
            <summary>Получить последний участок</summary>
            <remarks>Возвращаемое значение необходимо преобразовать к соответствующему типу сегмента</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.GetPrevSegment(TFlex.Model.Model3D.PipePath3D.BaseSegment)">
            <summary>Получить предыдущий участок</summary>
            <remarks>Возвращаемое значение необходимо преобразовать к соответствующему типу сегмента</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.GetNextSegment(TFlex.Model.Model3D.PipePath3D.BaseSegment)">
            <summary>Получить следующий участок</summary>
            <remarks>Возвращаемое значение необходимо преобразовать к соответствующему типу сегмента</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.GetBeginSegment">
            <summary>Получить первый участок</summary>
            <remarks>Возвращаемое значение необходимо преобразовать к соответствующему типу сегмента</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.RemoveSegment(System.Int32)">
            <summary>Удалить участок по индексу</summary>
            <remarks>Индекс indexSegment должен лежат в интервале от 0 до CountSegments</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.RemoveSegment(TFlex.Model.Model3D.PipePath3D.BaseSegment)">
            <summary>Удалить участок</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.AddSegment_back``1(TFlex.Model.Model3D.SegmentPipePathType)">
            <summary>Добавить участок в конец</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.AddSegment_front``1(TFlex.Model.Model3D.SegmentPipePathType)">
            <summary>Добавить участок в начало</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PipePath3D.GetSegment(System.Int32)">
            <summary>Получить участок</summary>
            <remarks>Индекс indexSegment должен лежат в интервале от 0 до CountSegments.
Возвращаемое значение необходимо преобразовать к соответствующему типу сегмента.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.PipePath3D.CountSegments">
            <summary>Возвращает количество участков</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.PipePath3D">
            <summary>Класс пути трубопровода</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Coordinate">
            <summary>Класс осей координат</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.SegmentPipePathType">
            <summary>Тип сегмента пути трубопровода</summary>
            <remarks>Поддерживается: сплайн по точкам, сплайн по ломаной, ломаная, участок пути на поверхности, участок по пути(ребру)</remarks>
        </member>
        <member name="M:Point2Dto3D.DoActionLikeRemoveLink(DeleteElementsContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Пытаемся разорвать связь с родителем
</member>
        <member name="P:TFlex.Model.Model3D.EdgesArray.default(System.Int32)">
            <summary>Ребро по номеру</summary>
            <param name="Index">Номер ребра</param>
            <remarks>Рёбра нумеруются от нуля. Если индекс отрицательный или превышает количество рёбер, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgesArray">
            <summary>Множество модельных рёбер</summary>
            <remarks>Возможно перечисление рёбер с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelEdge.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.Sense">
            <summary>Получить признак совпадения ориентации кривой и ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.Interval">
            <summary>Получить интервал кривой на котором лежит ребро</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.Curve">
            <summary>Получить кривую, на которой лежит ребро</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelEdge.GetPolyline(System.Double,System.Double,System.Double)">
            <summary>Полилиния</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelEdge.GetPolyline">
            <summary>Полилиния</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.Vertices">
            <summary>Множество вершин, смежных ребру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.Loops">
            <summary>Множество смежных циклов</summary>
            <remarks>Обычно смежных циклов не больше двух</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.Faces">
            <summary>Множество смежных граней</summary>
            <remarks>Обычно смежных граней не больше двух</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.Geometry">
            <summary>Получить геометрические данные ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.Contour">
            <summary>Получить контур</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.Curve">
            <summary>Получить кривую, на которой лежит кривая</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.Surface">
            <summary>Если ребро лежит в плоскости, то можно получить эту плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.Wire">
            <summary>Получить проволочную модель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.MiddlePoint">
            <summary>Получить точку в середине ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.ArcTangentIntersectPoint">
            <summary>Если ребро лежит на дуге ( части окружности ), то можно получить точку пересечания касательных на концах дуги</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.CurvePoint">
            <summary>Если ребро лежит на окружности или эллипсе, то можно получить их центр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.Plane">
            <summary>Если ребро лежит в плоскости, то можно получить эту плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.Axis">
            <summary>Если ребро лежит на оси, то можно получить её направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.Direction">
            <summary>В большинстве случаев ребро имеет не более одного направления. Выбрать любое возможное направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.LineDirection">
            <summary>Если ребро лежит на прямой, то можно получить её направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData.PlaneDirection">
            <summary>Если ребро лежит на окружности или эллипсе, то можно получить направление их осей</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelEdge.GeometryData">
            <summary>Множество геометрических данных ребра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelEdge">
            <summary>Модельное ребро</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Edge.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Edge.GetPolyline(System.Double,System.Double,System.Double)">
            <summary>Полилиния</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Edge.GetPolyline">
            <summary>Полилиния</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Edge.Vertices">
            <summary>Множество вершин, смежных ребру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Edge.Loops">
            <summary>Множество смежных циклов</summary>
            <remarks>Обычно смежных циклов не больше двух</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Edge.Faces">
            <summary>Множество смежных граней</summary>
            <remarks>Обычно смежных граней не больше двух</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Edge.Sense">
            <summary>Получить признак совпадения ориентации кривой и ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Edge.Interval">
            <summary>Получить интервал кривой на котором лежит ребро</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Edge.Curve">
            <summary>Получить кривую, на которой лежит ребро</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Edge">
            <summary>Геометрическое ребро</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseEdge.GetPolyline(System.Double,System.Double,System.Double)">
            <summary>Полилиния</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseEdge.GetPolyline">
            <summary>Полилиния</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdge.Vertices">
            <summary>Множество вершин, смежных ребру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdge.Loops">
            <summary>Множество смежных циклов</summary>
            <remarks>Обычно смежных циклов не больше двух</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdge.Faces">
            <summary>Множество смежных граней</summary>
            <remarks>Обычно смежных граней не больше двух</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdge.Sense">
            <summary>Получить признак совпадения ориентации кривой и ребра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdge.Interval">
            <summary>Получить интервал кривой на котором лежит ребро</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEdge.Curve">
            <summary>Получить кривую, на которой лежит ребро</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseEdge">
            <summary>Базовый интерфейс для геометрических и модельных рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FacesArray.default(System.Int32)">
            <summary>Грань по номеру</summary>
            <param name="index">Номер грани</param>
            <remarks>Грани нумеруются от нуля. Если индекс отрицательный или превышает количество граней, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.FacesArray">
            <summary>Множество модельных граней</summary>
            <remarks>Возможно перечисление граней с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelFace.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelFace.IntersectSurface(TFlex.Model.Model3D.Geometry.BaseSurface,System.Boolean,TFlex.Model.Model3D.Geometry.BaseBox,System.Boolean,TFlex.Model.Model3D.Geometry.UVBox,System.Boolean,TFlex.Model.Model3D.Geometry.UVBox,System.Boolean,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Найти пересечение грани с другой поверхностью</summary>
            <param name="surface">Поверхность, с которой ищется пересечение</param>
            <param name="havebox">Использовать область поиска пересечений</param>
            <param name="box">Область поиска пересечений</param>
            <param name="haveuvbox1">Использовать параметрическую область поиска пересечений для первой поверхности</param>
            <param name="uvbox1">Параметрическая область поиска пересечений для первой поверхности</param>
            <param name="haveuvbox2">Использовать параметрическую область поиска пересечений для второй поверхности</param>
            <param name="uvbox2">Параметрическая область поиска пересечений для второй поверхности</param>
            <param name="havepoint">Использовать точку для отбора одной из нескольких веток пересечения, на которой лежит точка</param>
            <param name="point">Точка для отбора одной из нескольких веток пересечения, на которой лежит точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelFace.IntersectCurve(TFlex.Model.Model3D.Geometry.BaseCurve,System.Double,System.Double)">
            <summary>Ищет пересечения между указываемым участком кривой и гранью.</summary>
            <param name="curve">Изгиб, с которым будет искаться пересечение</param>
            <param name="IntervalStart">Начало интервала изгиба</param>
            <param name="IntervalEnd">Конец интервала изгиба</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelFace.OutputSurfTrimmed(System.Double)">
            <summary>Возвращает обрезанную поверхность</summary>
            <param name="tolerance">Максимально допустимое расстояние между поверхностью грани и аппроксимирующей сплайновой поверхностью</param>
            <remarks>Рекомендуемая точность = 0.00001</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.Sense">
            <summary>Получить признак совпадения ориентации поверхности и грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.UVBox">
            <summary>Получить UVbox грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.Surface">
            <summary>Получить поверхность, на которой лежит грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.Vertices">
            <summary>Множество вершин</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.Loops">
            <summary>Множество циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.Edges">
            <summary>Множество рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.Geometry">
            <summary>Получить геометрические данные грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.Surface">
            <summary>Получить поверхность, на которой лежит грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.Wire">
            <summary>Получить проволочный контур из рёбер, ограничивающих грань</summary>
            <remarks>Результат определён только для одноконтурной грани</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.Sheet">
            <summary>Получить листовое тело по грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.Contour">
            <summary>Получить контур</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.Point">
            <summary>Если грань лежит на сфере или торе, то можно получить центр сферы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.Plane">
            <summary>Если грань плоская, то можно получить эту плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.Axis">
            <summary>Если грань лежит на цилиндре, конусе или торе, то можно получить направление их осей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.Direction">
            <summary>В большинстве случаев грань имеет не более одного направления. Выбрать любое возможное направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.PlaneDirection">
            <summary>Если грань плоская, то можно получить направление нормали к этой плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData.SurfaceDirection">
            <summary>Если грань лежит на цилиндре, конусе или торе, то можно получить направление их осей</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelFace.GeometryData">
            <summary>Множество геометрических данных грани</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelFace">
            <summary>Модельная грань</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Face.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Face.Vertices">
            <summary>Множество вершин</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Face.Loops">
            <summary>Множество циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Face.Edges">
            <summary>Множество рёбер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Face.OutputSurfTrimmed(System.Double)">
            <summary>Возвращает обрезанную поверхность</summary>
            <param name="tolerance">Максимально допустимое расстояние между поверхностью грани и аппроксимирующей сплайновой поверхностью</param>
            <remarks>Рекомендуемая точность = 0.00001</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Face.Sense">
            <summary>Получить признак совпадения ориентации поверхности и грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Face.UVBox">
            <summary>Получить UVbox грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Face.IntersectCurve(TFlex.Model.Model3D.Geometry.BaseCurve,System.Double,System.Double)">
            <summary>Ищет пересечения между указываемым участком кривой и гранью.</summary>
            <param name="curve">Изгиб, с которым будет искаться пересечение</param>
            <param name="IntervalStart">Начало интервала изгиба</param>
            <param name="IntervalEnd">Конец интервала изгиба</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Face.IntersectFace(TFlex.Model.Model3D.Geometry.Face,System.Boolean,TFlex.Model.Model3D.Geometry.BaseBox,System.Boolean,TFlex.Model.Model3D.Geometry.UVBox,System.Boolean,TFlex.Model.Model3D.Geometry.UVBox,System.Boolean,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Найти пересечение грани с другой гранью</summary>
            <param name="face">Грань, с которой ищется пересечение</param>
            <param name="havebox">Использовать область поиска пересечений</param>
            <param name="box">Область поиска пересечений</param>
            <param name="haveuvbox1">Использовать параметрическую область поиска пересечений для первой поверхности</param>
            <param name="uvbox1">Параметрическая область поиска пересечений для первой поверхности</param>
            <param name="haveuvbox2">Использовать параметрическую область поиска пересечений для второй поверхности</param>
            <param name="uvbox2">Параметрическая область поиска пересечений для второй поверхности</param>
            <param name="havepoint">Использовать точку для отбора одной из нескольких веток пересечения, на которой лежит точка</param>
            <param name="point">Точка для отбора одной из нескольких веток пересечения, на которой лежит точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Face.IntersectSurface(TFlex.Model.Model3D.Geometry.BaseSurface,System.Boolean,TFlex.Model.Model3D.Geometry.BaseBox,System.Boolean,TFlex.Model.Model3D.Geometry.UVBox,System.Boolean,TFlex.Model.Model3D.Geometry.UVBox,System.Boolean,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Найти пересечение грани с другой поверхностью</summary>
            <param name="surface">Поверхность, с которой ищется пересечение</param>
            <param name="havebox">Использовать область поиска пересечений</param>
            <param name="box">Область поиска пересечений</param>
            <param name="haveuvbox1">Использовать параметрическую область поиска пересечений для первой поверхности</param>
            <param name="uvbox1">Параметрическая область поиска пересечений для первой поверхности</param>
            <param name="haveuvbox2">Использовать параметрическую область поиска пересечений для второй поверхности</param>
            <param name="uvbox2">Параметрическая область поиска пересечений для второй поверхности</param>
            <param name="havepoint">Использовать точку для отбора одной из нескольких веток пересечения, на которой лежит точка</param>
            <param name="point">Точка для отбора одной из нескольких веток пересечения, на которой лежит точка</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Face.Surface">
            <summary>Получить поверхность, на которой лежит грань</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Face">
            <summary>Геометрическая грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFace.Vertices">
            <summary>Множество вершин</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFace.Loops">
            <summary>Множество циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFace.Edges">
            <summary>Множество рёбер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseFace.OutputSurfTrimmed(System.Double)">
            <summary>Возвращает обрезанную поверхность</summary>
            <param name="tolerance">Максимально допустимое расстояние между поверхностью грани и аппроксимирующей сплайновой поверхностью</param>
            <remarks>Рекомендуемая точность = 0.00001</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFace.Sense">
            <summary>Получить признак совпадения ориентации поверхности и грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFace.UVBox">
            <summary>Получить UVbox грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseFace.Surface">
            <summary>Получить поверхность, на которой лежит грань</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseFace">
            <summary>Базовый интерфейс для геометрических и модельных граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionItem.ParametersOnCurve">
            <summary>Параметр на кривой</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionItem.SurfaceUV">
            <summary>Параметр на поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionItem.IntersectionPoint">
            <summary>Точка пересечения кривой и грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionItem.IntersectionType">
            <summary>Тип пересечения кривой и грани.</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionItem">
            <summary>Тип данных, описывающий одно пересечение грани и кривой.</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType">
            <summary>Типы пересечениий грани и кривой.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.EndCurve">
            <summary>Кривая выходит из грани в конце региона, связанного с поверхностью.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.StartCurve">
            <summary>Кривая входит в грань в начале региона, связанного с поверхностью.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.InsideCurve">
            <summary>Начало или конец кривой лежит внутри грани или на ее границах.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.OutTangent">
            <summary>Кривая касается снаружи ребра или прохоит через вершину, но не соприкасается с гранью.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.InTangent">
            <summary>Кривая касается изнутри ребра или прохоит через вершину, но не соприкасается с гранью.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.InCoincidence">
            <summary>Кривая пересекает грань изнутри по напаравлению к региону, совпадающему с границами грани.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.CoincidenceIn">
            <summary>Кривая пересекает грань от региона, совпадающего с границами грани, внутрь.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.CoincidenceOut">
            <summary>Кривая пересекает грань от региона, совпадающего с границами грани, наружу.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.OutCoincidence">
            <summary>Кривая пересекает грань снаружи по напаравлению к региону, совпадающему с границами грани.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.InOut">
            <summary>Кривая пересекает грань по направлению изнутри наружу.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.OutIn">
            <summary>Кривая пересекает грань по направлению снаружи внутрь.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.Tangent">
            <summary>Кривая соприкасается с гранью в одной точке, но не проходит сквозь нее.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.Simple">
            <summary>Пересечение кривой с гранью в одной точке.</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.FaceCurveIntersectionType.Undefined">
            <summary>Тип не определён</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.UseHelpPoint">
            <summary>Параметр использования вспомогательной точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.BlendWalls">
            <summary>Тип результата</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.BlendTrim">
            <summary>Тип торца</summary>
            <param name="trimType">Тип</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ConstraintLimit2">
            <summary>Вторая ограничивающая плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ConstraintLimit1">
            <summary>Первая ограничивающая плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.NumberOfConstraintEdges">
            <summary>Получить число ограничивающих рёбер</summary>
            <returns>Число ограничивающих рёбер</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.RemoveAllConstraintEdges">
            <summary>Удалить все ограничивающие рёбра</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.RemoveConstraintEdge(System.Int32)">
            <summary>Удалить ограничивающее ребро</summary>
            <param name="edgeIndex">Номер ребра</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.AddConstraintEdge(TFlex.Model.Model3D.Geometry.ModelEdge,TFlex.Model.Model3D.FaceBlending.ConstraintEdgeType)">
            <summary>Добавить ограничивающее ребро</summary>
            <param name="edge">Ребро</param>
            <param name="type">Тип ограничения</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.CrossSectionPlaneMethod">
            <summary>Тип плоскости пересечения секций</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.PropagateFlag">
            <summary>Параметр "Продолжить по касательной"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.NotchFlag">
            <summary>Параметр "Вырез"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.HelpPoint">
            <summary>Вспомогательная точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.Spine">
            <summary>Путь</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.Attribute">
            <summary>Атрибут сглаживания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.RightSense">
            <summary>Реверс правой стенки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.NumberOfRightFaces">
            <summary>Получить число граней образующих правую стенку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.GetRightFace(System.Int32)">
            <summary>Полуить правую грань</summary>
            <param name="faceIndex">Номер грани</param>
            <returns>Грань</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.RemoveAllRightFaces">
            <summary>Удалить грани образующие правую стенку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.RemoveRightFace(System.Int32)">
            <summary>Удалить правую грань</summary>
            <param name="faceIndex">Номер грани</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.AddRightFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить грань в правую стенку</summary>
            <param name="face">Грань</param>
            <remarks>Все правые грани должны образовывать G1-непрерывную поверхность.
Все правые грани должны принадлежать одному телу.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.LeftSense">
            <summary>Реверс левой стенки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.NumberOfLeftFaces">
            <summary>Получить число граней образующих левую стенку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.GetLeftFace(System.Int32)">
            <summary>Полуить левую грань</summary>
            <param name="faceIndex">Номер грани</param>
            <returns>Грань</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.RemoveAllLeftFaces">
            <summary>Удалить грани образующие левую стенку</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.RemoveLeftFace(System.Int32)">
            <summary>Удалить левую грань</summary>
            <param name="faceIndex">Номер грани</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.AddLeftFace(TFlex.Model.Model3D.Geometry.ModelFace)">
            <summary>Добавить грань в левую стенку</summary>
            <param name="face">Грань</param>
            <remarks>Все левые грани должны образовывать G1-непрерывную поверхность.
Все левые грани должны принадлежать одному телу.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания операции "Сглаживание граней"</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ContinuousWidthAttribute.Ratio">
            <summary>Отношение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ContinuousWidthAttribute.Width">
            <summary>Ширина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ContinuousWidthAttribute.Type">
            <summary>Получить тип атрибута</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.ContinuousWidthAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор для создания операции сглаживания с постоянной шириной</summary>
            <param name="width">Ширина</param>
            <param name="ratio">Отношение длины между фасками</param>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.ContinuousWidthAttribute">
            <summary>Класс свойств использумый для создания сглаживания с постоянной шириной</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.ShapeMethod">
            <summary>Тип поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.PositionCount">
            <summary>Число позиций</summary>
            <remarks>Число позиций всегда больше или равно 2</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.GetPosition(System.Int32)">
            <summary>Удалить позицию</summary>
            <param name="positionIndex">Номер позиции, должен быть в диапазоне 1..последняя позиция-1</param>
            <returns>Новый номер позиции</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.SetPosition(System.Int32,TFlex.Model.Model3D.FaceBlending.PositionData)">
            <summary>Удалить позицию</summary>
            <param name="positionIndex">Номер позиции, должен быть в диапазоне 1..последняя позиция-1</param>
            <param name="data">Параметры заданные в позиции</param>
            <returns>Новый номер позиции</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.RemovePosition(System.Int32)">
            <summary>Удалить позицию</summary>
            <param name="positionIndex">Номер позиции, должен быть в диапазоне 1..последняя позиция-1</param>
            <remarks>Первая и последняя позиции не могут быть удалены</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.AddPosition(TFlex.Model.Model3D.FaceBlending.PositionData)">
            <summary>Добавить позицию</summary>
            <param name="data">Параметры заданные в позиции</param>
            <returns>Номер добавленной позиции</returns>
            <remarks>Всегда существуют две позиции со значениями 0 и 100.
Позиции всегда располагаются в порядке возрастания значения, добавление
новых позиций может привести к изменению порядкового индекса ранее добавленных позиций</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.Type">
            <summary>Получить тип атрибута</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.#ctor(TFlex.Model.Model3D.FaceBlending.PositionData,TFlex.Model.Model3D.FaceBlending.PositionData)">
            <summary>Конструктор</summary>
            <param name="first">Параметры переменного сглаживания в начальной позиции</param>
            <param name="last">Параметры переменного сглаживания в конечной позиции</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute.#ctor(TFlex.Model.Model3D.FaceBlending.PositionData)">
            <summary>Конструктор</summary>
            <param name="data">Параметры переменного сглаживания в начальной и конечной позиции</param>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.VariableRadiusAttribute">
            <summary>Класс свойств используемый для создания сглаживания с переменным радиусом</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute.ShapeMethod">
            <summary>Тип поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute.Softness">
            <summary>Мягкость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute.Radius">
            <summary>Радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute.Type">
            <summary>Получить тип атрибута</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Model3D.FaceBlending.ShapeType)">
            <summary>Конструктор</summary>
            <param name="radius">Радиус</param>
            <param name="softness">Мягкость</param>
            <param name="shape">Тип фигуры</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="radius">Радиус</param>
            <param name="softness">Мягкость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute.#ctor(TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="radius">Радиус</param>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute">
            <summary>Класс свойств используемый для создания сглаживания с постоянным радиусом</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.PositionData.Offset">
            <summary>Смещение</summary>
            <remarks>Смещение можно получить только если тип поверхности G2</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.PositionData.Depth">
            <summary>Глубина</summary>
            <remarks>Глубину можно получить только если тип поверхности G2</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.PositionData.Rho">
            <summary>Кривизна</summary>
            <remarks>Кривизна может быть установлена только если тип поверхности Conic</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.PositionData.Radius2">
            <summary>Второй радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.PositionData.Radius1">
            <summary>Первый радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.PositionData.Position">
            <summary>Значение позиции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.PositionData.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="position">Положение на последовательности рёбер</param>
            <param name="radius1">1-й радиус</param>
            <param name="radius2">2-й радиус</param>
            <param name="rho">Кривизна</param>
            <param name="depth">Глубина</param>
            <param name="offset">Смещение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.PositionData.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="position">Положение на последовательности рёбер</param>
            <param name="radius1">1-й радиус</param>
            <param name="radius2">2-й радиус</param>
            <param name="rho">Кривизна</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.PositionData.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="position">Положение на последовательности рёбер</param>
            <param name="radius1">1-й радиус</param>
            <param name="radius2">2-й радиус</param>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceBlending.PositionData.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="position">Положение на последовательности рёбер</param>
            <param name="radius">Радиус</param>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.PositionData">
            <summary>Класс используемый для задания параметров переменного сглаживания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceBlending.BlendAttribute.Type">
            <summary>Получить тип атрибута</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.BlendAttribute">
            <summary>Абстрактный класс используемый для задания свойств сглаживания</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.AttributeType.ContinuousWidth">
            <summary>Сглаживание с постоянной шириной</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.AttributeType.VariableRadius">
            <summary>Сглаживание с переменным радиусом</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.AttributeType.ContinuousRadius">
            <summary>Сглаживание с постоянным радиусом</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.AttributeType">
            <summary>Тип сглаживания граней</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.ShapeType.Chamfer">
            <summary>Фаска</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.ShapeType.G2">
            <summary>Непрерывная по 2-й производной</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.ShapeType.Conic">
            <summary>Коническая</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.ShapeType">
            <summary>Тип получаемой поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.WallsType.Solid">
            <summary>Отдельное тело</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.WallsType.Attach">
            <summary>Новое тело</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.WallsType.TrimBoth">
            <summary>Обрезать стенки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.WallsType.TrimNo">
            <summary>По левой стенке</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.WallsType">
            <summary>Результат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.TrimType.ToWalls">
            <summary>Обрезка по стенкам</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.TrimType.Long">
            <summary>Удлиненная обрезка</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.TrimType.Short">
            <summary>Короткая обрезка</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.TrimType.No">
            <summary>Не образать</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.TrimType">
            <summary>Тип обрезки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.ConstraintEdgeType.InvConicEdge">
            <summary>Обратное коническое ребро</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.ConstraintEdgeType.InvTangentEdge">
            <summary>Обратное касательное ребро</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.ConstraintEdgeType.ConicEdge">
            <summary>Коническое ребро</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.ConstraintEdgeType.TangentEdge">
            <summary>Касательное ребро</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.ConstraintEdgeType.CliffEdge">
            <summary>Обрезающее ребро</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.ConstraintEdgeType">
            <summary>Тип ограничивающего ребра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.CrossSectionPlaneType.Isoparameter">
            <summary>Изопараметрический</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.CrossSectionPlaneType.Disc">
            <summary>Дисковый метод</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.FaceBlending.CrossSectionPlaneType.RollingBall">
            <summary>Метод катящегося шарика</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending.CrossSectionPlaneType">
            <summary>Тип формирования плоскости пересечения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceBlending">
            <summary>Сглаживание граней</summary>
            <example>
                <code name="Сглаживание граней">
public static void FaceBlending()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("операция сглаживания граней");//Открытие блока изменений документа
       
   //путь
   PathConstruction pathConstruction = new PathConstruction(document);
   TFlex.Model.Model2D.Contour cn = pathConstruction.Contour;//контур
           
   //создание узлов
   FreeNode fn1 = new FreeNode(document, -200, 50);			
   FreeNode fn2 = new FreeNode(document, -160, 100);
   FreeNode fn3 = new FreeNode(document, -120, 50);			
   FreeNode fn4 = new FreeNode(document, -80, 100);  
           
   //соединяем узлы линиями
   ConstructionOutline l1 = new ConstructionOutline(document, fn1, fn2);
   ConstructionOutline l2 = new ConstructionOutline(document, fn2, fn3);
   ConstructionOutline l3 = new ConstructionOutline(document, fn3, fn4);
           
   double r = 68;	
           
   //дуга окружности, проходящая через два узла с заданным радиусом
   TwoPointArcOutline twoPointArcOutline = new TwoPointArcOutline(document, fn4, fn1, r);	
           
   //отнесение этих линий к контуру 
   OutlineContourSegment s1 = new OutlineContourSegment(cn);
   OutlineContourSegment s2 = new OutlineContourSegment(cn);
   OutlineContourSegment s3 = new OutlineContourSegment(cn);
   OutlineContourSegment s4 = new OutlineContourSegment(cn);             
   s1.Outline = l1; s2.Outline = l2; s3.Outline = l3;s4.Outline = twoPointArcOutline;  
           
   //создание штриховки
   Area ar = new Area (document); 
   TFlex.Model.Model2D.Contour cn1 = ar.AppendContour(); 
   //путь - контур штирховки
   ConstructionContourSegment seg1 = new ConstructionContourSegment(cn1); 
   seg1.Construction = pathConstruction; 
           
   //построение профиля
   StandardWorkplane swp = new StandardWorkplane(document, StandardWorkplane.StandardType.Left); 
   AreaProfile areaProfile = new AreaProfile(document); 
   areaProfile.Area = ar; //профиль по штриховке
   areaProfile.WorkSurface = swp;//Рабочая поверхность, задающая ориентацию профиля
           
   //выталкивание
   ThickenExtrusion ex = new ThickenExtrusion(document); 
   ex.Thickness1 = 10; 
   ex.LengthType = ThickenExtrusion.LengthValue.AutoValue; //Данный параметр должен быть выставлен! 
   ex.ForwardLength = 50; 
   ex.Profile.Add(areaProfile.Geometry.SheetContour);     
           
   document.ApplyChanges();//Применить изменения без закрытия блока изменения документа           
   FaceBlending faceBlending = new FaceBlending(document);//операция сглаживания
           
   int r = 30;//радиус сглаживания
   //класс свойств, используемый для создания сглаживания с постоянным радиусом
   TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute s = new TFlex.Model.Model3D.FaceBlending.ContinuousRadiusAttribute(r);
   faceBlending.Attribute = s;//установка радиуса для операции    
           
   //грани тела выталкивания
   faceBlending.AddLeftFace((ModelFace)ex.Geometry.Solid[0].Faces[0]);
   faceBlending.AddRightFace((ModelFace)ex.Geometry.Solid[0].Faces[1]);	
           
   //реверс этих граней
   faceBlending.LeftSense = true;
   faceBlending.RightSense = true;
   faceBlending.BlendWalls = FaceBlending.WallsType.Solid;//тип результата - отдельное тело
           
   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="F:Operation3DBase.m_visualProperty">
"видимые" свойства операции
</member>
        <member name="M:Operation3DBase.ReadForFragment_v1(TFDocRegenContext*,CFile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MapPtr2Ptr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16,COwnVersionTriplet*!System.Runtime.CompilerServices.IsConst)">
Чтение исполнения до 15 версии
</member>
        <member name="M:Operation3DBase.InitMember">
Инициализация операции. Вызывается из конструкторов.
</member>
        <member name="M:Operation3DBase.CopyBody(Operation3DBase*,TFDocRegenContext*)">
Копировать тела из source операции в текущую
</member>
        <member name="M:Operation3DBase.WriteForFragment(CTfw32Doc*,CFile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Запись исполнения
</member>
        <member name="M:Operation3DBase.ReadForFragment(TFDocRegenContext*,CFile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MapPtr2Ptr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16,COwnVersionTriplet*!System.Runtime.CompilerServices.IsConst)">
Чтение исполнения
</member>
        <member name="M:Operation3DBase.GetBodyType">
фукнция возвращает общий тип тел в операции
</member>
        <member name="M:Operation3DBase.NeedUpdateBodiesProperties">
необходимо обновить свойства(материал, цвет, прозрачность и т.д.) тел в операции
</member>
        <member name="M:Operation3DBase.UpdateBodiesProperties(System.Boolean)">
функция обновляет "видимые" свойства тел операции
</member>
        <member name="M:Operation3DBase.SetSolid(System.Int32,GeometricBody*)">
заменить тело на другое
</member>
        <member name="M:Operation3DBase.AddSolid(TFDocRegenContext*,GeometricBody*)">
функция добавляет тело в операцию
</member>
        <member name="F:oo_Enrichment">
Флаг устанавливается для новых операций
</member>
        <member name="F:OperationVisualProperty.m_Wireframe">
реберное представление
</member>
        <member name="F:OperationVisualProperty.m_complexity_Obsolete">
параметр определяющий качество сетки (устарел)
</member>
        <member name="F:VisualPropertyBase.m_coatingMaterialVar">
материал покрытия
</member>
        <member name="F:VisualPropertyBase.m_materialVar">
основной материал
</member>
        <member name="F:VisualPropertyBase.m_color">
индекс цвета
</member>
        <member name="M:CTFTransfObj.DoActionLikeRemoveLink(DeleteElementsContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Пытаемся разорвать связь с целевыми 3D фрагментами
</member>
        <member name="M:CTFTransfObj.OldTransfVersion(System.Int32)">
Номер старой версии алгоритма
</member>
        <member name="T:CTFTransfObj.TypeSourceCoordinatSystem">
Способ задания исходной системы координат
</member>
        <member name="T:CTFTransfObj">
Базовый класс для объектов 3D-модели, к которым применимо преобразование
</member>
        <member name="M:SelScnObj.DoActionAfterOpen(TFDocRegenContext*)">
Метод вызывается после чтения, актуализации, исправлений
</member>
        <member name="F:TF_REF_DIR_RESTORE">
Обычно используется при конвертации моделей из старых версий
</member>
        <member name="M:TFlex.Geometry.TFPKTransf.GetTransf(System.Boolean)">
Функция эффективно формирует парасолидное представление преобразования (кэширование), допускает создание копий
</member>
        <member name="M:TFlex.Geometry.TFPKTransf.SetTransf(System.Int32!System.Runtime.CompilerServices.IsConst,System.Boolean)">
Функция конвертирует парасолидное представление преобразование в формате TF3D::AffineMap (в случае copy == true снимает копию с transf, иначе полное владение transf)
</member>
        <member name="M:TF_PK_BODY_clip_sheet(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,System.Int32,PK_EDGE_array_s!System.Runtime.CompilerServices.IsConst*,System.Int32,PK_VECTOR_s!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsConst,System.Int32*!System.Runtime.CompilerServices.IsConst,System.Int32**!System.Runtime.CompilerServices.IsConst,PK_TOPOL_track_r_s*!System.Runtime.CompilerServices.IsConst)">
Обрезка набора тел по границам, образованным связанными наборами рёбер
Точки, лежащие на листовых телах, которые остаются в результате обрезки
Если обрезаемые тела образуют одную или несколько замкнутых поверхностей, то задание точек обязательно.
В случае листовых тел, если точки не заданы, то выбираются внутренние компоненты. Из них вырезаются остальные компоненты согласно порядку вложенности.
Если листовое тело имеет замыкание, и линия разреза является петлёй, то также явно нужно задавать, какой компонент оставлять
</member>
        <member name="M:TF_PK_VERTEX_ask_faces(System.Int32,std.list&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Для вершины формируется упорядоченный список граней
</member>
        <member name="M:PK_EDGE_find_common_vertex(System.Int32,System.Int32,System.Int32*)">
Для двух смежных рёбер находим общие вершины. Если рёбра образуют замкнутую последовательность, то возвращаются обе вершины
</member>
        <member name="M:TF_PK_EDGE_ask_conformed_faces(std.list&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Для заданной согласованной по концам последовательности рёбер получить листы смежных граней c двух сторон
</member>
        <member name="M:TF_PK_EDGE_find_g1_components(std.vector&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;std.list&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;,std.allocator&lt;std.list&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Для заданного набора рёбер формируются гладкие связанные последовательности рёбер
В результирующих последовательностях могут встречаться рёбра, которых нет в исходной последовательности
Функцию можно использовать и для получения упорядоченной последовательности по одному ребру
</member>
        <member name="M:TF_PK_EDGE_regularize(System.Int32,System.Int32*,std.list&lt;System.Int32,std.allocator&lt;System.Int32&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Упорядочить множество рёбер в связаную последовательность
</member>
        <member name="M:CTfw32Doc.GetUndoManager(System.Boolean)">
            <summary> Получить Undo-менеджер </summary>
            <param name="createIfNone"> Флаг того, что если менеджер не создан, то нужно ли его создавать (true - нужно, false - нет) </param>
            <returns> Указатель на Undo-менеджер документа, или nullptr в случае, если данный документ не может управлять Undo (IsFragment() == true) </returns>
        </member>
        <member name="M:CTfw32Doc.IsObjectIncludedInCurrentChanges(CTFObject!System.Runtime.CompilerServices.IsConst*)">
            <summary> Проверяет, зарегистрирован ли объект в текущем изменении документа (в текущем Undo-блоке) </summary>
            <param name="object"> Указатель на объект </param>
            <returns> true - если объект зарегистрирован в текущем изменении, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectReplacement(CTFObject*,CTFObject*)">
            <summary> Зарегистрировать замену объекта в документе на новый объект </summary>
            <remarks>
Ответственность за удаление заменяющего объекта передаётся документу.
В случае неудачи (например, если Undo-блок не открыт или данный документ не может изменяться) - удаляет заменяющий объект сразу.
Сценарий использования: 
1. Создаём заменяющий объект в куче.
2. Находим в документе объект, который хотим заменить.
3. Передаём указатели на заменяемый и заменяющий объекты в данный метод.
</remarks>
            <param name="objectInDoc"> Указатель на заменяемый объект в документе (НЕ КОПИЯ) </param>
            <param name="newObject"> Указатель на заменяющий объект в куче </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectForChange(CTFObject*)">
            <summary> Зарегистрировать объект в документе и Undo-блоке для дальнейшего изменения </summary>
            <remarks>
Сценарий использования: 
1. Находим в документе объект, который хотим отредактирвоать.
2. Передаём указатель на него в данный метод.
3. В случае успеха - изменяем объект по тому же указателю.
</remarks>
            <param name="objectInDoc"> Указатель на объект в документе (НЕ КОПИЯ) </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectDeletion(System.UInt32,CTFObject**,System.UInt32)">
            <summary> Зарегистрировать удаление объекта в документе и Undo-блоке </summary>
            <remarks>
Удаляет объект из документа, если открыт Undo-блок.
Сценарий использования: 
1. Находим в документе объект, который хотим удалить.
2. Передаём указатель на него в данный метод.
</remarks>
            <param name="objectInDoc"> Указатель на удаляемый объект в документе </param>
            <param name="flags"> Параметры удаления объекта </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectCreationWithCopy(CTFObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Зарегистрировать создание объекта в документе и Undo-блоке </summary>
            <remarks>
Делает копию созданного на стеке объекта.
Сценарий использования: 
1. Создаём объект в стеке.
2. Передаём его в данный метод.
3. В случае успеха можем изменять объект по указателю, который вернул данный метод.
</remarks>
            <param name="objectOnStack"> Cозданный на стеке объект </param>
            <returns> Указатель на объект в документе - в случае успеха, nullptr - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RegisterObjectCreation(CTFObject*)">
            <summary> Зарегистрировать создание объекта в документе и Undo-блоке </summary>
            <remarks>
Ответственность за удаление созданного объекта передаётся документу.
В случае неудачи (например, если Undo-блок не открыт или данный документ не может изменяться) - удаляет созданный объект сразу.
Сценарий использования: 
1. Создаём объект в куче.
2. Передаём указатель на него в данный метод.
3. В случае успеха можем изменять объект по тому же указателю.
</remarks>
            <param name="objectOnHeap"> Указатель на созданный объект в куче </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.IsChanging">
            <summary> Изменяется ли документ в данный момент (открыт ли Undo-блок) </summary>
            <returns> true - документ изменяется, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.CancelChanges(System.Boolean)">
            <summary> Отменить текущие изменения документа и закрыть Undo-блок </summary>
            <remarks>
Отменяет изменения только если открыт Undo-блок. Если Undo-блок вложенный - изменения не отменяет, но закрывает вложенный блок.
Недопустимо нарушение парности вызовов BeginChanges() и EndChanges() или CancelChanges(). Для удобства можно использовать RAII класс UndoBlock.
</remarks>
            <param name="regenerate"> true - выполнить пересчёт документа </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.EndChanges(System.Boolean,System.Boolean)">
            <summary> Закончить изменение документа с регистрацией в Undo </summary>
            <remarks>
Здесь регистрируется блок Undo, после его регистрации уже нельзя воспользоваться методом CancelChanges().
Недопустимо нарушение парности вызовов BeginChanges() и EndChanges() или CancelChanges(). Для удобства можно использовать RAII класс UndoBlock.
</remarks>
            <param name="regenerate"> true - выполнить пересчёт документа </param>
            <param name="merge"> Объединить текущий Undo-блок с верхним Undo-блоком </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.BeginChanges(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Начать изменение документа с регистрацией в undo </summary>
            <remarks>
Блоки могут быть вложенными (с точки зрения вызовов BeginChanges() EndChanges() CancelChanges()).
В этом случае, при вызове последнего EndChanges() будет сформирован один общий Undo-блок, а при последнем вызове CancelChanges() будет произведена отмена всех вложенных блоков.
Недопустимо нарушение парности вызовов BeginChanges() и EndChanges() или CancelChanges(). Для удобства можно использовать RAII класс UndoBlock.
</remarks>
            <param name="undoBlockName"> Название блока undo </param>
            <returns> true - в случае успеха, false - иначе </returns>
        </member>
        <member name="M:CTfw32Doc.RedrawViews(TFlex.FlagSet&lt;&lt;unknown type&gt;&gt;)">
            <summary> Перерисовать все виды документа </summary>
            <param name="params"> Параметры перерисовки </param>
        </member>
        <member name="T:CTfw32Doc.RedrawViewFlags">
            <summary> Параметры перерисовки видов </summary>
        </member>
        <member name="M:AllElementsOptions.EditForWhat">
Редактировать список типов родителей, которые запрашиваются
</member>
        <member name="M:AllElementsOptions.GetForWhat">
Получить список типов родителей, которые запрашиваются
</member>
        <member name="M:AllElementsOptions.IsUpdateStyleUsage">
Проверить режим обновления информации об использовании стилей
</member>
        <member name="M:AllElementsOptions.SetUpdateStyleUsage(System.Boolean)">
Установить режим обновления информации об использовании стилей
</member>
        <member name="F:STATUS._solvers">
Решатель ограничений
</member>
        <member name="D:DimensionVector">
Множество размеров
</member>
        <member name="D:SketchConstraintVector">
Множество ограничений
</member>
        <member name="D:SketchSolverVector">
Множество объектов пересчета
</member>
        <member name="T:SketchSolver">
Временный модельный объект, который используется для вычислений в дереве пересчета модели
</member>
        <member name="D:Constraints2D.EqualCurvePropertyPtr">
Разделяемая ссылка на совпадение свойств двух кривых в точке
</member>
        <member name="T:Constraints2D.EqualCurveProperty">
Совпадение свойств двух кривых в точке
</member>
        <member name="D:Constraints2D.CurvePtr">
Разделяемая ссылка на кривую
</member>
        <member name="T:Constraints2D.Curve">
Кривая
</member>
        <member name="D:Constraints2D.OffsetCurvePtr">
Разделяемая ссылка на смещение
</member>
        <member name="T:Constraints2D.OffsetCurve">
Смещение
</member>
        <member name="D:Constraints2D.ParametricCurvePtr">
Разделяемая ссылка на параметрическую кривую
</member>
        <member name="D:Constraints2D.CurveLengthPtr">
Разделяемая ссылка на ограничение типа длина кривой
</member>
        <member name="T:Constraints2D.ProcessMonitorData">
Функция мониторинга процесса выполнения методов решателя с возможностью прерывания
</member>
        <member name="D:Constraints2D.RigidLinearEquationPtr">
Разделяемая ссылка на линейное уравнение

Разделяемая ссылка на линейное уравнение
</member>
        <member name="D:Constraints2D.LinearEquationPtr">
Разделяемая ссылка на линейное уравнение
</member>
        <member name="D:Constraints2D.EquationMediatorPtr">
Разделяемая ссылка на уравнение
</member>
        <member name="D:Constraints2D.EquationSet">
Множество уравнений
</member>
        <member name="D:Constraints2D.EquationPtr">
Разделяемая ссылка на уравнение
</member>
        <member name="D:Constraints2D.VariableVector">
Упорядоченное множество переменных
</member>
        <member name="D:Constraints2D.VariableSet">
Множество переменных
</member>
        <member name="D:Constraints2D.VariableMediatorVector">
Множество посредников переменных
</member>
        <member name="D:Constraints2D.VariableMediatorPtr">
Разделяемая ссылка на посредник переменной
</member>
        <member name="D:Constraints2D.VariablePtr">
Разделяемая ссылка на переменную
</member>
        <member name="D:Constraints2D.ConstraintTypeVector">
Множество типов ограничений
</member>
        <member name="T:Constraints2D.ConstraintType">
Тип ограничения
</member>
        <member name="D:Constraints2D.InstancePtr">
Разделяемая ссылка на копию
</member>
        <member name="T:Constraints2D.Instance">
Копия
</member>
        <member name="D:Constraints2D.FixParameterPtr">
Разделяемая ссылка на фиксированный параметр в ограничении
</member>
        <member name="T:Constraints2D.FixParameter">
Фиксация параметра в ограничении
</member>
        <member name="D:Constraints2D.NormalPtr">
Разделяемая ссылка на перпендикулярность касательных в точке пересечения кривых
</member>
        <member name="T:Constraints2D.Normal">
Перпендикулярность касательных в точке пересечения кривых
</member>
        <member name="D:Constraints2D.EqualDistancePtr">
Разделяемая ссылка на равенство расстояний
</member>
        <member name="T:Constraints2D.EqualDistance">
Равенство расстояний
</member>
        <member name="D:Constraints2D.MidPointPtr">
Разделяемая ссылка на среднюю точку
</member>
        <member name="T:Constraints2D.MidPoint">
Средняя точка
</member>
        <member name="D:Constraints2D.AnglePtr">
Разделяемая ссылка на угол
</member>
        <member name="T:Constraints2D.Angle">
Угол
</member>
        <member name="D:Constraints2D.ArcLengthPtr">
Разделяемая ссылка на длину дуги
</member>
        <member name="T:Constraints2D.ArcLength">
Длина дуги
</member>
        <member name="D:Constraints2D.TangentPtr">
Разделяемая ссылка на касание
</member>
        <member name="T:Constraints2D.Tangent">
Касание
</member>
        <member name="T:Constraints2D.FixType">
Фиксация геометрии
</member>
        <member name="D:Constraints2D.SymmetricPtr">
Разделяемая ссылка на симметрию
</member>
        <member name="T:Constraints2D.Symmetric">
Симметрия
</member>
        <member name="D:Constraints2D.RadiusPtr">
Разделяемая ссылка на радиус
</member>
        <member name="T:Constraints2D.Radius">
Радиус
</member>
        <member name="D:Constraints2D.EqualRadiusPtr">
Разделяемая ссылка на равные радиусы
</member>
        <member name="T:Constraints2D.EqualRadius">
Равные радиусы
</member>
        <member name="D:Constraints2D.ConcentricPtr">
Разделяемая ссылка на соосность
</member>
        <member name="T:Constraints2D.Concentric">
Соосность
</member>
        <member name="D:Constraints2D.DistancePtr">
Разделяемая ссылка на расстояние
</member>
        <member name="T:Constraints2D.Distance">
Расстояние
</member>
        <member name="D:Constraints2D.DimensionPtr">
Разделяемая ссылка на размер
</member>
        <member name="T:Constraints2D.Dimension">
Размер
</member>
        <member name="D:Constraints2D.LockGeometryVector">
Массив блокировок
</member>
        <member name="D:Constraints2D.LockGeometryPtr">
Разделяемая ссылка на блокировку
</member>
        <member name="T:Constraints2D.LockGeometry">
Блокировка
</member>
        <member name="D:Constraints2D.CoincidentPtr">
Разделяемая ссылка на совпадение
</member>
        <member name="T:Constraints2D.Coincident">
Совпадение
</member>
        <member name="D:Constraints2D.PerpendicularPtr">
Разделяемая ссылка на перпендикулярность
</member>
        <member name="T:Constraints2D.Perpendicular">
Перпендикулярность
</member>
        <member name="D:Constraints2D.ParallelPtr">
Разделяемая ссылка на параллельность
</member>
        <member name="T:Constraints2D.Parallel">
Параллельность
</member>
        <member name="D:Constraints2D.ConstraintMediatorPtr">
Разделяемая ссылка на посредника для взаимодействия ограничения с конкретным решателем
</member>
        <member name="T:Constraints2D.ConstraintMediator">
Посредник для взаимодействия ограничения с конкретным решателем
</member>
        <member name="D:Constraints2D.ConstraintVector">
Множество ограничений
</member>
        <member name="D:Constraints2D.ConstraintSet">
Множество ограничений
</member>
        <member name="D:Constraints2D.ConstraintPtr">
Разделяемая ссылка на ограничение
</member>
        <member name="T:Constraints2D.Constraint">
Базовый класс ограничения
</member>
        <member name="D:Constraints2D.PatternPtr">
Разделяемая ссылка на копирование по образцу
</member>
        <member name="D:Constraints2D.SplinePtr">
Разделяемая ссылка на сплайн
</member>
        <member name="D:Constraints2D.EllipsePtr">
Разделяемая ссылка на эллипс
</member>
        <member name="D:Constraints2D.CirclePtr">
Разделяемая ссылка на окружность
</member>
        <member name="D:Constraints2D.LinePtr">
Разделяемая ссылка на линию
</member>
        <member name="D:Constraints2D.PointVector">
Массив разделяемых ссылок на точку
</member>
        <member name="D:Constraints2D.PointPtr">
Разделяемая ссылка на точку
</member>
        <member name="T:Constraints2D.Pattern">
Копирование по образцу
</member>
        <member name="T:Constraints2D.Spline">
Сплайн
</member>
        <member name="T:Constraints2D.Ellipse">
Эллипс
</member>
        <member name="T:Constraints2D.Circle">
Окружность
</member>
        <member name="T:Constraints2D.Line">
Линия
</member>
        <member name="T:Constraints2D.Point">
Точка
</member>
        <member name="D:Constraints2D.SolverPtr">
Разделяемая ссылка на решатель системы ограничений
</member>
        <member name="T:Constraints2D.Solver">
Решатель системы ограничений
</member>
        <member name="D:Constraints2D.DimensionSystemPtr">
Разделяемая ссылка на систему ограничений
</member>
        <member name="T:Constraints2D.DimensionSystem">
Система ограничений
</member>
        <member name="D:Constraints2D.GeometryMediatorVector">
Массив разделяемых ссылок на посредников для взаимодействия геометрии с конкретным решателем
</member>
        <member name="D:Constraints2D.GeometryMediatorPtr">
Разделяемая ссылка на посредника для взаимодействия геометрии с конкретным решателем
</member>
        <member name="T:Constraints2D.GeometryMediator">
Посредник для взаимодействия геометрии с конкретным решателем
</member>
        <member name="D:Constraints2D.MediatorSet">
Множество посредников
</member>
        <member name="D:Constraints2D.MediatorPtr">
Разделяемая ссылка на базовый класс посредника для взаимодействия с конкретным решателем
</member>
        <member name="T:Constraints2D.Mediator">
Базовый класс посредника для взаимодействия с конкретным решателем
</member>
        <member name="D:Constraints2D.GeometryVector">
Множество геометрических данных
</member>
        <member name="D:Constraints2D.GeometrySet">
Множество геометрических данных
</member>
        <member name="D:Constraints2D.GeometryPtr">
Разделяемая ссылка на геометрические данные
</member>
        <member name="T:Constraints2D.Geometry">
Геометрические данные для решателя ограничений
</member>
        <member name="M:KNOT.HasConstraints">
Данные для решателя ограничений
</member>
        <member name="M:KNOT.IsFixedForConstraint">
Линия фиксирована в решателе ограничений
</member>
        <member name="M:DRAW.HasConstraints">
Данные для решателя ограничений
</member>
        <member name="M:FlatObject.IsFixedForConstraint">
Объект фиксирован в решателе ограничений
</member>
        <member name="M:FlatObject.TypedRegenerateSketch(FlatObject.RegenerateSketchOptions!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Функция, непосредственно осуществляющая регенерацию объекта на эскизе после решения системы ограничений
</member>
        <member name="T:FlatObject.RegenerateSketchOptions">
Эскизы с ограничениями и управляющими размерами
</member>
        <member name="M:CompiledExpression.#ctor">
Конструктор
</member>
        <member name="M:ExpressionItem.BeginAt">
            <summary>Возвращает начальную позицию лексемы в заданном выражении, необходимо для раскраски</summary>
        </member>
        <member name="M:ExpressionItem.Length">
            <summary>Возвращает длину символов в начальном выражении, необходимо для раскраски</summary>
        </member>
        <member name="M:ExpressionItem.GetType">
            <summary>Возвращает тип лексемы</summary>
        </member>
        <member name="M:ExpressionItem.Dispose">
Деструктор
</member>
        <member name="M:ExpressionItem.#ctor">
Конструктор
</member>
        <member name="F:FunctionParameter">
            <remarks>Параметр пользовательской функции</remarks>
        </member>
        <member name="F:UserFunction">
            <remarks>пользовательская функция</remarks>
        </member>
        <member name="F:StartFunction">
            <remarks>начало списка параметров функции</remarks>
        </member>
        <member name="F:DatabaseField">
            <remarks>поле базы данных</remarks>
        </member>
        <member name="F:Comment">
            <remarks>комментарий</remarks>
        </member>
        <member name="F:Colon">
            <remarks>оператор двоеточие (используется в семантике тернарного оператора)</remarks>
        </member>
        <member name="F:Comma">
            <remarks>оператор запятая (используется в функциях с несколькими переменными)</remarks>
        </member>
        <member name="F:PowerOperation">
Операции возведения в степень
</member>
        <member name="F:LogicalOr">
            <remarks>логическое ИЛИ: '|'</remarks>
        </member>
        <member name="F:LogicalAnd">
            <remarks>логическое И: '&amp;'</remarks>
        </member>
        <member name="F:LogicalGreatedEqual">
            <remarks>логическое больше-равно: '&gt;='</remarks>
        </member>
        <member name="F:LogicalLessEqual">
            <remarks>логическое меньше-равно: '&lt;='</remarks>
        </member>
        <member name="F:LogicalNotEqual">
            <remarks>логическое неравенство: '!='</remarks>
        </member>
        <member name="F:LogicalEqual">
            <remarks>логическое равенство: '=='</remarks>
        </member>
        <member name="F:LogicalGreater">
            <remarks>логическое больше: '&gt;'</remarks>
        </member>
        <member name="F:LogicalLess">
            <remarks>логическое меньше: '&lt;'</remarks>
        </member>
        <member name="F:Mod">
Бинарный оператор получения остатка от деления: '%'
</member>
        <member name="F:Divide">
Бинарный оператор деления: '/'
</member>
        <member name="F:Multiply">
Бинарный оператор умножения: '*'
</member>
        <member name="F:Add">
Бинарный оператор плюс: '+'
</member>
        <member name="F:Subtract">
Бинарный оператор минус: '-'
</member>
        <member name="F:LogicalNot">
Унарный оператор НЕ: '!'
</member>
        <member name="F:UnaryMinus">
Унарный оператор минус: '-'
</member>
        <member name="F:TernarySeparatorOperation">
Тернарный оператор: '?', разделитель группы
</member>
        <member name="F:EndTernaryOperation">
Тернарный оператор: '?', конец группы
</member>
        <member name="F:BeginTernaryOperation">
Тернарный оператор: '?', начало группы
</member>
        <member name="F:TernaryOperation">
Тернарный оператор: '?'
</member>
        <member name="F:CloseScope">
Закрывающий оператор приоритета ")"
</member>
        <member name="F:OpenScope">
Открывающий оператор приоритета "("
</member>
        <member name="F:FunctionCall">
Функция	
</member>
        <member name="F:StringConstant">
Константа
</member>
        <member name="F:RealConstant">
Константа
</member>
        <member name="F:InexistingVariableReference">
Несуществующая переменная
</member>
        <member name="F:VariableReference">
Переменная
</member>
        <member name="F:Unknown">
Неизвестный тип
</member>
        <member name="M:ExpressionCompilerError.Length">
            <summary>Длина ошибки, выраженная в количестве символов(необходимо для подсветки ошибки)</summary>
            <returns>Возвращает длину ошибочной части строки выражения, тип std::size_t</returns>
        </member>
        <member name="M:ExpressionCompilerError.StartAt">
            <summary>Возвращает исходную позицию, с которой начинается ошибка, в переданном выражении(необходимо для подсветки ошибки)</summary>
            <returns>Возвращает начальную позицию ошибки, тип std::size_t</returns>
        </member>
        <member name="M:ExpressionCompilerError.What">
            <summary>Возвращает строку с описанием ошибки компиляции выражения</summary>
            <returns>Возвращает текст ошибки, тип std::wstring</returns>
        </member>
        <member name="M:ExpressionCompilerError.HasError">
            <summary>Возвращает флаг наличия ошибки</summary>
            <returns>Возвращает true при наличии ошибки, false - при отсутствии</returns>
        </member>
        <member name="M:ExpressionCompilerError.Clear">
            <summary>Сбрасывает информацию об ошибках</summary>
        </member>
        <member name="M:ExpressionCompilerError.#ctor">
Конструктор
</member>
        <member name="T:ExpressionCompilerError">
Класс, хранящий ошибку компиляции выражения
</member>
        <member name="M:PlineHandler.Instance">
            <summary> Хэндлер полилинии для локального трэда </summary>
            <remarks>
Общая схема:
Есть пул полилиний. Хэндлер для работы с полилинией объявлен как thread_local, что означает,
что при первом обращении к нему в текущем трэде у него вызывается конструктор по умолчанию, а при завершении трэда - вызывается деструктор.
В конструкторе хэндлер получает полилинию из пула, а в деструкторе - возвращает ее.
</remarks>
        </member>
        <member name="T:PlineHandler">
            <summary> Класс, обеспечивающий доступ к полилинии </summary>
        </member>
        <member name="M:PlineData.GetRawX">
            <summary> Интерфейс для использования старых алгоритмов </summary>
        </member>
        <member name="M:PlineData.AddPolyline(RGPlatform.Geometry.Polyline2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Добавить полилинию из источника.</summary>
        </member>
        <member name="M:PlineData.Fill(RGPlatform.Geometry.Polyline2D!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double)">
            <summary> Заполнить полилинию из источника </summary>
        </member>
        <member name="M:PlineData.GetContour(System.UInt64)">
            <summary> Получить контур поиндексу </summary>
        </member>
        <member name="M:PlineData.CountContours">
            <summary> Получить количество контуров </summary>
        </member>
        <member name="M:PlineData.GetPoint(System.UInt64)">
            <summary> Получить координаты точки по индексу </summary>
        </member>
        <member name="M:PlineData.CountPoints">
            <summary> Получить количество точек </summary>
        </member>
        <member name="T:PlineData.Contour">
            <summary> Контур </summary>
        </member>
        <member name="T:PlineData">
Legacy end
<summary> Структура данных полилинии </summary></member>
        <member name="M:LockPline">
Legacy
</member>
        <member name="M:SelectableObject.ReplaceCharacteristicDataReferences(CharacteristicDataToReplace!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Заменить ссылки на характерные данные других объектов </summary>
            <remarks> Если входящие данные не находят соответствия какой-либо ссылке, то эта ссылка просто пропускается. </remarks>
            <param name="iData"> Входящие данные для замены ссылок </param>
            <returns> false, если хотя бы одна ссылка была удалена, true - иначе </returns>
        </member>
        <member name="M:SelectableObject.GetCharacteristicDataCount">
Характерные данные объекта: габаритные точки, центры симметрии, концы или середина кривой, очерк. Пока поддерживаются только точки
</member>
        <member name="M:CharacteristicDataToReplace.#ctor(CharacteristicDataToReplace!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="T:CharacteristicDataToReplace">
Параметры замены характерных данных родителей
</member>
        <member name="T:CharacteristicDataReference">
Ссылка на характерные данные объекта
</member>
        <member name="M:CharacteristicDataChanges.GetGeometry">
Новая геометрия, если харакетристика задаётся произвольной геометрией
</member>
        <member name="M:CharacteristicDataChanges.GetPoint">
Новые координаты, если харакетристика задаётся точкой
</member>
        <member name="M:CharacteristicDataChanges.GetID">
Идентификатор узла
</member>
        <member name="M:CharacteristicDataChanges.#ctor(CharacteristicDataChanges!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="T:CharacteristicDataChanges">
Параметры изменения характерных данных, если они являются управляющими
</member>
        <member name="M:CharacteristicDataReport.GetGeometry">
Харакетристика задаётся произвольной геометрией
</member>
        <member name="M:CharacteristicDataReport.GetPoint">
Харакетристика задаётся точкой
</member>
        <member name="T:CharacteristicDataReport.FixType">
Параметр на кривой фиксирован, если характеристика является точкой
</member>
        <member name="M:CharacteristicDataReport.GetParameter">
Параметр на кривой, если характеристика является точкой
</member>
        <member name="T:CharacteristicDataReport.RelationType">
Тип характеристики по отношению к геометрии объекта
</member>
        <member name="T:CharacteristicDataReport.ParameterType">
Тип характеристики как параметра объекта
</member>
        <member name="T:CharacteristicDataReport.CharacteristicType">
Тип характеристики
</member>
        <member name="M:CharacteristicDataReport.#ctor(CharacteristicDataReport!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="T:CharacteristicDataReport">
Результаты запроса информации о характеристике
</member>
        <member name="M:CharacteristicDataQuery.GetCheckError">
Идентификатор характеристики
</member>
        <member name="M:CharacteristicDataQuery.GetID">
Идентификатор характеристики
</member>
        <member name="M:CharacteristicDataQuery.#ctor(CharacteristicDataQuery!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Защита от копирования
</member>
        <member name="T:CharacteristicDataQuery">
Параметры запроса информации о характеристике
</member>
        <member name="M:CTFObject.DoActionLikeAfterRegenerateOptions.IsNestedRegeneration">
Проверить режим вложенного пересчета(например, параметрические копии)
</member>
        <member name="M:CTFObject.DoActionLikeAfterRegenerateOptions.SetNestedRegeneration(System.Boolean)">
Установить режим вложенного пересчета(например, параметрические копии)
</member>
        <member name="M:CTFObject.DoActionLikeAfterRegenerateOptions.IsOnly2D">
Проверить режим 2D пересчета
</member>
        <member name="M:CTFObject.DoActionLikeAfterRegenerateOptions.SetOnly2D(System.Boolean)">
Установить режим 2D пересчета
</member>
        <member name="M:op_OnesComplement(&lt;unknown type&gt;)">
Класс только для наследования от него
</member>
        <member name="M:CTFObject.GetToModelSpaceScale">
Методы для вычислений на точной геометрии
</member>
        <member name="M:CTFObject.ChangeWhenChildrenAreDeleted(DeleteElementsContext*)">
Изменение родителя, при удалении потомка
</member>
        <member name="M:CTFObject.GetParentsThatChangeWhenDelete(CParentsArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,DeleteElementsContext*)">
Получить родителей, которые меняются при удалении
</member>
        <member name="M:CTFObject.GetDeletingParents(CParentsArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,DeleteElementsContext*)">
Функция возвращает список родителей, которые нужно удалять вместе с объектом.
В процессе построения дерева удаления объектов функция может вызываться много раз.
</member>
        <member name="F:IS_ELEVABLE">
не используется в 2D
</member>
        <member name="F:REFER_CLONE_MOVE">
не используется в 2D
</member>
        <member name="F:ref_ScreenObjectToFragmentProjectionReference">
Тела в списке проецирования соритуются по этим идентификаторам
</member>
        <member name="F:pfwReallyChanged">
Альтернатива рекурсивному вызову IsReallyChanged
</member>
        <member name="F:pfwDistance">
Порядок расположения объектов в дереве модели
</member>
        <member name="F:pfwTestRecursion">
Проверка рекурсии. Используется для специальной обработки случаев, когда формально существующая по связам рекурсия, на самом деле таковой не является.
Например, 3D фрагмент задаётся 2D фрагментом, который берёт значения переменных с 3D коннектора (система координат). При это система кординат и 3D фрагмент связаны сопряжениями
</member>
        <member name="F:ptFORMULA_Variable">
Переделан метод IsAuxiliary
</member>
        <member name="F:ptLockType_Remove_Container">
ptLockType_Import								= 12508,
</member>
        <member name="F:ptPoint2Dto3D_Mesh">
Точка на сетке
</member>
        <member name="F:ptCViewData_Next">
Следующий идентификатор для проекций
</member>
        <member name="F:ptCViewData_ScreenObjects">
Тела в списке проецирования соритуются по этим идентификаторам
</member>
        <member name="F:ptPath3D_FromProjectionOnFace_Direction">
5414 используется
</member>
        <member name="F:CBitmapRenderTarget.m_pBitmapRenderTarget">
            <summary>
A pointer to an ID2D1BitmapRenderTarget object.
</summary>
        </member>
        <member name="M:CBitmapRenderTarget.GetBitmap(CD2DBitmap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieves the bitmap for this render target. The returned bitmap can be used for drawing operations. </summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="bitmap">When this method returns, contains the valid bitmap for this render target. This bitmap can be used for drawing operations.</param>
        </member>
        <member name="M:CBitmapRenderTarget.op_Implicit~ID2D1BitmapRenderTarget*">
            <summary>
Returns ID2D1BitmapRenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1BitmapRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CBitmapRenderTarget.GetBitmapRenderTarget">
            <summary>
Returns ID2D1BitmapRenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1BitmapRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CBitmapRenderTarget.Detach">
            <summary>
Detaches render target interface from the object</summary>
            <returns> 
Pointer to detached render target interface.</returns>
        </member>
        <member name="M:CBitmapRenderTarget.Attach(ID2D1BitmapRenderTarget*)">
            <summary>
Attaches existing render target interface to the object</summary>
            <param name="pTarget">Existing render target interface. Cannot be NULL</param>
        </member>
        <member name="M:CBitmapRenderTarget.#ctor">
            <summary>
Constructs a CBitmapRenderTarget object.</summary>
        </member>
        <member name="F:CDCRenderTarget.m_pDCRenderTarget">
            <summary>
A pointer to an ID2D1DCRenderTarget object.
</summary>
        </member>
        <member name="M:CDCRenderTarget.op_Implicit~ID2D1DCRenderTarget*">
            <summary>
Returns ID2D1DCRenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1DCRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CDCRenderTarget.GetDCRenderTarget">
            <summary>
Returns ID2D1DCRenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1DCRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CDCRenderTarget.BindDC(CDC!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Binds the render target to the device context to which it issues drawing commands</summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="dc">The device context to which the render target issues drawing commands</param>
            <param name="rect">The dimensions of the handle to a device context (HDC) to which the render target is bound</param>
        </member>
        <member name="M:CDCRenderTarget.Create(D2D1_RENDER_TARGET_PROPERTIES!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a CDCRenderTarget.</summary>
            <returns>
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="props">The rendering mode, pixel format, remoting options, DPI information, and the minimum DirectX support required for hardware rendering.</param>
        </member>
        <member name="M:CDCRenderTarget.Detach">
            <summary>
Detaches render target interface from the object</summary>
            <returns> 
Pointer to detached render target interface.</returns>
        </member>
        <member name="M:CDCRenderTarget.Attach(ID2D1DCRenderTarget*)">
            <summary>
Attaches existing render target interface to the object</summary>
            <param name="pTarget">Existing render target interface. Cannot be NULL</param>
        </member>
        <member name="M:CDCRenderTarget.#ctor">
            <summary>
Constructs a CDCRenderTarget object.</summary>
        </member>
        <member name="T:CDCRenderTarget">
            <summary>
ID2D1DCRenderTarget wrapper.
</summary>
        </member>
        <member name="F:CHwndRenderTarget.m_pHwndRenderTarget">
            <summary>
A pointer to an ID2D1HwndRenderTarget object.
</summary>
        </member>
        <member name="M:CHwndRenderTarget.Resize(CD2DSizeU!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Changes the size of the render target to the specified pixel size</summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="size">The new size of the render target in device pixels</param>
        </member>
        <member name="M:CHwndRenderTarget.CheckWindowState">
            <summary>
Indicates whether the HWND associated with this render target is occluded.</summary>
            <returns>
A value that indicates whether the HWND associated with this render target is occluded.</returns>
        </member>
        <member name="M:CHwndRenderTarget.GetHwnd">
            <summary>
Returns the HWND associated with this render target.</summary>
            <returns>
The HWND associated with this render target.</returns>
        </member>
        <member name="M:CHwndRenderTarget.op_Implicit~ID2D1HwndRenderTarget*">
            <summary>
Returns ID2D1HwndRenderTarget interface.</summary>
            <returns>
Pointer to an ID2D1HwndRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CHwndRenderTarget.GetHwndRenderTarget">
            <summary>
Returns ID2D1HwndRenderTarget interface.</summary>
            <returns>
Pointer to an ID2D1HwndRenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CHwndRenderTarget.ReCreate(HWND__*)">
            <summary>
Re-creates a render target associated with the window</summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="hWnd">The HWND associated with this render target</param>
        </member>
        <member name="M:CHwndRenderTarget.Create(HWND__*)">
            <summary>
Creates a render target associated with the window </summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE</returns>
            <param name="hWnd">The HWND associated with this render target</param>
        </member>
        <member name="M:CHwndRenderTarget.Detach">
            <summary>
Detaches render target interface from the object</summary>
            <returns> 
Pointer to detached render target interface.</returns>
        </member>
        <member name="M:CHwndRenderTarget.Attach(ID2D1HwndRenderTarget*)">
            <summary>
Attaches existing render target interface to the object</summary>
            <param name="pTarget">Existing render target interface. Cannot be NULL</param>
        </member>
        <member name="M:CHwndRenderTarget.#ctor(HWND__*)">
            <summary>
Constructs a CHwndRenderTarget object from HWND.</summary>
            <param name="hwnd">The HWND associated with this render target</param>
        </member>
        <member name="T:CHwndRenderTarget">
            <summary>
ID2D1HwndRenderTarget wrapper.
</summary>
        </member>
        <member name="F:CRenderTarget.m_pTextFormatDefault">
            <summary>
A pointer to CD2DTextFormat object that contains a default text format.
</summary>
        </member>
        <member name="F:CRenderTarget.m_lstResources">
            <summary>
A list of pointers to CD2DResource objects.
</summary>
        </member>
        <member name="F:CRenderTarget.m_pRenderTarget">
            <summary>
A pointer to an ID2D1RenderTarget object.
</summary>
        </member>
        <member name="M:CRenderTarget.VerifyResource(CD2DResource*)">
            <summary>
Verifies CD2DResource object validity; creates the object if it didn't already exist.</summary>
            <param name="pResource">Pointer to CD2DResource object.</param>
            <returns> 
TRUE is object if valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CRenderTarget.PopAxisAlignedClip">
            <summary>
Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations.</summary>
        </member>
        <member name="M:CRenderTarget.PushAxisAlignedClip(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,D2D1_ANTIALIAS_MODE)">
            <summary>
Removes the last axis-aligned clip from the render target. After this method is called, the clip is no longer applied to subsequent drawing operations.</summary>
            <param name="rectClip">The size and position of the clipping area, in device-independent pixels.</param>
            <param name="mode">The antialiasing mode that is used to draw the edges of clip rects that have subpixel boundaries, and to blend the clip with the scene contents. The blending is performed once when the PopAxisAlignedClip method is called, and does not apply to each primitive within the layer.</param>
        </member>
        <member name="M:CRenderTarget.RestoreDrawingState(ID2D1DrawingStateBlock*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets the render target's drawing state to that of the specified ID2D1DrawingStateBlock.</summary>
            <param name="drawingStateBlock">The new drawing state of the render target.</param>
        </member>
        <member name="M:CRenderTarget.SaveDrawingState(ID2D1DrawingStateBlock*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Saves the current drawing state to the specified ID2D1DrawingStateBlock.</summary>
            <param name="drawingStateBlock">When this method returns, contains the current drawing state of the render target. This parameter must be initialized before passing it to the method.</param>
        </member>
        <member name="M:CRenderTarget.Flush(System.UInt64*,System.UInt64*)">
            <summary>
Executes all pending drawing commands.</summary>
            <param name="tag1">Contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</param>
            <param name="tag2">Contains the tag for drawing operations that caused errors or 0 if there were no errors. This parameter is passed uninitialized.</param>
        </member>
        <member name="M:CRenderTarget.PopLayer">
            <summary>
Stops redirecting drawing operations to the layer that is specified by the last PushLayer call.</summary>
        </member>
        <member name="M:CRenderTarget.PushLayer(D2D1_LAYER_PARAMETERS!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DLayer*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Adds the specified layer to the render target so that it receives all subsequent drawing operations until PopLayer is called.</summary>
            <param name="layerParameters">The content bounds, geometric mask, opacity, opacity mask, and antialiasing options for the layer.</param>
            <param name="layer">The layer that receives subsequent drawing operations.</param>
        </member>
        <member name="M:CRenderTarget.CreateCompatibleRenderTarget(CBitmapRenderTarget*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DSizeF,CD2DSizeU,D2D1_PIXEL_FORMAT*,D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS)">
            <summary>
Creates a new bitmap render target for use during intermediate offscreen drawing that is compatible with the current render target .</summary>
            <returns>If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="bitmapTarget">When this method returns, contains the address of a pointer to a new bitmap render target. This parameter is passed uninitialized.</param>
            <param name="sizeDesired">The desired size of the new render target in device-independent pixels if it should be different from the original render target, or NULL. For more information, see the Remarks section.</param>
            <param name="sizePixelDesired">The desired size of the new render target in pixels if it should be different from the original render target, or NULL. For more information, see the Remarks section.</param>
            <param name="desiredFormat">The desired pixel format and alpha mode of the new render target, or NULL. If the pixel format is set to DXGI_FORMAT_UNKNOWN or if this parameter is null, the new render target uses the same pixel format as the original render target. If the alpha mode is D2D1_ALPHA_MODE_UNKNOWN or this parameter is NULL, the alpha mode of the new render target defaults to D2D1_ALPHA_MODE_PREMULTIPLIED. For information about supported pixel formats, see Supported Pixel Formats and Alpha Modes.</param>
            <param name="options">A value that specifies whether the new render target must be compatible with GDI.</param>
        </member>
        <member name="M:CRenderTarget.GetTransform(D2D_MATRIX_3X2_F*)">
            <summary>
Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.</summary>
            <param name="transform">The transform to apply to the render target.</param>
        </member>
        <member name="M:CRenderTarget.SetTransform(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.</summary>
            <param name="transform">The transform to apply to the render target.</param>
        </member>
        <member name="M:CRenderTarget.SetTransform(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space.</summary>
            <param name="transform">The transform to apply to the render target.</param>
        </member>
        <member name="M:CRenderTarget.GetTextRenderingParams(IDWriteRenderingParams**)">
            <summary>
Retrieves the render target's current text rendering options.</summary>
            <param name="textRenderingParams">When this method returns, textRenderingParamscontains the address of a pointer to the render target's current text rendering options.</param>
        </member>
        <member name="M:CRenderTarget.SetTextRenderingParams(IDWriteRenderingParams*)">
            <summary>
Specifies text rendering options to be applied to all subsequent text and glyph drawing operations.</summary>
            <param name="textRenderingParams">The text rendering options to be applied to all subsequent text and glyph drawing operations; NULL to clear current text rendering options.</param>
        </member>
        <member name="M:CRenderTarget.GetTextAntialiasMode">
            <summary>
Gets the current antialiasing mode for text and glyph drawing operations.</summary>
            <returns>
Current antialiasing mode for text and glyph drawing operations.</returns>
        </member>
        <member name="M:CRenderTarget.SetTextAntialiasMode(D2D1_TEXT_ANTIALIAS_MODE)">
            <summary>
Specifies the antialiasing mode to use for subsequent text and glyph drawing operations.</summary>
            <param name="textAntialiasMode">The antialiasing mode to use for subsequent text and glyph drawing operations.</param>
        </member>
        <member name="M:CRenderTarget.GetAntialiasMode">
            <summary>
Retrieves the current antialiasing mode for nontext drawing operations.</summary>
            <returns>
Current antialiasing mode for nontext drawing operations.</returns>
        </member>
        <member name="M:CRenderTarget.SetAntialiasMode(D2D1_ANTIALIAS_MODE)">
            <summary>
Sets the antialiasing mode of the render target. The antialiasing mode applies to all subsequent drawing operations, excluding text and glyph drawing operations.</summary>
            <param name="antialiasMode">The antialiasing mode for future drawing operations.</param>
        </member>
        <member name="M:CRenderTarget.FillMesh(CD2DMesh*,CD2DBrush*)">
            <summary>
Paints the interior of the specified mesh.</summary>
            <param name="pMesh">The mesh to paint.</param>
            <param name="pBrush">The brush used to paint the mesh.</param>
        </member>
        <member name="M:CRenderTarget.DrawGlyphRun(CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,DWRITE_GLYPH_RUN!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,DWRITE_MEASURING_MODE)">
            <summary>
Draws the specified glyphs.</summary>
            <param name="ptBaseLineOrigin">The origin, in device-independent pixels, of the glyphs' baseline.</param>
            <param name="glyphRun">The glyphs to render.</param>
            <param name="pForegroundBrush">The brush used to paint the specified glyphs.</param>
            <param name="measuringMode">A value that indicates how glyph metrics are used to measure text when it is formatted. The default value is DWRITE_MEASURING_MODE_NATURAL.</param>
        </member>
        <member name="M:CRenderTarget.FillGeometry(CD2DGeometry*,CD2DBrush*,CD2DBrush*)">
            <summary>
Paints the interior of the specified geometry.</summary>
            <param name="pGeometry">The geometry to paint.</param>
            <param name="pBrush">The brush used to paint the geometry's interior.</param>
            <param name="pOpacityBrush">The opacity mask to apply to the geometry;NULL for no opacity mask. If an opacity mask (the opacityBrush parameter) is specified, brush must be an ID2D1BitmapBrush that has its x- and y-extend modes set to D2D1_EXTEND_MODE_CLAMP. For more information, see the Remarks section.</param>
        </member>
        <member name="M:CRenderTarget.DrawGeometry(CD2DGeometry*,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws the outline of the specified geometry using the specified stroke style.</summary>
            <param name="pGeometry">The geometry to draw.</param>
            <param name="pBrush">The brush used to paint the geometry's stroke.</param>
            <param name="fStrokeWidth">The thickness of the geometry's stroke. The stroke is centered on the geometry's outline.</param>
            <param name="strokeStyle">The style of stroke to apply to the geometry's outline, or NULL to paint a solid stroke.</param>
        </member>
        <member name="M:CRenderTarget.DrawBitmap(CD2DBitmap*,CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,D2D1_BITMAP_INTERPOLATION_MODE,CD2DRectF!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Draws the formatted text described by the specified IDWriteTextLayout object.</summary>
            <param name="pBitmap">The bitmap to render.</param>
            <param name="rectDest">The size and position, in device-independent pixels in the render target's coordinate space, of the area to which the bitmap is drawn. If the rectangle is not well-ordered, nothing is drawn, but the render target does not enter an error state.</param>
            <param name="fOpacity">A value between 0.0f and 1.0f, inclusive, that specifies an opacity value to apply to the bitmap; this value is multiplied against the alpha values of the bitmap's contents.</param>
            <param name="interpolationMode">The interpolation mode to use if the bitmap is scaled or rotated by the drawing operation.</param>
            <param name="pRectSrc">The size and position, in device-independent pixels in the bitmap's coordinate space, of the area within the bitmap to draw.</param>
        </member>
        <member name="M:CRenderTarget.DrawTextLayout(CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DTextLayout*,CD2DBrush*,D2D1_DRAW_TEXT_OPTIONS)">
            <summary>
Draws the formatted text described by the specified IDWriteTextLayout object.</summary>
            <param name="ptOrigin">The point, described in device-independent pixels, at which the upper-left corner of the text described by textLayout is drawn.</param>
            <param name="textLayout">The formatted text to draw. Any drawing effects that do not inherit from ID2D1Resource are ignored. If there are drawing effects that inherit from ID2D1Resource that are not brushes, this method fails and the render target is put in an error state.</param>
            <param name="pBrushForeground">The brush used to paint any text in textLayout that does not already have a brush associated with it as a drawing effect (specified by the IDWriteTextLayout::SetDrawingEffect method).</param>
            <param name="options">A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle. The default value is D2D1_DRAW_TEXT_OPTIONS_NONE, which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle.</param>
        </member>
        <member name="M:CRenderTarget.DrawText(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,CD2DTextFormat*,D2D1_DRAW_TEXT_OPTIONS,DWRITE_MEASURING_MODE)">
            <summary>
Draws the specified text using the format information provided by an IDWriteTextFormat object.</summary>
            <param name="strText">A pointer to an array of Unicode characters to draw.</param>
            <param name="rect">The size and position of the area in which the text is drawn.</param>
            <param name="pForegroundBrush">The brush used to paint the text.</param>
            <param name="textFormat">An object that describes formatting details of the text to draw, such as the font, the font size, and flow direction.</param>
            <param name="options">A value that indicates whether the text should be snapped to pixel boundaries and whether the text should be clipped to the layout rectangle. The default value is D2D1_DRAW_TEXT_OPTIONS_NONE, which indicates that text should be snapped to pixel boundaries and it should not be clipped to the layout rectangle.</param>
            <param name="measuringMode">A value that indicates how glyph metrics are used to measure text when it is formatted. The default value is DWRITE_MEASURING_MODE_NATURAL.</param>
        </member>
        <member name="M:CRenderTarget.FillOpacityMask(CD2DBitmap*,CD2DBrush*,D2D1_OPACITY_MASK_CONTENT,CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Applies the opacity mask described by the specified bitmap to a brush and uses that brush to paint a region of the render target.</summary>
            <param name="pOpacityMask">The position and radius, in device-independent pixels, of the ellipse to paint.</param>
            <param name="pBrush">The brush used to paint the region of the render target specified by destinationRectangle.</param>
            <param name="content">The type of content the opacity mask contains. The value is used to determine the color space in which the opacity mask is blended.</param>
            <param name="rectDest">The region of the render target to paint, in device-independent pixels.</param>
            <param name="rectSrc">The region of the bitmap to use as the opacity mask, in device-independent pixels.</param>
        </member>
        <member name="M:CRenderTarget.DrawLine(CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws a line between the specified points using the specified stroke style.</summary>
            <param name="ptFrom">The start point of the line, in device-independent pixels.</param>
            <param name="ptTo">The end point of the line, in device-independent pixels.</param>
            <param name="pBrush">The brush used to paint the line's stroke.</param>
            <param name="fStrokeWidth">A value greater than or equal to 0.0f that specifies the width of the stroke. If this parameter isn't specified, it defaults to 1.0f. The stroke is centered on the line.</param>
            <param name="strokeStyle">The style of stroke to paint, or NULL to paint a solid line.</param>
        </member>
        <member name="M:CRenderTarget.FillEllipse(CD2DEllipse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*)">
            <summary>
Paints the interior of the specified ellipse.</summary>
            <param name="ellipse">The position and radius, in device-independent pixels, of the ellipse to paint.</param>
            <param name="pBrush">The brush used to paint the interior of the ellipse.</param>
        </member>
        <member name="M:CRenderTarget.DrawEllipse(CD2DEllipse!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws the outline of the specified ellipse using the specified stroke style.</summary>
            <param name="ellipse">The position and radius of the ellipse to draw, in device-independent pixels.</param>
            <param name="pBrush">The brush used to paint the ellipse's outline.</param>
            <param name="fStrokeWidth">The thickness of the ellipse's stroke. The stroke is centered on the ellipse's outline.</param>
            <param name="strokeStyle">The style of stroke to apply to the ellipse's outline, or NULL to paint a solid stroke.</param>
        </member>
        <member name="M:CRenderTarget.FillRoundedRectangle(CD2DRoundedRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*)">
            <summary>
Paints the interior of the specified rounded rectangle.</summary>
            <param name="rectRounded">The dimensions of the rounded rectangle to paint, in device independent pixels.</param>
            <param name="pBrush">The brush used to paint the interior of the rounded rectangle.</param>
        </member>
        <member name="M:CRenderTarget.DrawRoundedRectangle(CD2DRoundedRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws the outline of the specified rounded rectangle using the specified stroke style.</summary>
            <param name="rectRounded">The dimensions of the rounded rectangle to draw, in device-independent pixels.</param>
            <param name="pBrush">The brush used to paint the rounded rectangle's outline.</param>
            <param name="fStrokeWidth">The width of the rounded rectangle's stroke. The stroke is centered on the rounded rectangle's outline. The default value is 1.0f.</param>
            <param name="strokeStyle">The style of the rounded rectangle's stroke, or NULL to paint a solid stroke. The default value is NULL.</param>
        </member>
        <member name="M:CRenderTarget.FillRectangle(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*)">
            <summary>
Paints the interior of the specified rectangle.</summary>
            <param name="rect">The dimension of the rectangle to paint, in device-independent pixels.</param>
            <param name="pBrush">The brush used to paint the rectangle's interior.</param>
        </member>
        <member name="M:CRenderTarget.DrawRectangle(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DBrush*,System.Single,ID2D1StrokeStyle*)">
            <summary>
Draws the outline of a rectangle that has the specified dimensions and stroke style.</summary>
            <param name="rect">The dimensions of the rectangle to draw, in device-independent pixels</param>
            <param name="pBrush">The brush used to paint the rectangle's stroke</param>
            <param name="fStrokeWidth">A value greater than or equal to 0.0f that specifies the width of the rectangle's stroke. The stroke is centered on the rectangle's outline.</param>
            <param name="strokeStyle">The style of stroke to paint, or NULL to paint a solid stroke.</param>
        </member>
        <member name="M:CRenderTarget.Clear(_D3DCOLORVALUE)">
            <summary>
Clears the drawing area to the specified color.</summary>
            <param name="color">The color to which the drawing area is cleared.</param>
        </member>
        <member name="M:CRenderTarget.COLORREF_TO_D2DCOLOR(System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32)">
            <summary>
Converts GDI color and alpha values to the D2D1_COLOR_F object.</summary>
            <param name="color">RGB value.</param>
            <param name="nAlpha">Alpha value.</param>
            <returns>
D2D1_COLOR_F value.</returns>
        </member>
        <member name="M:CRenderTarget.EndDraw">
            <summary>
Ends drawing operations on the render target and indicates the current error state and associated tags.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
        </member>
        <member name="M:CRenderTarget.BeginDraw">
            <summary>
Initiates drawing on this render target.</summary>
        </member>
        <member name="M:CRenderTarget.Detach">
            <summary>
Detaches render target interface from the object</summary>
            <returns> 
Pointer to detached render target interface.</returns>
        </member>
        <member name="M:CRenderTarget.Attach(ID2D1RenderTarget*)">
            <summary>
Attaches existing render target interface to the object</summary>
            <param name="pRenderTarget">Existing render target interface. Cannot be NULL</param>
        </member>
        <member name="M:CRenderTarget.GetMaximumBitmapSize">
            <summary>
Gets the maximum size, in device-dependent units (pixels), of any one bitmap dimension supported by the render target</summary>
            <returns> 
The maximum size, in pixels, of any one bitmap dimension supported by the render target</returns>
        </member>
        <member name="M:CRenderTarget.IsSupported(D2D1_RENDER_TARGET_PROPERTIES!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Indicates whether the render target supports the specified properties</summary>
            <returns> 
TRUE if the specified render target properties are supported by this render target; otherwise, FALSE</returns>
            <param name="renderTargetProperties">The render target properties to test</param>
        </member>
        <member name="M:CRenderTarget.SetTags(System.UInt64,System.UInt64)">
            <summary>
Specifies a label for subsequent drawing operations.</summary>
            <param name="tag1">A label to apply to subsequent drawing operations.</param>
            <param name="tag2">A label to apply to subsequent drawing operations.</param>
        </member>
        <member name="M:CRenderTarget.GetTags(System.UInt64*,System.UInt64*)">
            <summary>
Gets the label for subsequent drawing operations.</summary>
            <param name="tag1">Contains the first label for subsequent drawing operations. This parameter is passed uninitialized. If NULL is specified, no value is retrieved for this parameter.</param>
            <param name="tag2">Contains the second label for subsequent drawing operations. This parameter is passed uninitialized. If NULL is specified, no value is retrieved for this parameter.</param>
        </member>
        <member name="M:CRenderTarget.GetPixelSize">
            <summary>
Returns the size of the render target in device pixels</summary>
            <returns> 
The size of the render target in device pixels</returns>
        </member>
        <member name="M:CRenderTarget.GetPixelFormat">
            <summary>
Retrieves the pixel format and alpha mode of the render target</summary>
            <returns> 
The pixel format and alpha mode of the render target</returns>
        </member>
        <member name="M:CRenderTarget.GetDpi">
            <summary>
Returns the render target's dots per inch (DPI)</summary>
            <returns> 
The render target's dots per inch (DPI).</returns>
        </member>
        <member name="M:CRenderTarget.SetDpi(CD2DSizeF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets the dots per inch (DPI) of the render target.</summary>
            <param name="sizeDPI">A value greater than or equal to zero that specifies the horizontal/verticalDPI of the render target.</param>
        </member>
        <member name="M:CRenderTarget.GetSize">
            <summary>
Returns the size of the render target in device-independent pixels</summary>
            <returns> 
The current size of the render target in device-independent pixels</returns>
        </member>
        <member name="M:CRenderTarget.op_Implicit~ID2D1RenderTarget*">
            <summary>
Returns ID2D1RenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1RenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CRenderTarget.GetRenderTarget">
            <summary>
Returns ID2D1RenderTarget interface</summary>
            <returns> 
Pointer to an ID2D1RenderTarget interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CRenderTarget.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CRenderTarget.Destroy(System.Int32)">
            <summary>
Deletes one or more resources</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE</returns>
            <param name="bDeleteResources">If bDeleteResources is TRUE, all resources located in m_lstResources will be automatically destroyed.</param>
        </member>
        <member name="M:CRenderTarget.Dispose">
            <summary>
The destructor. Called when a render target object is being destroyed.
</summary>
        </member>
        <member name="M:CRenderTarget.#ctor">
            <summary>
Constructs a CRenderTarget object.</summary>
        </member>
        <member name="T:CRenderTarget">
            <summary>
ID2D1RenderTarget wrapper.
</summary>
        </member>
        <member name="F:CD2DMesh.m_pMesh">
            <summary>
A pointer to an ID2D1Mesh.
</summary>
        </member>
        <member name="M:CD2DMesh.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DMesh.Destroy">
            <summary>
Destroys a CD2DMesh object.</summary>
        </member>
        <member name="M:CD2DMesh.Create(CRenderTarget*)">
            <summary>
Creates a CD2DMesh.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DMesh.Open">
            <summary>
Opens the mesh for population.</summary>
            <returns>
A pointer to an ID2D1TessellationSink that is used to populate the mesh.</returns>
        </member>
        <member name="M:CD2DMesh.op_Implicit~ID2D1Mesh*">
            <summary>
Returns ID2D1Mesh interface</summary>
            <returns> 
Pointer to an ID2D1Mesh interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DMesh.Get">
            <summary>
Returns ID2D1Mesh interface</summary>
            <returns> 
Pointer to an ID2D1Mesh interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DMesh.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DMesh.Attach(ID2D1Mesh*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DMesh.Dispose">
            <summary>
The destructor. Called when a D2D mesh object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DMesh.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DMesh object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DMesh">
            <summary>
ID2D1Mesh wrapper.
</summary>
        </member>
        <member name="F:CD2DGeometrySink.m_pSink">
            <summary>
A pointer to an ID2D1GeometrySink.
</summary>
        </member>
        <member name="M:CD2DGeometrySink.SetSegmentFlags(D2D1_PATH_SEGMENT)">
            <summary>
Specifies stroke and join options to be applied to new segments added to the geometry sink.</summary>
            <param name="vertexFlags">Stroke and join options to be applied to new segments added to the geometry sink.</param>
        </member>
        <member name="M:CD2DGeometrySink.SetFillMode(D2D1_FILL_MODE)">
            <summary>
Specifies the method used to determine which points are inside the geometry described by this geometry sink and which points are outside.</summary>
            <param name="fillMode">The method used to determine whether a given point is part of the geometry.</param>
        </member>
        <member name="M:CD2DGeometrySink.Close">
            <summary>
Closes the geometry sink</summary>
            <returns> 
Nonzero if successful; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DGeometrySink.AddLines(CArray&lt;CD2DPointF,CD2DPointF&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a sequence of lines using the specified points and adds them to the geometry sink.</summary>
            <param name="points">An array of one or more points that describe the lines to draw. A line is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by BeginFigure) to the first point in the array. if the array contains additional points, a line is drawn from the first point to the second point in the array, from the second point to the third point, and so on. An array of a sequence of the end points of the lines to draw.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddLine(CD2DPointF)">
            <summary>
Creates a line segment between the current point and the specified end point and adds it to the geometry sink.</summary>
            <param name="point">The end point of the line to draw.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddQuadraticBeziers(CArray&lt;D2D1_QUADRATIC_BEZIER_SEGMENT,D2D1_QUADRATIC_BEZIER_SEGMENT&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Adds a sequence of quadratic Bezier segments as an array in a single call.</summary>
            <param name="beziers">An array of a sequence of quadratic Bezier segments.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddQuadraticBezier(D2D1_QUADRATIC_BEZIER_SEGMENT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a quadratic Bezier curve between the current point and the specified end point.</summary>
            <param name="bezier">A structure that describes the control point and the end point of the quadratic Bezier curve to add.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddBeziers(CArray&lt;D2D1_BEZIER_SEGMENT,D2D1_BEZIER_SEGMENT&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a sequence of cubic Bezier curves and adds them to the geometry sink.</summary>
            <param name="beziers">An array of Bezier segments that describes the Bezier curves to create. A curve is drawn from the geometry sink's current point (the end point of the last segment drawn or the location specified by BeginFigure) to the end point of the first Bezier segment in the array. if the array contains additional Bezier segments, each subsequent Bezier segment uses the end point of the preceding Bezier segment as its start point.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddBezier(D2D1_BEZIER_SEGMENT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Creates a cubic Bezier curve between the current point and the specified end point.</summary>
            <param name="bezier">A structure that describes the control points and end point of the Bezier curve to add.</param>
        </member>
        <member name="M:CD2DGeometrySink.AddArc(D2D1_ARC_SEGMENT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Adds a single arc to the path geometry</summary>
            <param name="arc">The arc segment to add to the figure</param>
        </member>
        <member name="M:CD2DGeometrySink.EndFigure(D2D1_FIGURE_END)">
            <summary>
Ends the current figure; optionally, closes it.</summary>
            <param name="figureEnd">A value that indicates whether the current figure is closed. If the figure is closed, a line is drawn between the current point and the start point specified by BeginFigure.</param>
        </member>
        <member name="M:CD2DGeometrySink.BeginFigure(CD2DPointF,D2D1_FIGURE_BEGIN)">
            <summary>
Starts a new figure at the specified point.</summary>
            <param name="startPoint">The point at which to begin the new figure.</param>
            <param name="figureBegin">Whether the new figure should be hollow or filled.</param>
        </member>
        <member name="M:CD2DGeometrySink.op_Implicit~ID2D1GeometrySink*">
            <summary>
Returns ID2D1GeometrySink interface</summary>
            <returns> 
Pointer to an ID2D1GeometrySink interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DGeometrySink.Get">
            <summary>
Returns ID2D1GeometrySink interface</summary>
            <returns> 
Pointer to an ID2D1GeometrySink interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DGeometrySink.IsValid">
            <summary>
Checks geometry sink validity</summary>
            <returns> 
TRUE if geometry sink is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DGeometrySink.Dispose">
            <summary>
The destructor. Called when a D2D geometry sink object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DGeometrySink.#ctor(CD2DPathGeometry*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DGeometrySink object from CD2DPathGeometry object.</summary>
            <param name="pathGeometry">An existing CD2DPathGeometry object.</param>
        </member>
        <member name="T:CD2DGeometrySink">
            <summary>
ID2D1GeometrySink wrapper.
</summary>
        </member>
        <member name="F:CD2DPathGeometry.m_pPathGeometry">
            <summary>
A pointer to an ID2D1PathGeometry.
</summary>
        </member>
        <member name="M:CD2DPathGeometry.GetFigureCount">
            <summary>
Retrieves tthe number of figures in the path geometry.</summary>
            <returns> 
Returns the number of figures in the path geometry.</returns>
        </member>
        <member name="M:CD2DPathGeometry.GetSegmentCount">
            <summary>
Retrieves the number of segments in the path geometry.</summary>
            <returns> 
Returns the number of segments in the path geometry.</returns>
        </member>
        <member name="M:CD2DPathGeometry.Stream(ID2D1GeometrySink*)">
            <summary>
Copies the contents of the path geometry to the specified ID2D1GeometrySink.</summary>
            <returns>
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="geometrySink">The sink to which the path geometry's contents are copied. Modifying this sink does not change the contents of this path geometry.</param>
        </member>
        <member name="M:CD2DPathGeometry.Open">
            <summary>
Retrieves the geometry sink that is used to populate the path geometry with figures and segments.</summary>
            <returns>
A pointer to the ID2D1GeometrySink that is used to populate the path geometry with figures and segments.</returns>
        </member>
        <member name="M:CD2DPathGeometry.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DPathGeometry.Attach(ID2D1PathGeometry*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DPathGeometry.Destroy">
            <summary>
Destroys a CD2DPathGeometry object.</summary>
        </member>
        <member name="M:CD2DPathGeometry.Create(CRenderTarget*)">
            <summary>
Creates a CD2DPathGeometry.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DPathGeometry.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DPathGeometry object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DPathGeometry">
            <summary>
ID2D1PathGeometry wrapper.
</summary>
        </member>
        <member name="F:CD2DGeometry.m_pGeometry">
            <summary>
A pointer to an ID2D1Geometry.
</summary>
        </member>
        <member name="M:CD2DGeometry.Widen(System.Single,ID2D1StrokeStyle*,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1SimplifiedGeometrySink*,System.Single)">
            <summary>
Widens the geometry by the specified stroke and writes the result to an ID2D1SimplifiedGeometrySink after it has been transformed by the specified matrix and flattened using the specified tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="strokeWidth">The amount by which to widen the geometry.</param>
            <param name="strokeStyle">The style of stroke to apply to the geometry, or NULL.</param>
            <param name="worldTransform">The transform to apply to the geometry after widening it.</param>
            <param name="geometrySink">The ID2D1SimplifiedGeometrySink to which the widened geometry is appended.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.Tessellate(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1TessellationSink*,System.Single)">
            <summary>
Creates a set of clockwise-wound triangles that cover the geometry after it has been transformed using the specified matrix and flattened using the specified tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to this geometry, or NULL.</param>
            <param name="tessellationSink">The ID2D1TessellationSink to which the tessellated is appended.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.Simplify(D2D1_GEOMETRY_SIMPLIFICATION_OPTION,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1SimplifiedGeometrySink*,System.Single)">
            <summary>
Creates a simplified version of the geometry that contains only lines and (optionally) cubic Bezier curves and writes the result to an ID2D1SimplifiedGeometrySink.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="simplificationOption">A value that specifies whether the simplified geometry should contain curves.</param>
            <param name="worldTransform">The transform to apply to the simplified geometry.</param>
            <param name="geometrySink">The ID2D1SimplifiedGeometrySink to which the simplified geometry is appended.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.Outline(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1SimplifiedGeometrySink*,System.Single)">
            <summary>
Computes the outline of the geometry and writes the result to an ID2D1SimplifiedGeometrySink.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to the geometry outline.</param>
            <param name="geometrySink">The ID2D1SimplifiedGeometrySink to which the geometry transformed outline is appended.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.StrokeContainsPoint(CD2DPointF,System.Single,ID2D1StrokeStyle*,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Single)">
            <summary>
Determines whether the geometry's stroke contains the specified point given the specified stroke thickness, style, and transform.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="point">The point to test for containment.</param>
            <param name="strokeWidth">The thickness of the stroke to apply.</param>
            <param name="strokeStyle">The style of the stroke to apply.</param>
            <param name="worldTransform">The transform to apply to the stroked geometry.</param>
            <param name="contains">When this method returns, contains a boolean value set to TRUE if the geometry's stroke contains the specified point; otherwise, FALSE. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the stroke by less than the tolerance are still considered inside. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.FillContainsPoint(CD2DPointF,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32*,System.Single)">
            <summary>
Indicates whether the area filled by the geometry would contain the specified point given the specified flattening tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="point">The point to test.</param>
            <param name="worldTransform">The transform to apply to the geometry prior to testing for containment.</param>
            <param name="contains">When this method returns, contains a bool value that is TRUE if the area filled by the geometry contains point; otherwise, FALSE. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The numeric accuracy with which the precise geometric path and path intersection is calculated. Points missing the fill by less than the tolerance are still considered inside. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.GetWidenedBounds(System.Single,ID2D1StrokeStyle*,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DRectF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Gets the bounds of the geometry after it has been widened by the specified stroke width and style and transformed by the specified matrix.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="strokeWidth">The amount by which to widen the geometry by stroking its outline.</param>
            <param name="strokeStyle">The style of the stroke that widens the geometry.</param>
            <param name="worldTransform">A transform to apply to the geometry after the geometry is transformed and after the geometry has been stroked.</param>
            <param name="bounds">When this method returns, contains the bounds of the widened geometry. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.GetBounds(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DRectF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieves the bounds of the geometry.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to this geometry before calculating its bounds.</param>
            <param name="bounds">When this method returns, contains the bounds of this geometry. If the bounds are empty, this will be a rect where bounds.left is greater than bounds.right. You must allocate storage for this parameter.</param>
        </member>
        <member name="M:CD2DGeometry.ComputePointAtLength(System.Single,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DPointF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DPointF*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Calculates the point and tangent vector at the specified distance along the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="length">The distance along the geometry of the point and tangent to find. If this distance is less then 0, this method calculates the first point in the geometry. If this distance is greater than the length of the geometry, this method calculates the last point in the geometry.</param>
            <param name="worldTransform">The transform to apply to the geometry before calculating the specified point and tangent.</param>
            <param name="point">The location at the specified distance along the geometry. If the geometry is empty, this point contains NaN as its x and y values.</param>
            <param name="unitTangentVector">When this method returns, contains a pointer to the tangent vector at the specified distance along the geometry. If the geometry is empty, this vector contains NaN as its x and y values. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.ComputeLength(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Calculates the length of the geometry as though each segment were unrolled into a line.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to the geometry before calculating its length.</param>
            <param name="length">When this method returns, contains a pointer to the length of the geometry. For closed geometries, the length includes an implicit closing segment. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.ComputeArea(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Computes the area of the geometry after it has been transformed by the specified matrix and flattened using the specified tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="worldTransform">The transform to apply to this geometry before computing its area.</param>
            <param name="area">When this method returns, contains a pointer to the area of the transformed, flattened version of this geometry. You must allocate storage for this parameter.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometry. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.CompareWithGeometry(CD2DGeometry*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single)">
            <summary>
Describes the intersection between this geometry and the specified geometry. The comparison is performed using the specified flattening tolerance.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="inputGeometry">The geometry to test.</param>
            <param name="inputGeometryTransform">The transform to apply to inputGeometry.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution. </param>
        </member>
        <member name="M:CD2DGeometry.CombineWithGeometry(CD2DGeometry*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,D2D1_COMBINE_MODE,D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,ID2D1SimplifiedGeometrySink*,System.Single)">
            <summary>
Combines this geometry with the specified geometry and stores the result in an ID2D1SimplifiedGeometrySink.</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE.</returns>
            <param name="inputGeometry">The geometry to combine with this instance.</param>
            <param name="combineMode">The type of combine operation to perform.</param>
            <param name="inputGeometryTransform">The transform to apply to inputGeometry before combining.</param>
            <param name="geometrySink">The result of the combine operation.</param>
            <param name="flatteningTolerance">The maximum bounds on the distance between points in the polygonal approximation of the geometries. Smaller values produce more accurate results but cause slower execution.</param>
        </member>
        <member name="M:CD2DGeometry.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DGeometry.Destroy">
            <summary>
Destroys a CD2DGeometry object.</summary>
        </member>
        <member name="M:CD2DGeometry.op_Implicit~ID2D1Geometry*">
            <summary>
Returns ID2D1Geometry interface</summary>
            <returns> 
Pointer to an ID2D1Geometry interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DGeometry.Get">
            <summary>
Returns ID2D1Geometry interface</summary>
            <returns> 
Pointer to an ID2D1Geometry interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DGeometry.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DGeometry.Attach(ID2D1Geometry*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DGeometry.Dispose">
            <summary>
The destructor. Called when a D2D geometry object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DGeometry.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DGeometry object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DGeometry">
            <summary>
ID2D1Geometry wrapper.
</summary>
        </member>
        <member name="F:CD2DTextLayout.m_pTextLayout">
            <summary>
A pointer to an IDWriteTextLayout.
</summary>
        </member>
        <member name="M:CD2DTextLayout.GetLocaleName(System.UInt32,DWRITE_TEXT_RANGE*)">
            <summary>
Gets the locale name of the text at the specified position.</summary>
            <returns>
CString object that contains the current locale name.</returns>
            <param name="currentPosition">The position of the text to inspect.</param>
            <param name="textRange">The range of text that has the same formatting as the text at the position specified by currentPosition. This means the run has the exact formatting as the position specified, including but not limited to the locale name.</param>
        </member>
        <member name="M:CD2DTextLayout.GetFontFamilyName(System.UInt32,DWRITE_TEXT_RANGE*)">
            <summary>
Copies the font family name of the text at the specified position.</summary>
            <returns>
CString object that contains the current font family name.</returns>
            <param name="currentPosition">The position of the text to examine.</param>
            <param name="textRange">The range of text that has the same formatting as the text at the position specified by currentPosition. This means the run has the exact formatting as the position specified, including but not limited to the font family name.</param>
        </member>
        <member name="M:CD2DTextLayout.SetLocaleName(System.Char!System.Runtime.CompilerServices.IsConst*,DWRITE_TEXT_RANGE)">
            <summary>
Sets the locale name for text within a specified text range</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE</returns>
            <param name="pwzLocaleName">A null-terminated locale name string</param>
            <param name="textRange">Text range to which this change applies</param>
        </member>
        <member name="M:CD2DTextLayout.SetFontFamilyName(System.Char!System.Runtime.CompilerServices.IsConst*,DWRITE_TEXT_RANGE)">
            <summary>
Sets null-terminated font family name for text within a specified text range</summary>
            <returns> 
If the method succeeds, it returns TRUE. Otherwise, it returns FALSE</returns>
            <param name="pwzFontFamilyName">The font family name that applies to the entire text string within the range specified by textRange</param>
            <param name="textRange">Text range to which this change applies</param>
        </member>
        <member name="M:CD2DTextLayout.op_Implicit~IDWriteTextLayout*">
            <summary>
Returns IDWriteTextLayout interface</summary>
            <returns>
Pointer to an IDWriteTextLayout interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DTextLayout.Get">
            <summary>
Returns IDWriteTextLayout interface</summary>
            <returns>
Pointer to an IDWriteTextLayout interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DTextLayout.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DTextLayout.Destroy">
            <summary>
Destroys a CD2DTextLayout object.</summary>
        </member>
        <member name="M:CD2DTextLayout.Create(CRenderTarget*)">
            <summary>
Creates a CD2DTextLayout.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DTextLayout.ReCreate(CRenderTarget*)">
            <summary>
Re-creates a CD2DTextLayout.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DTextLayout.Dispose">
            <summary>
The destructor. Called when a D2D text layout object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DTextLayout.#ctor(CRenderTarget*,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DTextFormat*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DSizeF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
            <summary>
Constructs a CD2DTextLayout object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="strText">A CString object that contains the string to create a new CD2DTextLayout object from.</param>
            <param name="textFormat">A CString object that contains the format to apply to the string.</param>
            <param name="sizeMax">The size of the layout box.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DTextLayout">
            <summary>
IDWriteTextLayout wrapper.
</summary>
        </member>
        <member name="F:CD2DTextFormat.m_pTextFormat">
            <summary>
A pointer to an IDWriteTextFormat.
</summary>
        </member>
        <member name="M:CD2DTextFormat.GetLocaleName">
            <summary>
Gets a copy of the locale name.</summary>
            <returns>
CString object that contains the current locale name.</returns>
        </member>
        <member name="M:CD2DTextFormat.GetFontFamilyName">
            <summary>
Gets a copy of the font family name.</summary>
            <returns>
CString object that contains the current font family name.</returns>
        </member>
        <member name="M:CD2DTextFormat.op_Implicit~IDWriteTextFormat*">
            <summary>
Returns IDWriteTextFormat interface</summary>
            <returns>
Pointer to an IDWriteTextFormat interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DTextFormat.Get">
            <summary>
Returns IDWriteTextFormat interface</summary>
            <returns> 
Pointer to an IDWriteTextFormat interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DTextFormat.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DTextFormat.Destroy">
            <summary>
Destroys a CD2DTextFormat object.</summary>
        </member>
        <member name="M:CD2DTextFormat.Create(CRenderTarget*)">
            <summary>
Creates a CD2DTextFormat.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DTextFormat.ReCreate(CRenderTarget*)">
            <summary>
Re-creates a CD2DTextFormat.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DTextFormat.Dispose">
            <summary>
The destructor. Called when a D2D text format object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DTextFormat.#ctor(CRenderTarget*,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Single,DWRITE_FONT_WEIGHT,DWRITE_FONT_STYLE,DWRITE_FONT_STRETCH,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,IDWriteFontCollection*,System.Int32)">
            <summary>
Constructs a CD2DTextFormat object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="strFontFamilyName">A CString object that contains the name of the font family.</param>
            <param name="fontSize">The logical size of the font in DIP ("device-independent pixel") units. A DIPequals 1/96 inch.</param>
            <param name="fontWeight">A value that indicates the font weight for the text object.</param>
            <param name="fontStyle">A value that indicates the font style for the text object.</param>
            <param name="fontStretch">A value that indicates the font stretch for the text object.</param>
            <param name="strFontLocale">A CString object that contains the locale name.</param>
            <param name="pFontCollection">A pointer to a font collection object. When this is NULL, indicates the system font collection.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DTextFormat">
            <summary>
IDWriteTextFormat wrapper.
</summary>
        </member>
        <member name="F:CD2DRadialGradientBrush.m_pRadialGradientBrush">
            <summary>
A pointer to an ID2D1RadialGradientBrush.
</summary>
        </member>
        <member name="F:CD2DRadialGradientBrush.m_RadialGradientBrushProperties">
            <summary>
The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.
</summary>
        </member>
        <member name="M:CD2DRadialGradientBrush.GetRadiusY">
            <summary>
Retrieves the y-radius of the gradient ellipse</summary>
            <returns> 
The y-radius of the gradient ellipse. This value is expressed in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.GetRadiusX">
            <summary>
Retrieves the x-radius of the gradient ellipse</summary>
            <returns> 
The x-radius of the gradient ellipse. This value is expressed in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.GetGradientOriginOffset">
            <summary>
Retrieves the offset of the gradient origin relative to the gradient ellipse's center</summary>
            <returns> 
The offset of the gradient origin from the center of the gradient ellipse. This value is expressed in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.GetCenter">
            <summary>
Retrieves the center of the gradient ellipse</summary>
            <returns> 
The center of the gradient ellipse. This value is expressed in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.SetRadiusY(System.Single)">
            <summary>
Specifies the y-radius of the gradient ellipse, in the brush's coordinate space</summary>
            <param name="radiusY">The y-radius of the gradient ellipse. This value is in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.SetRadiusX(System.Single)">
            <summary>
Specifies the x-radius of the gradient ellipse, in the brush's coordinate space</summary>
            <param name="radiusX">The x-radius of the gradient ellipse. This value is in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.SetGradientOriginOffset(CD2DPointF)">
            <summary>
Specifies the offset of the gradient origin relative to the gradient ellipse's center</summary>
            <param name="gradientOriginOffset">The offset of the gradient origin from the center of the gradient ellipse</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.SetCenter(CD2DPointF)">
            <summary>
Specifies the center of the gradient ellipse in the brush's coordinate space</summary>
            <param name="point">The center of the gradient ellipse, in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.op_Implicit~ID2D1RadialGradientBrush*">
            <summary>
Returns ID2D1RadialGradientBrush interface</summary>
            <returns> 
Pointer to an ID2D1RadialGradientBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.Get">
            <summary>
Returns ID2D1RadialGradientBrush interface</summary>
            <returns> 
Pointer to an ID2D1RadialGradientBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DRadialGradientBrush.Attach(ID2D1RadialGradientBrush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.Destroy">
            <summary>
Destroys a CD2DRadialGradientBrush object.</summary>
        </member>
        <member name="M:CD2DRadialGradientBrush.Create(CRenderTarget*)">
            <summary>
Creates a CD2DRadialGradientBrush.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DRadialGradientBrush.Dispose">
            <summary>
The destructor. Called when a D2D radial gradient brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DRadialGradientBrush.#ctor(CRenderTarget*,D2D1_GRADIENT_STOP!System.Runtime.CompilerServices.IsConst*,System.UInt32,D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES,D2D1_GAMMA,D2D1_EXTEND_MODE,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DLinearGradientBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="gradientStopsCount">A value greater than or equal to 1 that specifies the number of gradient stops in the gradientStops array.</param>
            <param name="RadialGradientBrushProperties">The center, gradient origin offset, and x-radius and y-radius of the brush's gradient.</param>
            <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
            <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DRadialGradientBrush">
            <summary>
ID2D1RadialGradientBrush wrapper.
</summary>
        </member>
        <member name="F:CD2DLinearGradientBrush.m_pLinearGradientBrush">
            <summary>
A pointer to an ID2D1LinearGradientBrush.
</summary>
        </member>
        <member name="F:CD2DLinearGradientBrush.m_LinearGradientBrushProperties">
            <summary>
The start and end points of the gradient.
</summary>
        </member>
        <member name="M:CD2DLinearGradientBrush.GetEndPoint">
            <summary>
Retrieves the ending coordinates of the linear gradient</summary>
            <returns> 
The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.GetStartPoint">
            <summary>
Retrieves the starting coordinates of the linear gradient</summary>
            <returns> 
The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.SetEndPoint(CD2DPointF)">
            <summary>
Sets the ending coordinates of the linear gradient in the brush's coordinate space</summary>
            <param name="point">The ending two-dimensional coordinates of the linear gradient, in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DLinearGradientBrush.SetStartPoint(CD2DPointF)">
            <summary>
Sets the starting coordinates of the linear gradient in the brush's coordinate space</summary>
            <param name="point">The starting two-dimensional coordinates of the linear gradient, in the brush's coordinate space</param>
        </member>
        <member name="M:CD2DLinearGradientBrush.op_Implicit~ID2D1LinearGradientBrush*">
            <summary>
Returns ID2D1LinearGradientBrush interface</summary>
            <returns> 
Pointer to an ID2D1LinearGradientBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.Get">
            <summary>
Returns ID2D1LinearGradientBrush interface</summary>
            <returns> 
Pointer to an ID2D1LinearGradientBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DLinearGradientBrush.Attach(ID2D1LinearGradientBrush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DLinearGradientBrush.Destroy">
            <summary>
Destroys a CD2DLinearGradientBrush object.</summary>
        </member>
        <member name="M:CD2DLinearGradientBrush.Create(CRenderTarget*)">
            <summary>
Creates a CD2DLinearGradientBrush.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DLinearGradientBrush.Dispose">
            <summary>
The destructor. Called when a D2D linear gradient brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DLinearGradientBrush.#ctor(CRenderTarget*,D2D1_GRADIENT_STOP!System.Runtime.CompilerServices.IsConst*,System.UInt32,D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES,D2D1_GAMMA,D2D1_EXTEND_MODE,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DLinearGradientBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="gradientStopsCount">A value greater than or equal to 1 that specifies the number of gradient stops in the gradientStops array.</param>
            <param name="LinearGradientBrushProperties">The start and end points of the gradient.</param>
            <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
            <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DLinearGradientBrush">
            <summary>
ID2D1LinearGradientBrush wrapper.
</summary>
        </member>
        <member name="F:CD2DGradientBrush.m_pGradientStops">
            <summary>
A pointer to an array of D2D1_GRADIENT_STOP structures.
</summary>
        </member>
        <member name="F:CD2DGradientBrush.m_extendMode">
            <summary>
The behavior of the gradient outside the [0,1] normalized range.
</summary>
        </member>
        <member name="F:CD2DGradientBrush.m_colorInterpolationGamma">
            <summary>
The space in which color interpolation between the gradient stops is performed.
</summary>
        </member>
        <member name="F:CD2DGradientBrush.m_arGradientStops">
            <summary>
Array of the D2D1_GRADIENT_STOP structures.
</summary>
        </member>
        <member name="M:CD2DGradientBrush.Destroy">
            <summary>
Destroys a CD2DGradientBrush object.</summary>
        </member>
        <member name="M:CD2DGradientBrush.Dispose">
            <summary>
The destructor. Called when a D2D gradient brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DGradientBrush.#ctor(CRenderTarget*,D2D1_GRADIENT_STOP!System.Runtime.CompilerServices.IsConst*,System.UInt32,D2D1_GAMMA,D2D1_EXTEND_MODE,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DGradientBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="gradientStops">A pointer to an array of D2D1_GRADIENT_STOP structures.</param>
            <param name="gradientStopsCount">A value greater than or equal to 1 that specifies the number of gradient stops in the gradientStops array.</param>
            <param name="colorInterpolationGamma">The space in which color interpolation between the gradient stops is performed.</param>
            <param name="extendMode">The behavior of the gradient outside the [0,1] normalized range.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DGradientBrush">
            <summary>
The base class of CD2DLinearGradientBrush and CD2DRadialGradientBrush classes.
</summary>
        </member>
        <member name="F:CD2DBitmapBrush.m_pBitmapBrushProperties">
            <summary>
Bitmap brush properties.
</summary>
        </member>
        <member name="F:CD2DBitmapBrush.m_pBitmapBrush">
            <summary>
Stores a pointer to an ID2D1BitmapBrush object.
</summary>
        </member>
        <member name="F:CD2DBitmapBrush.m_pBitmap">
            <summary>
Stores a pointer to a CD2DBitmap object.
</summary>
        </member>
        <member name="M:CD2DBitmapBrush.CommonInit(D2D1_BITMAP_BRUSH_PROPERTIES*)">
            <summary>
Initializes the object</summary>
            <param name="pBitmapBrushProperties">A pointer to the bitmap brush properties.</param>
        </member>
        <member name="M:CD2DBitmapBrush.Destroy">
            <summary>
Destroys a CD2DBitmapBrush object.</summary>
        </member>
        <member name="M:CD2DBitmapBrush.Create(CRenderTarget*)">
            <summary>
Creates a CD2DBitmapBrush.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DBitmapBrush.GetInterpolationMode">
            <summary>
Gets the interpolation method used when the brush bitmap is scaled or rotated</summary>
            <returns> 
The interpolation method used when the brush bitmap is scaled or rotated</returns>
        </member>
        <member name="M:CD2DBitmapBrush.GetExtendModeY">
            <summary>
Gets the method by which the brush vertically tiles those areas that extend past its bitmap</summary>
            <returns> 
A value that specifies how the brush vertically tiles those areas that extend past its bitmap</returns>
        </member>
        <member name="M:CD2DBitmapBrush.GetExtendModeX">
            <summary>
Gets the method by which the brush horizontally tiles those areas that extend past its bitmap</summary>
            <returns> 
A value that specifies how the brush horizontally tiles those areas that extend past its bitmap</returns>
        </member>
        <member name="M:CD2DBitmapBrush.SetBitmap(CD2DBitmap*)">
            <summary>
Specifies the bitmap source that this brush uses to paint</summary>
            <param name="pBitmap">The bitmap source used by the brush</param>
        </member>
        <member name="M:CD2DBitmapBrush.SetInterpolationMode(D2D1_BITMAP_INTERPOLATION_MODE)">
            <summary>
Specifies the interpolation mode used when the brush bitmap is scaled or rotated</summary>
            <param name="interpolationMode">The interpolation mode used when the brush bitmap is scaled or rotated</param>
        </member>
        <member name="M:CD2DBitmapBrush.SetExtendModeY(D2D1_EXTEND_MODE)">
            <summary>
Specifies how the brush vertically tiles those areas that extend past its bitmap</summary>
            <param name="extendModeY">A value that specifies how the brush vertically tiles those areas that extend past its bitmap</param>
        </member>
        <member name="M:CD2DBitmapBrush.SetExtendModeX(D2D1_EXTEND_MODE)">
            <summary>
Specifies how the brush horizontally tiles those areas that extend past its bitmap</summary>
            <param name="extendModeX">A value that specifies how the brush horizontally tiles those areas that extend past its bitmap</param>
        </member>
        <member name="M:CD2DBitmapBrush.GetBitmap">
            <summary>
Gets the bitmap source that this brush uses to paint</summary>
            <returns> 
Pointer to an CD2DBitmap object or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmapBrush.op_Implicit~ID2D1BitmapBrush*">
            <summary>
Returns ID2D1BitmapBrush interface</summary>
            <returns> 
Pointer to an ID2D1BitmapBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmapBrush.Get">
            <summary>
Returns ID2D1BitmapBrush interface</summary>
            <returns> 
Pointer to an ID2D1BitmapBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmapBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DBitmapBrush.Attach(ID2D1BitmapBrush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DBitmapBrush.Dispose">
            <summary>
The destructor. Called when a D2D bitmap brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DBitmapBrush.#ctor(CRenderTarget*,System.Char!System.Runtime.CompilerServices.IsConst*,CD2DSizeU,D2D1_BITMAP_BRUSH_PROPERTIES*,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DBitmapBrush object from file.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="lpszImagePath">Pointer to a null-terminated string that contains the name of file.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="pBitmapBrushProperties">A pointer to the extend modes and the interpolation mode of a bitmap brush.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmapBrush.#ctor(CRenderTarget*,System.UInt32,System.Char!System.Runtime.CompilerServices.IsConst*,CD2DSizeU,D2D1_BITMAP_BRUSH_PROPERTIES*,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DBitmapBrush object from resource.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="uiResID">The resource ID number of the resource.</param>
            <param name="lpszType">Pointer to a null-terminated string that contains the resource type.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="pBitmapBrushProperties">A pointer to the extend modes and the interpolation mode of a bitmap brush.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmapBrush.#ctor(CRenderTarget*,D2D1_BITMAP_BRUSH_PROPERTIES*,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DBitmapBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="pBitmapBrushProperties">A pointer to the extend modes and the interpolation mode of a bitmap brush.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DBitmapBrush">
            <summary>
ID2D1BitmapBrush wrapper.
</summary>
        </member>
        <member name="F:CD2DSolidColorBrush.m_colorSolid">
            <summary>
Brush solid color.
</summary>
        </member>
        <member name="F:CD2DSolidColorBrush.m_pSolidColorBrush">
            <summary>
Stores a pointer to an ID2D1SolidColorBrush object.
</summary>
        </member>
        <member name="M:CD2DSolidColorBrush.Destroy">
            <summary>
Destroys a CD2DSolidColorBrush object.</summary>
        </member>
        <member name="M:CD2DSolidColorBrush.Create(CRenderTarget*)">
            <summary>
Creates a CD2DSolidColorBrush.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DSolidColorBrush.GetColor">
            <summary>
Retrieves the color of the solid color brush</summary>
            <returns> 
The color of this solid color brush</returns>
        </member>
        <member name="M:CD2DSolidColorBrush.SetColor(_D3DCOLORVALUE)">
            <summary>
Specifies the color of this solid color brush</summary>
            <param name="color">The color of this solid color brush</param>
        </member>
        <member name="M:CD2DSolidColorBrush.op_Implicit~ID2D1SolidColorBrush*">
            <summary>
Returns ID2D1SolidColorBrush interface</summary>
            <returns> 
Pointer to an ID2D1SolidColorBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DSolidColorBrush.Get">
            <summary>
Returns ID2D1SolidColorBrush interface</summary>
            <returns> 
Pointer to an ID2D1SolidColorBrush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DSolidColorBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DSolidColorBrush.Attach(ID2D1SolidColorBrush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DSolidColorBrush.Dispose">
            <summary>
The destructor. Called when a D2D solid brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DSolidColorBrush.#ctor(CRenderTarget*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DSolidColorBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="color">The red, green, and blue values of the brush's color.</param>
            <param name="nAlpha">The opacity of the brush's color.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DSolidColorBrush.#ctor(CRenderTarget*,_D3DCOLORVALUE,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DSolidColorBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="color">The red, green, blue, and alpha values of the brush's color.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DSolidColorBrush">
            <summary>
ID2D1SolidColorBrush wrapper.
</summary>
        </member>
        <member name="F:CD2DBrush.m_pBrushProperties">
            <summary>
Brush properties.
</summary>
        </member>
        <member name="F:CD2DBrush.m_pBrush">
            <summary>
Stores a pointer to an ID2D1Brush object.
</summary>
        </member>
        <member name="M:CD2DBrush.GetTransform(D2D_MATRIX_3X2_F*)">
            <summary>
Gets the current transform of the render target</summary>
            <param name="transform">When this returns, contains the current transform of the render target. This parameter is passed uninitialized</param>
        </member>
        <member name="M:CD2DBrush.SetTransform(D2D_MATRIX_3X2_F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Applies the specified transform to the render target, replacing the existing transformation. All subsequent drawing operations occur in the transformed space</summary>
            <param name="transform">The transform to apply to the render target</param>
        </member>
        <member name="M:CD2DBrush.GetOpacity">
            <summary>
Gets the degree of opacity of this brush</summary>
            <returns> 
A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0 to 1 before they are multiplied together</returns>
        </member>
        <member name="M:CD2DBrush.SetOpacity(System.Single)">
            <summary>
Sets the degree of opacity of this brush</summary>
            <param name="opacity">A value between zero and 1 that indicates the opacity of the brush. This value is a constant multiplier that linearly scales the alpha value of all pixels filled by the brush. The opacity values are clamped in the range 0 to 1 before they are multiplied together</param>
        </member>
        <member name="M:CD2DBrush.Destroy">
            <summary>
Destroys a CD2DBrush object.</summary>
        </member>
        <member name="M:CD2DBrush.op_Implicit~ID2D1Brush*">
            <summary>
Returns ID2D1Brush interface</summary>
            <returns> 
Pointer to an ID2D1Brush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBrush.Get">
            <summary>
Returns ID2D1Brush interface</summary>
            <returns> 
Pointer to an ID2D1Brush interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBrush.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DBrush.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DBrush.Attach(ID2D1Brush*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DBrush.Dispose">
            <summary>
The destructor. Called when a D2D brush object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DBrush.#ctor(CRenderTarget*,CD2DBrushProperties*,System.Int32)">
            <summary>
Constructs a CD2DBrush object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="pBrushProperties">A pointer to the opacity and transformation of a brush.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DBrush">
            <summary>
ID2D1Brush wrapper.
</summary>
        </member>
        <member name="M:CD2DBrushProperties.CommonInit">
            <summary>
Initializes the object</summary>
        </member>
        <member name="M:CD2DBrushProperties.#ctor(D2D_MATRIX_3X2_F,System.Single)">
            <summary>
Creates a CD2D_BRUSH_PROPERTIES structure</summary>
            <param name="_transform">The transformation to apply to the brush</param>
            <param name="_opacity">The base opacity of the brush. The default value is 1.0.</param>
        </member>
        <member name="M:CD2DBrushProperties.#ctor(System.Single)">
            <summary>
Creates a CD2D_BRUSH_PROPERTIES structure</summary>
            <param name="_opacity">The base opacity of the brush. The default value is 1.0.</param>
        </member>
        <member name="M:CD2DBrushProperties.#ctor">
            <summary>
Creates a CD2D_BRUSH_PROPERTIES structure</summary>
        </member>
        <member name="T:CD2DBrushProperties">
            <summary>
D2D1_BRUSH_PROPERTIES wrapper.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_bAutoDestroyHBMP">
            <summary>
TRUE if m_hBmpSrc should be destroyed; otherwise FALSE.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_hBmpSrc">
            <summary>
Source bitmap handle.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_sizeDest">
            <summary>
Bitmap destination size.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_strPath">
            <summary>
Botmap file path.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_lpszType">
            <summary>
Resource type.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_uiResID">
            <summary>
Bitmap resource ID.
</summary>
        </member>
        <member name="F:CD2DBitmap.m_pBitmap">
            <summary>
Stores a pointer to an ID2D1Bitmap object.
</summary>
        </member>
        <member name="M:CD2DBitmap.Destroy">
            <summary>
Destroys a CD2DBitmap object.</summary>
        </member>
        <member name="M:CD2DBitmap.Create(CRenderTarget*)">
            <summary>
Creates a CD2DBitmap.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DBitmap.CommonInit">
            <summary>
Initializes the object</summary>
        </member>
        <member name="M:CD2DBitmap.op_Implicit~ID2D1Bitmap*">
            <summary>
Returns ID2D1Bitmap interface</summary>
            <returns> 
Pointer to an ID2D1Bitmap interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmap.Get">
            <summary>
Returns ID2D1Bitmap interface</summary>
            <returns> 
Pointer to an ID2D1Bitmap interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DBitmap.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DBitmap.CopyFromMemory(System.Void!System.Runtime.CompilerServices.IsConst*,System.UInt32,CD2DRectU!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Copies the specified region from memory into the current bitmap</summary>
            <returns> 
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="srcData">The data to copy</param>
            <param name="pitch">The stride, or pitch, of the source bitmap stored in srcData. The stride is the byte count of a scanline (one row of pixels in memory). The stride can be computed from the following formula: pixel width * bytes per pixel + memory padding</param>
            <param name="destRect">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied</param>
        </member>
        <member name="M:CD2DBitmap.CopyFromRenderTarget(CRenderTarget!System.Runtime.CompilerServices.IsConst*,CD2DPointU!System.Runtime.CompilerServices.IsConst*,CD2DRectU!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Copies the specified region from the specified render target into the current bitmap</summary>
            <returns> 
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">The render target that contains the region to copy</param>
            <param name="destPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied</param>
            <param name="srcRect">The area of renderTarget to copy</param>
        </member>
        <member name="M:CD2DBitmap.CopyFromBitmap(CD2DBitmap!System.Runtime.CompilerServices.IsConst*,CD2DPointU!System.Runtime.CompilerServices.IsConst*,CD2DRectU!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Copies the specified region from the specified bitmap into the current bitmap</summary>
            <returns> 
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pBitmap">The bitmap to copy from</param>
            <param name="destPoint">In the current bitmap, the upper-left corner of the area to which the region specified by srcRect is copied</param>
            <param name="srcRect">The area of bitmap to copy</param>
        </member>
        <member name="M:CD2DBitmap.GetDPI">
            <summary>
Return the dots per inch (DPI) of the bitmap</summary>
            <returns> 
The horizontal and vertical DPI of the bitmap.</returns>
        </member>
        <member name="M:CD2DBitmap.GetPixelFormat">
            <summary>
Retrieves the pixel format and alpha mode of the bitmap</summary>
            <returns> 
The pixel format and alpha mode of the bitmap.</returns>
        </member>
        <member name="M:CD2DBitmap.GetPixelSize">
            <summary>
Returns the size, in device-dependent units (pixels), of the bitmap</summary>
            <returns> 
The size, in pixels, of the bitmap..</returns>
        </member>
        <member name="M:CD2DBitmap.GetSize">
            <summary>
Returns the size, in device-independent pixels (DIPs), of the bitmap</summary>
            <returns> 
The size, in DIPs, of the bitmap.</returns>
        </member>
        <member name="M:CD2DBitmap.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DBitmap.Attach(ID2D1Bitmap*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DBitmap.Dispose">
            <summary>
The destructor. Called when a D2D bitmap object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DBitmap.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DBitmap object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmap.#ctor(CRenderTarget*,HBITMAP__*,CD2DSizeU,System.Int32)">
            <summary>
Constructs a CD2DBitmap object from HBITMAP.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="hbmpSrc">Handle to the bitmap.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmap.#ctor(CRenderTarget*,System.Char!System.Runtime.CompilerServices.IsConst*,CD2DSizeU,System.Int32)">
            <summary>
Constructs a CD2DBitmap object from file.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="lpszPath">Pointer to a null-terminated string that contains the name of file.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="M:CD2DBitmap.#ctor(CRenderTarget*,System.UInt32,System.Char!System.Runtime.CompilerServices.IsConst*,CD2DSizeU,System.Int32)">
            <summary>
Constructs a CD2DBitmap object from resource.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="uiResID">The resource ID number of the resource.</param>
            <param name="lpszType">Pointer to a null-terminated string that contains the resource type.</param>
            <param name="sizeDest">Destination size of the bitmap.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DBitmap">
            <summary>
ID2D1Bitmap wrapper.
</summary>
        </member>
        <member name="F:CD2DLayer.m_pLayer">
            <summary>
Stores a pointer to an ID2D1Layer object.
</summary>
        </member>
        <member name="M:CD2DLayer.Destroy">
            <summary>
Destroys a CD2DLayer object.</summary>
        </member>
        <member name="M:CD2DLayer.Create(CRenderTarget*)">
            <summary>
Creates a CD2DLayer.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DLayer.Detach">
            <summary>
Detaches resource interface from the object</summary>
            <returns> 
Pointer to detached resource interface.</returns>
        </member>
        <member name="M:CD2DLayer.Attach(ID2D1Layer*)">
            <summary>
Attaches existing resource interface to the object</summary>
            <param name="pResource">Existing resource interface. Cannot be NULL</param>
        </member>
        <member name="M:CD2DLayer.op_Implicit~ID2D1Layer*">
            <summary>
Returns ID2D1Layer interface</summary>
            <returns> 
Pointer to an ID2D1Layer interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DLayer.Get">
            <summary>
Returns ID2D1Layer interface</summary>
            <returns> 
Pointer to an ID2D1Layer interface or NULL if object is not initialized yet.</returns>
        </member>
        <member name="M:CD2DLayer.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DLayer.GetSize">
            <summary>
Returns the size of the render target in device-independent pixels</summary>
            <returns> 
The current size of the render target in device-independent pixels</returns>
        </member>
        <member name="M:CD2DLayer.Dispose">
            <summary>
The destructor. Called when a D2D layer object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DLayer.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DLayer object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DLayer">
            <summary>
ID2D1Layer wrapper.
</summary>
        </member>
        <member name="F:CD2DResource.m_pParentTarget">
            <summary>
Pointer to the parent CRenderTarget)</summary>
        </member>
        <member name="F:CD2DResource.m_bIsAutoDestroy">
            <summary>
Resource will be destoyed by owner (CRenderTarget)</summary>
        </member>
        <member name="M:CD2DResource.IsValid">
            <summary>
Checks resource validity</summary>
            <returns> 
TRUE if resource is valid; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DResource.Destroy">
            <summary>
Destroys a CD2DResource object.</summary>
        </member>
        <member name="M:CD2DResource.Create(CRenderTarget*)">
            <summary>
Creates a CD2DResource.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DResource.ReCreate(CRenderTarget*)">
            <summary>
Re-creates a CD2DResource.</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.</returns>
            <param name="pRenderTarget">A pointer to the render target.</param>
        </member>
        <member name="M:CD2DResource.IsAutoDestroy">
            <summary>
Check auto destroy flag.</summary>
            <returns>
TRUE if the object will be destroyed by its owner; otherwise FALSE.</returns>
        </member>
        <member name="M:CD2DResource.Dispose">
            <summary>
The destructor. Called when a D2D resource object is being destroyed.
</summary>
        </member>
        <member name="M:CD2DResource.#ctor(CRenderTarget*,System.Int32)">
            <summary>
Constructs a CD2DResource object.</summary>
            <param name="pParentTarget">A pointer to the render target.</param>
            <param name="bAutoDestroy">Indicates that the object will be destroyed by owner (pParentTarget).</param>
        </member>
        <member name="T:CD2DResource">
            <summary>
An abstract class, which provides a interface for creating and managing D2D resources such as brushes, layers and texts.
</summary>
        </member>
        <member name="M:CD2DEllipse.#ctor(CD2DPointF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DSizeF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DEllipse from CD2DPointF and CD2DSizeF objects.</summary>
            <param name="ptCenter">The center point of the ellipse.</param>
            <param name="sizeRadius">The X-radius and Y-radius of the ellipse.</param>
        </member>
        <member name="M:CD2DEllipse.#ctor(D2D1_ELLIPSE!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DEllipse object from D2D1_ELLIPSE object.</summary>
            <param name="ellipse">source ellipse</param>
        </member>
        <member name="M:CD2DEllipse.#ctor(D2D1_ELLIPSE!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DEllipse object from D2D1_ELLIPSE object.</summary>
            <param name="ellipse">source ellipse</param>
        </member>
        <member name="M:CD2DEllipse.#ctor(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DEllipse object from CD2DRectF object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="T:CD2DEllipse">
            <summary>
D2D1_ELLIPSE wrapper
</summary>
        </member>
        <member name="M:CD2DRoundedRect.#ctor(D2D1_ROUNDED_RECT!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DRoundedRect object from D2D1_ROUNDED_RECT object.</summary>
            <param name="rectIn">source rectangle</param>
        </member>
        <member name="M:CD2DRoundedRect.#ctor(D2D1_ROUNDED_RECT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRoundedRect object from D2D1_ROUNDED_RECT object.</summary>
            <param name="rectIn">source rectangle</param>
        </member>
        <member name="M:CD2DRoundedRect.#ctor(CD2DRectF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CD2DSizeF!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRoundedRect object from CD2DRectF object.</summary>
            <param name="rectIn">source rectangle</param>
            <param name="sizeRadius">radius size</param>
        </member>
        <member name="T:CD2DRoundedRect">
            <summary>
D2D1_ROUNDED_RECT wrapper
</summary>
        </member>
        <member name="M:CD2DRectU.op_Implicit~CRect">
            <summary>
Converts CD2DRectU to CRect object.</summary>
            <returns>
Current value of D2D rectangle.
</returns>
        </member>
        <member name="M:CD2DRectU.IsNull">
            <summary>
Returns a Boolean value that indicates whether an expression contains no valid data (Null).</summary>
            <returns>
TRUE if rectangle's top, left, bottom, and right values are all equal to 0; otherwise FALSE.
</returns>
        </member>
        <member name="M:CD2DRectU.#ctor(System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
Constructs a CD2DRectU object from four UINT32 values.</summary>
            <param name="uLeft">source left coordinate</param>
            <param name="uTop">source top coordinate</param>
            <param name="uRight">source right coordinate</param>
            <param name="uBottom">source bottom coordinate</param>
        </member>
        <member name="M:CD2DRectU.#ctor(D2D_RECT_U!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DRectU object from D2D1_RECT_U object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="M:CD2DRectU.#ctor(D2D_RECT_U!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRectU object from D2D1_RECT_U object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="M:CD2DRectU.#ctor(CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRectU object from CRect object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="T:CD2DRectU">
            <summary>
D2D1_RECT_U wrapper
</summary>
        </member>
        <member name="M:CD2DRectF.op_Implicit~CRect">
            <summary>
Converts CD2DRectF to CRect object.</summary>
            <returns>
Current value of D2D rectangle.
</returns>
        </member>
        <member name="M:CD2DRectF.IsNull">
            <summary>
Returns a Boolean value that indicates whether an expression contains no valid data (Null).</summary>
            <returns>
TRUE if rectangle's top, left, bottom, and right values are all equal to 0; otherwise FALSE.
</returns>
        </member>
        <member name="M:CD2DRectF.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
Constructs a CD2DRectF object from four FLOAT values.</summary>
            <param name="fLeft">source left coordinate</param>
            <param name="fTop">source top coordinate</param>
            <param name="fRight">source right coordinate</param>
            <param name="fBottom">source bottom coordinate</param>
        </member>
        <member name="M:CD2DRectF.#ctor(D2D_RECT_F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DRectF object from D2D1_RECT_F object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="M:CD2DRectF.#ctor(D2D_RECT_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRectF object from D2D1_RECT_F object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="M:CD2DRectF.#ctor(CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DRectF object from CRect object.</summary>
            <param name="rect">source rectangle</param>
        </member>
        <member name="T:CD2DRectF">
            <summary>
D2D1_RECT_F wrapper
</summary>
        </member>
        <member name="M:CD2DSizeU.op_Implicit~CSize">
            <summary>
Converts CD2DSizeU to CSize object.</summary>
            <returns>
Current value of D2D size.
</returns>
        </member>
        <member name="M:CD2DSizeU.IsNull">
            <summary>
Returns a Boolean value that indicates whether an expression contains no valid data (Null).</summary>
            <returns>
TRUE if width and height are empty; otherwise FALSE.
</returns>
        </member>
        <member name="M:CD2DSizeU.#ctor(System.UInt32,System.UInt32)">
            <summary>
Constructs a CD2DSizeU object from two UINT32 values.</summary>
            <param name="cx">source width</param>
            <param name="cy">source height</param>
        </member>
        <member name="M:CD2DSizeU.#ctor(D2D_SIZE_U!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DSizeU object from D2D1_SIZE_U object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="M:CD2DSizeU.#ctor(D2D_SIZE_U!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DSizeU object from D2D1_SIZE_U object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="M:CD2DSizeU.#ctor(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DSizeU object from CSize object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="T:CD2DSizeU">
            <summary>
D2D1_SIZE_U wrapper
</summary>
        </member>
        <member name="M:CD2DSizeF.op_Implicit~CSize">
            <summary>
Converts CD2DSizeF to CSize object.</summary>
            <returns>
Current value of D2D size.
</returns>
        </member>
        <member name="M:CD2DSizeF.IsNull">
            <summary>
Returns a Boolean value that indicates whether an expression contains no valid data (Null).</summary>
            <returns>
TRUE if width and height are empty; otherwise FALSE.
</returns>
        </member>
        <member name="M:CD2DSizeF.#ctor(System.Single,System.Single)">
            <summary>
Constructs a CD2DSizeF object from two FLOAT values.</summary>
            <param name="cx">source width</param>
            <param name="cy">source height</param>
        </member>
        <member name="M:CD2DSizeF.#ctor(D2D_SIZE_F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DSizeF object from D2D1_SIZE_F object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="M:CD2DSizeF.#ctor(D2D_SIZE_F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DSizeF object from D2D1_SIZE_F object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="M:CD2DSizeF.#ctor(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DSizeF object from CSize object.</summary>
            <param name="size">source size</param>
        </member>
        <member name="T:CD2DSizeF">
            <summary>
D2D1_SIZE_F wrapper
</summary>
        </member>
        <member name="M:CD2DPointU.op_Implicit~CPoint">
            <summary>
Converts CD2DPointU to CPoint object.</summary>
            <returns>
Current value of D2D point.
</returns>
        </member>
        <member name="M:CD2DPointU.#ctor(System.UInt32,System.UInt32)">
            <summary>
Constructs a CD2DPointU object from two UINT32 values.</summary>
            <param name="uX">source X</param>
            <param name="uY">source Y</param>
        </member>
        <member name="M:CD2DPointU.#ctor(D2D_POINT_2U!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DPointU from object D2D1_POINT_2U object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="M:CD2DPointU.#ctor(D2D_POINT_2U!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DPointU from object D2D1_POINT_2U object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="M:CD2DPointU.#ctor(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DPointU object from CPoint object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="T:CD2DPointU">
            <summary>
D2D1_POINT_2U wrapper
</summary>
        </member>
        <member name="M:CD2DPointF.op_Implicit~CPoint">
            <summary>
Converts CD2DPointF to CPoint object.</summary>
            <returns>
Current value of D2D point.
</returns>
        </member>
        <member name="M:CD2DPointF.#ctor(System.Single,System.Single)">
            <summary>
Constructs a CD2DPointF object from two FLOAT values.</summary>
            <param name="fX">source X</param>
            <param name="fY">source Y</param>
        </member>
        <member name="M:CD2DPointF.#ctor(D2D_POINT_2F!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructs a CD2DPointF object from D2D1_POINT_2F object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="M:CD2DPointF.#ctor(D2D_POINT_2F!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DPointF object from D2D1_POINT_2F object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="M:CD2DPointF.#ctor(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Constructs a CD2DPointF object from CPoint object.</summary>
            <param name="pt">source point</param>
        </member>
        <member name="T:CD2DPointF">
            <summary>
D2D1_POINT_2F wrapper
</summary>
        </member>
        <member name="M:CCustomTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <remarks>
This method also can set initial value and initial velocity to be applied to an animation variable, which is
associated with this transition. For this purpose you have to call SetInitialValue and SetInitialVelocity before
the framework creates the encapsulated transition COM object (it happens when you call CAnimationController::AnimateGroup).
</remarks>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="M:CCustomTransition.SetInitialVelocity(System.Double)">
            <summary>
Sets an initial velocity, which will be applied to an animation variable associated with this transition.
</summary>
        </member>
        <member name="M:CCustomTransition.SetInitialValue(System.Double)">
            <summary>
Sets an initial value, which will be applied to an animation variable associated with this transition.
</summary>
        </member>
        <member name="M:CCustomTransition.#ctor(CCustomInterpolator*)">
            <summary>
Constructs a custom transition object.
</summary>
            <param name="pInterpolator">A pointer to custom interpolator.</param>
        </member>
        <member name="F:CCustomTransition.m_initialVelocity">
            <summary>
Stores the initial velocity.
</summary>
        </member>
        <member name="F:CCustomTransition.m_initialValue">
            <summary>
Stores the initial value.
</summary>
        </member>
        <member name="F:CCustomTransition.m_bInitialVelocitySpecified">
            <summary>
Specifies whether the initial velocity was specified with SetInitialVelocity.
</summary>
        </member>
        <member name="F:CCustomTransition.m_bInitialValueSpecified">
            <summary>
Specifies whether the initial value was specified with SetInitialValue.
</summary>
        </member>
        <member name="F:CCustomTransition.m_pInterpolator">
            <summary>
Stores a pointer to a custom interpolator.
</summary>
        </member>
        <member name="T:CCustomTransition">
            <summary>
Implements custom transition.
</summary>
            <remarks>
The CCustomTransitions class allows developers to implement custom transitions. It's created and used
as a standard transition, but its constructor accepts as parameter a pointer to a custom interpolator.
Perform the following steps to use custom transitions:
1. Derive a class from CCustomInterpolator and implement at least InterpolateValue method.
2. Ensure that the lifetime of custom interpolator object must be longer than duration of animation where it's used.
3. Instantiate (using operator new) a CCustomTransition object and pass a pointer to custom interpolator in the constructor.
4. Call CCustomTransition::SetInitialValue and CCustomTransition::SetInitialVelocity if these parameters are required for custom interpolation.
5. Pass the pointer to custom transition to AddTransition method of animation object, whose value should be animated with the custom algorithm.
6. When the value of animation object should change Windows Animation API will call InterpolateValue (and other relevant methods) in CCustomInterpolator.
</remarks>
        </member>
        <member name="M:CInterpolatorBase.GetDependencies(__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*,__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*,__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*)">
            <summary>
Gets the interpolator's dependencies.
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the GetDependencies method.
</returns>
            <param name="initialValueDependencies">Output. Aspects of the interpolator that depend on the initial value passed to SetInitialValueAndVelocity.</param>
            <param name="initialVelocityDependencies">Output. Aspects of the interpolator that depend on the initial velocity passed to SetInitialValueAndVelocity.</param>
            <param name="durationDependencies">Output. Aspects of the interpolator that depend on the duration passed to SetDuration.</param>
        </member>
        <member name="M:CInterpolatorBase.InterpolateVelocity(System.Double,System.Double*)">
            <summary>
Interpolates the velocity at a given offset
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the InterpolateVelocity method.
</returns>
            <param name="offset">The offset from the start of the transition.
The offset is always greater than or equal to zero and less than or equal to the duration of the transition.
This method is not called if the duration of the transition is zero. </param>
            <param name="velocity">Output. The velocity of the variable at the offset.</param>
        </member>
        <member name="M:CInterpolatorBase.InterpolateValue(System.Double,System.Double*)">
            <summary>
Interpolates the value at a given offset
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the InterpolateValue method.
</returns>
            <param name="offset">The offset from the start of the transition.
The offset is always greater than or equal to zero and less than the duration of the transition.
This method is not called if the duration of the transition is zero.</param>
            <param name="value">Output. The interpolated value.</param>
        </member>
        <member name="M:CInterpolatorBase.GetFinalValue(System.Double*)">
            <summary>
Gets the final value to which the interpolator leads.
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the GetFinalValue method.
</returns>
            <param name="value">Output. The final value of a variable at the end of the transition.</param>
        </member>
        <member name="M:CInterpolatorBase.GetDuration(System.Double*)">
            <summary>
Gets the interpolator's duration.
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the GetDuration method.
</returns>
            <param name="duration">Output. The duration of the transition, in seconds.</param>
        </member>
        <member name="M:CInterpolatorBase.SetDuration(System.Double)">
            <summary>
Sets the interpolator's duration
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the SetDuration method.
</returns>
            <param name="duration">The duration of the transition.</param>
        </member>
        <member name="M:CInterpolatorBase.SetInitialValueAndVelocity(System.Double,System.Double)">
            <summary>
Sets the interpolator's initial value and velocity.
</summary>
            <returns>
If the method succeeds, it returns S_OK. It returns E_FAIL if CCustomInterpolator is not
set, or custom implementation returns FALSE from the SetInitialValueAndVelocity method.
</returns>
            <param name="initialValue">The value of the variable at the start of the transition.</param>
            <param name="initialVelocity">The velocity of the variable at the start of the transition.</param>
        </member>
        <member name="M:CInterpolatorBase.CreateInstance(CCustomInterpolator*,IUIAnimationInterpolator**)">
            <summary>
Creates an instance of CInterpolatorBase and stores a pointer to custom interpolator, which will be handling events.
</summary>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
<param name="pInterpolator">A pointer to custom interpolator.</param><param name="ppHandler">Output. Contains a pointer to instance of CInterpolatorBase when the function returns.</param></member>
        <member name="M:CInterpolatorBase.SetCustomInterpolator(CCustomInterpolator*)">
            <summary>
Stores  a pointer to custom interpolator, which will be handling events.
</summary>
            <param name="pInterpolator">A pointer to custom interpolator.</param>
        </member>
        <member name="M:CInterpolatorBase.#ctor">
            <summary>
Constructs the CInterpolatorBase object.
</summary>
        </member>
        <member name="T:CInterpolatorBase">
            <summary>
Implements a callback, which is called by Animation API when it needs to calculate a new value of animation variable.
</summary>
            <remarks>
This handler is created and passed to IUIAnimationTransitionFactory::CreateTransition when a CCustomTransition
object is being created as a part of animation initialization process (started by CAnimationController::AnimateGroup).
Usually you don't need to use this class directly, it just routs all events to a CCustomInterpolator-derived class, whose
pointer is passed to constructor of CCustomTransition.
</remarks>
        </member>
        <member name="M:CCustomInterpolator.GetDependencies(__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*,__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*,__MIDL___MIDL_itf_UIAnimation_0000_0010_0001*)">
            <summary>
Gets the interpolator's dependencies.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="initialValueDependencies">Output. Aspects of the interpolator that depend on the initial value passed to SetInitialValueAndVelocity.</param>
            <param name="initialVelocityDependencies">Output. Aspects of the interpolator that depend on the initial velocity passed to SetInitialValueAndVelocity.</param>
            <param name="durationDependencies">Output. Aspects of the interpolator that depend on the duration passed to SetDuration.</param>
        </member>
        <member name="M:CCustomInterpolator.InterpolateVelocity(System.Double,System.Double*)">
            <summary>
Interpolates the velocity at a given offset
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="offset">The offset from the start of the transition.
The offset is always greater than or equal to zero and less than or equal to the duration of the transition.
This method is not called if the duration of the transition is zero. </param>
            <param name="velocity">Output. The velocity of the variable at the offset.</param>
        </member>
        <member name="M:CCustomInterpolator.InterpolateValue(System.Double,System.Double*)">
            <summary>
Interpolates the value at a given offset.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="offset">The offset from the start of the transition.
The offset is always greater than or equal to zero and less than the duration of the transition.
This method is not called if the duration of the transition is zero.</param>
            <param name="value">Output. The interpolated value.</param>
        </member>
        <member name="M:CCustomInterpolator.GetFinalValue(System.Double*)">
            <summary>
Gets the final value to which the interpolator leads.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="value">Output. The final value of a variable at the end of the transition.</param>
        </member>
        <member name="M:CCustomInterpolator.GetDuration(System.Double*)">
            <summary>
Gets the interpolator's duration.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="duration">Output. The duration of the transition, in seconds.</param>
        </member>
        <member name="M:CCustomInterpolator.SetDuration(System.Double)">
            <summary>
Sets the interpolator's duration.
</summary>
            <returns>
Basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="duration">The duration of the transition.</param>
        </member>
        <member name="M:CCustomInterpolator.SetInitialValueAndVelocity(System.Double,System.Double)">
            <summary>
Sets the interpolator's initial value and velocity.
</summary>
            <returns>
The basic implementation always returns TRUE. Return FALSE from overridden implementation if you wish to fail the event.
</returns>
            <param name="initialValue">The value of the variable at the start of the transition.</param>
            <param name="initialVelocity">The velocity of the variable at the start of the transition.</param>
        </member>
        <member name="M:CCustomInterpolator.Init(System.Double,System.Double)">
            <summary>
Initializes duration and final value.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="finalValue">The final value of a variable at the end of the transition.</param>
        </member>
        <member name="M:CCustomInterpolator.#ctor(System.Double,System.Double)">
            <summary>
Constructs a custom interpolator object and initializes duration and velocity to specified values.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="finalValue" />
        </member>
        <member name="M:CCustomInterpolator.#ctor">
            <summary>
Constructs a custom interpolator object and sets all values to default 0.
</summary>
            <remarks>
Use CCustomInterpolator::Init to initialize duration and final value later in the code.
</remarks>
        </member>
        <member name="F:CCustomInterpolator.m_currentVelocity">
            <summary>
The interpolated velocity.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_currentValue">
            <summary>
The interpolated value.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_initialVelocity">
            <summary>
The velocity of the variable at the start of the transition.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_initialValue">
            <summary>
The value of the variable at the start of the transition.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_finalValue">
            <summary>
The final value of a variable at the end of the transition.
</summary>
        </member>
        <member name="F:CCustomInterpolator.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="T:CCustomInterpolator">
            <summary>
Implements a basic interpolator.
</summary>
            <remarks>
Derive a class from CCustomInterpolator and override all necessary methods in order to implement a custom
interpolation algorithm. A pointer to this class should be passed as a parameter to CCustomTransition.
</remarks>
        </member>
        <member name="M:CSinusoidalTransitionFromVelocity.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CSinusoidalTransitionFromVelocity.m_period">
            <summary>
The period of oscillation of the sinusoidal wave in seconds.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromVelocity.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CSinusoidalTransitionFromVelocity.#ctor(System.Double,System.Double)">
            <summary>
Constructs a transition object.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="period">The period of oscillation of the sinusoidal wave in seconds. </param>
        </member>
        <member name="T:CSinusoidalTransitionFromVelocity">
            <summary>
Encapsulates a sinusoidal-velocity transition, with an amplitude determined by the animation variable's initial velocity..
</summary>
            <remarks>
The value of the animation variable oscillates around the initial value over the entire duration of a
sinusoidal-range transition. The amplitude of the oscillation is determined by the animation variable's velocity
when the transition begins.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CSinusoidalTransitionFromRange.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_slope">
            <summary>
The slope at the start of the transition.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_period">
            <summary>
The period of oscillation of the sinusoidal wave in seconds.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_dblMaximumValue">
            <summary>
The value of the animation variable at a peak of the sinusoidal wave.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_dblMinimumValue">
            <summary>
The value of the animation variable at a trough of the sinusoidal wave.
</summary>
        </member>
        <member name="F:CSinusoidalTransitionFromRange.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CSinusoidalTransitionFromRange.#ctor(System.Double,System.Double,System.Double,System.Double,__MIDL___MIDL_itf_UIAnimation_0000_0009_0001)">
            <summary>
Constructs a transition object.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="dblMinimumValue">The value of the animation variable at a trough of the sinusoidal wave.</param>
            <param name="dblMaximumValue">The value of the animation variable at a peak of the sinusoidal wave.</param>
            <param name="period">The period of oscillation of the sinusoidal wave in seconds. </param>
            <param name="slope">The slope at the start of the transition. </param>
        </member>
        <member name="T:CSinusoidalTransitionFromRange">
            <summary>
Encapsulates a sinusoidal-range transition, with a given range of oscillation.
</summary>
            <remarks>
The value of the animation variable fluctuates between the specified minimum and maximum values over the entire
duration of a sinusoidal-range transition. The slope parameter is used to disambiguate between the two possible
sine waves specified by the other parameters.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CReversalTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CReversalTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CReversalTransition.#ctor(System.Double)">
            <summary>
Constructs a reversal transition object and initializes its duration.
</summary>
            <param name="duration">The duration of the transition. </param>
        </member>
        <member name="T:CReversalTransition">
            <summary>
Encapsulates a reversal transition.
</summary>
            <remarks>
A reversal transition smoothly changes direction over a given duration.
The final value will be the same as the initial value and the final velocity will be the negative of the initial velocity.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CParabolicTransitionFromAcceleration.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CParabolicTransitionFromAcceleration.m_dblAcceleration">
            <summary>
The acceleration of the animation variable during the transition.
</summary>
        </member>
        <member name="F:CParabolicTransitionFromAcceleration.m_dblFinalVelocity">
            <summary>
The velocity of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CParabolicTransitionFromAcceleration.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="M:CParabolicTransitionFromAcceleration.#ctor(System.Double,System.Double,System.Double)">
            <summary>
Constructs a parabolic-acceleration transition and initializes it with specified parameters.
</summary>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition. </param>
            <param name="dblFinalVelocity">The velocity of the animation variable at the end of the transition. </param>
            <param name="dblAcceleration">The acceleration of the animation variable during the transition.</param>
        </member>
        <member name="T:CParabolicTransitionFromAcceleration">
            <summary>
Encapsulates a parabolic-acceleration transition.
</summary>
            <remarks>
During a parabolic-acceleration transition, the value of the animation variable changes from the initial value
to the final value ending at a specified velocity. You can control how quickly the variable reaches the final
value by specifying the rate of acceleration.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CSmoothStopTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CSmoothStopTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CSmoothStopTransition.m_maximumDuration">
            <summary>
The maximum duration of the transition.
</summary>
        </member>
        <member name="M:CSmoothStopTransition.#ctor(System.Double,System.Double)">
            <summary>
Constructs a smooth-stop transition and initializes its maximum duration and final value.
</summary>
            <param name="maximumDuration">The maximum duration of the transition.</param>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition.</param>
        </member>
        <member name="T:CSmoothStopTransition">
            <summary>
Encapsulates a smooth-stop transition.
</summary>
            <remarks>
A smooth-stop transition slows down as it approaches a given final value, and reaches it with a velocity of zero.
The duration of the transition is determined by the initial velocity, the difference between the initial and final values,
and the specified maximum duration. If there is no solution consisting of a single parabolic arc,
this method creates a cubic transition.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CLinearTransitionFromSpeed.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CLinearTransitionFromSpeed.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CLinearTransitionFromSpeed.m_dblSpeed">
            <summary>
The absolute value of the variable's velocity.
</summary>
        </member>
        <member name="M:CLinearTransitionFromSpeed.#ctor(System.Double,System.Double)">
            <summary>
Constructs a linear-speed transition object and initializes it with speed and final value.
</summary>
            <param name="dblSpeed">The absolute value of the variable's velocity.</param>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition.</param>
        </member>
        <member name="T:CLinearTransitionFromSpeed">
            <summary>
Encapsulates a linear-speed transition.
</summary>
            <remarks>
During a linear-speed transition, the value of the animation variable changes at a specified rate.
The duration of the transition is determined by the difference between the initial value and the specified final value.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CLinearTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CLinearTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CLinearTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CLinearTransition.#ctor(System.Double,System.Double)">
            <summary>
Constructs a linear transition object and initializes it with duration and final value.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition.</param>
        </member>
        <member name="T:CLinearTransition">
            <summary>
Encapsulates a linear transition.
</summary>
            <remarks>
During a linear transition, the value of the animation variable transitions linearly from its initial value to a specified final value.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CInstantaneousTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CInstantaneousTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="M:CInstantaneousTransition.#ctor(System.Double)">
            <summary>
Constructs a transition object and initializes its final value.
</summary>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition.</param>
        </member>
        <member name="T:CInstantaneousTransition">
            <summary>
Encapsulates an instantaneous transition.
</summary>
            <remarks>
During an instantaneous transition, the value of the animation variable changes instantly from its current
value to a specified final value. The duration of this transition is always zero.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CDiscreteTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CDiscreteTransition.m_hold">
            <summary>
The amount of time by which to hold the variable at its final value.
</summary>
        </member>
        <member name="F:CDiscreteTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CDiscreteTransition.m_delay">
            <summary>
The amount of time by which to delay the instantaneous switch to the final value.
</summary>
        </member>
        <member name="M:CDiscreteTransition.#ctor(System.Double,System.Double,System.Double)">
            <summary>
Constructs a discrete transition object and initializes its parameters.
</summary>
            <param name="delay">The amount of time by which to delay the instantaneous switch to the final value.</param>
            <param name="dblFinalValue">The value of the animation variable at the end of the transition. </param>
            <param name="hold">The amount of time by which to hold the variable at its final value.</param>
        </member>
        <member name="T:CDiscreteTransition">
            <summary>
Encapsulates a discrete transition.
</summary>
            <remarks>
During a discrete transition, the animation variable remains at the initial value for a specified delay time,
then switches instantaneously to a specified final value and remains at that value for a given hold time.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CCubicTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CCubicTransition.m_dblFinalVelocity">
            <summary>
The velocity of the variable at the end of the transition.
</summary>
        </member>
        <member name="F:CCubicTransition.m_dblFinalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CCubicTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CCubicTransition.#ctor(System.Double,System.Double,System.Double)">
            <summary>
Constructs a transition object and initializes its parameters.
</summary>
            <param name="duration">The duration of the transition.</param>
            <param name="finalValue">The value of the animation variable at the end of the transition.</param>
            <param name="finalVelocity">The velocity of the variable at the end of the transition.</param>
        </member>
        <member name="T:CCubicTransition">
            <summary>
Encapsulates a cubic transition.
</summary>
            <remarks>
During a cubic transition, the value of the animation variable changes from its initial value to a specified
final value over the duration of the transition, ending at a specified velocity.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CConstantTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CConstantTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CConstantTransition.#ctor(System.Double)">
            <summary>
Constructs a transition object and initializes its duration.
</summary>
            <param name="duration">The duration of the transition. </param>
        </member>
        <member name="T:CConstantTransition">
            <summary>
Encapsulates a constant transition.
</summary>
            <remarks>
During a constant transition, the value of an animation variable remains at the initial value over the duration
of the transition.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CAccelerateDecelerateTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Calls the transition library to create encapsulated transition COM object.
</summary>
            <returns>
TRUE if transition is created successfully; otherwise FALSE.
</returns>
            <param name="pLibrary">A pointer to transition library, which is responsible for creation of standard transitions.</param>
            <param name="pFactory">A pointer to transition factory, which is responsible for creation of custom transitions.</param>
        </member>
        <member name="F:CAccelerateDecelerateTransition.m_decelerationRatio">
            <summary>
The ratio of the time spent decelerating to the duration.
</summary>
        </member>
        <member name="F:CAccelerateDecelerateTransition.m_accelerationRatio">
            <summary>
The ratio of the time spent accelerating to the duration.
</summary>
        </member>
        <member name="F:CAccelerateDecelerateTransition.m_finalValue">
            <summary>
The value of the animation variable at the end of the transition.
</summary>
        </member>
        <member name="F:CAccelerateDecelerateTransition.m_duration">
            <summary>
The duration of the transition.
</summary>
        </member>
        <member name="M:CAccelerateDecelerateTransition.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
Constructs a transition object.
</summary>
            <param name="duration">The duration of the transition. </param>
            <param name="finalValue">The value of the animation variable at the end of the transition. </param>
            <param name="accelerationRatio">The ratio of the time spent accelerating to the duration.</param>
            <param name="decelerationRatio">The ratio of the time spent decelerating to the duration. </param>
        </member>
        <member name="T:CAccelerateDecelerateTransition">
            <summary>
Implements an accelerate-decelerate transition.
</summary>
            <remarks>
During an accelerate-decelerate transition, the animation variable speeds up and then slows down over the
duration of the transition, ending at a specified value. You can control how quickly the variable accelerates and
decelerates independently, by specifying different acceleration and deceleration ratios.
When the initial velocity is zero, the acceleration ratio is the fraction of the duration that the variable will
spend accelerating; likewise with the deceleration ratio. If the initial velocity is non-zero, it is the
fraction of the time between the velocity reaching zero and the end of transition. The acceleration ratio and
the deceleration ratio should sum to a maximum of 1.0.
Because all transitions are cleared automatically, it's recommended to allocated them using operator new.
The encapsulated IUIAnimationTransition COM object is created by CAnimationController::AnimateGroup, until then
it's NULL. Changing member variables after creation of this COM object has no effect.
</remarks>
        </member>
        <member name="M:CAnimationTimerEventHandler.OnRenderingTooSlow(System.UInt32)">
            <summary>
Handles events that occur when the rendering frame rate for an animation falls below the minimum desirable frame rate.
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
        </member>
        <member name="M:CAnimationTimerEventHandler.OnPostUpdate">
            <summary>
Handles events that occur after an animation update is finished.
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
        </member>
        <member name="M:CAnimationTimerEventHandler.OnPreUpdate">
            <summary>
Handles events that occur before an animation update begins.
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
        </member>
        <member name="M:CAnimationTimerEventHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationTimerEventHandler.CreateInstance(CAnimationController*,IUIAnimationTimerEventHandler**)">
            <summary>
Creates an instance of CAnimationTimerEventHandler callback.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppTimerEventHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
animation timer events.</param>
        </member>
        <member name="T:CAnimationTimerEventHandler">
            <summary>
Implements a call back, which is called by Animation API when timing events occur.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationTimer::SetTimerEventHandler when you call
CAnimationController::EnableAnimationTimerEventHandler.
</remarks>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.OnStoryboardUpdated(IUIAnimationStoryboard*)">
            <summary>
Handles OnStoryboardUpdated events, which occur when a storyboard is updated
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
            <param name="storyboard">A pointer to storyboard, which was updated.</param>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.OnStoryboardStatusChanged(IUIAnimationStoryboard*,__MIDL___MIDL_itf_UIAnimation_0000_0002_0001,__MIDL___MIDL_itf_UIAnimation_0000_0002_0001)">
            <summary>
Handles OnStoryboardStatusChanged events, which occur when a storyboard's status changes
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
            <param name="storyboard">A pointer to storyboard whose status has changed.</param>
            <param name="newStatus">Specifies new storyboard status.</param>
            <param name="previousStatus">Specifies previous storyboard status.</param>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.CreateInstance(CAnimationController*,IUIAnimationStoryboardEventHandler**)">
            <summary>
Creates an instance of CAnimationStoryboardEventHandler callback.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
storyboard events.</param>
        </member>
        <member name="M:CAnimationStoryboardEventHandler.#ctor">
            <summary>
Constructs a CAnimationStoryboardEventHandler object.
</summary>
        </member>
        <member name="T:CAnimationStoryboardEventHandler">
            <summary>
Implements a callback, which is called by Animation API when storyboard's status is changed or storyboard is updated.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationStoryboard::SetStoryboardEventHandler method,
when you call CAnimationController::EnableStoryboardEventHandler.
</remarks>
        </member>
        <member name="M:CAnimationVariableIntegerChangeHandler.OnIntegerValueChanged(IUIAnimationStoryboard*,IUIAnimationVariable*,System.Int32,System.Int32)">
            <summary>
Called when a value of an animation variable has changed.
</summary>
            <returns>
S_OK if the method succeeds; otherwise E_FAIL.
</returns>
            <param name="storyboard">The storyboard that is animating the variable.</param>
            <param name="variable">The animation variable that was updated.</param>
            <param name="newValue">The new rounded value.</param>
            <param name="previousValue">The previous rounded value.</param>
        </member>
        <member name="M:CAnimationVariableIntegerChangeHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationVariableIntegerChangeHandler.CreateInstance(CAnimationController*,IUIAnimationVariableIntegerChangeHandler**)">
            <summary>
Creates an instance of CAnimationVariableIntegerChangeHandler callback.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
variable integer change events.</param>
        </member>
        <member name="M:CAnimationVariableIntegerChangeHandler.#ctor">
            <summary>
Constructs a CAnimationVariableIntegerChangeHandler object.
</summary>
        </member>
        <member name="T:CAnimationVariableIntegerChangeHandler">
            <summary>
Implements a call back, which is called by Animation API when the value of an animation variable changes.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationVariable::SetVariableIntegerChangeHandler method,
when you call CAnimationVariable::EnableIntegerValueChangedEvent or CAnimationBaseObject::EnableIntegerValueChangedEvent
(which enables this event for all animation variables encapsulated in an animation object).
</remarks>
        </member>
        <member name="M:CAnimationVariableChangeHandler.OnValueChanged(IUIAnimationStoryboard*,IUIAnimationVariable*,System.Double,System.Double)">
            <summary>
Called when a value of an animation variable has changed.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="storyboard">The storyboard that is animating the variable.</param>
            <param name="variable">The animation variable that was updated.</param>
            <param name="newValue">The new value.</param>
            <param name="previousValue">The previous value.</param>
        </member>
        <member name="M:CAnimationVariableChangeHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationVariableChangeHandler.CreateInstance(CAnimationController*,IUIAnimationVariableChangeHandler**)">
            <summary>
Creates an instance of CAnimationVariableChangeHandler object.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
variable change events.</param>
        </member>
        <member name="M:CAnimationVariableChangeHandler.#ctor">
            <summary>
Constructs a CAnimationVariableChangeHandler object.
</summary>
        </member>
        <member name="T:CAnimationVariableChangeHandler">
            <summary>
Implements a call back, which is called by Animation API when the value of an animation variable changes.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationVariable::SetVariableChangeHandler method,
when you call CAnimationVariable::EnableValueChangedEvent or CAnimationBaseObject::EnableValueChangedEvent
(which enables this event for all animation variables encapsulated in an animation object).
</remarks>
        </member>
        <member name="M:CAnimationManagerEventHandler.OnManagerStatusChanged(__MIDL___MIDL_itf_UIAnimation_0000_0000_0002,__MIDL___MIDL_itf_UIAnimation_0000_0000_0002)">
            <summary>
Called when a status of animation manager has changed.
</summary>
            <returns>
Current implementation always returns S_OK;
</returns>
            <param name="newStatus">New status.</param>
            <param name="previousStatus">Previous status.</param>
        </member>
        <member name="M:CAnimationManagerEventHandler.SetAnimationController(CAnimationController*)">
            <summary>
Stores a pointer to animation controller to route events.
</summary>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
        </member>
        <member name="M:CAnimationManagerEventHandler.CreateInstance(CAnimationController*,IUIAnimationManagerEventHandler**)">
            <summary>
Creates an instance of CAnimationManagerEventHandler object.
</summary>
            <returns>
If the method succeeds, it returns S_OK. Otherwise, it returns an HRESULT error code.
</returns>
            <param name="pAnimationController">A pointer to animation controller, which will receive events.</param>
            <param name="ppManagerEventHandler">Output. If the method succeeds it contains a pointer to COM object that will handle
status updates to an animation manager.</param>
        </member>
        <member name="M:CAnimationManagerEventHandler.#ctor">
            <summary>
Constructs a CAnimationManagerEventHandler object.
</summary>
        </member>
        <member name="T:CAnimationManagerEventHandler">
            <summary>
Implements a callback, which is called by Animation API when a status of animation manager changed.
</summary>
            <remarks>
This event handler is created and passed to IUIAnimationManager::SetManagerEventHandler method,
when you call CAnimationController::EnableAnimationManagerEvent.
</remarks>
        </member>
        <member name="M:CAnimationController.CleanUpGroup(CAnimationGroup*)">
            <summary>
A helper that cleans up the group.
</summary>
            <remarks>
This method removes all transitions and keyframes from the specified group.
</remarks>
            <param name="pGroup">A pointer to animation group to clean.</param>
        </member>
        <member name="M:CAnimationController.OnAfterSchedule(CAnimationGroup*)">
            <summary>
Called by the framework when an animation for the specified group has just been scheduled.
</summary>
            <remarks>
The default implementation removes keyframes from the specified group and transitions from animation variables that
belong to the specified group. Can be overridden in a derived class to take any additional actions upon animation schedule.
</remarks>
            <param name="pGroup">A pointer to an animation group, which has been scheduled.</param>
        </member>
        <member name="M:CAnimationController.OnAnimationTimerRenderingTooSlow(System.UInt32)">
            <summary>
Called by the framework when the rendering frame rate for an animation falls below a minimum desirable frame rate.
</summary>
            <remarks>
This method is called if you enable timer event handlers using EnableAnimationTimerEventHandler.
It can be overridden in a derived class to take application-specific actions.
The minimum desirable frame rate is specified by calling IUIAnimationTimer::SetFrameRateThreshold.
</remarks>
            <param name="fps">The current frame rate in frames per second. </param>
        </member>
        <member name="M:CAnimationController.OnAnimationTimerPostUpdate">
            <summary>
Called by the framework after an animation update is finished.
</summary>
            <remarks>
This method is called if you enable timer event handlers using EnableAnimationTimerEventHandler.
It can be overridden in a derived class to take application-specific actions.
</remarks>
        </member>
        <member name="M:CAnimationController.OnAnimationTimerPreUpdate">
            <summary>
Called by the framework before an animation update begins.
</summary>
            <remarks>
This method is called if you enable timer event handlers using EnableAnimationTimerEventHandler.
It can be overridden in a derived class to take application-specific actions.
</remarks>
        </member>
        <member name="M:CAnimationController.OnHasPriorityCompress(CAnimationGroup*,CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0008_0001)">
            <summary>
Called by the framework to resolve scheduling conflicts.
</summary>
            <returns>
Should return TRUE if storyboard owned by pGroupNew has priority. Should return FALSE if storyboard owned by
pGroupScheduled has priority.
</returns>
            <remarks>
This method is called if you enable priority comparison events using CAnimationController::EnablePriorityComparisonHandler
and specify UI_ANIMATION_PHT_COMPRESS.
It can be overridden in a derived class to take application-specific actions.
Read Windows Animation API documentation for more information about Conflict Management (http://msdn.microsoft.com/en-us/library/dd371759(VS.85).aspx).
</remarks>
            <param name="pGroupScheduled">The group that owns the currently scheduled storyboard.</param>
            <param name="pGroupNew">The group that owns the new storyboard that is in scheduling conflict with the scheduled storyboard owned by pGroupScheduled.</param>
            <param name="priorityEffect">The potential effect on pGroupNew if pGroupScheduled has a higher priority.</param>
        </member>
        <member name="M:CAnimationController.OnHasPriorityTrim(CAnimationGroup*,CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0008_0001)">
            <summary>
Called by the framework to resolve scheduling conflicts.
</summary>
            <returns>
Should return TRUE if storyboard owned by pGroupNew has priority. Should return FALSE if storyboard owned by
pGroupScheduled has priority.
</returns>
            <remarks>
This method is called if you enable priority comparison events using CAnimationController::EnablePriorityComparisonHandler
and specify UI_ANIMATION_PHT_TRIM.
It can be overridden in a derived class to take application-specific actions.
Read Windows Animation API documentation for more information about Conflict Management (http://msdn.microsoft.com/en-us/library/dd371759(VS.85).aspx).
</remarks>
            <param name="pGroupScheduled">The group that owns the currently scheduled storyboard.</param>
            <param name="pGroupNew">The group that owns the new storyboard that is in scheduling conflict with the scheduled storyboard owned by pGroupScheduled.</param>
            <param name="priorityEffect">The potential effect on pGroupNew if pGroupScheduled has a higher priority.</param>
        </member>
        <member name="M:CAnimationController.OnHasPriorityConclude(CAnimationGroup*,CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0008_0001)">
            <summary>
Called by the framework to resolve scheduling conflicts.
</summary>
            <returns>
Should return TRUE if storyboard owned by pGroupNew has priority. Should return FALSE if storyboard owned by
pGroupScheduled has priority.
</returns>
            <remarks>
This method is called if you enable priority comparison events using CAnimationController::EnablePriorityComparisonHandler
and specify UI_ANIMATION_PHT_CONCLUDE.
It can be overridden in a derived class to take application-specific actions.
Read Windows Animation API documentation for more information about Conflict Management (http://msdn.microsoft.com/en-us/library/dd371759(VS.85).aspx).
</remarks>
            <param name="pGroupScheduled">The group that owns the currently scheduled storyboard.</param>
            <param name="pGroupNew">The group that owns the new storyboard that is in scheduling conflict with the scheduled storyboard owned by pGroupScheduled.</param>
            <param name="priorityEffect">The potential effect on pGroupNew if pGroupScheduled has a higher priority.</param>
        </member>
        <member name="M:CAnimationController.OnHasPriorityCancel(CAnimationGroup*,CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0008_0001)">
            <summary>
Called by the framework to resolve scheduling conflicts.
</summary>
            <returns>
Should return TRUE if storyboard owned by pGroupNew has priority. Should return FALSE if storyboard owned by
pGroupScheduled has priority.
</returns>
            <remarks>
This method is called if you enable priority comparison events using CAnimationController::EnablePriorityComparisonHandler
and specify UI_ANIMATION_PHT_CANCEL.
It can be overridden in a derived class to take application-specific actions.
Read Windows Animation API documentation for more information about Conflict Management (http://msdn.microsoft.com/en-us/library/dd371759(VS.85).aspx).
</remarks>
            <param name="pGroupScheduled">The group that owns the currently scheduled storyboard.</param>
            <param name="pGroupNew">The group that owns the new storyboard that is in scheduling conflict with the scheduled storyboard owned by pGroupScheduled.</param>
            <param name="priorityEffect">The potential effect on pGroupNew if pGroupScheduled has a higher priority.</param>
        </member>
        <member name="M:CAnimationController.OnStoryboardUpdated(CAnimationGroup*)">
            <summary>
Called by the framework when storyboard has been updated.
</summary>
            <remarks>
This method is called if you enable storyboard events using CAnimationController::EnableStoryboardEventHandler.
It can be overridden in a derived class to take application-specific actions.
</remarks>
            <param name="pGroup">A pointer to a group that owns the storyboard.</param>
        </member>
        <member name="M:CAnimationController.OnStoryboardStatusChanged(CAnimationGroup*,__MIDL___MIDL_itf_UIAnimation_0000_0002_0001,__MIDL___MIDL_itf_UIAnimation_0000_0002_0001)">
            <summary>
Called by the framework when storyboard status has changed.
</summary>
            <remarks>
This method is called if you enable storyboard events using CAnimationController::EnableStoryboardEventHandler.
It can be overridden in a derived class to take application-specific actions.
</remarks>
            <param name="pGroup">A pointer to an animation group that owns the storyboard whose status has changed.</param>
            <param name="newStatus">Specifies the new status.</param>
            <param name="previousStatus">Specifies the previous status.</param>
        </member>
        <member name="M:CAnimationController.OnAnimationIntegerValueChanged(CAnimationGroup*,CAnimationBaseObject*,IUIAnimationVariable*,System.Int32,System.Int32)">
            <summary>
Called by the framework when integer value of animation variable has changed.
</summary>
            <remarks>
This method is called if you enable animation variable events with EnableIntegerValueChangedEvent called for a specific
animation variable or animation object.
It can be overridden in a derived class to take application-specific actions.
</remarks>
            <param name="pGroup">A pointer to an animation group that holds an animation object whose value has changed.</param>
            <param name="pObject">A pointer to an animation object that contains an animation variable whose value has changed.</param>
            <param name="variable">A pointer to an animation variable.</param>
            <param name="newValue">Specifies new value.</param>
            <param name="prevValue">Specifies previous value.</param>
        </member>
        <member name="M:CAnimationController.OnAnimationValueChanged(CAnimationGroup*,CAnimationBaseObject*,IUIAnimationVariable*,System.Double,System.Double)">
            <summary>
Called by the framework when value of animation variable has changed.
</summary>
            <remarks>
This method is called if you enable animation variable events with EnableValueChangedEvent called for a specific
animation variable or animation object.
It can be overridden in a derived class to take application-specific actions.
</remarks>
            <param name="pGroup">A pointer to an animation group that holds an animation object whose value has changed.</param>
            <param name="pObject">A pointer to an animation object that contains an animation variable whose value has changed.</param>
            <param name="variable">A pointer to an animation variable.</param>
            <param name="newValue">Specifies new value.</param>
            <param name="prevValue">Specifies previous value.</param>
        </member>
        <member name="M:CAnimationController.OnAnimationManagerStatusChanged(__MIDL___MIDL_itf_UIAnimation_0000_0000_0002,__MIDL___MIDL_itf_UIAnimation_0000_0000_0002)">
            <summary>
Called by the framework in response to StatusChanged event from animation manager.
</summary>
            <remarks>
This method is called if you enable animation manager events with EnableAnimationManagerEvent.
It can be overridden in a derived class to take application-specific actions. The default implementation
updates a related window if it has been set with SetRelatedWnd.
</remarks>
            <param name="newStatus">New animation manager status.</param>
            <param name="previousStatus">Previous animation manager status.</param>
        </member>
        <member name="M:CAnimationController.OnBeforeAnimationStart(CAnimationGroup*)">
            <summary>
Called by the framework right before the animation is scheduled.
</summary>
            <remarks>
This call is routed to related CWnd and can be overridden in a derived class to perform any
additional actions before the animation starts for the specified group.
</remarks>
            <param name="pGroup">A pointer to an animation group whose animation is about to start.</param>
        </member>
        <member name="M:CAnimationController.CleanUpGroup(System.UInt32)">
            <summary>
Called by the framework to clean up the group when animation has been scheduled.
</summary>
            <remarks>
This method removes all transitions and keyframes from the specified group, because they are not relevant
after an animation has been scheduled.
</remarks>
            <param name="nGroupID">Specifies GroupID.</param>
        </member>
        <member name="M:CAnimationController.ScheduleGroup(System.UInt32,System.Double)">
            <summary>
Schedules an animation.
</summary>
            <returns>
TRUE if animation was scheduled successfully. FALSE if storyboard has not been created, or other error occurs.
</returns>
            <remarks>
You must call AnimateGroup with parameter bScheduleNow set to FALSE prior ScheduleGroup. You can specify the
desired animation time obtained from IUIAnimationTimer::GetTime. If the time parameter is 0.0, the animation is scheduled for the
current time.
</remarks>
            <param name="nGroupID">Specifies animation Group ID to schedule.</param>
            <param name="time">Specifies time to schedule.</param>
        </member>
        <member name="M:CAnimationController.AnimateGroup(System.UInt32,System.Int32)">
            <summary>
Prepares a group to run animation and optionally schedules it.
</summary>
            <returns>
TRUE if animation was successfully scheduled and run.
</returns>
            <remarks>
This method does the actual work creating storyboard, adding animation variables, applying transitions and setting keyframes.
It's possible to delay scheduling if you set bScheduleNow to FALSE. In this case the specified group
will hold a storyboard that has been set up for animation. At that point you can setup events for the storyboard and
animation variables. When you actually need to run the animation call CAnimationController::ScheduleGroup.
</remarks>
            <param name="nGroupID">Specifies GroupID.</param>
            <param name="bScheduleNow">Specifies whether to run animation right away.</param>
        </member>
        <member name="M:CAnimationController.FindAnimationObject(IUIAnimationVariable*,CAnimationBaseObject**,CAnimationGroup**)">
            <summary>
Finds animation object containing a specified animation variable.
</summary>
            <returns>
TRUE if object was found; otherwise FALSE.
</returns>
            <remarks>
Called from event handlers when it's required to find an animation object from incoming animation variable.
</remarks>
            <param name="pVariable">A pointer to animation variable.</param>
            <param name="ppObject">Output. Contains a pointer to animation object or NULL. </param>
            <param name="ppGroup">Output. Contains a pointer to animation group that holds the animation object, or NULL.</param>
        </member>
        <member name="M:CAnimationController.FindAnimationGroup(IUIAnimationStoryboard*)">
            <summary>
Finds an animation group by its storyboard.
</summary>
            <returns>
A pointer to animation group if succeeds, or NULL if no group plays the specified storyboard.
</returns>
            <remarks>
This method is usually called from event handlers to find a group by pointer to storyboard that comes as a parameter to an event handler.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
        </member>
        <member name="M:CAnimationController.FindAnimationGroup(System.UInt32)">
            <summary>
Finds an animation group by its Group ID.
</summary>
            <returns>
A pointer to animation group or NULL if the group with specified ID is not found.
</returns>
            <remarks>
Use this method to find an animation group at runtime. A group is created and added to the internal list of animation groups
when a first animation object with particular GroupID is being added to animation controller.
</remarks>
            <param name="nGroupID">Specifies a GroupID.</param>
        </member>
        <member name="M:CAnimationController.AddKeyframeToGroup(System.UInt32,CBaseKeyFrame*)">
            <summary>
Adds a keyframe to group.
</summary>
            <returns>
TRUE if the function succeeds; otherwise FALSE.
</returns>
            <remarks>
Usually you don't need to call this method, use CAnimationController::CreateKeyframe instead, which creates
and adds the created keyframe to a group automatically.
</remarks>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="pKeyframe">A pointer to a keyframe.</param>
        </member>
        <member name="M:CAnimationController.CreateKeyframe(System.UInt32,CBaseKeyFrame*,System.Double)">
            <summary>
Creates a keyframe that depends on other keyframe with optional offset in seconds and adds it to the specified group.
</summary>
            <returns>
A pointer to newly created keyframe if the function succeeds.
</returns>
            <remarks>
You can store the returned pointer and base other keyframes on the newly created keyframe (see the second overload).
It's possible to begin transitions at keyframes - see CBaseTransition::SetKeyframes.
You don't need to delete keyframes created in this way, because they are deleted automatically by animation groups.
Be careful when creating keyframes based on other keyframes and transitions and avoid circular references.
</remarks>
            <param name="nGroupID">Specifies Group ID for which keyframe is created.</param>
            <param name="pKeyframe">A  pointer to base keyframe for this keyframe.</param>
            <param name="offset">Offset in seconds from the base keyframe specified by pKeyframe.</param>
        </member>
        <member name="M:CAnimationController.CreateKeyframe(System.UInt32,CBaseTransition*)">
            <summary>
Creates a keyframe that depends on transition and adds it to the specified group.
</summary>
            <returns>
A pointer to newly created keyframe if the function succeeds.
</returns>
            <remarks>
You can store the returned pointer and base other keyframes on the newly created keyframe (see the second overload).
It's possible to begin transitions at keyframes - see CBaseTransition::SetKeyframes.
You don't need to delete keyframes created in this way, because they are deleted automatically by animation groups.
Be careful when creating keyframes based on other keyframes and transitions and avoid circular references.
</remarks>
            <param name="nGroupID">Specifies Group ID for which keyframe is created.</param>
            <param name="pTransition">A pointer to transition. Keyframe will be inserted to storyboard after this transition.</param>
        </member>
        <member name="M:CAnimationController.RemoveTransitions(System.UInt32)">
            <summary>
Removes transitions from animation objects that belong to the specified group.
</summary>
            <remarks>
The group loops over its animation objects and calls ClearTransitions(FALSE) for each animation object.
This method is called by the framework after animation has been scheduled.
</remarks>
            <param name="nGroupID">Specifies Group ID.</param>
        </member>
        <member name="M:CAnimationController.RemoveAllAnimationGroups">
            <summary>
Removes all animation groups from animation controller.
</summary>
            <remarks>
All groups will be deleted, their pointer, if stored at the application level, must be invalidated.
If CAnimationGroup::m_bAutodestroyAnimationObjects for a group being deleted is TRUE,
all animation objects that belong to that group will be deleted; otherwise their references to parent animation
controller will be set to NULL and they can be added to another controller.
</remarks>
        </member>
        <member name="M:CAnimationController.RemoveAnimationGroup(System.UInt32)">
            <summary>
Removes an animation group with specified ID from animation controller.
</summary>
            <remarks>
This method removes an animation group from the internal list of groups and deletes it, therefore if you stored
a pointer to that animation group, it must be invalidated. If CAnimationGroup::m_bAutodestroyAnimationObjects is TRUE,
all animation objects that belong to that group will be deleted; otherwise their references to parent animation
controller will be set to NULL and they can be added to another controller.
</remarks>
            <param name="nGroupID">Specifies animation group ID.</param>
        </member>
        <member name="M:CAnimationController.RemoveAnimationObject(CAnimationBaseObject*,System.Int32)">
            <summary>
Remove an animation object from animation controller.
</summary>
            <remarks>
Removes an animation object from animation controller and animation group. Call this function if
a particular object should not be animated anymore, or if you need to move the object to another animation controller.
In the last case bNoDelete must be TRUE.
</remarks>
            <param name="pObject">A pointer to an animation object.</param>
            <param name="bNoDelete">If this parameter is TRUE the object will not be deleted upon remove.</param>
        </member>
        <member name="M:CAnimationController.AddAnimationObject(CAnimationBaseObject*)">
            <summary>
Adds an animation object to a group that belongs to the animation controller.
</summary>
            <returns>
A pointer to existing or new animation group where pObject has been added if function succeeds; NULL if
pObject has already been added to a group that belongs to another animation controller.
</returns>
            <remarks>
Call this method to add an animation object to the animation controller. An object will be added to a group
according to object's GroupID (see CAnimationBaseObject::SetID). The animation controller will create a new
group if it's the first object being added with the specified GroupID. An animation object can be added to
one animation controller only. If you need to add an object to another controller, call RemoveAnimationObject first.
If you call SetID with new GroupID for an object that has been already added to a group, the object will be removed
from the old group and added to another group with specified ID.
</remarks>
            <param name="pObject">A pointer to an animation object.</param>
        </member>
        <member name="M:CAnimationController.SetRelatedWnd(CWnd*)">
            <summary>
Establishes a relationship between animation controller and a window.
</summary>
            <remarks>
If a related CWnd object is set, the animation controller can automatically update it (send WM_PAINT message) when
the status of animation manager has changed or timer post update event has occurred.
</remarks>
            <param name="pWnd">A pointer to window object to set.</param>
        </member>
        <member name="M:CAnimationController.IsAnimationInProgress">
            <summary>
Tells whether at least one group is playing animation.
</summary>
            <returns>
TRUE if there is an animation in progress for this animation controller; otherwise FALSE.
</returns>
            <remarks>
Checks status of animation manager and returns TRUE if the status is UI_ANIMATION_MANAGER_BUSY.
</remarks>
        </member>
        <member name="M:CAnimationController.UpdateAnimationManager">
            <summary>
Directs the animation manager to update the values of all animation variables.
</summary>
            <remarks>
Calling this method advances the animation manager to current time, changing statuses of storyboards as necessary
and updating any animation variables to appropriate interpolated values. Internally this method calls
IUIAnimationTimer::GetTime(timeNow) and IUIAnimationManager::Update(timeNow). Override this method in a derived
class to customize this behavior.
</remarks>
        </member>
        <member name="M:CAnimationController.EnableAnimationTimerEventHandler(System.Int32,__MIDL___MIDL_itf_UIAnimation_0000_0012_0001)">
            <summary>
Sets or releases a handler for timing events and handler for timing updates.
</summary>
            <returns>
TRUE if handlers were successfully set or released; FALSE if this method is called for a second time without
releasing the handlers first, or if any other error occurs.
</returns>
            <remarks>
When the handlers are set (enabled) Windows Animation API calls OnAnimationTimerPreUpdate, OnAnimationTimerPostUpdate,
OnRenderingTooSlow methods.
You need to enable animation timers to allow Windows Animation API update storyboards. Otherwise you'll need to
call CAnimationController::UpdateAnimationManager in order to direct the animation manager to update the values
of all animation variables.
</remarks>
            <param name="bEnable">Specifies whether to set or release the handlers.</param>
            <param name="idleBehavior">Specifies idle behavior for timer update handler.</param>
        </member>
        <member name="M:CAnimationController.EnableStoryboardEventHandler(System.UInt32,System.Int32)">
            <summary>
Sets or releases a handler for storyboard status and update events.
</summary>
            <returns>
TRUE if the handler was successfully set or released; FALSE if the specified animation group is now found or
animation for the specified group has not been initiated and its internal storyboard is NULL.
</returns>
            <remarks>
When a handler is set (enabled) Windows Animation API calls OnStoryboardStatusChanges and OnStoryboardUpdated virtual methods.
A handler must be set after CAnimationController::Animate has been called for the specified animation group, because
it creates encapsulated IUIAnimationStoryboard object.
</remarks>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="bEnable">Specifies whether to set or release a handler.</param>
        </member>
        <member name="M:CAnimationController.EnablePriorityComparisonHandler(System.UInt64)">
            <summary>
Sets or releases the priority comparison handler to call to determine whether a scheduled storyboard can be cancelled,
concluded, trimmed or compressed.
</summary>
            <returns>
TRUE if the handler was successfully set or released.
</returns>
            <remarks>
When a handler is set (enabled) Windows Animation calls the following virtual methods depending on dwHandlerType:
OnHasPriorityCancel, OnHasPriorityConclude, OnHasPriorityTrim, OnHasPriorityCompress.
dwHandler can be a combination of the following flags:
UI_ANIMATION_PHT_NONE - release all handlers
UI_ANIMATION_PHT_CANCEL - set Cancel comparison handler
UI_ANIMATION_PHT_CONCLUDE - set Conclude comparison handler
UI_ANIMATION_PHT_COMPRESS - set Compress comparison handler
UI_ANIMATION_PHT_TRIM - set Trim comparison handler
UI_ANIMATION_PHT_CANCEL_REMOVE - remove Cancel comparison handler
UI_ANIMATION_PHT_CONCLUDE_REMOVE - remove Conclude comparison handler
UI_ANIMATION_PHT_COMPRESS_REMOVE - remove Compress comparison handler
UI_ANIMATION_PHT_TRIM_REMOVE - remove Trim comparison handler
</remarks>
            <param name="dwHandlerType">A combination of UI_ANIMATION_PHT_ flags (see remarks), which specifies what handlers to set or release.</param>
        </member>
        <member name="M:CAnimationController.EnableAnimationManagerEvent(System.Int32)">
            <summary>
Sets or releases a handler to call when animation manager's status changes.
</summary>
            <returns>
TRUE if the handler was successfully set or released.
</returns>
            <remarks>
When a handler is set (enabled) Windows Animation calls OnAnimationManagerStatusChanged when animation manager's status changes.
</remarks>
            <param name="bEnable">Specifies whether to set or release a handler.</param>
        </member>
        <member name="M:CAnimationController.GetKeyframeStoryboardStart">
            <summary>
Returns a keyframe that identifies start of storyboard.
</summary>
            <returns>
A pointer to base keyframe, which identifies start of storyboard.
</returns>
            <remarks>
Obtain this keyframe to base any other keyframes or transitions on the moment in time when a storyboard starts.
</remarks>
        </member>
        <member name="M:CAnimationController.IsValid">
            <summary>
Tells whether animation controller is valid.
</summary>
            <returns>
TRUE if animation controller is valid; otherwise FALSE.
</returns>
            <remarks>
This method returns FALSE only if Windows Animation API is not supported on the current OS and creation of
animation manager failed because it's not registered. You need to call GetUIAnimationManager at least once after initialization of
COM libraries to cause setting of this flag.
</remarks>
        </member>
        <member name="M:CAnimationController.GetUITransitionFactory">
            <summary>
A pointer to IUIAnimationTransitionFactory interface or NULL, if creation of transition library failed.
</summary>
            <returns>
A pointer to IUIAnimationTransitionFactory or NULL, if creation of transition factory failed.
</returns>
            <remarks>
If current OS does not support Windows Animation API, this method returns NULL and after that all subsequent calls
on CAnimationController::IsValid return FALSE.
</remarks>
        </member>
        <member name="M:CAnimationController.GetUIAnimationTimer">
            <summary>
Provides access to encapsulated IUIAnimationTimer object.
</summary>
            <returns>
A pointer to IUIAnimationTimer interface or NULL, if creation of animation timer failed.
</returns>
            <remarks>
If current OS does not support Windows Animation API, this method returns NULL and after that all subsequent calls
on CAnimationController::IsValid return FALSE.
</remarks>
        </member>
        <member name="M:CAnimationController.GetUITransitionLibrary">
            <summary>
Provides access to encapsulated IUIAnimationTransitionLibrary object.
</summary>
            <returns>
A pointer to IUIAnimationTransitionLibrary interface or NULL, if creation of transition library failed.
</returns>
            <remarks>
If current OS does not support Windows Animation API, this method returns NULL and after that all subsequent calls
on CAnimationController::IsValid return FALSE.
</remarks>
        </member>
        <member name="M:CAnimationController.GetUIAnimationManager">
            <summary>
Provides access to encapsulated IUIAnimationManager object.
</summary>
            <returns>
A pointer to IUIAnimationManager interface or NULL, if creation of animation manager failed.
</returns>
            <remarks>
If current OS does not support Windows Animation API, this method returns NULL and after that all subsequent calls
on CAnimationController::IsValid return FALSE.
You may need to access IUIAnimationManager in order to call its interface methods, which are not wrapped by
animation controller.
</remarks>
        </member>
        <member name="M:CAnimationController.Dispose">
            <summary>
The destructor. Called when animation controller object is being destroyed.
</summary>
        </member>
        <member name="M:CAnimationController.#ctor">
            <summary>
Constructs an animation controller.
</summary>
        </member>
        <member name="F:CAnimationController.g_KeyframeStoryboardStart">
            <summary>
A keyframe that represents start of storyboard.
</summary>
        </member>
        <member name="F:CAnimationController.m_lstAnimationGroups">
            <summary>
A list of animation groups that belong to this animation controller.
</summary>
        </member>
        <member name="F:CAnimationController.m_pRelatedWnd">
            <summary>
A pointer to a related CWnd object, which can be automatically redrawn when
the status of animation manager has changed, or post update event has occurred. Can be NULL.
</summary>
        </member>
        <member name="F:CAnimationController.m_pTransitionFactory">
            <summary>
Stores a pointer to Transition Factory COM object.
</summary>
        </member>
        <member name="F:CAnimationController.m_pAnimationTimer">
            <summary>
Stores a pointer to Animation Timer COM object.
</summary>
        </member>
        <member name="F:CAnimationController.m_pTransitionLibrary">
            <summary>
Stores a pointer to Transition Library COM object.
</summary>
        </member>
        <member name="F:CAnimationController.m_pAnimationManager">
            <summary>
Stores a pointer to Animation Manager COM object.
</summary>
        </member>
        <member name="F:CAnimationController.m_bIsValid">
            <summary>
Specifies whether an animation controller is valid or not.
This member is set to FALSE if current OS does not support Windows Animation API.
</summary>
        </member>
        <member name="T:CAnimationController">
            <summary>
Implements the animation controller, which provides a central interface for creating and managing UI animations.
</summary>
            <remarks>
The CAnimationController class is the key class that manages animations.
You may create one or more instances of animation controller in an application and, optionally, connect an instance of
animation controller to a CWnd object using CAnimationController::SetRelatedWnd. This connection is required to send WM_PAINT messages
to the related window automatically when animation manager status has changed or animation timer has been updated.
If you do not enable this relation, you must redraw a window that displays an animation manually. For this purpose you can derive a class
from CAnimationController and override OnAnimationManagerStatusChanged and/or OnAnimationTimerPostUpdate and invalidate one or
more windows when necessary.
</remarks>
        </member>
        <member name="F:CAnimationGroup.m_bAutodestroyAnimationObjects">
            <summary>
Specifies how to destroy animation objects. If this parameter is TRUE, animation objects will be destroyed automatically
when the group is destroyed. Otherwise animation objects must be destroyed manually. The default value is FALSE.
Set this value to TRUE only if all animation objects that belong to group are allocated dynamically with operator new.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_bAutoclearTransitions">
            <summary>
Specifies how to clear transitions from animation objects that belong to group. If this member is TRUE,
transitions are removed automatically when an animation has been scheduled. Otherwise you need to remove
transitions manually.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_bAutodestroyKeyframes">
            <summary>
Specifies how to destroy keyframes. If this value is TRUE, all keyframes are removed and destroyed;
otherwise they are removed from the list only. The default value is TRUE.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_pStoryboard">
            <summary>
Points to animation storyboard. This pointer is valid only after call on Animate.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_lstKeyFrames">
            <summary>
Contains a list of keyframes.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_lstAnimationObjects">
            <summary>
Contains a list of animation objects.
</summary>
        </member>
        <member name="M:CAnimationGroup.SetAutodestroyTransitions(System.Int32)">
            <summary>
Directs all animation objects that belong to group automatically destroy transitions.
</summary>
            <remarks>
Set this value to FALSE only if you allocate transitions on the stack. The default value is TRUE, therefore
it's highly recommended to allocate transition objects using operator new.
</remarks>
            <param name="bAutoDestroy">Specifies how to destroy transitions.</param>
        </member>
        <member name="M:CAnimationGroup.Schedule(IUIAnimationTimer*,System.Double)">
            <summary>
Schedules an animation at the specified time.
</summary>
            <returns>
TRUE if the method succeeds; FALSE if the method fails or if Animate has not been called with bScheduleNow set to FALSE.
</returns>
            <remarks>
Call this function to schedule an animation at the specified time. You must call Animate with bScheduleNow set to FALSE first.
</remarks>
            <param name="pTimer">A pointer to animation timer.</param>
            <param name="time">Specifies time to schedule the animation.</param>
        </member>
        <member name="M:CAnimationGroup.Animate(IUIAnimationManager*,IUIAnimationTimer*,System.Int32)">
            <summary>
Animates a group.
</summary>
            <returns>
TRUE if the method succeeds; otherwise FALSE.
</returns>
            <remarks>
This method creates an internal storyboard, creates and applies transitions and schedules an animation
if bScheduleNow is TRUE. If bScheduleNow is FALSE, you need to call Schedule to start animation at the
specified time.
</remarks>
            <param name="pManager" />
            <param name="pTimer" />
            <param name="bScheduleNow" />
        </member>
        <member name="M:CAnimationGroup.FindAnimationObject(IUIAnimationVariable*)">
            <summary>
Finds an animation object that contains the specified animation variable.
</summary>
            <returns>
A pointer to animation object, or NULL if animation object is not found.
</returns>
            <param name="pVariable">A pointer to animation variable.</param>
        </member>
        <member name="M:CAnimationGroup.RemoveKeyframes">
            <summary>
Removes and optionally destroys all keyframes that belong to an animation group.
</summary>
            <remarks>
If m_bAutodestroyKeyframes member is TRUE then keyframes are removed and destroyed, otherwise keyframes are
just removed from the internal list of keyframes.
</remarks>
        </member>
        <member name="M:CAnimationGroup.RemoveTransitions">
            <summary>
Removes transitions from animation objects that belong to an animation group.
</summary>
            <remarks>
If m_bAutoclearTransitions flag is set to TRUE, this method loops over all animation objects that belong to the group
and calls CAnimationObject::ClearTransitions(FALSE).
</remarks>
        </member>
        <member name="M:CAnimationGroup.ApplyTransitions">
            <summary>
Applies transitions to animation objects.
</summary>
            <remarks>
This method ASSERTS in debug mode if storyboard has not been created.
It creates all transitions first, then adds "static" keyframes (keyframes that depend on offsets),
adds transitions that do not depend on keyframes, adds keyframes depending on transitions and other keyframes,
and at last adds transitions that depend on keyframes.
</remarks>
        </member>
        <member name="M:CAnimationGroup.GetGroupID">
            <summary>
Returns GroupID.
</summary>
            <returns>
A group identifier.
</returns>
        </member>
        <member name="M:CAnimationGroup.Dispose">
            <summary>
The destructor. Called when an animation group is being destroyed.
</summary>
        </member>
        <member name="M:CAnimationGroup.#ctor(CAnimationController*,System.UInt32)">
            <summary>
Constructs an animation group.
</summary>
            <param name="pParentController">A pointer to animation controller that creates a group.</param>
            <param name="nGroupID">Specifies GroupID.</param>
        </member>
        <member name="M:CAnimationGroup.CreateTransitions">
            <summary>
A helper that creates COM transition objects.
</summary>
            <returns>
TRUE is the method succeeds, otherwise FALSE.
</returns>
        </member>
        <member name="M:CAnimationGroup.AddTransitions(IUIAnimationStoryboard*,System.Int32)">
            <summary>
A helper that adds transitions to a storyboard.
</summary>
            <param name="pStoryboard">A pointer to a storyboard COM object.</param>
            <param name="bDependOnKeyframes">Specifies whether this method should add to the storyboard transitions that depend on other keyframes.</param>
        </member>
        <member name="M:CAnimationGroup.AddKeyframes(IUIAnimationStoryboard*,System.Int32)">
            <summary>
A helper that adds keyframes to a storyboard.
</summary>
            <param name="pStoryboard">A pointer to a storyboard COM object.</param>
            <param name="bAddDeep">Specifies whether this method should add to the storyboard keyframes that depend on other keyframes.</param>
        </member>
        <member name="F:CAnimationGroup.m_pParentController">
            <summary>
A pointer to animation controller this group belongs to.
</summary>
        </member>
        <member name="F:CAnimationGroup.m_nGroupID">
            <summary>
A unique identifier of animation group.
</summary>
        </member>
        <member name="T:CAnimationGroup">
            <summary>
Implements an animation group, which combines an animation storyboard, animation objects and transitions
to define an animation.
</summary>
            <remarks>
Animation groups are created automatically by animation controller (CAnimationController) when you add animation
objects using CAnimationController::AddAnimationObject.
An animation group is identified by GroupID, which is usually taken as a parameter to manipulate animation groups.
The GroupID is taken from the first animation object being added to a new animation group.
An encapsulated animation storyboard is created after you call CAnimationController::AnimateGroup and can be
accessed via public member m_pStoryboard.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variables into a list.
</summary>
            <param name="lst">When the function returns, it contains pointers to four CAnimationVariable objects
representing coordinates of rectangle.</param>
        </member>
        <member name="F:CAnimationRect.m_bFixedSize">
            <summary>
Specifies whether the rectangle has fixed size.
</summary>
            <remarks>
If this member is true, then the size of rectangle is fixed and right and bottom values
are recalculated each time the top-left corner is  moved according to the fixed size.
Set this value to TRUE to easily move the rectangle around the screen. In this case transitions applied to
right and bottom coordinates are ignored. The size is stored internally when you construct the object and/or
call SetDefaultValue. By default this member is set to FALSE.
</remarks>
        </member>
        <member name="M:CAnimationRect.AddTransition(CBaseTransition*,CBaseTransition*,CBaseTransition*,CBaseTransition*)">
            <summary>
Adds transitions for left, top, right and bottom coordinates.
</summary>
            <remarks>
Call this function to add the specified transitions to the internal list of transitions to be applied to animation variables for each rectangle sides.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
If you don't need to apply a transition to one of the rectangle sides, you can pass NULL.
</remarks>
            <param name="pLeftTransition">Specifies transition for the left side.</param>
            <param name="pTopTransition">Specifies transition for the top side.</param>
            <param name="pRightTransition">Specifies transition for the right side.</param>
            <param name="pBottomTransition">Specifies transition for the bottom side.</param>
        </member>
        <member name="M:CAnimationRect.op_Implicit~tagRECT">
            <summary>
Converts a CAnimationRect to RECT.
</summary>
            <returns>
Current value of animation rectangle as RECT.
</returns>
            <remarks>
This function internally calls GetValue. If GetValue for some reason fails, the returned RECT will contain default values for all rectangle coordinates.
</remarks>
        </member>
        <member name="M:CAnimationRect.op_Assign(tagRECT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Assigns rect to CAnimationRect.
</summary>
            <remarks>
It's recommended to do that before animation start, because this operator calls
SetDefaultValue, which recreates the underlying COM objects for color components if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="rect">The new value of animation rectangle.</param>
        </member>
        <member name="M:CAnimationRect.GetBottom">
            <summary>
Provides access to CAnimationVariable representing bottom coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing bottom coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing the bottom coordinate.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetRight">
            <summary>
Provides access to CAnimationVariable representing right coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing right coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing the right coordinate.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetTop">
            <summary>
Provides access to CAnimationVariable representing top coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing top coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing the top coordinate.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetLeft">
            <summary>
Provides access to CAnimationVariable representing left coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing left coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing the left coordinate.
</remarks>
        </member>
        <member name="M:CAnimationRect.GetValue(CRect*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns current value.
</summary>
            <returns>
TRUE, if the current value was successfully retrieved; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value of animation rectangle. If this method fails or underlying COM objects for
left, top, right and bottom have not been initialized, rect contains default value, which was previously set in constructor or by SetDefaultValue.
</remarks>
            <param name="rect">Output. Contains the current value when this method returns.</param>
        </member>
        <member name="M:CAnimationRect.GetDefaultValue">
            <summary>
Returns the default values for rectangle's bounds.
</summary>
            <returns>
A CRect value containing defaults for left, right, top and bottom.
</returns>
            <remarks>
Call this function to retrieve default value, which was previously set by constructor or SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationRect.SetDefaultValue(CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this function to set a default value to animation object. This methods assigns default values to rectangle's bounds.
It also recreates underlying COM objects if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="rect">Specifies new default values for left, top, right and bottom.</param>
        </member>
        <member name="M:CAnimationRect.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation rect object.
</summary>
            <remarks>
The object is constructed with specified coordinates of each side, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="nLeft">Specifies coordinate of left bound.</param>
            <param name="nTop">Specifies coordinate of top bound.</param>
            <param name="nRight">Specifies coordinate of right bound.</param>
            <param name="nBottom">Specifies coordinate of bottom bound.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationRect.#ctor(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation rect object.
</summary>
            <remarks>
The object is constructed with specified top-left corner coordinates and size of rectangle, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="pt">Coordinate of top-left corner.</param>
            <param name="sz">Size of rectangle.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationRect.#ctor(CRect!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation rect object.
</summary>
            <remarks>
The object is constructed with specified rect coordinates, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="rect">Specifies default rectangle.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationRect.#ctor">
            <summary>
Constructs a CAnimationRect object.
</summary>
            <remarks>
The object is constructed with default values for left, top, right and bottom, Object ID and Group ID, which will be set to 0. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
        </member>
        <member name="F:CAnimationRect.m_szInitial">
            <summary>
Specifies initial size of animation rectangle.
</summary>
        </member>
        <member name="F:CAnimationRect.m_bottomValue">
            <summary>
The encapsulated animation variable that represents Bottom bound of animation rectangle.
</summary>
        </member>
        <member name="F:CAnimationRect.m_rightValue">
            <summary>
The encapsulated animation variable that represents Right bound of animation rectangle.
</summary>
        </member>
        <member name="F:CAnimationRect.m_topValue">
            <summary>
The encapsulated animation variable that represents Top bound of animation rectangle.
</summary>
        </member>
        <member name="F:CAnimationRect.m_leftValue">
            <summary>
The encapsulated animation variable that represents Left bound of animation rectangle.
</summary>
        </member>
        <member name="T:CAnimationRect">
            <summary>
Implements the functionality of a rectangle whose top, left, right and bottom sides can be animated.
</summary>
            <remarks>
The CAnimationRect class encapsulates four CAnimationVariable objects and can represent in applications
a rectangle.
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to left, right top and bottom coordinates.
</remarks>
        </member>
        <member name="M:CAnimationColor.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variables into a list.
</summary>
            <param name="lst">When the function returns, it contains pointers to three CAnimationVariable objects
representing red, green and blue components.</param>
        </member>
        <member name="M:CAnimationColor.AddTransition(CBaseTransition*,CBaseTransition*,CBaseTransition*)">
            <summary>
Adds transitions for Red, Green and Blue components.
</summary>
            <remarks>
Call this function to add the specified transitions to the internal list of transitions to be applied to animation variables representing color components.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
If you don't need to apply a transition to one of the color components, you can pass NULL.
</remarks>
            <param name="pRTransition">Transition for Red component.</param>
            <param name="pGTransition">Transition for Green component.</param>
            <param name="pBTransition">Transition for Blue component.</param>
        </member>
        <member name="M:CAnimationColor.op_Implicit~System.UInt32!System.Runtime.CompilerServices.IsLong">
            <summary>
Converts a CAnimationColor to COLORREF.
</summary>
            <returns>
Current value of animation color object as COLORREF.
</returns>
            <remarks>
This function internally calls GetValue. If GetValue for some reason fails, the returned COLORREF will contain default values for all color components.
</remarks>
        </member>
        <member name="M:CAnimationColor.op_Assign(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Assigns color to CAnimationColor.
</summary>
            <remarks>
It's recommended to do that before animation start, because this operator calls
SetDefaultValue, which recreates the underlying COM objects for color components if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="color">Specifies new value Animation Color.</param>
        </member>
        <member name="M:CAnimationColor.GetB">
            <summary>
Provides access to CAnimationVariable representing Blue component.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Blue component.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Blue component.
</remarks>
        </member>
        <member name="M:CAnimationColor.GetG">
            <summary>
Provides access to CAnimationVariable representing Green component.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Green component.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Green component.
</remarks>
        </member>
        <member name="M:CAnimationColor.GetR">
            <summary>
Provides access to CAnimationVariable representing Red component.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Red component.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Red component.
</remarks>
        </member>
        <member name="M:CAnimationColor.GetValue(System.UInt32!System.Runtime.CompilerServices.IsLong*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns current value.
</summary>
            <returns>
TRUE, if the current value was successfully retrieved; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value of animation color. If this method fails or underlying COM objects for
color components have not been initialized, color contains default value, which was previously set in constructor or by SetDefaultValue.
</remarks>
            <param name="color">Output. Contains the current value when this method returns.</param>
        </member>
        <member name="M:CAnimationColor.GetDefaultValue">
            <summary>
Returns the default values for color components.
</summary>
            <returns>
A COLORREF value containing defaults for RGB components.
</returns>
            <remarks>
Call this function to retrieve default value, which was previously set by constructor or SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationColor.SetDefaultValue(System.UInt32!System.Runtime.CompilerServices.IsLong)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this function to set a default value to animation object. This methods assigns default values to color components
of animation color. It also recreates underlying COM objects if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="color">Specifies new default values for red, green and blue components.</param>
        </member>
        <member name="M:CAnimationColor.#ctor(System.UInt32!System.Runtime.CompilerServices.IsLong,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation color object.
</summary>
            <remarks>
The object is constructed with specified values for RGB components, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="color">Specifies default color.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationColor.#ctor">
            <summary>
Constructs a CAnimationColor object.
</summary>
            <remarks>
The object is constructed with default values for red, green, blue, Object ID and Group ID, which will be set to 0. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
        </member>
        <member name="F:CAnimationColor.m_bValue">
            <summary>
The encapsulated animation variable that represents Blue component of animation color.
</summary>
        </member>
        <member name="F:CAnimationColor.m_gValue">
            <summary>
The encapsulated animation variable that represents Green component of animation color.
</summary>
        </member>
        <member name="F:CAnimationColor.m_rValue">
            <summary>
The encapsulated animation variable that represents Red component of animation color.
</summary>
        </member>
        <member name="T:CAnimationColor">
            <summary>
Implements the functionality of a color whose red, green and blue components can be animated.
</summary>
            <remarks>
The CAnimationColor class encapsulates three CAnimationVariable objects and can represent in applications
a color. For example, you can use this class to animate colors of any object on the screen (like text color, background color etc).
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to Red, Green and Blue components.
</remarks>
        </member>
        <member name="M:CAnimationSize.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variables into a list.
</summary>
            <param name="lst">When the function returns, it contains pointers to two CAnimationVariable objects
representing the width and height.</param>
        </member>
        <member name="M:CAnimationSize.AddTransition(CBaseTransition*,CBaseTransition*)">
            <summary>
Adds transitions for Width and Height.
</summary>
            <remarks>
Call this function to add the specified transitions to the internal list of transitions to be applied to animation variables for Width and Height.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
If you don't need to apply a transition to one of dimensions, you can pass NULL.
</remarks>
            <param name="pCXTransition">A pointer to transition for Width.</param>
            <param name="pCYTransition">A pointer to transition for Height.</param>
        </member>
        <member name="M:CAnimationSize.op_Implicit~CSize">
            <summary>
Converts a CAnimationSize to a CSize.
</summary>
            <returns>
Current value of animation size as CSize.
</returns>
            <remarks>
This function internally calls GetValue. If GetValue for some reason fails, the returned size will contain default values for Width and Height.
</remarks>
        </member>
        <member name="M:CAnimationSize.op_Assign(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Assigns szSrc to CAnimationSize.
</summary>
            <remarks>
Assigns szSrc to CAnimationSize. It's recommended to do that before animation start, because this operator calls
SetDefaultValue, which recreates the underlying COM objects for Width and Height if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="szSrc">Refers to CSize or SIZE.</param>
        </member>
        <member name="M:CAnimationSize.GetCY">
            <summary>
Provides access to CAnimationVariable representing Height.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Height.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Height.
</remarks>
        </member>
        <member name="M:CAnimationSize.GetCX">
            <summary>
Provides access to CAnimationVariable representing Width.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Width.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Width.
</remarks>
        </member>
        <member name="M:CAnimationSize.GetValue(CSize*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns current value.
</summary>
            <returns>
TRUE, if the current value was successfully retrieved; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value of animation size. If this method fails or underlying COM objects for
Width and Size have not been initialized, szValue contains default value, which was previously set in constructor or by SetDefaultValue.
</remarks>
            <param name="szValue">Output. Contains the current value when this method returns.</param>
        </member>
        <member name="M:CAnimationSize.GetDefaultValue">
            <summary>
Returns the default values for Width and Height.
</summary>
            <returns>
A CSize object containing default values.
</returns>
            <remarks>
Call this function to retrieve default value, which was previously set by constructor or SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationSize.SetDefaultValue(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this function to set a default value to animation object. This methods assigns default values to Width and Height
of animation size. It also recreates underlying COM objects if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="szDefault">Specifies new default size.</param>
        </member>
        <member name="M:CAnimationSize.#ctor(CSize!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation size object.
</summary>
            <remarks>
The object is constructed with specified values for width, height, Object ID and Group ID. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
            <param name="szDefault">Specifies default size.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationSize.#ctor">
            <summary>
Constructs an animation size object.
</summary>
            <remarks>
The object is constructed with default values for width, height, Object ID and Group ID, which will be set to 0. They can be changed
later at runtime using SetDefaultValue and SetID.
</remarks>
        </member>
        <member name="F:CAnimationSize.m_cyValue">
            <summary>
The encapsulated animation variable that represents height of animation size.
</summary>
        </member>
        <member name="F:CAnimationSize.m_cxValue">
            <summary>
The encapsulated animation variable that represents width of animation size.
</summary>
        </member>
        <member name="T:CAnimationSize">
            <summary>
Implements the functionality of a size object whose dimensions can be animated.
</summary>
            <remarks>
The CAnimationSize class encapsulates two CAnimationVariable objects and can represent in applications
a size. For example, you can use this class to animate a size of any two dimensional object on the screen (like rectangle, control etc).
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to Width and/or Height.
</remarks>
        </member>
        <member name="M:CAnimationPoint.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variables into a list.
</summary>
            <param name="lst">When the function returns, it contains pointers to two CAnimationVariable objects
representing the X and Y coordinates.</param>
        </member>
        <member name="M:CAnimationPoint.AddTransition(CBaseTransition*,CBaseTransition*)">
            <summary>
Adds transitions for X and Y coordinates.
</summary>
            <remarks>
Call this function to add the specified transitions to the internal list of transitions to be applied to animation variables for X and Y coordinates.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
If you don't need to apply a transition to one of coordinates, you can pass NULL.
</remarks>
            <param name="pXTransition">A pointer to transition for X coordinates.</param>
            <param name="pYTransition">A pointer to transition for Y coordinate.</param>
        </member>
        <member name="M:CAnimationPoint.GetY">
            <summary>
Provides access to CAnimationVariable for Y coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing Y coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing Y coordinate.
</remarks>
        </member>
        <member name="M:CAnimationPoint.GetX">
            <summary>
Provides access to CAnimationVariable for X coordinate.
</summary>
            <returns>
A reference to encapsulated CAnimationVariable representing X coordinate.
</returns>
            <remarks>
You can call this method to get direct access to underlying CAnimationVariable representing X coordinate.
</remarks>
        </member>
        <member name="M:CAnimationPoint.op_Implicit~CPoint">
            <summary>
Converts a CAnimationPoint to a CPoint.
</summary>
            <returns>
Current value of CAnimationPoint as CPoint.
</returns>
            <remarks>
This function internally calls GetValue. If GetValue for some reason fails, the returned point will contain default values for X and Y coordinates.
</remarks>
        </member>
        <member name="M:CAnimationPoint.op_Assign(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Assigns ptSrc to CAnimationPoint.
</summary>
            <remarks>
Assigns ptSrc to CAnimationPoint. It's recommended to do that before animation start, because this operator calls
SetDefaultValue, which recreates the underlying COM objects for X and Y coordinates if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="ptSrc">Refers to CPoint or POINT.</param>
        </member>
        <member name="M:CAnimationPoint.GetValue(CPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns current value.
</summary>
            <returns>
TRUE, if the current value was successfully retrieved; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value of animation point. If this method fails or underlying COM objects for
X and Y coordinates have not been initialized, ptValue contains default
value, which was previously set in constructor or by SetDefaultValue.
</remarks>
            <param name="ptValue">Output. Contains the current value when this method returns.</param>
        </member>
        <member name="M:CAnimationPoint.GetDefaultValue">
            <summary>
Returns the default values for X and Y coordinates.
</summary>
            <returns>
A point containing default value.
</returns>
            <remarks>
Call this function to retrieve default value, which was previously set by constructor or SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationPoint.SetDefaultValue(tagPOINT!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this function to set a default value to animation object. This methods assigns default values to X and Y
coordinates of animation point. It also recreates underlying COM objects if they have been created. If you
subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="ptDefault">Specifies the default point value.</param>
        </member>
        <member name="M:CAnimationPoint.#ctor(CPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs CAnimationPoint object.
</summary>
            <remarks>
Constructs CAnimationPoint object with specified properties.
</remarks>
            <param name="ptDefault">Specifies default point coordinates.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">Specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationPoint.#ctor">
            <summary>
Constructs CAnimationPoint object.
</summary>
            <remarks>
Constructs CAnimationPoint object with default properties: default point coordinates, Group ID and Object ID are set to 0.
</remarks>
        </member>
        <member name="F:CAnimationPoint.m_yValue">
            <summary>
The encapsulated animation variable that represents Y coordinate of animation point.
</summary>
        </member>
        <member name="F:CAnimationPoint.m_xValue">
            <summary>
The encapsulated animation variable that represents X coordinate of animation point.
</summary>
        </member>
        <member name="T:CAnimationPoint">
            <summary>
Implements the functionality of a point whose coordinates can be animated.
</summary>
            <remarks>
The CAnimationPoint class encapsulates two CAnimationVariable objects and can represent in applications
a point. For example, you can use this class to animate a position of any object on the screen (like text string, circle, point etc).
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to X and/or Y coordinates.
</remarks>
        </member>
        <member name="M:CAnimationValue.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Puts the encapsulated animation variable into a list.
</summary>
            <param name="lst">When the function returns, it contains a pointer to CAnimationVariable representing the animated value.</param>
        </member>
        <member name="M:CAnimationValue.AddTransition(CBaseTransition*)">
            <summary>
Adds a transition to be applied to a value.
</summary>
            <remarks>
Call this function to add a transition to internal list of transitions to be applied to an animation variable.
When you add transitions, they are not applied immediately and stored in an internal list. Transitions are applied
(added to a storyboard for a particular value) when you call CAnimationController::AnimateGroup.
</remarks>
            <param name="pTransition">A pointer to transition object.</param>
        </member>
        <member name="M:CAnimationValue.GetVariable">
            <summary>
Provides access to encapsulated animation variable.
</summary>
            <returns>
A reference to encapsulated animation variable.
</returns>
            <remarks>
Use this method to access the encapsulated animation variable. From CAnimationVariable you get access
to underlying IUIAnimationVariable object, whose pointer can be NULL if animation variable has not been created.
</remarks>
        </member>
        <member name="M:CAnimationValue.op_Assign(System.Int32)">
            <summary>
Assigns an INT32 value to CAnimationValue.
</summary>
            <remarks>
Assigns an INT32 value to CAnimationValue. This value is set as a default value for encapsulated animation variable.
If you subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="nVal">Specifies the value to be assigned to Animation Value.</param>
        </member>
        <member name="M:CAnimationValue.op_Assign(System.Double)">
            <summary>
Assigns a DOUBLE value to CAnimationValue.
</summary>
            <remarks>
Assigns a DOUBLE value to CAnimationValue. This value is set as a default value for encapsulated animation variable.
If you subscribed this animation object to events (ValueChanged or IntegerValueChanged), you need to re-enable these events.
</remarks>
            <param name="dblVal">Specifies the value to be assigned to Animation Value.</param>
        </member>
        <member name="M:CAnimationValue.op_Implicit~System.Int32">
            <summary>
Provides conversion between CAnimationValue and INT32.
</summary>
            <returns>
Current value of Animation Value as integer.
</returns>
            <remarks>
Provides conversion between CAnimationValue and INT32. This method internally calls GetValue and doesn't check for
errors. If GetValue fails, the returned value will contain a default value previously set in constructor or with SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationValue.op_Implicit~System.Double">
            <summary>
Provides conversion between CAnimationValue and DOUBLE.
</summary>
            <returns>
Current value of Animation Value.
</returns>
            <remarks>
Provides conversion between CAnimationValue and DOUBLE. This method internally calls GetValue and doesn't check for
errors. If GetValue fails, the returned value will contain a default value previously set in constructor or with SetDefaultValue.
</remarks>
        </member>
        <member name="M:CAnimationValue.GetValue(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieves the current value.
</summary>
            <returns>
TRUE if the current value was retrieved successfully; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value. This implementation calls the encapsulated COM object, and if
the call fails, this method returns the default value that was previously set in constructor or with SetDefaultValue.
</remarks>
            <param name="nValue">Output. When the function returns it contains a current value of animation variable.</param>
        </member>
        <member name="M:CAnimationValue.GetValue(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Retrieves the current value.
</summary>
            <returns>
TRUE if the current value was retrieved successfully; otherwise FALSE.
</returns>
            <remarks>
Call this function to retrieve the current value. This implementation calls the encapsulated COM object, and if
the call fails, this method returns the default value that was previously set in constructor or with SetDefaultValue.
</remarks>
            <param name="dblValue">Output. When the function returns it contains a current value of animation variable.</param>
        </member>
        <member name="M:CAnimationValue.SetDefaultValue(System.Double)">
            <summary>
Sets default value.
</summary>
            <remarks>
Use this method to set a default value. A default value is returned to application when animation has not been started
and/or underlying COM object has not been created. If the underlying COM object encapsulated in CAnimationVarible
was already created, this method recreates it, therefore you might need to call EnableValueChanged/EnableIntegerValueChanged
methods again.
</remarks>
            <param name="dblDefaultValue">Specifies the default value.</param>
        </member>
        <member name="M:CAnimationValue.#ctor(System.Double,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs a CAnimationValue object.
</summary>
            <remarks>
Constructs CAnimationValue object with specified properties.
</remarks>
            <param name="dblDefaultValue">Specifies default value.</param>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">specifies user-defined data.</param>
        </member>
        <member name="M:CAnimationValue.#ctor">
            <summary>
Constructs a CAnimationValue object.
</summary>
            <remarks>
Constructs CAnimationValue object with default properties: default value, Group ID and Object ID are set to 0.
</remarks>
        </member>
        <member name="F:CAnimationValue.m_value">
            <summary>
The encapsulated animation variable that represents animation value.
</summary>
        </member>
        <member name="T:CAnimationValue">
            <summary>
Implements the functionality of animation object with one value.
</summary>
            <remarks>
The CAnimationValue class encapsulates a single CAnimationVariable object and can represent in applications
a single animated value. For example, you can use this class for animated transparency (fade effect), angle (to rotate objects),
or for any other case when you need to create an animation depending on a single animated value.
To use this class in application, just instantiate an object of this class, add it to animation controller using
CAnimationController::AddAnimationObject and call AddTransition for each transition to be applied to the value.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.SetParentAnimationObjects">
            <summary>
Establishes relationship between animation variables, contained in an animation object, and their container.
</summary>
            <remarks>
This is a helper that can be used to establish relationship between animation variables, contained in an animation object,
and their container. It loops over animation variables and sets a back pointer to a parent animation object
to each animation variable.
In the current implementation the actual relationship is established in CAnimationBaseObject::ApplyTransitions, therefore
back pointers are not set until you call CAnimationGroup::Animate.
Knowing the relationship may be helpful when you processing events and need to get a parent animation object
from CAnimationVariable (use CAnimationVariable::GetParentAnimationObject).
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.GetAnimationVariableList(CList&lt;CAnimationVariable**,CAnimationVariable**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Collects pointers to contained animation variables.
</summary>
            <remarks>
This is a pure virtual method that must be overridden in a derived class.
An animation object, depending on its type, contains one or more animation variables. For example, CAnimationPoint
contains two variables, for X and Y coordinates respectively. The base class CAnimationBaseObject implements
some generic methods, which act on a list of animation variables: ApplyTransitions, ClearTransitions,
EnableValueChangedEvent, EnableIntegerValueChangedEvent. These methods call GetAnimationVariableList, which is filled
in a derived class with actual animation variables contained in a particular animation object, then loop over the
list and perform necessary actions.
If you create a custom animation object, you must add to lst all animation variables contained in that object.
</remarks>
            <param name="lst">A list that must be filled with animation variables contained in an animation object.</param>
        </member>
        <member name="M:CAnimationBaseObject.ContainsVariable(IUIAnimationVariable*)">
            <summary>
Determines whether an animation object contains a particular animation variable.
</summary>
            <returns>
TRUE if the animation variable is contained in the animation object; otherwise FALSE.
</returns>
            <remarks>
This method can be used to determine whether an animation variable specified by pVariable is contained
within an animation object. An animation object, depending on its type, may contain several animation variables.
For example, CAnimationColor contains three variables, one for each color component (red, green and blue). When a
value of animation variable has changed, Windows Animation API sends ValueChanged or IntegerValueChanged events (if enabled),
and the parameter of this event is a pointer to interface IUIAnimationVariable of animation variable.
This method helps to obtain a pointer to animation from a pointer to contained COM object.
</remarks>
            <param name="pVariable">A pointer to animation variable.</param>
        </member>
        <member name="M:CAnimationBaseObject.EnableIntegerValueChangedEvent(CAnimationController*,System.Int32)">
            <summary>
Sets up Integer Value Changed event handler.
</summary>
            <remarks>
If the Integer Value Changed event handler is enabled, you can handle this event in CAnimationController::OnAnimationIntegerValueChanged method,
which should be overridden in a CAnimationController-derived class. This method is called every time the animation integer value has changed.
</remarks>
            <param name="pController">A pointer to a parent controller.</param>
            <param name="bEnable">Specifies whether to enable, or disable Integer Value Changed event.</param>
        </member>
        <member name="M:CAnimationBaseObject.EnableValueChangedEvent(CAnimationController*,System.Int32)">
            <summary>
Sets up Value Changed event handler.
</summary>
            <remarks>
If the Value Changed event handler is enabled, you can handle this event in CAnimationController::OnAnimationValueChanged method,
which should be overridden in a CAnimationController-derived class. This method is called every time the animation value has changed.
</remarks>
            <param name="pController">A pointer to a parent controller.</param>
            <param name="bEnable">Specifies whether to enable, or disable Value Changed event.</param>
        </member>
        <member name="M:CAnimationBaseObject.ClearTransitions(System.Int32)">
            <summary>
Removes all related transitions.
</summary>
            <remarks>
Removes all related transitions and destroys them if bAutodestroy or m_bAutodestroyTransitions flag is TRUE.
Transitions should be destroyed automatically only if they are not allocated on the stack.
If the above flags are FALSE, transitions are just removed from the internal list of related transitions.
</remarks>
            <param name="bAutodestroy">Specifies whether to destroy transition objects automatically, or just remove them from the related list.</param>
        </member>
        <member name="M:CAnimationBaseObject.ApplyTransitions(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds transitions to storyboard with encapsulated animation variable.
</summary>
            <returns>
TRUE if transitions were added successfully.
</returns>
            <remarks>
Adds related transitions, that have been added with AddTransition (overloaded methods in derived classes), to storyboard.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDependOnKeyframes">With FALSE this method adds only those transitions that do not depend on keyframes.</param>
        </member>
        <member name="M:CAnimationBaseObject.GetAutodestroyTransitions">
            <summary>
Tells whether related transition are destroyed automatically.
</summary>
            <returns>
If TRUE, related transitions are destroyed automatically; if FALSE, transition objects should be deallocated by calling application.
</returns>
            <remarks>
By default this flag is TRUE. Set this flag only if you allocated transition on the stack and/or transitions should be deallocated by
the calling application.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.SetAutodestroyTransitions(System.Int32)">
            <summary>
Sets a flag that orders to automatically destroy transitions.
</summary>
            <remarks>
Set this flag only if you allocated transition objects using operator new. If for some reason transition
objects are allocated on the stack, the auto destroy flag should be FALSE. By default this flag is TRUE.
</remarks>
            <param name="bValue">Specifies the auto destroy flag.</param>
        </member>
        <member name="M:CAnimationBaseObject.GetUserData">
            <summary>
Returns user defined data.
</summary>
            <returns>
A value of custom data.
</returns>
            <remarks>
Call this method to retrieve the custom data at runtime. The returned value will be 0 if it was not explicitly initialized in constructor or with SetUserData.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.GetGroupID">
            <summary>
Returns current Group ID.
</summary>
            <returns>
Current Group ID.
</returns>
            <remarks>
Use this method to retrieve Group ID. It's 0 if Group ID has not been set explicitly in constructor or with SetID.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.GetObjectID">
            <summary>
Returns current Object ID.
</summary>
            <returns>
Current Object ID.
</returns>
            <remarks>
Use this method to retrieve Object ID. It's 0 if Object ID has not been set explicitly in constructor or with SetID.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.DetachFromController">
            <summary>
Detaches an animation object from parent animation controller.
</summary>
            <remarks>
This method is used internally.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.SetUserData(System.UInt64)">
            <summary>
Sets user-defined data.
</summary>
            <remarks>
Use this method to associate a custom data with an animation object. This data may be retrieved later at runtime by GetUserData.
</remarks>
            <param name="dwUserData">Specifies the custom data.</param>
        </member>
        <member name="M:CAnimationBaseObject.SetID(System.UInt32,System.UInt32)">
            <summary>
Sets new IDs.
</summary>
            <remarks>
Allows to change Object ID and Group ID. If the new Group ID differs from the current ID, an animation object
is moved to another group (a new group will be created, if necessary).
</remarks>
            <param name="nObjectID">Specifies new Object ID.</param>
            <param name="nGroupID">Specifies new Group ID.</param>
        </member>
        <member name="M:CAnimationBaseObject.CreateTransitions">
            <summary>
Creates transitions associated with an animation object.
</summary>
            <returns>
TRUE if transitions were created successfully; otherwise FALSE.
</returns>
            <remarks>
Loops over list of animation variables encapsulated in a derived animation object and creates transitions
associated with each animation variable.
</remarks>
        </member>
        <member name="M:CAnimationBaseObject.Dispose">
            <summary>
The destructor. Called when an animation object is being destroyed.
</summary>
        </member>
        <member name="M:CAnimationBaseObject.#ctor(System.UInt32,System.UInt32,System.UInt64)">
            <summary>
Constructs an animation object.
</summary>
            <remarks>
Constructs an animation object with specified Object ID and Group ID.
</remarks>
            <param name="nGroupID">Specifies Group ID.</param>
            <param name="nObjectID">Specifies Object ID.</param>
            <param name="dwUserData">User-defined data, which can be associated with animation object and retrieved later at runtime.</param>
        </member>
        <member name="M:CAnimationBaseObject.#ctor">
            <summary>
Constructs an animation object.
</summary>
            <remarks>
Constructs an animation objects and assigns default Object ID (0) and Group ID (0).
</remarks>
        </member>
        <member name="F:CAnimationBaseObject.m_pParentController">
            <summary>
A pointer to the parent animation controller.
</summary>
        </member>
        <member name="F:CAnimationBaseObject.m_bAutodestroyTransitions">
            <summary>
Specifies whether related transitions should be automatically destroyed.
</summary>
        </member>
        <member name="F:CAnimationBaseObject.m_dwUserData">
            <summary>
Stores user-defined data.
</summary>
        </member>
        <member name="F:CAnimationBaseObject.m_nObjectID">
            <summary>
Specifes the Object ID of the animation object.
</summary>
        </member>
        <member name="F:CAnimationBaseObject.m_nGroupID">
            <summary>
Specifies the Group ID of the animation object.
</summary>
        </member>
        <member name="T:CAnimationBaseObject">
            <summary>
The base class for all animation objects.
</summary>
            <remarks>
This class implements basic methods for all animation objects. An animation object can represent a value, point,
size, rectangle or color in an application, as well as any custom entity. Animation objects are stored in animation groups
(see CAnimationGroup). Each group can be animated separately and can be treated as an analogue of storyboard.
An animation object encapsulates one or more animation variables (see CAnimationVariable), depending on its logical
representation. For example, CAnimationRect contains four animation variables - one variable for each side of rectangle.
Each animation object class exposes overloaded AddTransition method, which should be used to apply transitions to
encapsulated animation variables.
An animation object can be identified by Object ID (optionally) and by Group ID. A Group ID is necessary in order
to place an animation object to correct group, but if a Group ID is not specified, an object is placed in the default group with ID 0.
If you call SetID with different GroupID, an animation object will be moved to another group (a new group is created if necessary).
</remarks>
        </member>
        <member name="F:CAnimationVariable.m_bAutodestroyTransitions">
            <summary>
Specifies whether related transition objects should be deleted.
</summary>
            <remarks>
Set this value to TRUE to force deletion of transition objects when they are being removed from the internal list
of transitions. If this value is FALSE the transitions should be deleted by calling application.
The list of transitions is always cleared after an animation has been scheduled. The default value is FALSE.
</remarks>
        </member>
        <member name="M:CAnimationVariable.GetDefaultValue">
            <summary>
Returns default value.
</summary>
            <returns>
The default value.
</returns>
            <remarks>
Use this function to obtain default value of animation variable. The default value can be set in constructor or by
SetDefaultValue method.
</remarks>
        </member>
        <member name="M:CAnimationVariable.EnableIntegerValueChangedEvent(CAnimationController*,System.Int32)">
            <summary>
Enables or disables the IntegerValueChanged event.
</summary>
            <remarks>
When ValueChanged event is enabled, the framework calls virtual method CAnimationController::OnAnimationIntegerValueChanged.
You need to override it in a class derived from CAnimationController in order to process this event. This method is called every time
the integer value of animation variable is changed.
</remarks>
            <param name="pController">A pointer to parent controller.</param>
            <param name="bEnable">TRUE - enable event, FALSE - disable event.</param>
        </member>
        <member name="M:CAnimationVariable.EnableValueChangedEvent(CAnimationController*,System.Int32)">
            <summary>
Enables or disables the ValueChanged event.
</summary>
            <remarks>
When ValueChanged event is enabled, the framework calls virtual method CAnimationController::OnAnimationValueChanged.
You need to override it in a class derived from CAnimationController in order to process this event. This method is called every time
the value of animation variable is changed.
</remarks>
            <param name="pController">A pointer to parent controller.</param>
            <param name="bEnable">TRUE - enable event, FALSE - disable event.</param>
        </member>
        <member name="M:CAnimationVariable.ApplyTransitions(CAnimationController*,IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds transitions from the internal list to storyboard.
</summary>
            <remarks>
This method adds transitions from the internal list to storyboard. It's called from the
top level code several times to add transitions that do not depend on keyframes and add
transitions that depend on keyframes. If the underlying animation variable
COM object has not been created, this method creates it at this stage.
</remarks>
            <param name="pController">A pointer to parent animation controller.</param>
            <param name="pStoryboard">A pointer to storyboard.</param>
            <param name="bDependOnKeyframes">TRUE, if this method should add transitions that depend on keyframes.</param>
        </member>
        <member name="M:CAnimationVariable.ClearTransitions(System.Int32)">
            <summary>
Clears transitions.
</summary>
            <remarks>
This method removes all transitions from the internal list of transitions. If bAutodestroy is TRUE, or
m_bAutodestroyTransitions is TRUE, then transitions are deleted. Otherwise the caller should deallocate
the transition objects.
</remarks>
            <param name="bAutodestroy">Specifies whether this method should delete transition objects.</param>
        </member>
        <member name="M:CAnimationVariable.AddTransition(CBaseTransition*)">
            <summary>
Adds a transition.
</summary>
            <remarks>
This method is called to add a transition to the internal list of transitions to be applied to the animation variable.
This list should be cleared when an animation has been scheduled.
</remarks>
            <param name="pTransition">A pointer to a transition to add.</param>
        </member>
        <member name="M:CAnimationVariable.GetValue(System.Int32*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns the current value of animation variable.
</summary>
            <returns>
S_OK if the value was obtained successfully, or underlying animation variable has not been created. Otherwise
HRESULT error code.
</returns>
            <remarks>
This method can be called to retrieve the current value of animation variable. If the underlying COM object
has not been created, dblValue will contain a default value, when the function returns.
</remarks>
            <param name="nValue">The current value of the animation variable.</param>
        </member>
        <member name="M:CAnimationVariable.GetValue(System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>
Returns the current value of animation variable.
</summary>
            <returns>
S_OK if the value was obtained successfully, or underlying animation variable has not been created. Otherwise
HRESULT error code.
</returns>
            <remarks>
This method can be called to retrieve the current value of animation variable. If the underlying COM object
has not been created, dblValue will contain a default value, when the function returns.
</remarks>
            <param name="dblValue">The current value of the animation variable.</param>
        </member>
        <member name="M:CAnimationVariable.CreateTransitions(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Creates all transitions to be applied to this animation variable.
</summary>
            <returns>
TRUE if transitions were created successfully; otherwise FALSE.
</returns>
            <remarks>
This method is called by the framework when it needs to create transitions that have been added
to the variable's internal list of transitions.
</remarks>
            <param name="pLibrary">A pointer to transition library.</param>
            <param name="pFactory">A pointer to transition factory.</param>
        </member>
        <member name="M:CAnimationVariable.Create(IUIAnimationManager*)">
            <summary>
Creates the underlying animation variable COM object.
</summary>
            <returns>
TRUE if the animation variable was successfully created; otherwise FALSE.
</returns>
            <remarks>
This method creates the underlying animation variable COM object and sets its default value.
</remarks>
            <param name="pManager">A pointer to animation manager.</param>
        </member>
        <member name="M:CAnimationVariable.SetDefaultValue(System.Double)">
            <summary>
Sets default value and releases IUIAnimationVariable COM object.
</summary>
            <remarks>
Use this method to reset the default value. This method releases the internal IUIAnimationVariable COM object,
therefore when animation variable is recreated, the underlying COM object gets the new default value.
The default value is returned by GetValue if the COM object representing the animation variable is not created,
or if the variable has not been animated.
</remarks>
            <param name="dblDefaultValue">Specifies the new default value.</param>
        </member>
        <member name="M:CAnimationVariable.GetVariable">
            <summary>
Returns a pointer to IUIAnimationVariable COM object.
</summary>
            <returns>
A valid pointer to IUIAnimationVariable COM object, or NULL if animation variable was not created, or can't be created.
</returns>
            <remarks>
Use this function to access the underlying IUIAnimationVariable COM object and call its methods directly if needed.
</remarks>
        </member>
        <member name="M:CAnimationVariable.GetParentAnimationObject">
            <summary>
Returns the parent animation object.
</summary>
            <returns>
A pointer to parent animation object, if relationship was established, otherwise NULL.
</returns>
            <remarks>
This method can be called to retrieve a pointer to a parent animation object (a container).
</remarks>
        </member>
        <member name="M:CAnimationVariable.Dispose">
            <summary>
The destructor. Called when a CAnimationVariable object is being destroyed.
</summary>
        </member>
        <member name="M:CAnimationVariable.#ctor(System.Double)">
            <summary>
Constructs an animation variable object.
</summary>
            <remarks>
Constructs an animation variable object and sets its default value. A default value is used when
a variable is not animated, or can't be animated.
</remarks>
            <param name="dblDefaultValue">Specifies the default value.</param>
        </member>
        <member name="M:CAnimationVariable.SetParentAnimationObject(CAnimationBaseObject*)">
            <summary>
Sets the relationship between an animation variable and an animation object.
</summary>
            <remarks>
This method is called internally to establish one-to-one relationship between an animation variable and an animation object that encapsulates it.
</remarks>
            <param name="pParentObject">A pointer to an animation object that contains this variable.</param>
        </member>
        <member name="F:CAnimationVariable.m_pParentObject">
            <summary>
A pointer to an animation object that encapsulates this animation variable.
</summary>
        </member>
        <member name="F:CAnimationVariable.m_lstTransitions">
            <summary>
Contains a list of transitions that animate this animation variable.
</summary>
        </member>
        <member name="F:CAnimationVariable.m_dblDefaultValue">
            <summary>
Specifies the default value, which is propagated to IUIAnimationVariable.
</summary>
        </member>
        <member name="F:CAnimationVariable.m_variable">
            <summary>
Stores a pointer to IUIAnimationVariable COM object. NULL if the COM object has not been created yet, or if creation failed.
</summary>
        </member>
        <member name="T:CAnimationVariable">
            <summary>
Represents an animation variable.
</summary>
            <remarks>
The CAnimationVariable class encapsulates IUIAnimationVariable COM object. It also holds a list of transitions
to be applied to the animation variable in a storyboard. CAnimationVariable objects are embedded to
animation objects, which can represent in an application an animated value, point, size, color and rectangle.
</remarks>
        </member>
        <member name="M:CKeyFrame.AddToStoryboardAtOffset(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds a keyframe to storyboard at offset.
</summary>
            <returns>
TRUE, if keyframe was added successfully.
</returns>
            <remarks>
This function is called by the framework to add a keyframe to storyboard at offset.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDeepAdd">Specifies whether to add a keyframe this keyframe depend on recursively.</param>
        </member>
        <member name="M:CKeyFrame.AddToStoryboardAfterTransition(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds a keyframe to storyboard after transition.
</summary>
            <returns>
TRUE, if keyframe was added successfully.
</returns>
            <remarks>
This function is called by the framework to add a keyframe to storyboard after transition.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDeepAdd">Specifies whether to add a transition recursively.</param>
        </member>
        <member name="M:CKeyFrame.AddToStoryboard(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds a keyframe to a storyboard.
</summary>
            <returns>
TRUE, if keyframe was added successfully.
</returns>
            <remarks>
This method adds a keyframe to storyboard. If it depends on other keyframe or transition and bDeepAdd is TRUE,
this method tries to add them recursively.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDeepAdd">Specifies whether to add keyframe or transition recursively.</param>
        </member>
        <member name="M:CKeyFrame.GetOffset">
            <summary>
Returns an offset from other keyframe.
</summary>
            <returns>
An offset in seconds from other keyframe.
</returns>
            <remarks>
This method should be called to determine an offset in seconds from other keyframe.
</remarks>
        </member>
        <member name="M:CKeyFrame.GetExistingKeyframe">
            <summary>
Returns a pointer to a keyframe this keyframe depends on.
</summary>
            <returns>
A valid pointer to keyframe, or NULL if this keyframe does not depend on other keyframe.
</returns>
            <remarks>
This is an accessor to a keyframe this keyframe depends on.
</remarks>
        </member>
        <member name="M:CKeyFrame.GetTransition">
            <summary>
Returns a pointer to a transition this keyframe depends on.
</summary>
            <returns>
A valid pointer to transition, or NULL if this keyframe does not depend on transition.
</returns>
            <remarks>
This is an accessor to a transition this keyframe depends on.
</remarks>
        </member>
        <member name="M:CKeyFrame.#ctor(CBaseKeyFrame*,System.Double)">
            <summary>
Constructs a keyframe that depends on other keyframe.
</summary>
            <remarks>
The constructed keyframe will represent a moment in time within a storyboard, which has a specified offset from pKeyframe.
</remarks>
            <param name="pKeyframe">A pointer to keyframe.</param>
            <param name="offset">Offset, in seconds, from keyframe specified by pKeyframe.</param>
        </member>
        <member name="M:CKeyFrame.#ctor(CBaseTransition*)">
            <summary>
Constructs a keyframe that depends on a transition.
</summary>
            <remarks>
The constructed keyframe will represent a moment in time within a storyboard when the specified transition ends.
</remarks>
            <param name="pTransition">A pointer to a transition.</param>
        </member>
        <member name="F:CKeyFrame.m_pExistingKeyFrame">
            <summary>
Stores a pointer to an existing keframe. This keyframe is added to storyboard with m_offset to the existing keyframe.
</summary>
        </member>
        <member name="F:CKeyFrame.m_offset">
            <summary>
Specifies offset of this keyframe from a keyframe stored in m_pExistingKeyFrame.
</summary>
        </member>
        <member name="F:CKeyFrame.m_pTransition">
            <summary>
Stores a pointer to transtion that begins at this keyframe.
</summary>
        </member>
        <member name="T:CKeyFrame">
            <summary>
Represents an animation keyframe.
</summary>
            <remarks>
This class implements an animation keyframe. A keyframe represents a moment in time within a
storyboard and can be used to specify the start and end times of transitions.
A keyframe may be based on other keyframe and have an offset (in seconds) from it, or may be based on a transition and
represent a moment in time when this transition ends.
</remarks>
        </member>
        <member name="M:CBaseKeyFrame.AddToStoryboard(IUIAnimationStoryboard*,System.Int32)">
            <summary>
Adds a keyframe to storyboard.
</summary>
            <returns>
TRUE if keyframe was added to storyboard successfully; otherwise FALSE.
</returns>
            <remarks>
This method is called to add a keyframe to storyboard.
</remarks>
            <param name="pStoryboard">A pointer to a storyboard.</param>
            <param name="bDeepAdd">If this parameter is TRUE and the keyframe being added depends on some other keyframe or transition, this method tries
to add this keyframe or transition to storyboard first.</param>
        </member>
        <member name="M:CBaseKeyFrame.IsKeyframeAtOffset">
            <summary>
Specifies whether the keyframe should be added to storyboard at offset, or after transition.
</summary>
            <returns>
TRUE if the keyframe should be added to storyboard at some specified offset.
FALSE if the keyframe should be added to storyboard after some transition.
</returns>
            <remarks>
Specifies whether the keyframe should be added to storyboard at offset.
The offset or transition must be specified in a derived class.
</remarks>
        </member>
        <member name="M:CBaseKeyFrame.IsAdded">
            <summary>
Tells whether a keyframe has been added to storyboard.
</summary>
            <returns>
TRUE if a keyframe is added to a storyboard; otehrwise FALSE.
</returns>
            <remarks>
In the base class IsAdded always returns TRUE, but it's overridden in derived classes.
</remarks>
        </member>
        <member name="M:CBaseKeyFrame.GetAnimationKeyframe">
            <summary>
Returns the underlying keyframe value.
</summary>
            <returns>
A current keyframe. The default value is UI_ANIMATION_KEYFRAME_STORYBOARD_START.
</returns>
            <remarks>
This is an accessor to the underlying keyframe value.
</remarks>
        </member>
        <member name="M:CBaseKeyFrame.#ctor">
            <summary>
Constructs a keyframe object.
</summary>
        </member>
        <member name="F:CBaseKeyFrame.m_bIsKeyframeAtOffset">
            <summary>
Specifies whether this keyframe should be added to storyboard at an offset from
another existing keyframe, or at the end of some transition.
</summary>
        </member>
        <member name="F:CBaseKeyFrame.m_bAdded">
            <summary>
Specifies whether this keyframe has been added to a storyboard.
</summary>
        </member>
        <member name="F:CBaseKeyFrame.m_keyframe">
            <summary>
Represents a Windows Animation API keyframe. When a keyframe is not initialized
it is set to the predefined value UI_ANIMATION_KEYFRAME_STORYBOARD_START.
</summary>
        </member>
        <member name="T:CBaseKeyFrame">
            <summary>
Implements basic functionality of keyframe.
</summary>
            <remarks>
Encapsulates UI_ANIMATION_KEYFRAME variable. Serves as a base class for any keyframe implementation.
A keyframe represents a moment in time within a storyboard and can be used to specify the start and end times of transitions.
There are two types of keyframes - keyframes added to storyboard at the specified offset (in time), or keyframes added
after specified transition. Because durations of some transitions can't be known before animation starts, the actual values
of some keyframes are determined at runtime only.
Because keyframes may depend on transitions, which in their turn depend on keyframes, it's important to prevent
infinite recursions when building keyframe chains.
</remarks>
        </member>
        <member name="F:CBaseTransition.m_bAdded">
            <summary>
Specifies whether a transition has been added to a storyboard.
</summary>
        </member>
        <member name="F:CBaseTransition.m_pRelatedVariable">
            <summary>
A pointer to an animation variable, which is animated with the transition stored in m_transition.
</summary>
        </member>
        <member name="F:CBaseTransition.m_pEndKeyframe">
            <summary>
Stores a pointer to the keyframe that specifies the end of the transition.
</summary>
        </member>
        <member name="F:CBaseTransition.m_pStartKeyframe">
            <summary>
Stores a pointer to the keyframe that specifies the beginning of the transition.
</summary>
        </member>
        <member name="F:CBaseTransition.m_transition">
            <summary>
Stores a pointer to IUIAnimationTransition. NULL if a COM transition object has not been created.
</summary>
        </member>
        <member name="F:CBaseTransition.m_type">
            <summary>
Stores the transition type.
</summary>
        </member>
        <member name="M:CBaseTransition.AddToStoryboardAtKeyframes(IUIAnimationStoryboard*)">
            <summary>
Adds a transition to a storyboard.
</summary>
            <returns>
TRUE, if transition was successfully added to a storyboard.
</returns>
            <remarks>
Applies the transition to the related variable in the storyboard. If the start keyframe was specified, the transition
begins at that keyframe. If the end keyframe was specified, the transition begins at the start keyframe and
and stops at the end keyframe. If the transition was created with a duration parameter specified, that duration is
overwritten with the duration of time between the start and end keyframes.
If no keyframe was specified, the transition is appended to the transition added most recently to the variable.
</remarks>
            <param name="pStoryboard">A pointer to storyboard, which will animate the related variable.</param>
        </member>
        <member name="M:CBaseTransition.AddToStoryboard(IUIAnimationStoryboard*)">
            <summary>
Adds a transition to a storyboard.
</summary>
            <returns>
TRUE, if transition was successfully added to a storyboard.
</returns>
            <remarks>
Applies the transition to the related variable in the storyboard.  If this is the first transition
applied to this variable in this storyboard, the transition begins at the start of the storyboard.
Otherwise, the transition is appended to the transition added most recently to the variable.
</remarks>
            <param name="pStoryboard">A pointer to storyboard, which will animate the related variable.</param>
        </member>
        <member name="M:CBaseTransition.GetRelatedVariable">
            <summary>
Returns a pointer to related variable.
</summary>
            <returns>
A valid pointer to animation variable, or NULL if an animation variable has not been set by SetRelatedVariable.
</returns>
            <remarks>
This is an accessor to related animation variable.
</remarks>
        </member>
        <member name="M:CBaseTransition.SetRelatedVariable(CAnimationVariable*)">
            <summary>
Establishes a relationship between animation variable and transition.
</summary>
            <remarks>
Establishes a relationship between animation variable and transition. A transition can be applied only to one variable.
</remarks>
            <param name="pVariable">A pointer to related animation variable.</param>
        </member>
        <member name="M:CBaseTransition.GetEndKeyframe">
            <summary>
Returns start keyframe.
</summary>
            <returns>
A valid pointer to a keyframe, or NULL if a transition should not be inserted between keyframes.
</returns>
            <remarks>
This method can be used to access a keyframe object that was previously set by SetKeyframes.
It's called by top level code when transitions are being added to storyboard.
</remarks>
        </member>
        <member name="M:CBaseTransition.GetStartKeyframe">
            <summary>
Returns start keyframe.
</summary>
            <returns>
A valid pointer to a keyframe, or NULL if a transition should not start after a keyframe.
</returns>
            <remarks>
This method can be used to access a keyframe object that was previously set by SetKeyframes.
It's called by top level code when transitions are being added to storyboard.
</remarks>
        </member>
        <member name="M:CBaseTransition.IsAdded">
            <summary>
Tells whether a transition has been added to a storyboard.
</summary>
            <returns>
Returns TRUE if a transition has been added to a storyboard, otherwise FALSE.
</returns>
            <remarks>
This flag is set internally when the top level code adds transitions to storyboard.
</remarks>
        </member>
        <member name="M:CBaseTransition.SetKeyframes(CBaseKeyFrame*,CBaseKeyFrame*)">
            <summary>
Sets keyframes for a transition.
</summary>
            <remarks>
This method tells the transition to start after specified keyframe and, optionally, if pEnd is not NULL, end
before the specified keyframe.
If the transition was created with a duration parameter specified, that duration is overwritten with the duration of time between the start and end keyframes.
</remarks>
            <param name="pStart">A keyframe that specifies the beginning of the transition. </param>
            <param name="pEnd">A keyframe that specifies the end of the transition.</param>
        </member>
        <member name="M:CBaseTransition.GetTransition">
            <summary>
Returns a pointer to underlying COM transition object.
</summary>
            <returns>
A valid pointer to IUIAnimationTransition or NULL if underlying transition can't be created.
</returns>
            <remarks>
It's an accessor method to underlying COM transition object. It doesn't instantiates the underlying IUIAnimationTransition COM
object if it wasn't created.
</remarks>
        </member>
        <member name="M:CBaseTransition.GetTransition(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Returns a pointer to underlying COM transition object.
</summary>
            <returns>
A valid pointer to IUIAnimationTransition or NULL if underlying transition can't be created.
</returns>
            <remarks>
This method returns a pointer to underlying COM transition object and creates it if necessary.
</remarks>
            <param name="pLibrary">A pointer to transition library, which creates standard transitions. It can be NULL for custom transitions.</param>
            <param name="pFactory">A pointer to transition factory, which creates custom transitions. It can be NULL for standard transitions.</param>
        </member>
        <member name="M:CBaseTransition.Create(IUIAnimationTransitionLibrary*,IUIAnimationTransitionFactory*)">
            <summary>
Creates a COM transition.
</summary>
            <returns>
TRUE if a transition COM object was created successfully; otherwise FALSE.
</returns>
            <remarks>
This is a pure virtual function that must be overridden in a derived class.
It's called by the framework to instantiate the underlying COM transition object.
</remarks>
            <param name="pLibrary">A pointer to transition library, which creates standard transitions. It can be NULL for custom transitions.</param>
            <param name="pFactory">A pointer to transition factory, which creates custom transitions. It can be NULL for standard transitions.</param>
        </member>
        <member name="M:CBaseTransition.GetType">
            <summary>
Returns transition type.
</summary>
            <returns>
One of TRANSITION_TYPE enumerated values.
</returns>
            <remarks>
This method can be used to identify a transition object by its type.
The type is set in a constructor in a derived class.
</remarks>
        </member>
        <member name="M:CBaseTransition.Clear">
            <summary>
Releases encapsulated IUIAnimationTransition COM object.
</summary>
            <remarks>
This method should be called from a derived class's Create method in order to prevent
IUITransition interface leak.
</remarks>
        </member>
        <member name="M:CBaseTransition.Dispose">
            <summary>
The destructor. Called when a transition object is being destroyed.
</summary>
        </member>
        <member name="M:CBaseTransition.#ctor">
            <summary>
Constructs a base transtion object.
</summary>
        </member>
        <member name="T:CBaseTransition.TRANSITION_TYPE">
            <summary>
Defines the transition types currently supported by the MFC implementation of Windows Animation API.
</summary>
            <remarks>
A transition type is set in the constructor of specific transition.
For example, CSinusoidalTransitionFromRange sets its type to SINUSOIDAL_FROM_RANGE.
</remarks>
        </member>
        <member name="T:CBaseTransition">
            <summary>
Represents a basic transition.
</summary>
            <remarks>
This class encapsulates IUIAnimationTransition interface and serves as a base class for all transitions.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.Run">
            <summary>Функция генерации сглаживания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.Spine">
            <summary>Направляющая кривая</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.FlushFacesAndEdges">
            <summary>Функция сбрасывает заданные данные</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.Softness">
            <summary>Коэффициент "мягкости" для сглаживания с непрерывностью по кривизне</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.Ratio">
            <summary>Отношение сторон для сглаживания постоянной ширины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.RF">
            <summary>Радиус сглаживания для сглаживания с постоянным радиусом</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.AddEdgeToBorder(TFlex.Model.Model3D.Geometry.BaseTopol,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Функция добавляет ограничительное ребро в список таких рёбер</summary>
            <param name="edge">Добавляемое ребро</param>
            <param name="invert">Признак использования ребра для задания обратного касания</param>
            <param name="useCliff">Признак использования ребра для задания обрезки</param>
            <param name="invConic">Признак использования ребра для задания обратного конического касания</param>
            <param name="сonic">Признак использования ребра для задания прямого конического касания</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.AddFaceToRightWall(TFlex.Model.Model3D.Geometry.BaseTopol)">
            <summary>Функция добавляет грань в правую стенку</summary>
            <param name="face">Добавляемая грань</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.AddFaceToLeftWall(TFlex.Model.Model3D.Geometry.BaseTopol)">
            <summary>Функция добавляет грань в левую стенку</summary>
            <param name="face">Добавляемая грань</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D,TFlex.Model.Model3D.Geometry.Body,System.Boolean,System.Boolean,TFlex.Model.Model3D.Geometry.TFBlendMode,TFlex.Model.Model3D.Geometry.TFCutMode,TFlex.Model.Model3D.Geometry.TFPlaneOrientation)">
            <summary>Конструктор для задания базовых объектов сглаживания</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <param name="body">Тело на котором строится сглаживание</param>
            <param name="leftSense">Параметр ориентации левой стенки</param>
            <param name="rightSense">Параметр ориентации правой стенки</param>
            <param name="bm">Режим сглаживания</param>
            <param name="cm">Режим обрезки результата</param>
            <param name="po">Режим ориентации плоскости сечения сглажиавния</param>
            <remarks>3D объект внешнего приложения должен быть связан с внешним объектом</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.FaceFaceBlendGenerator">
            <summary>Генератор сглаживания граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TFPlaneOrientation">
            <summary>Режимы ориентации плоскости сглаживания</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFPlaneOrientation.isoparamblend">
            <summary>isoparamblend - по касательной к изолиниям левой стенки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFPlaneOrientation.diskblend">
            <summary>diskblend - параллельно осевой кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFPlaneOrientation.rollblend">
            <summary>rollblend - ориентация "катящегося шарика" - перпендикулярно обоим стенкам</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TFCutMode">
            <summary>Режимы обрезки граней при сглаживании</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFCutMode.cutnone">
            <summary>cutnone - без обрезки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFCutMode.wallstrimjoint">
            <summary>wallstrimjoint - обрезать стенки и сшить всё но твёрдое тело не образовывать</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFCutMode.wallstrimboth">
            <summary>wallstrimboth - обрезать стенки и не сшивать</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFCutMode.wallstrimyes">
            <summary>wallstrimyes - обрезать стенки и сшить всё в тело</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFCutMode.shortwall">
            <summary>shortwall - обрезать по короткой стенке</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFCutMode.longwall">
            <summary>longwall - обрезать по длинной стенке</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFCutMode.bothwalls">
            <summary>bothwalls - обрезать по обеим стенкам</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TFBlendMode">
            <summary>Режимы сглаживания</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBlendMode.notchyes">
            <summary>notchyes - скругление с обработкой выреза</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBlendMode.propyes">
            <summary>propyes - скругление с продолжением на гладкосопряжённые грани</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBlendMode.g2continuous">
            <summary>g2continuous - скругление непрерывное по кривизне</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBlendMode.constwidth">
            <summary>constwidth - скругление постоянной ширины</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBlendMode.rounding">
            <summary>rounding - скругление постоянного радиуса</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.TFBlendMode.chamfering">
            <summary>chamfering - фаска</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BodyGenerator.Result">
            <summary>Получить множество результирующих тел</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BodyGenerator.ResultBodies.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BodyGenerator.ResultBodies.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BodyGenerator.ResultBodies.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BodyGenerator.ResultBodies.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BodyGenerator.ResultBodies.default(System.Int32)">
            <summary>Получить тело по номеру</summary>
            <param name="index">Номер тела</param>
            <remarks>Тела нумеруются от нуля. Если индекс отрицательный или превышает количество тел, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BodyGenerator.ResultBodies.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BodyGenerator.ResultBodies">
            <summary>Множество результирующих тел. Возможно перечисление тел с использованием конструкции foreach</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BodyGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D)">
            <summary>Конструктор для задания генератора</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <remarks>Ссылка на 3D объект внешнего приложения является обязательным параметром.
3D объект внешнего приложения должен быть связан с внешним объектом.</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BodyGenerator">
            <summary>Базовый класс для генераторов тел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseGenerator.LastResult">
            <summary>Результат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseGenerator.Run">
            <summary>Основная функция генерации геометрических результатов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseGenerator.Proxy">
            <summary>Получить внешнее приложение, для которого генерируется результат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseGenerator.#ctor(TFlex.Model.Model3D.ProxyObject3D)">
            <summary>Конструктор для задания генератора</summary>
            <param name="object">3D объект внешнего приложения, для которого генерируется результат</param>
            <remarks>Ссылка на 3D объект внешнего приложения является обязательным параметром.
3D объект внешнего приложения должен быть связан с внешним объектом.</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseGenerator">
            <summary>Базовый класс для всех генераторов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.DecorationManager.Owner">
            <summary>Документ, соответствующий диспетчеру</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationManager.RemoveAllDecorations">
            <summary>Удаление всех декораций</summary>
            <remarks>
После удаления декорации из диспетчера обращение к ней недопустимо. Метод Dispose() вызывается автоматически при удалении декорации.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationManager.RemoveDecoration(System.String)">
            <summary>Удаление декорации</summary>
            <remarks>
После удаления декорации из диспетчера обращение к ней недопустимо. Метод Dispose() вызывается автоматически при удалении декорации.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationManager.GetDecoration(System.String)">
            <summary>Поиск декорации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationManager.AddDecoration(TFlex.Model.Model3D.Visual.Decoration)">
            <summary>Регистрация декорации</summary>
            <remarks>
Недопустимо регистрировать декорацию более одного раза. Декорации, связанные с манипулятором, не надо регистрировать. Для зарегистрированной декорации Dispose() вызывается автоматически.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationManager.GetManager(TFlex.Model.Document)">
            <summary>Получение диспетчера для соответствующего документа</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationManager">
            <summary>Диспетчер декораций</summary>
            <remarks>Для того, чтобы декорация стала видимой, ее нужно добавить в диспетчер соответствующего документа</remarks>
            <seealso cref="T:TFlex.Model.Model3D.Visual.Decoration" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DraggerManager" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationContainer.GetEnumerator">
            <summary>Реализация интерфейса IEnumerable</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationContainer.IsEmpty">
            <summary>Проверка пустоты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationContainer.RemoveAllDecorations">
            <summary>Удаление всех декораций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationContainer.GetDecoration(System.String)">
            <summary>Поиск декорации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationContainer.RemoveDecoration(System.String)">
            <summary>Удаление декорации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationContainer.AddDecoration(TFlex.Model.Model3D.Visual.Decoration)">
            <summary>Добавление декорации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationContainer.#ctor(System.String)">
Конструктор
<param name="name">Имя должно быть уникальным</param></member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationContainer">
            <summary>Контейнер декораций</summary>
            <remarks>Позволяет группировать несколько декораций
Не допускается модифицировать контейнер декораций, который был получен от системы, а не создан явным образом.</remarks>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationShape" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationNURBS.#ctor(System.String,TFlex.Model.Model3D.Geometry.BasePoint3D[],System.Double[])">
            <summary>Конструктор</summary>
            <param name="name">Имя должно быть уникальным</param>
            <param name="controlPoints">Определяющие точки</param>
            <param name="knots">Узловой вектор</param>
            <remarks />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationNURBS.#ctor(System.String,TFlex.Model.Model3D.Geometry.BasePoint3D[],System.Double[],System.Double[])">
            <summary>Конструктор</summary>
            <param name="name">Имя должно быть уникальным</param>
            <param name="controlPoints">Определяющие точки</param>
            <param name="weights">Веса точек</param>
            <param name="knots">Узловой вектор</param>
            <remarks>
Число элементов массивов weights и controlPoints должно совпадать
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationNURBS.#ctor(System.String,TFlex.Model.Model3D.FloatVector[],System.Single[])">
            <summary>Конструктор</summary>
            <param name="name">Имя должно быть уникальным</param>
            <param name="controlPoints">Определяющие точки</param>
            <param name="knots">Узловой вектор</param>
            <remarks />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationNURBS.#ctor(System.String,TFlex.Model.Model3D.FloatVector[],System.Single[],System.Single[])">
            <summary>Конструктор</summary>
            <param name="name">Имя должно быть уникальным</param>
            <param name="controlPoints">Определяющие точки</param>
            <param name="weights">Веса точек</param>
            <param name="knots">Узловой вектор</param>
            <remarks>
Число элементов массивов weights и controlPoints должно совпадать
</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationNURBS">
            <summary>NURBS кривая</summary>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationContainer" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationCircleArc.#ctor(System.String,TFlex.Model.Model3D.Geometry.BaseAxis,TFlex.Model.Model3D.FloatVector,System.Double)">
            <summary>Конструктор</summary>
            <value>
Создает дугу окружности по оси, началу дуги и углу
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="axis">Ось</param>
            <param name="start">Начало дуги</param>
            <param name="angle">Угол поворота в градусах</param>
            <remarks />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationCircleArc.#ctor(System.String,TFlex.Model.Model3D.FloatVector,TFlex.Model.Model3D.FloatVector,TFlex.Model.Model3D.FloatVector,System.Double)">
            <summary>Конструктор</summary>
            <value>
Создает дугу окружности по центру, направлению оси, началу дуги и углу
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="center">Центр окружности</param>
            <param name="axis">Направление оси</param>
            <param name="start">Начало дуги</param>
            <param name="angle">Угол поворота в градусах</param>
            <remarks />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationCircleArc.#ctor(System.String,TFlex.Model.Model3D.FloatVector,TFlex.Model.Model3D.FloatVector,TFlex.Model.Model3D.FloatVector)">
            <summary>Конструктор</summary>
            <value>
Создает дугу окружности по центру, началу и концу дуги
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="center">Центр окружности</param>
            <param name="start">Начало дуги</param>
            <param name="end">Конец дуги</param>
            <remarks />
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationCircleArc">
            <summary>Дуга окружности</summary>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationContainer" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationCircle" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationCircle.#ctor(System.String,TFlex.Model.Model3D.Geometry.BaseAxis,System.Double)">
            <summary>Конструктор</summary>
            <value>
Создает окружность по оси и радиусу
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="axis">Ось окружности</param>
            <param name="radius">Радиус окружности</param>
            <remarks />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationCircle.#ctor(System.String,TFlex.Model.Model3D.FloatVector,TFlex.Model.Model3D.FloatVector,System.Double)">
            <summary>Конструктор</summary>
            <value>
Создает окружность по центру, направлению оси и радиусу
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="center">Центр окружности</param>
            <param name="axis">Направление оси</param>
            <param name="radius">Радиус окружности</param>
            <remarks />
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationCircle">
            <summary>Окружность</summary>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationContainer" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationCircleArc" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationPoint.#ctor(System.String,TFlex.Model.Model3D.FloatVector,System.Single)">
            <summary>Конструктор</summary>
            <value>
Создает точку
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="coords">Координаты точки</param>
            <param name="size">Размер точки</param>
            <remarks />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationPoint.#ctor(System.String,TFlex.Model.Model3D.FloatVector)">
            <summary>Конструктор</summary>
            <value>
Создает точку
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="coords">Координаты точки</param>
            <remarks />
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationPoint">
            <summary>Точка</summary>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationContainer" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationPoint" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationLine.#ctor(System.String,TFlex.Model.Model3D.FloatVector,TFlex.Model.Model3D.FloatVector)">
            <summary>Конструктор</summary>
            <value>
Создает отрезок
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="startPoint">Начало отрезка</param>
            <param name="endPoint">Конец отрезка</param>
            <remarks />
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationLine">
            <summary>Отрезок</summary>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationContainer" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationLine" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationPolyline.#ctor(System.String,TFlex.Model.Model3D.Geometry.BasePoint3D[])">
            <summary>Конструктор</summary>
            <value>
Создает ломаную из массива точек
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="points">Массив координат</param>
            <remarks />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationPolyline.#ctor(System.String,TFlex.Model.Model3D.FloatVector[])">
            <summary>Конструктор</summary>
            <value>
Создает ломаную из массива точек
</value>
            <param name="name">Имя должно быть уникальным</param>
            <param name="points">Массив координат</param>
            <remarks />
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationPolyline">
            <summary>Ломаная</summary>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationContainer" />
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.DecorationShape.Pattern">
            <summary>Установка стиля линии</summary>
            <param name="pattern">Используются младшие 16 бит. 1 соответствует закрашиваемому участку линии, 0 - прозрачному.</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.DecorationShape.UsePattern">
            <summary>Установка использования стиля линии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.DecorationShape.LineWidth">
            <summary>Установка толщины линий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Visual.DecorationShape.Color">
            <summary>Цвет</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.DecorationShape.#ctor(System.String)">
            <summary>Конструктор</summary>
            <param name="name">Имя должно быть уникальным</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.DecorationShape">
            <summary>Декорация-изображение</summary>
            <value>
Базовый класс для всех декораций, которые хранят данные об изображениях
</value>
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />
            <seealso cref="T:TFlex.Model.Model3D.Visual.DecorationContainer" />
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Decoration.#ctor(System.String)">
Конструктор
</member>
        <member name="P:TFlex.Model.Model3D.Visual.Decoration.Name">
            <summary>Имя декорации</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Decoration">
            <summary>Декорация</summary>
            <value>
Декорации выводятся в 3D окнах поверх всех модельных объектов.
</value>
            <remarks>
Чтобы декорация стала изображаться, необходимо после создания добавить ее в 
<see cref="T:TFlex.Model.Model3D.Visual.DecorationManager" />, диспетчер декораций
или связать с <see cref="T:TFlex.Model.Model3D.Visual.Dragger" />, манипулятором.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Scene.GetScene(TFlex.Model.Document)">
            <summary>Возвращает сцену, принадлежащую данному документу</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Scene.Remove(TFlex.Model.Model3D.Visual.ObjectRepresentation)">
            <summary>Удаление узла</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Scene.Add(TFlex.Model.Model3D.Visual.ObjectRepresentation)">
            <summary>Добавление узла в сцену</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Scene.Find(TFlex.Model.Model3D.Object3D)">
            <summary>Поиск узла, соответствующего данному объекту</summary>
            <remarks>Возвращает null в случае, если объект не представлен в сцене</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Scene">
            <summary>Класс обеспечивает доступ к трёхмерной сцене документа</summary>
            <remarks>Сцена представляет из себя набор узлов, каждый из которых является изображением одного из трёхмерных модельных объектов</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.CurrentObject">
            <summary>Объект, выбранный под мышкой</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.GetDefaultParameters">
            <summary>Получить параметры 3D вида по умолчанию для новых видов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.SetDefaultParameters(TFlex.Model.Model3D.View3D.Parameters)">
            <summary>Установить параметры 3D вида по умолчанию для новых видов</summary>
            <param name="params">Параметры 3D вида</param>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.GetParameters">
            <summary>Получить параметры 3D вида</summary>
            <returns>Параметры 3D вида</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.SetParameters(TFlex.Model.Model3D.View3D.Parameters)">
            <summary>Установить параметры 3D вида</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.Parameters.Clone">
            <summary>Возвращает копию объекта</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.ShowLCS">
            <summary>Показывать систему координат</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.AutoResize">
            <summary>Автоматический подбор размеров окна</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.Lights">
            <summary>Параметры освещения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.ShowConstructions">
            <summary>Показывать элементы построения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.BackgroundBottomColor">
            <summary>Цвет нижней части фона окна</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.BackgroundTopColor">
            <summary>Цвет верхней части фона окна</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.Parameters.Translation(System.Int32)">
            <summary>Смещение камеры</summary>
            <remarks>Индекс должен быть от 0 до 1</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.Parameters.Viewpoint(System.Int32)">
            <summary>Точка взгляда</summary>
            <remarks>Индекс должен быть от 0 до 2</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.Angle">
            <summary>Угол поворота камеры</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.ScalePercent">
            <summary>Масштаб (используется только в параллельной проекции)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.CameraDistance">
            <summary>Расстояние от камеры до центра сцены (используется только в перспективной проекции)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.PerspectiveAngle">
            <summary>Угол обзора (используется только в перспективной проекции)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.CameraType">
            <summary>Тип проекции</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.Parameters.DrawStyle">
            <summary>Стиль изображения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.Parameters.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.Parameters">
            <summary>Параметры 3D вида</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.LightParameters.Clone">
            <summary>Возвращает копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.LightParameters.AddDirectionalLight(TFlex.Model.Model3D.View3D.DirectionalLight)">
            <summary>Добавляет новый источник света</summary>
            <param name="value">Новый источник света</param>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.LightParameters.DeleteDirectionalLight(System.Int32)">
            <summary>Удаляет источник света с заданным индексом</summary>
            <param name="index">Индекс источника света</param>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.LightParameters.DirectionalLight(System.Int32)">
            <summary>Направленный источник света с заданным индексом</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.LightParameters.NumDirectionalLights">
            <summary>Количество направленных источников света</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.LightParameters.EnvironmentLight">
            <summary>Параметры рассеянного освещения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.LightParameters.#ctor">
            <summary>Конструктор по умолчанию</summary>
            <remarks>Создаётся один направленный источник света с параметрами по умолчанию</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.LightParameters">
            <summary>Параметры освещения 3D вида</summary>
            <remarks>Освещение складывается из рассеянного освещения и направленных источников света.
Наличие направленных источников необязательно.
Их максимальное число зависит от используемой видеокарты и драйверов OpenGL.</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.EnvironmentLight.Color">
            <summary>Цвет</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.EnvironmentLight.Intensity">
            <summary>Интенсивность (диапазон 0 - 1)</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.EnvironmentLight">
            <summary>Параметры рассеянного освещения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DirectionalLight.Direction">
            <summary>Направление</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DirectionalLight.Color">
            <summary>Цвет</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DirectionalLight.Intensity">
            <summary>Интенсивность (диапазон 0 - 1)</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.DirectionalLight">
            <summary>Параметры направленного источника света</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.CameraType.Perspective">
            <summary>Перспективная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.CameraType.Orthographic">
            <summary>Параллельная</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.CameraType">
            <summary>Тип проекции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.DrawStyle.AreFaceEdgesShown">
            <summary>Возвращает true в случае, когда в текущем режиме задана опция "показывать рёбра"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.DrawStyle.IsHiddenLine">
            <summary>Возвращает true в случае, когда задан один из режимов удаления невидимых линий</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.DrawStyle.IsWireframe">
            <summary>Возвращает true в случае, когда задан режим проволочной модели или удаления невидимых линий</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.DrawStyle.IsFilled">
            <summary>Возвращает true в случае, когда задан режим тоновой закраски или тоновой закраски с материалами</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.DrawStyle.SemitransparentMode">
            <summary>Полупрозрачный режим</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.PrecisehiddenOptions">
            <summary>Дополнительные опции режима с точным удалением скрытых линий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.HiresOptions">
            <summary>Дополнительные опции режима тоновой закраски с материалами</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.QuickhiddenOptions">
            <summary>Дополнительные опции режима с быстрым удалением скрытых линий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.WireframeOptions">
            <summary>Дополнительные опции режима проволочной модели</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.ShadingOptions">
            <summary>Дополнительные опции режима тоновой закраски</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.CurrentStyle">
            <summary>Основной стиль изображения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.HiddenOptions.ShowSilhouettes">
            <summary>Показывать очерковые линии</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.HiddenOptions.ShowHidden">
            <summary>Показывать невидимые ребра пунктиром</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.DrawStyle.HiddenOptions">
            <summary>Дополнительные опции режимов с удалением скрытых линий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.WireOptions.ShowSilhouettes">
            <summary>Показывать очерковые линии</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.DrawStyle.WireOptions">
            <summary>Дополнительные опции режима проволочной модели</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.FilledOptions.ShowFaceting">
            <summary>Показывать разбиение на треугольники</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.FilledOptions.ShowSilhouettes">
            <summary>Показывать очерковые линии</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.FilledOptions.ShowHiddenEdges">
            <summary>Показывать невидимые рёбра пунктиром</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.FilledOptions.ShowEdges">
            <summary>Показывать рёбра тел</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.DrawStyle.FilledOptions">
            <summary>Дополнительные опции режимов тоновой закраски</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.Style.PreciseHidden">
            <summary>Точное удаление невидимых линий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.Style.Hires">
            <summary>Тоновая закраска с материалами</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.Style.QuickHidden">
            <summary>Быстрое удаление невидимых линий</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.Style.Wireframe">
            <summary>Проволочная модель</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.View3D.DrawStyle.Style.Shading">
            <summary>Тоновая закраска</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.DrawStyle.Style">
            <summary>Основной стиль изображения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D.DrawStyle">
            <summary>Стиль изображения в 3D окне</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.Pick(System.Int32,System.Int32,System.Single,TFlex.Model.Model3D.Visual.Decoration,TFlex.Model.Model3D.FloatVector@)">
            <summary>Ищет точку на декорации по заданным экранным координатам</summary>
            <param name="x">Экранная координата X</param>
            <param name="y">Экранная координата Y</param>
            <param name="tolerance">Допустимое расстояние в пикселях от точки на экране до декорации</param>
            <param name="decorationRoot">Декорация, на которой ведется поиск</param>
            <param name="closestPoint">Найденная ближайшая точка на декорации</param>
            <returns>Декорация, которой непосредственно принадлежит найденная точка. Отличается от decorationRoot в случае, если decorationRoot - контейнер декораций. NULL в случае, если точка не найдена.</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.RecommendedDraggerStep">
            <summary>Возвращает рекомендованное значение шага манипулятора при текущем приближении</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.DecorationScale">
            <summary>Возвращает коэффициент, используемый для определения шага манипуляторов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.PointToRay(System.Int32,System.Int32,TFlex.Model.Model3D.FloatVector@,TFlex.Model.Model3D.FloatVector@)">
            <summary>Преобразует точку на экране в луч в координатах модели</summary>
            <param name="x">Абцисса точки на экране</param>
            <param name="y">Ордината точки на экране</param>
            <param name="rayStart">Исходная точка луча</param>
            <param name="rayDir">Направление луча</param>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.ShowObject(TFlex.Model.Model3D.Object3D)">
            <summary>Изменить масштаб изображения, чтобы показать объект</summary>
            <param name="object">Объект, который требуется показать</param>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.DeactivateWorkplane">
            <summary>Завершает режим черчения на рабочей плоскости.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.ActivateWorkplane(TFlex.Model.Model3D.Workplane)">
            <summary>Переводит окно в режим черчения на рабочей плоскости.</summary>
            <param name="workplane">Рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.MoveCameraToContainPoints(TFlex.Model.Model3D.FloatVector[],System.Double,System.Boolean)">
            <summary />
            <param name="points">Массив точек</param>
            <param name="margin" />
            <param name="perspectiveAngleChange" />
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.ZoomAll">
            <summary>Показать все объекты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.ZoomOut">
            <summary>Уменьшить изображение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.ZoomIn">
            <summary>Увеличить изображение</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.Zoom(System.Double)">
            <summary>Увеличить или уменьшить изображение</summary>
            <param name="ratio">Коэффициент увеличения</param>
            <remarks>Например, 2.0 соответствует увеличению в 2 раза, 0.5 - уменьшению в 2 раза</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.View3D.FindBoundBox">
            <summary>Получить границы 3D сцены</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.View3D.Scene">
            <summary>Сцена, изображаемая в этом виде</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.View3D">
            <summary>Данный класс представляет собой 3D вид документа</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TopolArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TopolArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TopolArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TopolArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TopolArray.DeleteAll">
            <summary>Удалить все элементы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TopolArray.Delete(System.Int32)">
            <summary>Удалить элемент по номеру</summary>
            <param name="Index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество элементов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.TopolArray.Add(TFlex.Model.Model3D.Geometry.ModelTopol)">
            <summary>Добавить элемент в конец списка</summary>
            <param name="geom">Добавляемый элемент</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TopolArray.Insert(System.Int32,TFlex.Model.Model3D.Geometry.ModelTopol)">
            <summary>Вставить элемент перед номером</summary>
            <param name="Index">Номер элемента</param>
            <param name="geom">Вставляемый элемент</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество элементов, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.TopolArray.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TopolArray.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="Index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество элементов, то результат не определён</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.TopolArray">
            <summary>Множество топологиеских данных</summary>
            <remarks>Возможно перечисление топологических элементов с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.TopolReference.GeometryType">
            <summary>Тип геометрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TopolReference.Topol">
            <summary>Получить топологический элемент модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TopolReference.GroupType">
            <summary>Тип элемента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TopolReference.Owner">
            <summary>Владелец</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TopolReference">
            <summary>Базовый класс для всех типов ссылок на топологию</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTopol.Name">
            <summary>Название элемента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTopol.BaseBody">
            <summary>Получить модельное тело, в котором определён элемент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTopol.Body">
            <summary>Получить модельное тело, в котором определён элемент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTopol.ExistentReference">
            <summary>Возвращается ссылка, если она существует</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelTopol.CreateReference(TFlex.Model.Document)">
            <summary>Создать ссылку в целевом документ (создается либо топологическая ссылка, либо ссылочный элемент на топологию)</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelTopol.CreateReference">
            <summary>Создать ссылку (создается либо топологическая ссылка, либо ссылочный элемент на топологию)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTopol.Reference">
            <summary>Если ссылки не существует, то она создаётся</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelTopol.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTopol.Owner">
            <summary>Получить родительскую операцию</summary>
            <returns>Объект класса, которому принадлежит геометрический элемент</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTopol.Box">
            <summary>Получить границы элемента</summary>
            <returns>Объект, хранящий границы и ссылку на эти геометрические данные элемента</returns>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelTopol">
            <summary>Базовый класс для модельных граней, циклов, рёбер и вершин</summary>
            <remarks>Для двух элементов поддерживается функция сравнения</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Topol.BaseBody">
            <summary>Получить геометрическое тело, в котором определён элемент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Topol.Body">
            <summary>Получить геометрическое тело, в котором определён элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Topol.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Topol">
            <summary>Базовый класс для геометрических граней, циклов, рёбер и вершин</summary>
            <remarks>Для двух элементов поддерживается функция сравнения</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseTopol.Identify">
            <summary>Уникальный идентификатор элемента</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseTopol.FindExtreme(TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Найти экстремальную точку на элементе в заданном направлении</summary>
            <param name="direction1">Направление 1</param>
            <param name="direction2">Направление 2</param>
            <param name="direction3">Направление 3</param>
            <remarks>Экстремальная точка на элементе ищется в направлении 1. Если решение неоднозначное, то количество экстремальных точек последовательно редуцируется по направлениям 2 и 3</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseTopol.RangeTopol(TFlex.Model.Model3D.Geometry.BaseTopol)">
            <summary>Найти ближайшие расстояние между двумя топологическими элементами</summary>
            <param name="rhs">Топологический элемент</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseTopol.RangePoint(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Найти ближайшую точку на элементе к данной точке</summary>
            <param name="point">Точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseTopol.FindBoundBox">
            <summary>Получить границы элемента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseTopol.BaseBody">
            <summary>Получить тело, в котором определён элемент</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseTopol">
            <summary>Базовый класс для всех типов (модельных и геометрических) граней, циклов, рёбер и вершин</summary>
            <remarks>Для двух элементов поддерживается функция сравнения</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.RangeResult2.Distance">
            <summary>Длина отрезка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.RangeResult2.Coord2">
            <summary>Вторая точка отрезка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.RangeResult2.Coord1">
            <summary>Первая точка отрезка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.RangeResult2">
            <summary>Класс отрезка между двумя телами</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.GeometryType">
            <summary>Тип геометрии</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.GeometryType.Face">
            <summary>Грань</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.GeometryType.Loop">
            <summary>Цикл</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.GeometryType.Edge">
            <summary>Ребро</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.GeometryType.Vertex">
            <summary>Вершина</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.GeometryType.Undefined">
            <summary>Неопределённый тип</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Box.Maximum">
            <summary>Получить точку максимальных границ</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Box.Minimum">
            <summary>Получить точку минимальных границ</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Box.#ctor(TFlex.Model.Model3D.Geometry.BaseBox)">
            <summary>Конструктор для создания границы как копии другой границы</summary>
            <param name="box">Граница, c которой копируются свойства для данной границы</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Box.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конструтор для создания границы по двум точкам</summary>
            <param name="minimum">Точка минимальных границ</param>
            <param name="maximum">Точка максимальных границ</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Box">
            <summary>Геометрические границы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelBox.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной границы. Модельные границы не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelBox">
            <summary>Класс границ с модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBox.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конструктор для границ</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBox.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельных границ</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBox.Update">
            <summary>Обновить геометрию для каждого конкретного порождённого типа</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBox.Maximum">
            <summary>Получить точку максимальных границ</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBox.Minimum">
            <summary>Получить точку минимальных границ</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseBox">
            <summary>Базовый класс для границ</summary>
        </member>
        <member name="M:CTFTransformationsConverter.ChangeFixFragmentOnLayout(CTFTransfObj*,EuclideanWorkplane*,System.Boolean,System.Boolean)">
Привязка по планировке
</member>
        <member name="T:CFragmentEngine3DPicture">
Класс управления картинками, участвующими в проекционной связи
</member>
        <member name="M:CFragmentEngine3D.GetTargetCS">
Получить целeвую систему координат привязки 3D фрагмента
</member>
        <member name="M:CFragmentEngine3D.FindLastPlaneFix(TFDocRegenContext*,CFragment*,CTFBaseTransfManager*)">
Если преобразование на странице планировочного 2D фрагмента было последним в списке преобразований 3D фрагмента, то оно возвращается
</member>
        <member name="M:CFragmentEngine3D.FindDirection(TFDocRegenContext*,TFReference.LayoutProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFReference.LayoutProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Определение оси, по которой может двигаться второй планировочный фрагмент: true - по X, false - по Y
</member>
        <member name="M:CFragmentEngine3D.DegreesOfFreedom(TFDocRegenContext*,FRAGMENT!System.Runtime.CompilerServices.IsConst*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="T:CFragmentEngine3D">
Класс управления 2D-фрагментом
</member>
        <member name="T:CFragmentEngine2D">
Класс для хранения связи с 3D-фрагментом, если 2D-фрагмент читается в 2D-версии
</member>
        <member name="M:CFragmentEngine.CanAssignCoordsFromBinding">
Если привязка 3D фрагмента задаётся в 3D, то координаты точек привязки на 2D игнорируются
</member>
        <member name="M:CFragmentEngine.AssignCoordsFromBinding(TFDocRegenContext*,CFragment*)">
В настоящий момент возвращаются точки, задающие целевую систему координат
Сама целевая система может быть агрегирована в преобразование 3D фрагмента или быть объектом сборочной модели
</member>
        <member name="M:CFragmentEngine.GetBindingParents(CParentsArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Существуют внешние переменные, значения которых задаются параметрами объектов, задающих положение 3D фрагмента в сборке
{
В этом случае 2D фрагмент в режиме 3D пересчета должен пересчитываться после пересчета объектов, задающих положение 3D фрагмента в сборке
</member>
        <member name="M:CFragmentEngine.Is3DTransform">
Преобразование задаётся в 3D. У планировки нет совего дополнительного преобразования
</member>
        <member name="M:CFragmentEngine.OnPlaneMovement(TFDocRegenContext*,CFragment*,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Дополнительное перемещение 3D фрагмента задаётся 2D преобразованием системы координат страницы рабочей плоскости планировки
В этом случае метод возвращает проекцию точки системы координат на плоскость планировки
</member>
        <member name="M:CFragmentEngine.TransformFragment(TFDocRegenContext*,FRAGMENT*,System.Double,System.Double,ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Перемещение фрагмента
Метод редактирует порядок планировок при расчете положения Фрагмента и изменяет дополнительные преобразования в случае несобственных перемещений
Метод возвращает true, если был открыт undo-блок
</member>
        <member name="M:CFragmentEngine.RepositionFragment(TFDocRegenContext*,FRAGMENT*,CEditFragment*)">
Метод редактирует порядок планировок при расчете положения Фрагмента и изменяет дополнительные преобразования в случае несобственных перемещений
Метод возвращает true, если был открыт undo-блок
</member>
        <member name="M:CFragmentEngine.DegreesOfFreedom(TFDocRegenContext*,FRAGMENT!System.Runtime.CompilerServices.IsConst*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="M:CFragmentEngine.Draw(FRAGMENT*,TFGC*,TFDocRegenContext*)">
true - если 2D-фрагмент рисуется средствами аггрегированной проекции
false - 2D-фрагмент рисуется базовыми средствами рисования 2D-фрагментов
</member>
        <member name="M:CFragmentEngine.ReplaceParent(ReplaceParentStruct*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Расчет координат вектора привязки на 2D, если задан вектор и рабочая плоскость фрагмента при вставке в сборку параллельна рабочей плоскости сборки
</member>
        <member name="F:FailedFragmentUsedIn3DOnly">
- нет доступа к 3D-фрагменту. Например, документ открыт в режиме чтения только 2D-данных;
- это 3D-картинка, у которой нет информации о сборке;
- у 3D фрагмента нет информации о сборке. Например, фрагмент в момент его создания ещё не пересчитан
</member>
        <member name="T:CFragmentEngine.AssemblyNodeResult">
Результат получения корневого узла
</member>
        <member name="T:CFragmentEngine">
Базовый класс для управления набором связанных проекционной связью 2D-фрагментов
</member>
        <member name="T:Layout.WayToMove">
Способ перемещения
</member>
        <member name="T:Layout.RestrictionOnTheWayToMove">
Ограничение на способ перемещения
</member>
        <member name="T:Layout.FixingMode">
Способ проецирования
</member>
        <member name="M:filtering.Filter.Parse(ATL.CStringT&lt;System.Char,StrTraitMFC_DLL&lt;System.Char,ATL.ChTraitsCRT{System.Char}&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,filtering.Term!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Перобразовывает заданное строковое представление фильтра в эквивалентный ему объект фильтра</summary>
            <param name="str">Строковое представление фильтра</param>
            <param name="templateTerm">шаблон выражения</param>
            <returns>Фильтр, эквивалентный указанному строковому представлению</returns>
        </member>
        <member name="M:filtering.Filter.ToString">
            <summary>Возвращает строковое представление фильтра</summary>
            <returns>Строковое представление фильтра</returns>
        </member>
        <member name="M:filtering.Filter.Match(filtering.IFilteringObject*)">
            <summary>Возвращает значение, указывающее, соответствует ли указанный объект условиям фильтра</summary>
            <param name="pObject">Объект для проверки</param>
            <returns>Значение true, если объект соответствует условиям фильтра; в противном случае - значение false</returns>
        </member>
        <member name="M:filtering.Filter.IsValid">
            <summary>Возвращает значение, указывающее, является ли фильтр допустимым</summary>
            <returns>Значение true, если фильтр является допустимым; в противном случае - значение false</returns>
        </member>
        <member name="M:filtering.Filter.GetTerms">
            <summary>Возвращает корневую группу условий фильтра</summary>
        </member>
        <member name="M:filtering.TermGroup.RemoveItemAt(System.Int32)">
            <summary>Удаляет из текущей группы условий элемент с указанным индексом</summary>
            <param name="index">Индекс элемента в группе</param>
        </member>
        <member name="M:filtering.TermGroup.Insert(System.Int32,filtering.TermGroupItem*)">
            <summary>Добавляет в текущую группу условий указанный элемент по заданному индексу</summary>
            <param name="index">Индекс, по которому следует вставить элемент</param>
            <param name="pItem">Элемент, добавляемый в группу условий</param>
        </member>
        <member name="M:filtering.TermGroup.ToString">
            <summary>Возвращает строковое представление группы условий</summary>
            <returns>Строковое представление группы условий</returns>
        </member>
        <member name="M:filtering.TermGroup.Match(filtering.IFilteringObject*)">
            <summary>Возвращает значение, указывающее, соответствует ли указанный объект условиям группы</summary>
            <param name="pObject">Объект для проверки</param>
            <returns>Значение true, если объект соответствует условиям группы; в противном случае - значение false</returns>
        </member>
        <member name="M:filtering.TermGroup.AsGroup">
            <summary>Приводит текущий объект к типу <see cref="T:filtering.TermGroup" /></summary>
        </member>
        <member name="M:filtering.TermGroup.RemoveErrorItems(System.Boolean)">
            <summary>Удаляет из текущей группы элементы, которые находятся в ошибочном состоянии</summary>
            <param name="recursive">Значение true, если требуется удалять элементы в дочерних группах; в противном случае - значение false</param>
        </member>
        <member name="M:filtering.TermGroup.RemoveEmptyGroups(System.Boolean)">
            <summary>Удаляет из текущей группы элементы, которые являются пустыми группами</summary>
            <param name="recursive">Значение true, если требуется удалять элементы в дочерних группах; в противном случае - значение false</param>
        </member>
        <member name="M:filtering.TermGroup.AddGroup(filtering.LogicalOperator)">
            <summary>Добавляет дочернюю группу условий в текущую группу</summary>
            <param name="logicalOperator">Логический оператор</param>
            <returns>Добавленная группа условий</returns>
        </member>
        <member name="M:filtering.TermGroupItem.Match(filtering.IFilteringObject*)">
            <summary>Возвращает значение, указывающее, соответствует ли указанный объект условиям текущего элемента</summary>
            <param name="pObject">объект для проверки</param>
            <returns>Значение true, если объект соответствует условиям текущего элемента; в противном случае - значение false</returns>
        </member>
        <member name="M:filtering.TermGroupItem.IsError">
            <summary>Возвращает значение, указывающее, находится ли элемент в ошибочном состоянии</summary>
        </member>
        <member name="M:filtering.TermGroupItem.GetLogicalOperator">
            <summary>Логический оператор, которым текущий элемент соединяется с предыдущим элементом в группе условий</summary>
        </member>
        <member name="M:filtering.TermGroupItem.IsTerm">
            <summary>Возвращает значение, указывающее, является ли текущий элемент условием</summary>
        </member>
        <member name="M:filtering.TermGroupItem.AsTerm">
            <summary>Преобразует текущий элемент к типу <see cref="T:filtering.Term" /> (если он является условием)</summary>
        </member>
        <member name="M:filtering.TermGroupItem.IsGroup">
            <summary>Возвращает значение, указывающее, является ли текущий элемент группой условий</summary>
        </member>
        <member name="M:filtering.TermGroupItem.AsGroup">
            <summary>Приводит текущий элемент к типу <see cref="T:filtering.TermGroup" /> (если он является группой условий)</summary>
        </member>
        <member name="M:CEditFragment.DegreesOfFreedom(TFDocRegenContext*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="M:CEditFragment.Get3DFragment">
Методы для работы с планировками
</member>
        <member name="M:CEditFragment.StoreFixingCoordinates">
В документе фрагмента собирается и кешируется информация о всех векторах привязки
</member>
        <member name="T:FIXING_POINT.OrientationType">
Ориентация вида
</member>
        <member name="M:TF_PK_TOPOL_find_box(System.Int32,System.Int32!System.Runtime.CompilerServices.IsConst*,PK_BOX_s*!System.Runtime.CompilerServices.IsConst)">
Расчет границ множества тел
</member>
        <member name="M:Fragment3DBase.CalculateLayoutCoords(TFDocRegenContext*,TFReference.LayoutProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CTfw32Doc*,System.Boolean,TFM.SSE.Matrix4d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Пересчет положения 2D-фрагментов на планировках
</member>
        <member name="M:Fragment3DBase.CalculateLayout(TFDocRegenContext*,TFReference.LayoutProperty!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,CTfw32Doc*)">
Пересчет отдельно взятой планировки
</member>
        <member name="M:Fragment3DBase.RegenerateLayouts(TFDocRegenContext*)">
Пересчет всех планировок
</member>
        <member name="M:Fragment3DBase.OrderLayouts(std.vector&lt;TFReference.LayoutProperty,std.allocator&lt;TFReference.LayoutProperty&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Построить упорядоченный список планировок. Если 2D-фрагмент, по которому строится 3D-фрагмент, планировочный, то он также возвращается в списке
</member>
        <member name="M:Fragment3DBase.Layouts">
Планировки
</member>
        <member name="M:Fragment3DBase.FlushLinked2D">
Помечает связанные 2D фрагменты как изменённые
</member>
        <member name="M:Fragment3DBase.UpdateLinked2D">
Обновляет информацию о фрагменте в связанных 2D фрагментах (вызывается при изменении фрагмента)
</member>
        <member name="T:FragmentInsertMethod">
Метод вставки 3D фрагмента
</member>
        <member name="F:TFReference.LayoutArrayProperty._owner">
}
</member>
        <member name="M:TFReference.LayoutArrayProperty.empty">
Проверка, что список не пустой
</member>
        <member name="M:TFReference.LayoutArrayProperty.end">
Конец списка
</member>
        <member name="M:TFReference.LayoutArrayProperty.begin">
Методы для итерирования по элементам
{
Начало списка
</member>
        <member name="M:TFReference.LayoutArrayProperty.Count">
Количество планировок
</member>
        <member name="M:TFReference.LayoutArrayProperty.RemoveAll(System.Boolean)">
Удалить все планировки
</member>
        <member name="M:TFReference.LayoutArrayProperty.Insert(System.UInt32,FRAGMENT*,EuclideanWorkplane*,CViewData*,System.Boolean)">
Вставить планировку
</member>
        <member name="M:TFReference.LayoutArrayProperty.Remove(System.UInt32,System.Boolean)">
Удалить планировку
</member>
        <member name="M:TFReference.LayoutArrayProperty.Add(FRAGMENT*,EuclideanWorkplane*,CViewData*)">
Добавить планировку
</member>
        <member name="T:TFReference.LayoutArrayProperty">
Массив планировок
</member>
        <member name="M:TFReference.LayoutPropertyIterator.op_Decrement(System.Int32)">
Оператор постфиксного декремента
</member>
        <member name="M:TFReference.LayoutPropertyIterator.op_Decrement">
Оператор префиксного декремента
</member>
        <member name="M:TFReference.LayoutPropertyIterator.op_Increment(System.Int32)">
Оператор постфиксного инкремента
</member>
        <member name="M:TFReference.LayoutPropertyIterator.op_Increment">
Оператор префиксного инкремента
</member>
        <member name="M:TFReference.LayoutPropertyIterator.op_PointerDereference">
Тут возвращается не ссылка, а именно значение.
Потому что если мы вернём ссылку на _element, она станет недействительной
как только удалится итератор. Из-за этого, например, конструкция "return *begin()" приведёт к ошибке.
</member>
        <member name="M:TFReference.LayoutPropertyIterator.Dispose">
Конструктор
</member>
        <member name="M:TFReference.LayoutPropertyIterator.#ctor(CTFObject*,System.UInt32)">
Конструктор
</member>
        <member name="T:TFReference.LayoutPropertyIterator">
Двунаправленный итератор
</member>
        <member name="M:TFReference.LayoutProperty.Priority">
Приоритет планировки при пересчете положения 3D-фрагмента
</member>
        <member name="M:TFReference.LayoutProperty.GetFragment">
2D-фрагмент
</member>
        <member name="M:TFReference.LayoutProperty.Projection">
Аггрегированная проекция, если в документе фрагмента нет соответствующего 2D-вида
</member>
        <member name="M:TFReference.LayoutProperty.Workplane">
Рабочая плоскость
</member>
        <member name="M:TFReference.LayoutProperty.Fragment">
2D-фрагмент
</member>
        <member name="M:TFReference.LayoutProperty.#ctor(CTFObject*,FRAGMENT*)">
2D-фрагмент, по которому построен 3D-фрагмент
</member>
        <member name="M:TFReference.LayoutProperty.#ctor(CTFObject*,System.Int32)">
Планировочный фрагмент
</member>
        <member name="T:TFReference.LayoutProperty">
Класс для доступа к свойствам планировки
</member>
        <member name="M:CViewData.MakeServiceLines">
Создавать вспомогательные линии
</member>
        <member name="M:CViewData.TestBreakLinesOnTopol">
Проверять, попадает ли интервал линии разрыва на проецируемый элемент. Используется для отрисовки разрывов согласно принятым стандартам оформления разрывов
</member>
        <member name="M:CViewData.SolidIDs">
Стабилизация порядка обхода тел в операциях. Каждому проецируемому телу назначается уникальный целочисленный идентификатор.
Тела в списке проецирования соритуются по этим идентификаторам
</member>
        <member name="M:CViewData.IgnoreBrokenOffset">
Для проекций, построенных в версии 15, игнорировать смещения разрывов
</member>
        <member name="M:CViewData.InterpolatePolylineInSpline">
Интерполировать полилинию в сплайн
</member>
        <member name="M:CViewData.Flattened">
Проекции с приминением сценариев развёртки
</member>
        <member name="M:CViewData.Explosion">
Проекции с приминением сценариев разборки
</member>
        <member name="M:CViewData.UpdateLimitsFromBoundingBox(PK_BOX_s!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Пересчитать 2D габариты проекции по 3D габаритам модели
</member>
        <member name="M:CViewData.ProjectBoundingBox(TFDocRegenContext*,PK_BOX_s!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TAffineMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFRect*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проецирование габаритного прямоугольного параллелепипеда. Возвращается габаритный прямоугольник и преобразование проецирования габаритного прямоугольника.
Метод используется в проекционных 2D фрагментах для расчета вектора привязки.
</member>
        <member name="M:CViewData.CalculatePosition(CViewData.PositionCalculatingMethod,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFM.SSE.Vector3d*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Способ расчета положения проекции
</member>
        <member name="T:CViewData.PositionCalculatingMethod">
Способ расчета положения проекции
</member>
        <member name="M:CViewData.MakeProjection(TFDocRegenContext*,SelScnObj*)">
Построить проекцию заданного объекта
Используется в 3D-фрагментах для рисования планировок
</member>
        <member name="M:AreaMap.AreaDescription.GetBodyIndex(Operation3DBase!System.Runtime.CompilerServices.IsConst*)">
Номер тела в списке тел операции. Может быть -1
</member>
        <member name="M:AreaMap.AreaDescription.GetEqualBodyIndex">
Номер тела в списке тел с одинаковым ключом
</member>
        <member name="F:AreaMap.AreaDescription._simpleTopologyEntity">
Информация для идентификации штриховок по отдельным граням. Нужно для назначения отдельных стилей для каждой плоскости разреза в аксонометриях
</member>
        <member name="M:ImageMap.Add(ENElement!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,std.shared_ptr&lt;RenderLine.CSegmentFeatures&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean!System.Runtime.CompilerServices.IsConst)">
Метод используется для добавления сегмента в новой версии проекции, когда линии изображения создаются по запросу и могут иметь одинаковые идентификаторы топологических элементов
</member>
        <member name="F:PROJ_REFDIR">
Точка, задающая ориентцию проекции относительно глобального нуля!
</member>
        <member name="F:PROJ_NODE_GLOBAL">
Проекция глобального нуля
</member>
        <member name="F:PROJ_NODE_TOPLEFT">
Габаритные точки
</member>
        <member name="M:FRAGMENT.DegreesOfFreedom(TFDocRegenContext*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="M:FRAGMENT.Get3DFragment">
Методы для работы с планировками
</member>
        <member name="M:FRAGMENT.IsCopied">
Фрагмент является копией другого фрагмента
</member>
        <member name="M:CFragment.DegreesOfFreedom(TFDocRegenContext*,Layout.RestrictionOnTheWayToMove*)">
Возможные варианты степеней свободы для редактирования положения планировочного 2D фрагмента
</member>
        <member name="M:CFragment.Get3DFragment">
Методы для работы с планировками
</member>
        <member name="M:CFragment.GetVariableFragment">
Индекс фрагмента, c которого фрагмент берёт значения переменных
</member>
        <member name="M:CFragment.GetSourceFragment">
Индекс фрагмента, копией которго является данный фрагмент
</member>
        <member name="M:CFragment.GetSourceMap(TAffineMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Преобразование положения фрагмента без дополнительных преобразований
</member>
        <member name="M:CFragment.GetCurrentFragmentMap(TAffineMap*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Суммарное преобразование с учетом дополнительных преобразований
</member>
        <member name="M:LcsUtils.TranslatePointsInLcs(FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,std.list&lt;std.reference_wrapper&lt;TFPoint&gt;,std.allocator&lt;std.reference_wrapper&lt;TFPoint&gt;&gt;&gt;)">
            <summary> Перевести точки из СК страницы в ЛСК </summary>
            <param name="iLcs"> ЛСК в которую нужно перевести точки </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <param name="iPoints"> Точки </param>
        </member>
        <member name="M:LcsUtils.TranslatePointsInPageCs(FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst,std.list&lt;std.reference_wrapper&lt;TFPoint&gt;,std.allocator&lt;std.reference_wrapper&lt;TFPoint&gt;&gt;&gt;)">
            <summary> Перевести точки из ЛСК в СК страницы </summary>
            <param name="iLcs"> ЛСК в которой заданы точки </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <param name="iPoints"> Точки </param>
        </member>
        <member name="M:LcsUtils.GetPointInPageCs(FIXING_POINT!System.Runtime.CompilerServices.IsConst*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить координаты точки (заданной в ЛСК) в СК страницы </summary>
            <param name="iLcs"> ЛСК </param>
            <param name="iPointInLcs"> Точка, заданная в ЛСК iLcs </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в СК страницы </returns>
        </member>
        <member name="M:LcsUtils.GetPointInLcs(FIXING_POINT!System.Runtime.CompilerServices.IsConst*,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить координаты точки (заданной в СК страницы) в ЛСК </summary>
            <param name="iLcs"> ЛСК </param>
            <param name="iPointInPageCS"> Точка, заданная в СК страницы </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в ЛСК </returns>
        </member>
        <member name="M:TFModelPoint.Regenerate(TFDocument*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFDocRegenContext*)">
Методы для вызова в соответствующих виртуальных методах объектов, содержащих TFModelPoint
</member>
        <member name="M:TFModelPoint.DetachNode(CTFObject!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean,TFDocument!System.Runtime.CompilerServices.IsConst*)">
            <summary> Отвязаться от узла (обновляет координаты из узла) </summary>
            <param name="srcDoc"> Документ </param>
            <param name="setNodeCoords"> false, если не требуется обновление координат </param>
            <returns> true - если удалось получить узел, обновить координаты и отвязаться от него </returns>
        </member>
        <member name="M:TFModelPoint.UpdateWithConstraints(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Обновить с учётом ограничений </summary>
            <param name="iDoc"> Документ </param>
            <param name="iToModelScale"> Коэффициент преобразования в координаты модели </param>
            <param name="iPageScale"> Масштаб страницы </param>
        </member>
        <member name="M:TFModelPoint.GetPointInActiveLcs(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Получить точку в активной системе координат </summary>
            <param name="iDoc"> Документ </param>
            <returns> Точка в активной системе координат </returns>
        </member>
        <member name="M:TFModelPoint.GetPointInSpecifiedLcs(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить точку в указанной системе координат </summary>
            <param name="iDoc"> Документ </param>
            <param name="iLcs"> Система координт (если nullptr, то возвращает точку в СК страницы без учёта масштаба(!)) </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в указанной системе координат </returns>
        </member>
        <member name="M:TFModelPoint.GetPointInLcs(STATUS!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить точку в локальной системе координат (если ЛСК не задана, то в СК страницы без учёта масштаба(!)) </summary>
            <param name="lcsStatus"> Страница, ЛСК которой используется </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в локальной системе координат </returns>
        </member>
        <member name="M:TFModelPoint.GetPoint(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Получить точку в системе координат страницы </summary>
            <param name="iDoc"> Документ </param>
            <param name="iPageScale"> Масштаб страницы </param>
            <returns> Точка в системе координат страницы </returns>
        </member>
        <member name="M:TFModelPoint.SetPoint(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Задать точку (копирует все данные из входящей точки, кроме данных, относящихся к решателю ограничений) </summary>
            <param name="iPoint"> Входящая точка, из которой будут скопированны данные </param>
        </member>
        <member name="M:TFModelPoint.SetPoint(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Задать точку с учётом ЛСК (преобразует точку из системы координат страницы в координаты ЛСК, если она есть) </summary>
            <param name="iDoc"> Документ </param>
            <param name="iPointInPageCS"> Точка в системе координат страницы (с учётом масштаба) </param>
            <param name="iPageScale"> Масштаб страницы </param>
        </member>
        <member name="M:TFModelPoint.SetPoint(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Задать точку с выбором новой ЛСК (преобразует точку из системы координат страницы в координаты ЛСК) </summary>
            <param name="iPointInPageCS"> Точка в системе координат страницы (с учётом масштаба) </param>
            <param name="iLcs"> Новая локальная система координат </param>
            <param name="iPageScale"> Масштаб страницы </param>
        </member>
        <member name="M:TFModelPoint.SetPointByActivePage(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,STATUS!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Задать точку с выбором новой ЛСК (активной да данной странице) и масштабом (преобразует точку из системы координат страницы в координаты ЛСК) </summary>
            <param name="iPointInPageCS"> Точка в системе координат страницы (с учётом масштаба) </param>
            <param name="iPage"> Страница, с которой будет взята активная ЛСК и масштаб </param>
        </member>
        <member name="M:TFModelPoint.SetPoint(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32!System.Runtime.CompilerServices.IsConst,System.Double!System.Runtime.CompilerServices.IsConst)">
            <summary> Задать точку с выбором новой ЛСК (преобразует точку из системы координат страницы в координаты ЛСК) </summary>
            <param name="iDoc"> Документ </param>
            <param name="iPointInPageCS"> Точка в системе координат страницы (с учётом масштаба) </param>
            <param name="iLcs"> Индекс новой локальной системы координат </param>
            <param name="iPageScale"> Масштаб страницы </param>
        </member>
        <member name="M:TFModelPoint.IsInPageCs(TFDocument!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary> Проверка задана ли точка в СК страницы </summary>
            <param name="iDoc"> Документ </param>
            <returns> true - если точка задана в СК страницы, false - иначе </returns>
        </member>
        <member name="M:TFModelPoint.GetLcsIndex">
            <summary> Получить индекс локальной системы координат, в которой задана точка </summary>
            <returns> Индекс локальной системы координат (если точка задана в СК страницы, то -1) </returns>
        </member>
        <member name="T:FIXING_POINT">
            <summary> Получить локальную систему координат, в которой задана точка </summary>
            <param name="iDoc"> Документ </param>
            <returns> Указатель на локальную систему координат (если ЛСК не задана - nullptr) </returns>
        </member>
        <member name="M:TFModelPoint.HaveNode">
            <summary> Проверка на наличие узла </summary>
            <returns> true - если узел есть, false - иначе </returns>
        </member>
        <member name="M:TFModelPoint.GetNodeIndex">
            <summary> Получить индекс узла, которым задана точка </summary>
            <returns> Индекс узла (если узел не задан, то -1) </returns>
        </member>
        <member name="T:KNOT">
            <summary> Получить узел, которым задана точка </summary>
            <param name="iDoc"> Документ </param>
            <returns> Указатель узел (если узел не задан - nullptr) </returns>
        </member>
        <member name="M:TFModelPoint.SetNode(System.Int32)">
            <summary> Устновить узел, задающий точку </summary>
            <param name="iNode"> Индекс узла </param>
        </member>
        <member name="M:TFModelPoint.op_Equality(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор сравнения
</member>
        <member name="M:TFModelPoint.op_Assign(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Оператор присваивания (копирует указатели на данные для ограничений)
</member>
        <member name="M:TFModelPoint.#ctor(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,FIXING_POINT!System.Runtime.CompilerServices.IsConst*,System.Double!System.Runtime.CompilerServices.IsConst)">
Конструктор для точки, заданной в глобальной системе координат, с переводом в локальную
</member>
        <member name="M:TFModelPoint.#ctor(System.Double,System.Double,System.Int32)">
Конструктор для точки, заданной координатами в глобальной или локальной системе координат
</member>
        <member name="M:TFModelPoint.#ctor(TFPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
Конструктор для точки, заданной координатами в глобальной или локальной системе координат
</member>
        <member name="M:TFModelPoint.#ctor(System.Int32!System.Runtime.CompilerServices.IsConst)">
Конструктор для точки, заданной узлом
</member>
        <member name="M:TFModelPoint.#ctor(TFModelPoint!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Копирующий конструктор
</member>
        <member name="M:TFModelPoint.#ctor">
Конструктор по умолчанию
</member>
        <member name="M:TFMiddlePointConstraints2D.GetMiddle">
Точка на средней линии двух концов отрезка
</member>
        <member name="T:TFMiddlePointConstraints2D">
Точка на середине отрезка
</member>
        <member name="M:TFModelPointConstraints2DFixParameter.GetFixParameter">
Методы получения данных для решателя ограничений
</member>
        <member name="T:TFModelPointConstraints2DFixParameter">
Фиксация параметра на кривой
</member>
        <member name="M:TFModelPointConstraints2D.GetConstraintPoint">
Методы получения данных для решателя ограничений
</member>
        <member name="T:TFModelPointConstraints2D">
Данные для решателя ограничений
</member>
        <member name="T:CReferObject">
Сейчас refer-операции не хранятся и их идентификатор не используется. Идентификатор нужен для корректного пересчета старых моделей
</member>
        <member name="T:CTFCom_Is3D.CreateDetailMode">
Полезные фцнкции для деталировки
</member>
        <member name="M:CTFCom_Is3D.CreateUndoManager(CTfw32Doc*)">
Создать менеджер блока отмены действий
</member>
        <member name="M:CTFCom_Is3D.Run2DCommandOn3D(System.UInt64,=FUNC:System.Int64(System.UInt32,System.UInt64,System.Int64,CTFView*),System.UInt64,System.Int64,CTFView*,System.Boolean)">
Создать команду выбора активной рабочей плоскости
</member>
        <member name="M:CTFCom_Is3D.IsObjectVisibileForPS(CTFObject*,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проверка видимости объекта при обновление структуры изделия. Returns true if handled.
</member>
        <member name="M:CTFCom_Is3D.GetWPForPage(CTfw32Doc!System.Runtime.CompilerServices.IsConst*,System.Int32)">
Получить рабочую плоскость для страницы
</member>
        <member name="M:CTFCom_Is3D.GetWPIntersection(CTFObject*,CTFObject*,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFPoint*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Boolean)">
Получить линию пересечения двух РП в системе координат первой РП
</member>
        <member name="M:CTFCom_Is3D.CMarkContainerKey_CMarkContainerKey(SelectableObject!System.Runtime.CompilerServices.IsConst*,TFObjectID*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Метод возвращает идентификатор, который является ключом в контейнере маркирования
</member>
        <member name="M:CTFCom_Is3D.GetLabelForTheSection(CTFObject!System.Runtime.CompilerServices.IsConst*,CTFSection**!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Double*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Получить для проекции типа разрез или сечение, построенным по обозначению вида, собтсвенно это обозначение вида и масштаб проекции.
Во всех остальных случаях метод возвращает false. Значения выходных данных неопределены.
Используется для актуализации обозначения разреза или сечения.
</member>
        <member name="M:CTFRenderArea.InitRootScene">
Инициализация заголовка сцены.
</member>
        <member name="M:CContainer3DData.AfterRegenerate2D(TFDocRegenContext*)">
Метод вызывается после 2D пересчета. Используется для обработки 3D объектов, которые участвуют в 2D пересчете
</member>
        <member name="M:CContainer3DData.BeforeRegenerate2D(TFDocRegenContext*)">
Метод вызывается перед 2D пересчетом. Используется для обработки 3D объектов, которые участвуют в 2D пересчете
</member>
        <member name="T:CTFSelectedEntity">
Создание линии изображения для выбранного сегмента картиночной проекции
</member>
        <member name="T:CTFSelectedEntitySorted">
Выбор отдельных сегментов на картиночных проекциях

Выбор отдельных сегментов проекционного фрагмента

Выбор отдельных сегментов проекционного фрагмента
</member>
        <member name="M:CTFCom_CContainer3DData.AfterRegenerate2D(TFDocRegenContext*)">
Метод вызывается после 2D пересчета. Используется для обработки 3D объектов, которые участвуют в 2D пересчете
</member>
        <member name="M:CTFCom_CContainer3DData.BeforeRegenerate2D(TFDocRegenContext*)">
Метод вызывается перед 2D пересчетом. Используется для обработки 3D объектов, которые участвуют в 2D пересчете
</member>
        <member name="M:CTFCom_CContainer3DData.GetScreenObjects(std.list&lt;ScreenObject**,std.allocator&lt;ScreenObject**&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Сформировать список экранных объектов для рисования 3D объектов на 2D.
Сейчас используется для рисования фрагментов проекций с разными приоритетами
</member>
        <member name="P:TFlex.Model.Model3D.Model3DObjectGroup.Items">
            <summary>Элементы группы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DObjectGroup.ItemsCollection.Add(TFlex.Model.Model3D.Object3D)">
            <summary>Добавить объект</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DObjectGroup.ItemsCollection.Clear">
            <summary>Удалить все объекты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DObjectGroup.ItemsCollection.Remove(TFlex.Model.Model3D.Object3D)">
            <summary>Удалить объект</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DObjectGroup.ItemsCollection.GetAt(System.UInt32)">
            <summary>Получить объект по индексу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Model3DObjectGroup.ItemsCollection.Count">
            <summary>Количество</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Model3DObjectGroup.ItemsCollection">
            <summary>Коллеция объектов группы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DObjectGroup.Remove(TFlex.Model.Model3D.Object3D)">
            <summary>Удалить 3D объект из группы</summary>
            <param name="object">Удаляемый из группы 3D объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DObjectGroup.Add(TFlex.Model.Model3D.Object3D)">
            <summary>Добавление 3D объекта в группу</summary>
            <param name="object">Добавляемый в группу 3D объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DObjectGroup.#ctor(TFlex.Model.Document,System.String,TFlex.Model.ObjectType)">
            <summary>Конструктор</summary>
            <param name="Doc">Документ объекта</param>
            <param name="Name">Имя группы</param>
            <param name="Type">Тип группы</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Model3DObjectGroup">
            <summary>Класс группы объектов 3D модели.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.AffineTransformation.Inverse">
            <summary>Обратная матрица</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.AffineTransformation.MoveToLCS(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Преобразование совмещением глобальной системы координат с локальной</summary>
            <param name="origin">Начало локальной системы координат</param>
            <param name="zaxis">Ось Z локальной системы координат</param>
            <param name="xaxis">Ось X локальной системы координат</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.AffineTransformation.Scale(System.Double,System.Double,System.Double)">
            <summary>Масштабирование по осям глобальной системы координат</summary>
            <param name="xscale">Масштаб по оси X</param>
            <param name="yscale">Масштаб по оси Y</param>
            <param name="zscale">Масштаб по оси Z</param>
            <remarks>Вызов данного метода добавляет данное преобразование к уже заданным в этой трансформации</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.AffineTransformation.Transfer(TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Перемещение по вектору</summary>
            <param name="direction">Вектор, на длину которого выполняется перемещение</param>
            <remarks>Вызов данного метода добавляет данное преобразование к уже заданным в этой трансформации</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.AffineTransformation.Rotate(TFlex.Model.Model3D.Geometry.BaseAxis,System.Double)">
            <summary>Вращение вокруг оси на заданный угол</summary>
            <param name="axis">Ось, относительно которой выполняется вращение</param>
            <param name="angle">Угол в градусах, на который выполняется вращение</param>
            <remarks>Вызов данного метода добавляет данное преобразование к уже заданным в этой трансформации</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.AffineTransformation.#ctor(TFlex.Model.Model3D.Geometry.AffineTransformation)">
            <summary>Копирующий конструктор</summary>
            <param name="transformation">Трансформация, с которой копируются параметры для данной трансформации</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.AffineTransformation.#ctor">
            <summary>Конструктор для единичной трансформации</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.AffineTransformation">
            <summary>Аффинные преобразования</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.TransformationMatrix.Identity">
            <summary>Сделать матрицу единичной</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.TransformationMatrix.#ctor(TFlex.Model.Model3D.Geometry.TransformationMatrix)">
            <summary>Копирующий конструктор</summary>
            <param name="transformation">Трансформация, с которой копируются параметры для данной трансформации</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.TransformationMatrix.#ctor">
            <summary>Конструктор для единичной трансформации</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.TransformationMatrix.default(System.Int32)">
            <summary>Получить строку</summary>
            <param name="index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Всего четыре строки</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.TransformationMatrix.MatrixVector.default(System.Int32)">
            <summary>Элемент в строке по номеру столбца</summary>
            <param name="index">Номер столбца</param>
            <remarks>Элементы нумеруются от нуля. Всего четыре столбца</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TransformationMatrix.MatrixVector">
            <summary>Матрица преобразований</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TransformationMatrix">
            <summary>Базовый класс для преобразований</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.Root">
            <summary>Корневая папка с внешними параметрами</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.Comment">
            <summary>Подсказка для пользовательского элемента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.Name">
            <summary>Имя пользовательского элемента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.TopolParameter.Value">
            <summary>Значение параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.UDF.TopolParameter">
            <summary>Топологический параметр: вершина, ребро, цикл, грань</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.ModelParameter.ID">
            <summary>Значение ключа параметра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.ModelParameter.Value">
            <summary>Значение параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.UDF.ModelParameter">
            <summary>Модельный параметр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.BaseParameter.Comment">
            <summary>Комментарий к параметру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.BaseParameter.Name">
            <summary>Имя параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.UDF.BaseParameter">
            <summary>Собственно параметр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.UDF.FolderParameter.Reset">
            <summary>Начать сначала перебор параметров</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.UDF.FolderParameter.MoveNext">
            <summary>Перейти на следующий параметр</summary>
            <returns>Успешно или нет выполнен переход</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.FolderParameter.Current">
            <summary>Получить oчередной параметр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.FolderParameter.default(System.String)">
            <summary>Получить параметр по имени</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.FolderParameter.Name">
            <summary>Имя параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.UDF.FolderParameter">
            <summary>Папка содержит параметры и подпапки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.UDF.Parameter.Name">
            <summary>Имя параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.UDF.Parameter">
            <summary>Базовый класс для внешних параметров</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.UDF">
            <summary>Пользовательский элемент</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ObjectCreator3D">
            <summary>Класс для создания объектов 3D модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceOperation.OriginalLayerName">
            <summary>Имя слоя, на котором объект лежит в документе фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceOperation.OriginalName">
            <summary>Имя объекта в документе фрагмента</summary>
            <remarks>Для массивов и сборок выше второго уровня функция работает некорректно</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceOperation.Owner">
            <summary>Владелец ссылочного объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ReferenceOperation">
            <summary>Класс для представления ссылочной операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferencePath.OriginalLayerName">
            <summary>Имя слоя, на котором объект лежит в документе фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferencePath.OriginalName">
            <summary>Имя объекта в документе фрагмента</summary>
            <remarks>Для массивов и сборок выше второго уровня функция работает некорректно</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferencePath.Owner">
            <summary>Владелец ссылочного объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ReferencePath">
            <summary>Класс для представления ссылочного пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceWorkplane.OriginalLayerName">
            <summary>Имя слоя, на котором объект лежит в документе фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceWorkplane.OriginalName">
            <summary>Имя объекта в документе фрагмента</summary>
            <remarks>Для массивов и сборок выше второго уровня функция работает некорректно</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceWorkplane.Owner">
            <summary>Владелец ссылочного объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ReferenceWorkplane">
            <summary>Класс для представления ссылочной рабочей плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceProfile.OriginalLayerName">
            <summary>Имя слоя, на котором объект лежит в документе фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceProfile.OriginalName">
            <summary>Имя объекта в документе фрагмента</summary>
            <remarks>Для массивов и сборок выше второго уровня функция работает некорректно</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceProfile.Owner">
            <summary>Владелец ссылочного объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ReferenceProfile">
            <summary>Класс для представления ссылочного профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceNode3D.OriginalLayerName">
            <summary>Имя слоя, на котором объект лежит в документе фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceNode3D.OriginalName">
            <summary>Имя объекта в документе фрагмента</summary>
            <remarks>Для массивов и сборок выше второго уровня функция работает некорректно</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceNode3D.Owner">
            <summary>Владелец ссылочного объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ReferenceNode3D">
            <summary>Класс для представления ссылочного узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceLCS.OriginalLayerName">
            <summary>Имя слоя, на котором объект лежит в документе фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceLCS.OriginalName">
            <summary>Имя объекта в документе фрагмента</summary>
            <remarks>Для массивов и сборок выше второго уровня функция работает некорректно</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ReferenceLCS.Owner">
            <summary>Владелец ссылочного объекта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ReferenceLCS">
            <summary>Класс для представления ссылочной системы координат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.RememberTopLabel(TFlex.Model.Model3D.Fragment3D.LabelType)">
            <summary>Запомнить метку верхушки Undo-стэка</summary>
            <param name="type">Тип действия</param>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.LabelType.EndAfter">
            <summary>Метка Undo-действия после изменений в документа фрагмента после изменения самого фрагмента</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.LabelType.StartAfter">
            <summary>Метка Undo-действия перед началом изменений в документа фрагмента помле изменения самого фрагмента</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.LabelType.EndBefore">
            <summary>Метка Undo-действия после изменений в документа фрагмента перед изменением самого фрагмента</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.LabelType.StartBefore">
            <summary>Метка Undo-действия перед началом изменений в документа фрагмента перед изменением самого фрагмента</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Fragment3D.LabelType">
            <summary>Тип действия</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetBOMQuantity(System.Boolean)">
            <summary>Получить количество копий фрагмента во всех массивах</summary>
            <param name="onlyVisible">Считать количество только видимых копий, иначе считать всё</param>
            <returns>Количество копий фрагмента во всех массивах</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.IncludeInSpecificBom(System.String)">
            <summary>Включение в спецификацию</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.IncludeInNewBom">
            <summary>Включение в новую спецификацию</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetUserBomData(System.Boolean)">
            <summary>Пользовательские данные для спецификации</summary>
            <param name="onlyVisible" />
            <returns>Подсборка</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.OpenPart(TFlex.Model.Model2D.Fragment.OpenPartOptions)">
            <summary>Создать деталировку с данными параметрами</summary>
            <param name="options">Параметры</param>
            <returns>Новый деталированный документ</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.OpenPart">
            <summary>Создать деталировку</summary>
            <returns>Новый деталированный документ</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.MarkChanged">
            <summary>Пометить объект как изменённый</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.Parameters">
            <summary>Список идентификаторов объектов-параметров в документе фрагмента и объектов-значений в документе сборки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.RemoveAssociative">
            <summary>Разрывать ассоциативные связи при удалении объекта-значения параметра</summary>
            <remarks>Используется в мебельном модуле</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.RemoveParameters(System.Collections.Generic.List`1{System.UInt32})">
            <summary>Удаление внешних параметров из фрагмента</summary>
            <param name="parameters">Список удаляемых внешних параметров</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.MakeParameters(System.Collections.Generic.List`1{TFlex.Model.ModelObject},System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>В документе фрагмента создаются внешние параметры для списка операций из сборки и означиваются операциями из сборки</summary>
            <param name="objects">Операции из сборки, для которых строятся параметры</param>
            <param name="saveFragmentDocument">Сохранять документ фрагмента</param>
            <param name="closeFragmentDocument">Закрывать документ фрагмента</param>
            <param name="regenerateAssembly">Пересчитывать сборку</param>
            <param name="copyConnectorInfo">Копировать информацию о связи топологических элементов с коннекторами</param>
            <param name="associative">Ассоциативные параметры</param>
            <returns>Список индентификаторов операций из сборки</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetElevableLCS">
            <summary>Список систем координат, которые могут использоваться для привязки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetDefaultLCS">
            <summary>Имя системы координат, которая используется по умолчанию</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.HideLCSinTree">
            <summary>Не показывать системы координат в дереве модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.HideConnectors">
            <summary>Скрывать коннекторы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.AutoSave">
            <summary>Создавать фрагмент в режиме автосохранения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FragmentFileFolder">
            <summary>Путь на папку относительно папки сборки при сохранении в папку сборки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.SaveFragmentToAssemblyFolder">
            <summary>Cохранять файл фрагмента в папку сборки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.EditInContext">
            <summary>Редактировать в контексте сборки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.Processing">
            <summary>Обработка(Обогащение) фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.ClearUDF">
            <summary>Удаление параметров адаптивного фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.EditAssocParams(System.Boolean)">
            <summary>Редактирование параметров адаптивного фрагмента</summary>
            <param name="check">Проверять актуальность ссылки</param>
            <returns>Пользовательский элемент</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetFragmentDocument(System.Boolean,System.Boolean)">
            <summary>Получить документ фрамента с подстановкой значений переменных фрагмента</summary>
            <returns>Документ фрагмента</returns>
            <param name="substitute">Признак необходимости подстановки значений переменных</param>
            <param name="update">Обновить документ фрагмента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetFragmentDocument(System.Boolean)">
            <summary>Получить документ фрамента с подстановкой значений переменных фрагмента</summary>
            <returns>Документ фрагмента</returns>
            <param name="substitute">Признак необходимости подстановки значений переменных</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.InverseTransformation">
            <summary>Матрица обратного преобразования</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.UpdateVariablesFromFragmentDocument">
            <summary>Обновить переменные фрагмента по документу фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetVariablesFromFragment(TFlex.Model.Model3D.Fragment3D)">
            <summary>Установить значения всех переменных фрагмента в соответствии с переменными входящего фрагмента</summary>
            <param name="sourceFragment">Исходный фрагмент</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.ShowVariablesDialog">
            <summary>Показать диалог "Переменные"</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetVariables">
            <summary>Контейнер переменных фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetVariableValue(System.String,System.Boolean,System.Boolean)">
            <summary>Получить переменную фрагмента по имени</summary>
            <param name="name">Имя переменной</param>
            <param name="forSet">Признак необходимости изменения переменной</param>
            <returns>Переменная фрагмента</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.GetVariableValue(System.String,System.Boolean)">
            <summary>Получить переменную фрагмента по имени</summary>
            <param name="name">Имя переменной фрагмента</param>
            <param name="forSet">Признак необходимости изменения переменной</param>
            <returns>Переменная фрагмента</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.RotateZ">
            <summary>Вращение по оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.RotateY">
            <summary>Вращение по оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.RotateX">
            <summary>Вращение по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.MoveZ">
            <summary>Перемещение вдоль оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.MoveY">
            <summary>Перемещение вдоль оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.MoveX">
            <summary>Перемещение вдоль оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.Reference">
            <summary>Множество ссылочных объектов из которых состоит 3D Фрагмент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.AttributesFromSource">
            <summary>Значение свойства "Атрибуты с исходной операции"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.UseFragmentStatus">
            <summary>Использовать статус документа фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.ShowOn2D">
            <summary>Показывать ли на 2D виде фрагмент</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.Configuration">
            <summary>Имя конфигурации модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FullFilePath">
            <summary>Полный путь файла 3D Фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FilePath">
            <summary>Имя файла 3D Фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.Separated">
            <summary>Значение свойства "Как отдельные тела"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.BooleanOperationName">
            <summary>Имя операция для булевой операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.Fixing">
            <summary>Cпособ привязки 3D Фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.Workplane">
            <summary>Рабочая плоскость, используемая для привязки фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.TargetLCS">
            <summary>Целевая система координат в документе сборки, используемая для привязки фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.SourceLCSName">
            <summary>Имя системы координат созданной в документе фрагмента, используемой для привязки фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.FixByWorkplane(TFlex.Model.Model3D.Workplane)">
            <summary>Привязать фрагмент по расположению соответствующего 2D фрагмента на Рабочей плоскости</summary>
            <param name="Workplane">Рабочая плоскость(может быть <b>null</b>)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.FixByFragmentLCSToConnector(System.String,TFlex.Model.Model3D.LCS)">
            <summary>Привязать фрагмент по системе координат, существующей в документе фрагмента к системе координат в сборке.
Если целевая система координат является коннектором, то выполняется связывание параметров.</summary>
            <param name="sourceLCSName">Имя системы координат, созданной в документе фрагмента</param>
            <param name="targetLCS">Система координат, созданная в документе сборки(может быть <b>null</b>)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.FixByFragmentLCS(System.String,TFlex.Model.Model3D.LCS)">
            <summary>Привязать фрагмент по системе координат, существующей в документе фрагмента к системе координат в сборке</summary>
            <param name="sourceLCSName">Имя системы координат, созданной в документе фрагмента</param>
            <param name="targetLCS">Система координат, созданная в документе сборки(может быть <b>null</b>)</param>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FixingType.ByWorkplane">
            <summary>На основе расположения 2D фрагмента на Рабочей плоскости</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FixingType.ByAssemblyLCS">
            <summary>Система координат созданная в документе сборки в систему координат сборки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FixingType.ByFragmentLCS">
            <summary>Система координат созданная в документе фрагмента в систему координат сборки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FixingType.NoFixing">
            <summary>Не определён</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Fragment3D.FixingType">
            <summary>Способ привязки 3D Фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomPropertyContainer">
            <summary>Cтепени свободы 3D фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.ZEndRotationValue">
            <summary>Конец вращения по оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.ZBeginRotationValue">
            <summary>Начало вращения по оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.YEndRotationValue">
            <summary>Конец вращения по оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.YBeginRotationValue">
            <summary>Начало вращения по оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.XEndRotationValue">
            <summary>Конец вращения по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.XBeginRotationValue">
            <summary>Начало вращения по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.ZEndValue">
            <summary>Конец по Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.ZBeginValue">
            <summary>Начало по Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.YEndValue">
            <summary>Конец по Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.YBeginValue">
            <summary>Начало по Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.XEndValue">
            <summary>Конец по X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.XBeginValue">
            <summary>Начало по X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.ZRotation">
            <summary>Ограничения поворота вокруг оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.YRotation">
            <summary>Ограничения поворота вокруг оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.XRotation">
            <summary>Ограничения поворота вокруг оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.ZMovement">
            <summary>Начало ограничение по оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.YMovement">
            <summary>Начало ограничение по оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.XMovement">
            <summary>Начало ограничение по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.EnableRotationZ">
            <summary>Поворот вокруг оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.EnableRotationY">
            <summary>Поворот вокруг оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.EnableRotationX">
            <summary>Поворот вокруг оси Х</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.EnableMovementZ">
            <summary>Перемещение вдоль оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.EnableMovementY">
            <summary>Перемещение вдоль оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FreedomProperty.EnableMovementX">
            <summary>Перемещение вдоль оси Х</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.ZRotation">
            <summary>Ограничения поворота вокруг оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.YRotation">
            <summary>Ограничения поворота вокруг оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.XRotation">
            <summary>Ограничения поворота вокруг оси X</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.ZEnd">
            <summary>Конец по оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.ZBegin">
            <summary>Начало по оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.YEnd">
            <summary>Конец по оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.YBegin">
            <summary>Начало по оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.XEnd">
            <summary>Конец по оси X</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType.XBegin">
            <summary>Начало по оси X</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Fragment3D.FreedomProperty.LimitsType">
            <summary>Ограничение степеней свобод</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.FreedomsType.RotationZ">
            <summary>Поворот вокруг оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.FreedomsType.RotationY">
            <summary>Поворот вокруг оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.FreedomsType.RotationX">
            <summary>Поворот вокруг оси Х</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.FreedomsType.MovementZ">
            <summary>Перемещение вдоль оси Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.FreedomsType.MovementY">
            <summary>Перемещение вдоль оси Y</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Fragment3D.FreedomProperty.FreedomsType.MovementX">
            <summary>Перемещение вдоль оси Х</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Fragment3D.FreedomProperty.FreedomsType">
            <summary>Тип степень свободы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Fragment3D.FreedomProperty">
            <summary>Класс степени свободы 3D фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Fragment3D.FileLink">
            <summary>Ссылка на файл фрагмента</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.#ctor(TFlex.Model.Model2D.Fragment,TFlex.Model.Model3D.Workplane)">
            <summary>Конструктор с именем файла фрагмента</summary>
            <param name="fragment">Исходный 2D фрагмент</param>
            <param name="workplane">Рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.#ctor(TFlex.Model.FileLink)">
            <summary>Конструктор с именем файла фрагмента</summary>
            <param name="link">Ссылка на файл фрагмента</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.#ctor(System.String,TFlex.Model.Document,System.Boolean,System.Boolean)">
            <summary>Конструктор для создания 3D фрагмента</summary>
            <param name="fileName">Имя файла документа фрагмента</param>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="copy">Использовать файл как шаблон для создания нового документа фрагмента в оперативной памяти</param>
            <param name="autoSave">Создавать фрагмент в режиме автосохранения</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Fragment3D.#ctor(System.String,TFlex.Model.Document)">
            <summary>Конструктор для создания 3D фрагмента</summary>
            <param name="fileName">Имя файла документа фрагмента</param>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Fragment3D">
            <summary>Класс операции 3D фрагмента</summary>
            <example>
                <code name="FragmentLCS">
public static void FragmentLCS(string pathFragment, PointsLCS lcs)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");

   Fragment3D fr = new Fragment3D(pathFragment, document);
   fr.FixByFragmentLCS(lcs.Name, lcs); //привязка фрагмента к системе координат(название системы координат, сама система)

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
                <code name="FragmentVariables">
public static void FragmentVariables(string pathFragment)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");

   Fragment3D fragment = new Fragment3D(pathFragment, document);
   foreach(FragmentVariableValue v in fragment.GetVariables())//цикл по переменным фрагмента
   {
    if(v.Name == "D" &amp;&amp; v.IsReal)//находим переменную "D" 
    {
	    v.RealValue = 100;//устанавливаем значение
    }
   }

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
                <code name="FragmentOpenPart">
public static void FragmentOpenPart(string pathFragment)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");

   Fragment3D fr = new Fragment3D(pathFragment, document);
   fr.OpenPart(); //деталировка

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
                <code name="Пример создание 3D фрагментов методом планировок">
public static void FragmentMethodPlan(WorkPlane onPointsWorkplane, string pathFragment)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");

   Fragment f = new Fragment(document, pathFragment);//2D-фрагмент, имеющий 3D реализацию
   f.Page = onPointsWorkplane.Page;//привязка фрагмента к странице плоскости
   Fragment3D fr = new Fragment3D(f, onPointsWorkplane);//3D-фрагмент на основе 2D-фрагмента и плоскости

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model3D.References.Reset">
            <summary>Начать сначала перебор ссылочных объектов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.References.MoveNext">
            <summary>Перейти на следующий ссылочный объект</summary>
            <returns>Успешно или нет выполнен переход</returns>
            <remarks>Функция предназначена для перебора преобразований 3D элементов</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.References.Current">
            <summary>Получить oчередной ссылочный объект</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.References">
            <summary>Класс предназначенный для перечисления элементов 3D фрагмента</summary>
        </member>
        <member name="M:LCSystem2Dto3D.AssociateObjects">
Множество объектов ассоциированных с системой координат.
</member>
        <member name="M:LCSystem2Dto3D.CalculateLCS(TFDocRegenContext*,LCSystem*,System.Boolean,TFM.SSE.Vector3d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,LCSystem2Dto3D.e_PointSlot!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Расчет системы координат, которая задаётся по точкам и направлениям с возможностью замены одной из точек. Использоваться в пересчете системы координат и в расчете динамического положения редактируемой системы координат
</member>
        <member name="M:LCSystem2Dto3D.DoActionLikeRemoveLink(DeleteElementsContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Пытаемся разорвать связь с родителем
</member>
        <member name="P:TFlex.Model.Model3D.Equidistant3DPath.Angle">
            <summary>Значение угла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Equidistant3DPath.Offset">
            <summary>Значение смещения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Equidistant3DPath.SecondPoint">
            <summary>Вторая точка, задающая направление</summary>
            <remarks>Вектор эквидистанты задаётся двумя взаимоисключающими методами: направлением или двумя точками</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Equidistant3DPath.FirstPoint">
            <summary>Первая точка, задающая направление</summary>
            <remarks>Вектор эквидистанты задаётся двумя взаимоисключающими методами: направлением или двумя точками</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Equidistant3DPath.Direction">
            <summary>Direction</summary>
            <remarks>Вектор эквидистанты задаётся двумя взаимоисключающими методами: направлением или двумя точками</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Equidistant3DPath.Operation">
            <summary>3D операция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Equidistant3DPath.SourcePath3D">
            <summary>3D путь, для которого строится эквидистанта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Equidistant3DPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания эквидистанта к 3D пути по направлению</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Equidistant3DPath">
            <summary>Эквидистанта к 3D пути по направлению</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.PathOnSurface">
            <summary>Путь на поверхнсти</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.InverseAlgorithm">
            <summary>Параметр инвертирования алгоритма выбора граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.MovingDirection">
            <summary>Направление движения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EquidistantPath.MovingDirectionType.FromRight">
            <summary>По правому профилю</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EquidistantPath.MovingDirectionType.FromLeft">
            <summary>По левому профилю</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.EquidistantPath.MovingDirectionType">
            <summary>Направления движения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.Accuracy">
            <summary>Точность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.PointsQuantity">
            <summary>Количество точек</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.Approximation">
            <summary>Тип приближения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EquidistantPath.ApproximationType.ByAccuracy">
            <summary>Приближение с заданной точностью</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EquidistantPath.ApproximationType.ByPointsQuantity">
            <summary>Приближение заданным количеством точек</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.EquidistantPath.ApproximationType">
            <summary>Тип приближения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.FunctionOffset">
            <summary>Табличная функция смещения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.ConstantOffset">
            <summary>Значение константного смещения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EquidistantPath.Offset">
            <summary>Тип смещения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EquidistantPath.OffsetType.Function">
            <summary>Функция</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.EquidistantPath.OffsetType.Constant">
            <summary>Костанта</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.EquidistantPath.OffsetType">
            <summary>Типы смещения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EquidistantPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания эквидистанты к кривой на поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.EquidistantPath">
            <summary>Эквидистанта к кривой на поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OutlinePath.VerticalFaces">
            <summary>Параметр обработки вертикальных граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.OutlinePath.ChangeOutline">
            <summary>Выбрать другую линию очерка</summary>
            <remarks>Функцию можно вызывать, когда все данные заданы, то есть построен первый очерк</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OutlinePath.SecondPoint">
            <summary>Вторая точка, задающая направление очерка</summary>
            <remarks>Вектор очерка задаётся двумя взаимоисключающими методами: направлением или двумя точками</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OutlinePath.FirstPoint">
            <summary>Первая точка, задающая направление очерка</summary>
            <remarks>Вектор очерка задаётся двумя взаимоисключающими методами: направлением или двумя точками</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OutlinePath.Direction">
            <summary>Направление очерка</summary>
            <remarks>Вектор очерка задаётся двумя взаимоисключающими методами: направлением или двумя точками</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OutlinePath.Operation">
            <summary>Тело, для которого задаётся очерк</summary>
            <remarks>В настоящей версии в качестве тела можно выбирать только 3D операцию. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.OutlinePath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания линии очерка</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.OutlinePath">
            <summary>Класс линии очерка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ParametricPath.GeneratrixPoint">
            <summary>Образующая точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ParametricPath.Parametric">
            <summary>Общие свойства параметрических объектов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ParametricPath.ParamType">
            <summary>Способ задания параметризации</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ParametricPath.ParametricType.DirectedGuidePathParam">
            <summary>Свойства объекта задаются классом MultipleGuidePathParametric</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ParametricPath.ParametricType.OneGuidePathParam">
            <summary>Свойства объекта задаются классом OneGuidePathParametric</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ParametricPath.ParametricType.VariableParam">
            <summary>Свойства объекта задаются классом VariableParametric</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ParametricPath.ParametricType">
            <summary>Способы задания параметризации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ParametricPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания параметрического пути</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ParametricPath">
            <summary>Параметрический путь</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetPath.RemoveLoops">
            <summary>Удалять петли</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetPath.BreakFillType">
            <summary>Способ обработки разрывов</summary>
            <remarks>Для границ контуров, состоящих из нескольких рёбер или имеющих изломы в вершинах, возможно возникновение
разрывов между эквидистантами, построенными для каждого ребра. В этом случае задаётся способ обработки такого разрыва.
По умолчанию используется метод продолжения по кривой</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.OffsetPath.BreakFill.NaturalBreak">
            <summary>Продолжать по кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OffsetPath.BreakFill.LinearBreak">
            <summary>Продолжать по касательной</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OffsetPath.BreakFill.RoundBreak">
            <summary>Скругление</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OffsetPath.BreakFill">
            <summary>Типы обработки разрывов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetPath.Offset">
            <summary>Значение смещения</summary>
            <remarks>Значение смещения задаётся двумя взаимоисключающими способами: по точке или по значению</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetPath.OffsetPoint">
            <summary>Точка, определяющая значение смещения</summary>
            <remarks>В настоящей версии в качестве точки можно выбирать только 3D узел. В остальных случаях путь строится не будет.
Значение смещения задаётся двумя взаимоисключающими способами: по точке или по значению</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetPath.PlanarWire">
            <summary>Проволочная модель</summary>
            <remarks>В настоящей версии в качестве проволочной модели можно выбирать только плоский 3D путь. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.OffsetPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания пути как смещения к плоской проволочной модели</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.OffsetPath">
            <summary>Путь, построенный как смещение к плоской проволочной модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SectionPath.IntPlane">
            <summary>Поверхность</summary>
            <remarks>В настоящей версии в качестве поверхности можно выбирать только рабочую плоскость. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.SectionPath.IntSurface">
            <summary>Поверхность</summary>
            <remarks>В настоящей версии в качестве поверхности можно выбирать только рабочую плоскость. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.SectionPath.IntBody">
            <summary>Тело</summary>
            <remarks>В настоящей версии в качестве тела можно выбирать только операцию. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.SectionPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания пути на пересечении тела и поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.SectionPath">
            <summary>Путь, построенный на пересечении тела и поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DPath.OnHatch">
            <summary>2D узел, задающий перемещение узла пути в 3D узел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DPath.Target">
            <summary>3D узел для привязки плоскости пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DPath.Segments">
            <summary>Получить упорядоченное множество сегментов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DPath.SegmentsSet.default(System.Int32)">
            <summary>Сегмент по номеру</summary>
            <param name="index">Номер сегмента</param>
            <remarks>Сегменты нумеруются от нуля. Если индекс отрицательный или превышает количество сегментов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.DeleteAll">
            <summary>Удалить все сегменты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Delete(System.Int32)">
            <summary>Удалить сегмент по номеру</summary>
            <param name="Index">Номер сегмента</param>
            <remarks>Сегменты нумеруются от нуля. Если индекс отрицательный или превышает количество сегментов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Add(TFlex.Model.Model3D.Path2DPath.SegmentsSet.Segment)">
            <summary>Добавить сегмент в конец списка</summary>
            <param name="segment">Добавляемый сегмент</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Insert(System.Int32,TFlex.Model.Model3D.Path2DPath.SegmentsSet.Segment)">
            <summary>Вставить сегмент перед номером</summary>
            <param name="Index">Номер сегмента</param>
            <param name="segment">Вставляемый сегмент</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Segment.Clone">
            <summary>Создает копию объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Segment.Path">
            <summary>2D путь</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Segment.WorkSurface">
            <summary>Рабочая поверхность, задающая ориентацию пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Segment.#ctor(TFlex.Model.Model3D.WorkSurface,TFlex.Model.Model2D.Construction)">
            <summary>Конструктор сегмента</summary>
            <param name="surface">Рабочая поверхность, задающая ориентацию пути</param>
            <param name="path">2D путь</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Path2DPath.SegmentsSet.Segment">
            <summary>Класс сегмента</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Path2DPath.SegmentsSet">
            <summary>Упорядоченное множество сегментов 3D пути: 2D путь и рабочая поверхность</summary>
            <remarks>Возможно перечисление сегментов с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Path2DPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания пути по набору сегментов: 2D путь и рабочая поверхность</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Path2DPath">
            <summary>Путь, построенный по набору сегментов: 2D путь и рабочая поверхность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoProjectionsPath.SecondProjection">
            <summary>Вторая проекция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoProjectionsPath.FirstProjection">
            <summary>Первая проекция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoProjectionsPath.Projection.Path">
            <summary>Проекция</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoProjectionsPath.Projection.Workplane">
            <summary>Рабочая плоскость, задающую положение пути</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TwoProjectionsPath.Projection">
            <summary>Класс проекции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TwoProjectionsPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания пути по двум проекциям</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.TwoProjectionsPath">
            <summary>Путь, построенный по двум проекциям</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3DPath.Wires">
            <summary>Множество проволочных моделей</summary>
            <remarks>В настоящей версии в качестве проволочных моделей можно выбирать только 3D пути. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3DPath.StartPoint">
            <summary>Точка начала составного пути</summary>
            <remarks>В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Path3DPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания пути по набору проволочных моделей</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Path3DPath">
            <summary>Путь по набору проволочных моделей</summary>
            <remarks>В настоящей версии в качестве проволочных моделей можно выбирать только 3D пути. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyPath.EndPoint">
            <summary>Конечная граница копирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyPath.StartPoint">
            <summary>Начальная граница копирования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyPath.TargetLCS">
            <summary>Целевая локальная система координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyPath.SourceLCS">
            <summary>Исходная локальная система координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyPath.SourcePath3D">
            <summary>Копируемый путь</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CopyPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания копии пути</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyPath">
            <summary>Копия пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionPath.ProjectionDirection">
            <summary>Направление проецирования</summary>
            <remarks>Направление проецирования задаётся двумя взаимосиключающими методами: двумя точками или направлением.
В настоящей версии в качестве направления можно выбирать только оси системы координат. В остальных случаях путь строится не будет.
Если направление не задано, то выполняется проецирование по нормали к поверхности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionPath.SecondPoint">
            <summary>Вторая точка, задающая направление проецирования</summary>
            <remarks>Направление проецирования задаётся двумя взаимосиключающими методами: двумя точками или направлением.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях путь строится не будет.
Если направление не задано, то выполняется проецирование по нормали к поверхности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionPath.FirstPoint">
            <summary>Первая точка, задающая направление проецирования</summary>
            <remarks>Направление проецирования задаётся двумя взаимоиcключающими методами: двумя точками или направлением.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях путь строится не будет.
Если направление не задано, то выполняется проецирование по нормали к поверхности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionPath.ProjectionSurface">
            <summary>Поверхность проецирования</summary>
            <remarks>В настоящей версии в качестве поверхности можно выбирать только операции и грани. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionPath.ProjectedWire">
            <summary>Проецируемая провлочная геометрия</summary>
            <remarks>В настоящей версии в качестве проволочной модели можно выбирать только 3D путь. В остальных случаях путь строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания проекции проволочной модели на листовое или твёрдое тело</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionPath">
            <summary>Проекция проволочной модели на листовое или твёрдое тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.EdgePath.Edges">
            <summary>Множество рёбер</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.EdgePath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания пути по набору рёбер</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.EdgePath">
            <summary>Класс пути, построенного по набору рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AreaPath.OnHatch">
            <summary>2D узел, задающий перемещение узла контура в 3D узел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AreaPath.Target">
            <summary>3D узел для привязки плоскости контура</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AreaPath.Area">
            <summary>Штриховка, задающая форму пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AreaPath.WorkSurface">
            <summary>Рабочая поверхность, задающая положение пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.AreaPath.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания пути по одноконтурной штриховке и рабочей поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.AreaPath">
            <summary>Класс пути, построенного по одноконтурной штриховке, задающей форму пути и рабочей поверхности, задающей ориентацию пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PolylineSplinePath3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания полилинии</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.PolylineSplinePath3D">
            <summary>Полилиния</summary>
            <example>
                <code name="Полилиния">
public static void PolylineSplinePath3D()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("3D путь - полилиния");//Открытие блока изменений документа

   PolylineSplinePath3D polylineSplinePath3D = new PolylineSplinePath3D(document);
   PointsArray pa = polylineSplinePath3D.Points;

   CoordinateNode3D node1 = new CoordinateNode3D(document); 
   node1.X = 100; node1.Y = 100; node1.Z = 100; 

   CoordinateNode3D node2 = new CoordinateNode3D(document); 
   node2.X = 120; node2.Y = 130; node2.Z = 100; 

   CoordinateNode3D node3 = new CoordinateNode3D(document); 
   node3.X = 120; node3.Y = 140; node3.Z = 130;

   pa.Add(node1.Geometry.Point);
   pa.Add(node2.Geometry.Point);
   pa.Add(node3.Geometry.Point);

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model3D.ApproximatedSplinePath3D.SetKnot(System.Int32,TFlex.Model.Parameter)">
            <summary>Установить значение узла параметризации</summary>
            <param name="index">Номер узла</param>
            <param name="param">Значение</param>
            <remarks>Значения могут задаваться только для параметризации вручную</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ApproximatedSplinePath3D.GetKnot(System.Int32)">
            <summary>Получить значение узла параметризации</summary>
            <param name="index">Номер узла</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ApproximatedSplinePath3D.Parameterization">
            <summary>Тип параметризации</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ApproximatedSplinePath3D.ParameterizationType.Centripetal">
            <summary>Центробежная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ApproximatedSplinePath3D.ParameterizationType.Uniform">
            <summary>Однородная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ApproximatedSplinePath3D.ParameterizationType.Chord">
            <summary>Пропорциональная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.ApproximatedSplinePath3D.ParameterizationType.Manual">
            <summary>Вручную</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ApproximatedSplinePath3D.ParameterizationType">
            <summary>Типы параметризации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ApproximatedSplinePath3D.SetWeight(System.Int32,TFlex.Model.Parameter)">
            <summary>Установить вес точки</summary>
            <param name="index">Номер точки</param>
            <param name="weight">Вес точки</param>
            <remarks>Вес должен быть больше нуля</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ApproximatedSplinePath3D.GetWeight(System.Int32)">
            <summary>Получить вес точки</summary>
            <param name="index">Номер точки</param>
        </member>
        <member name="P:TFlex.Model.Model3D.ApproximatedSplinePath3D.Degree">
            <summary>Степень сплайна</summary>
            <remarks>Значение степени округляется до ближайшего целого.
Степень должна быть больше нуля и меньше числа точек.</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ApproximatedSplinePath3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сплайна по ломаной</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ApproximatedSplinePath3D">
            <summary>Класс сплайна, построенного по ломаной</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.InterpolatingSplinePath3D.EndDerivative">
            <summary>Касательные условия в конце кривой</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.InterpolatingSplinePath3D.StartDerivative">
            <summary>Касательные условия в начале кривой</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.InterpolatingSplinePath3D.Derivative.Magnitude">
            <summary>Длина касательной</summary>
            <remarks>Используется только в случае задания касательного условия на конце и установленного признака задания длины касательной</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.InterpolatingSplinePath3D.Derivative.Tangent">
            <summary>Признак задания длины касательной</summary>
            <remarks>Используется только в случае задания касательного условия на конце</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.InterpolatingSplinePath3D.Derivative.TangentDirection">
            <summary>Направление, задающее касательное условие на конце кривой</summary>
            <remarks>Касательное условие задаётся двумя взаимосиключающими методами : точкой или направлением</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.InterpolatingSplinePath3D.Derivative.TangentPoint">
            <summary>Точка, задающая касательное условие на конце кривой</summary>
            <remarks>Касательное условие задаётся двумя взаимосиключающими методами: точкой или направлением</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.InterpolatingSplinePath3D.Derivative">
            <summary>Касательные условия на концах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.InterpolatingSplinePath3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания сплайна через узлы</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.InterpolatingSplinePath3D">
            <summary>Класс сплайна построенного через узлы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SplinePath3D.Periodic">
            <summary>Свойство периодичности сплайна</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SplinePath3D.Points">
            <summary>Множество контрольных точек</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SplinePath3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания пути по точкам</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.SplinePath3D.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.SplinePath3D">
            <summary>Класс пути по точкам</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DSegments">
            <summary>Возвращает информацию об участках пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DSegment.FractureInEnd">
            <summary>Возвращает true, если нарушены условия гладкости пути трубопровода в точке конца участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DSegment.FractureInStart">
            <summary>Возвращает true, если нарушены условия гладкости пути трубопровода в точке начала участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DSegment.Round">
            <summary>Параметры скругления участка пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DSegment.End">
            <summary>Точка конца участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DSegment.Start">
            <summary>Точка начала участка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DSegment.Length">
            <summary>Длина</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DSegment.Type">
            <summary>Тип участка пути</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Path3D.Path3DSegment">
            <summary>Участок пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DRoundParameters.Angle">
            <summary>Угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DRoundParameters.Raduis">
            <summary>Радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Path3DRoundParameters.Center">
            <summary>Точка центра скругления</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Path3D.Path3DRoundParameters">
            <summary>Параметры скругления участка пути</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Path3D.Path3DSegmentType.Arc">
            <summary>Дуга</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Path3D.Path3DSegmentType.Rounded">
            <summary>Скругление</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Path3D.Path3DSegmentType.Curve">
            <summary>Кривая</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Path3D.Path3DSegmentType.Line">
            <summary>Отрезок</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Path3D.Path3DSegmentType">
            <summary>Тип участка пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового пути</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Reverse">
            <summary>Реверисровать направление пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.ConvertToSpline">
            <summary>Получить параметры для преобразования пути в сплайн</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.Geometry">
            <summary>Получить геометрические данные пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.ConvertToSplineData.Tolerance">
            <summary>Точность преобразования пути в сплайн</summary>
            <remarks>Точность задаётся параметром, нормированным от 0.0 (грубее) до 1.0 (точнее)</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.ConvertToSplineData.Convert">
            <summary>Параметр преобразования пути в сплайн</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Path3D.ConvertToSplineData">
            <summary>Класс параметров для преобразования пути в сплайн</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.Box">
            <summary>Получить границы пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.Curve">
            <summary>Получить кривую, на которой лежит кривая</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.Wire">
            <summary>Получить проволочную модель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.Contour">
            <summary>Получить контур</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.Point">
            <summary>Если путь лежит на окружности или эллипсе, то можно получить их центр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.Plane">
В большинстве случаев путь имеет не более одного направления. Выбрать любое возможное направление
property ModelDirection ^ Direction { ModelDirection ^ get (); }
<summary>Если путь лежит в плоскости, то можно получить эту плоскость</summary></member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.LineDirection">
            <summary>Если ребро лежит на прямой, то можно получить её направление</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.PlaneDirection">
            <summary>Если путь лежит в плоскости, то можно получить нормаль к этой плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Path3D.GeometryData.Axis">
            <summary>Если путь лежит на прямой, то можно получить её направление</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Path3D.GeometryData">
            <summary>Множество геометрических данных пути</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Path3D.TestCompatibility(TFlex.Model.Model3D.Path3D,TFlex.Model.Model3D.Path3D)">
            <summary>Проверить совместимость типов, трасса и трасса</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Path3D">
            <summary>Базовый класс для всех типов 3D путей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TableFunction.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TableFunction.default(System.Int32)">
            <summary>Элемент по номеру</summary>
            <param name="index">Номер элемента</param>
            <remarks>Элементы нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.DeleteAll">
            <summary>Удалить все точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.Delete(System.Int32)">
            <summary>Удалить точку по номеру</summary>
            <param name="index">Номер точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.Add(TFlex.Model.Model3D.TableFunction.Dependence)">
            <summary>Добавить точку в конец списка</summary>
            <param name="pair">Пара независимого и зависимого параметра</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.Insert(System.Int32,TFlex.Model.Model3D.TableFunction.Dependence)">
            <summary>Вставить точку перед номером</summary>
            <param name="index">Номер точки</param>
            <param name="pair">Пара независимого и зависимого параметра</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.TableFunction.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.Dependence.Clone">
            <summary>Метод создает неполную копию объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TableFunction.Dependence.Y">
            <summary>Зависимый параметр</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TableFunction.Dependence.X">
            <summary>Независимый параметр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TableFunction.Dependence.#ctor(TFlex.Model.Parameter,TFlex.Model.Parameter)">
            <summary>Конструктор</summary>
            <param name="x">Независимый параметр</param>
            <param name="y">Зависимый параметр</param>
        </member>
        <member name="T:TFlex.Model.Model3D.TableFunction.Dependence">
            <summary>Структура для хранения пары независимого ( X ) и зависимого ( Y ) значений</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TableFunction">
            <summary>Табличная функция</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="M:Path2Dto3D.IsAxis">
Путь может быть осью
</member>
        <member name="M:Path3D.CreatePathForFixedSegments(CList&lt;Path2Dto3D**,Path2Dto3D**&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,Point2Dto3D*,ENI_Path*,System.Int32)">
Создавать путь по фиксированным сегментам. Разрывы предалагается интерпретировать как ошибку
</member>
        <member name="P:TFlex.Model.Model3D.OffsetProfile.InnerContourType">
            <summary>Способ обработки внутреннего контура</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OffsetProfile.InnerContour.DecreaseInnerContour">
            <summary>Уменьшить</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OffsetProfile.InnerContour.ExpandInnerContour">
            <summary>Расширить</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OffsetProfile.InnerContour">
            <summary>Обработка внутренних контуров</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetProfile.BreakFillType">
            <summary>Способ обработки разрывов</summary>
            <remarks>Для границ контуров, состоящих из нескольких рёбер или имеющих изломы в вершинах, возможно возникновение
разрывов между эквидистантами, построенными для каждого ребра. В этом случае задаётся способ обработки такого разрыва.
По умолчанию используется метод продолжения по кривой</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.OffsetProfile.BreakFill.NaturalBreak">
            <summary>Продолжать по кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OffsetProfile.BreakFill.LinearBreak">
            <summary>Продолжать по касательной</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OffsetProfile.BreakFill.RoundBreak">
            <summary>Скругление</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OffsetProfile.BreakFill">
            <summary>Типы обработки разрывов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetProfile.Offset">
            <summary>Значение смещения</summary>
            <remarks>Значение смещения задаётся двумя взаимоисключающими способами: по точке или по значению</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetProfile.OffsetPoint">
            <summary>Точка, определяющая значение смещения</summary>
            <remarks>В настоящей версии в качестве точки можно выбирать только 3D узел. В остальных случаях профиль строится не будет.
Значение смещения задаётся двумя взаимоисключающими способами : по точке или по значению</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OffsetProfile.SourceContour">
            <summary>Плоский контур, для которого строится смещение</summary>
            <remarks>В настоящей версии в качестве контура можно выбирать только плоские листовые профили. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.OffsetProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания смещения к плоскому контуру</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.OffsetProfile">
            <summary>Смещение к плоскому контуру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionProfile.ProjectionDirection">
            <summary>Направление проецирования</summary>
            <remarks>Направление проецирования задаётся двумя взаимоисключающими методами: двумя точками или направлением.
В настоящей версии в качестве направления можно выбирать только оси системы координат. В остальных случаях профиль строится не будет.
Если направление не задано, то выполняется проецирование по нормали к поверхности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionProfile.SecondPoint">
            <summary>Вторая точка, задающая направление проецирования</summary>
            <remarks>Направление проецирования задаётся двумя взаимоисключающими методами: двумя точками или направлением.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет.
Если направление не задано, то выполняется проецирование по нормали к поверхности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionProfile.FirstPoint">
            <summary>Первая точка, задающая направление проецирования</summary>
            <remarks>Направление проецирования задаётся двумя взаимоисключающими методами: двумя точками или направлением.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет.
Если направление не задано, то выполняется проецирование по нормали к поверхности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionProfile.ProjectionSurface">
            <summary>Поверхность проецирования</summary>
            <remarks>В настоящей версии в качестве поверхности можно выбирать только операции и грани. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ProjectionProfile.ProjectedContour">
            <summary>Проецируемый контур</summary>
            <remarks>В настоящей версии в качестве контура можно выбирать только листовой профиль. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectionProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания проекции контура на листовое или твёрдое тело</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectionProfile">
            <summary>Проекция контура на листовое или твёрдое тело</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyProfile.TargetLCS">
            <summary>Целевая локальная система координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyProfile.SourceLCS">
            <summary>Исходная локальная система координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyProfile.SourceProfile">
            <summary>Копируемый профиль</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CopyProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания копии профиля</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyProfile">
            <summary>Копия профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TextProfile.OnText">
            <summary>2D узел, задающий перемещение узла контура в 3D узел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TextProfile.Target">
            <summary>3D узел для привязки плоскости контура</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TextProfile.Text">
            <summary>Текст, задающий форму профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TextProfile.WorkSurface">
            <summary>Рабочая поверхность, задающую положение профиля</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TextProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания профиля по тексту и рабочей поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.TextProfile">
            <summary>Профиль, построенный по тексту, задающей форму профиля и рабочей поверхности, задающей ориентацию профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SurfaceSetDevelopmentProfile.DeleteRedundant">
            <summary>Параметр "удалять лишние рёбра"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SurfaceSetDevelopmentProfile.FixedEdges">
            <summary>Набор неразрывных рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SurfaceSetDevelopmentProfile.PointOnFace">
            <summary>Точка на наборе граней</summary>
            <remarks>Эта точка задаёт начало развёртки. В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.SurfaceSetDevelopmentProfile.DevelopmentFaces">
            <summary>Набор разворачиваемых граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SurfaceSetDevelopmentProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания развёртки набора граней</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.SurfaceSetDevelopmentProfile">
            <summary>Развёртка набора граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ConeDevelopmentProfile.SectionIsolinePoint">
            <summary>Точка, через которую проходит изопараметрическая прямая, вдоль которой разрезается замкнтуая грань</summary>
            <remarks>В настоящей версии в качестве точки можно выбирать только 3D узел. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ConeDevelopmentProfile.PointOnFace">
            <summary>Точка на грани</summary>
            <remarks>Эта точка задаёт начало развёртки.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ConeDevelopmentProfile.Face">
            <summary>Разворачиваемая грань</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ConeDevelopmentProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания развёртки грани на конической поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ConeDevelopmentProfile">
            <summary>Развёртка грани на конической поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CylinderDevelopmentProfile.SectionIsolineAngle">
            <summary>Угол, определяющий изопараметрическую прямую, вдоль которой разрезается замкнутая грань</summary>
            <remarks>Линия разреза может задаваться тремя взаимоисключающими путями:
<list class="bullet"><item>кривой на грани;</item><item>изопараметрической прямой, проходящей через точку на поверхности;</item><item>углом разрезающей прямой.</item></list></remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.CylinderDevelopmentProfile.SectionIsolinePoint">
            <summary>Точка, через которую проходит изопараметрическая прямая, вдоль которой разрезается замкнутая грань</summary>
            <remarks>В настоящей версии в качестве точки можно выбирать только 3D узел. В остальных случаях профиль строится не будет.
Линия разреза может задаваться тремя взаимоисключающими путями:
<list class="bullet"><item>кривой на грани;</item><item>изопараметрической прямой, проходящей через точку на поверхности;</item><item>углом разрезающей прямой.</item></list></remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.CylinderDevelopmentProfile.SectionCurve">
            <summary>Кривая, вдоль которой разрезается замкнутая грань</summary>
            <remarks>В настоящей версии в качестве кривой можно выбирать только ребро. В остальных случаях профиль строится не будет.
Линия разреза может задаваться тремя взаимоисключающими путями:
<list class="bullet"><item>кривой на грани;</item><item>изопараметрической прямой, проходящей через точку на поверхности;</item><item>углом разрезающей прямой.</item></list></remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.CylinderDevelopmentProfile.PointOnFace">
            <summary>Точка на грани</summary>
            <remarks>Эта точка задаёт начало развёртки.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.CylinderDevelopmentProfile.Face">
            <summary>Разворачиваемая грань</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CylinderDevelopmentProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания развёртки грани на цилиндрической поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.CylinderDevelopmentProfile">
            <summary>Развёртка грани на цилиндрической поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LineSurfaceDevelopmentProfile.PointOnFace">
            <summary>Точка на грани</summary>
            <remarks>Эта точка задаёт начало развёртки.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.LineSurfaceDevelopmentProfile.Face">
            <summary>Разворачиваемая грань</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LineSurfaceDevelopmentProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания развёртки грани на линейчатой поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.LineSurfaceDevelopmentProfile">
            <summary>Развёртка грани на линейчатой поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ConvolutionProfile.Orientation">
            <summary>Ориентация направления свёртки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ConvolutionProfile.DirectionPointOnSurface">
            <summary>Вторая точка на поверхности</summary>
            <remarks>Эта точка и вторая точка в плоскости контура задают направление свертки.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ConvolutionProfile.StartPointOnSurface">
            <summary>Первая точка на поверхности</summary>
            <remarks>Эта точка и первая точка в плоскости контура задают начало свертки.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ConvolutionProfile.ConvolutionSurface">
            <summary>Набор граней, образующих поверхность, на которую выполняется свёртка</summary>
            <remarks>В настоящей версии в качестве поверхности можно выбирать только конические и цилиндрические грани. В остальных случаях профиль строится не будет.
В настоящей версии при свёртке учитываются границы граней. То есть, если границы свёртки пересекают границы грани или не лежат на грани, то профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ConvolutionProfile.DirectionPointOnPlane">
            <summary>Вторая точка в плоскости сворачиваемго контура</summary>
            <remarks>Эта точка и вторая точка на поверхности задают направление свертки.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ConvolutionProfile.StartPointOnPlane">
            <summary>Первая точка в плоскости сворачиваемго контура</summary>
            <remarks>Эта точка и первая точка на поверхности задают начало свёртки.
В настоящей версии в качестве точки можно выбирать только 3D узлы. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ConvolutionProfile.PlanarContour">
            <summary>Сворачиваемый плоский контур</summary>
            <remarks>В настоящей версии в качестве контура можно выбирать только плоские листовые профили. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.ConvolutionProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания свёртки плоского профиля на поверхность</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ConvolutionProfile">
            <summary>Свёртка плоского контура на поверхность</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AreaProfile.OnHatch">
            <summary>2D узел, задающий перемещение узла контура в 3D узел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AreaProfile.Target">
            <summary>3D узел для привязки плоскости контура</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AreaProfile.Area">
            <summary>Штриховка, задающая форму профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AreaProfile.WorkSurface">
            <summary>Рабочая поверхность, задающая ориентацию профиля</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.AreaProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания профиля по штриховке и рабочей поверхности</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.FaceProfile.Faces">
            <summary>Множество граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FaceProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания профиля по набору граней</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.FaceProfile">
            <summary>Профиль, построенный по набору граней</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SketchProfile.WorkSurface">
            <summary>Рабочая поверхность, с которой берётся эскиз</summary>
            <remarks>В настоящей версии в качестве рабочей поверхности можно выбирать только рабочую плоскость. В остальных случаях профиль строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.SketchProfile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания профиля по эскизу</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.SketchProfile">
            <summary>Профиль, построенный по эскизу</summary>
            <example>
                <code name="Профиль, построенный по эскизу">
public static void SketchProfile()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("профиль по штриховке");//Открытие блока изменений документа

   //создание узлов		
   FreeNode fn1 = new FreeNode(document, 10, 10);
   FreeNode fn2 = new FreeNode(document, 40, 30);
   FreeNode fn3 = new FreeNode(document, 70, 10);
		
   //создание линий, проходящих через эти узлы		
   ConstructionOutline l1 = new ConstructionOutline(document, fn1, fn2);
   ConstructionOutline l2 = new ConstructionOutline(document, fn2, fn3);
   ConstructionOutline l3 = new ConstructionOutline(document, fn3, fn1);
		
   //рабочая плоскость(вид слева), на которой будет построен профиль		
   StandardWorkplane swp = new StandardWorkplane(document, StandardWorkplane.StandardType.Left); 
   SketchProfile sp = new SketchProfile(document);
   sp.WorkSurface = swp;

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model3D.Profile.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового профиля</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ConvertToSpline">
            <summary>Получить параметры для преобразования составных контуров профиля в сплайны</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.Transparency">
            <summary>Прозрачность</summary>
            <remarks>Значение от 0 до 1</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.Thickness">
            <summary>Получить свойства толщины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.Geometry">
            <summary>Получить геометрические данные профиля</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ConvertToSplineData.Tolerance">
            <summary>Точность преобразования составных контуров профиля в сплайны</summary>
            <remarks>Точность задаётся параметром, нормированным от 0.0 (грубее) до 1.0 (точнее)</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ConvertToSplineData.Convert">
            <summary>Параметр преобразования составных контуров профиля в сплайны</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Profile.ConvertToSplineData">
            <summary>Параметры для преобразования составных контуров профиля в сплайны</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ThicknessData.SeparateLoopType">
            <summary>Способ обработки замкнутых контуров</summary>
            <remarks>Имеет смысл только для плоских контуров</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.SeparateLoop.WireLoop">
            <summary>Придать толщину</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.SeparateLoop.SheetLoop">
            <summary>Замыкать область</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Profile.ThicknessData.SeparateLoop">
            <summary>Способы обработки замкнутых контуров</summary>
            <remarks>Имеет смысл только для плоских контуров</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ThicknessData.CornerFillType">
            <summary>Способ обработки концов</summary>
            <remarks>Имеет смысл только для плоских контуров</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.CornerFill.LinearCorner">
            <summary>По прямой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.CornerFill.RoundCorner">
            <summary>Скруглить</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Profile.ThicknessData.CornerFill">
            <summary>Обработка концов</summary>
            <remarks>Имеет смысл только для плоских контуров</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ThicknessData.GapFillType">
            <summary>Способы обработки разрывов</summary>
            <remarks>При построении тонкостенного выталкивания для плоского контура строится эквидистантный контур.
Для границ контуров, состоящих из нескольких рёбер или имеющих изломы в вершинах, возможно возникновение
разрывов между эквидистантами, построенными для каждого ребра. В этом случае задаётся способ обработки такого разрыва.
По умолчанию используется метод продолжения по кривой</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.GapFill.NaturalGap">
            <summary>Продолжать по кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.GapFill.LinearGap">
            <summary>Продолжать по касательной</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.GapFill.RoundGap">
            <summary>Скругление</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Profile.ThicknessData.GapFill">
            <summary>Обработка разрывов в случае придания толщины стенкам контуров</summary>
            <remarks>Имеет смысл только для плоских контуров</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ThicknessData.Thickness2">
            <summary>Получить второе значение толщины стенок</summary>
            <remarks>Второе значение используется для задания толщины внутренней стенки в случае двусторонних стенок</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ThicknessData.Thickness1">
            <summary>Первое значение толщины стенок</summary>
            <remarks>Первое значение используется для задания толщины стенки в случае односторонних или симметричных стенок</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ThicknessData.ThicknessType">
            <summary>Тип тонкостенного элемента</summary>
            <remarks>Имеет смысл только для плоских контуров</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.Thickness.DoubleSided">
            <summary>Стенки задаются разными толщинами снаружи и изнутри</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.Thickness.Symmetrical">
            <summary>Стенки симметрично наружу и внутрь</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.Thickness.Inward">
            <summary>Стенки изнутри контура</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Profile.ThicknessData.Thickness.Outward">
            <summary>Стенки снаружи контура</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Profile.ThicknessData.Thickness">
            <summary>Способ придания толщины</summary>
            <remarks>Имеет смысл только для плоских контуров</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.ThicknessData.ThinWalled">
            <summary>Параметр придания толщины</summary>
            <remarks>Имеет смысл только для плоских контуров</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Profile.ThicknessData">
            <summary>Свойства толщины</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.WireBox">
            <summary>Получить границы проволчного профиля</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelBox" />, хранящий границы и ссылку на эти геометрические данные профиля</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.SheetBox">
            <summary>Получить границы листового профиля</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelBox" />, хранящий границы и ссылку на эти геометрические данные профиля</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.Curve">
            <summary>Получить кривую, на которой лежит профиль</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelCurve" />, хранящий кривую и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких рёбер, кривая может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.Surface">
            <summary>Получить поверхность, на которой лежит профиль</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelSurface" />, хранящий поверхность и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или состоящих только из рёбер (проволочные профили), поверхность может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.Sheet">
            <summary>Получить листовое тело профиля</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelSheet" />, хранящий листовое тело и ссылку на эти геометрические данные профиля</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.WireContour">
            <summary>Получить контур для проволочного профиля</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelContour" />, хранящий контуры и ссылку на эти геометрические данные профиля</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.LaminarContour">
            <summary>Получить контур - границы профиля</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelContour" />, хранящий контуры и ссылку на эти геометрические данные профиля</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.SheetContour">
            <summary>Получить контур - листовое тело</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelContour" />, хранящий контуры и ссылку на эти геометрические данные профиля</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.CurvePoint">
            <summary>Если профиль лежит на окружности или эллипсе, можно получить центр окружности или эллипса</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelPoint3D" />, хранящий координаты точки и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, точка может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.ToreCenter">
            <summary>Если профиль лежит на торе, то можно получить центр тора</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelPoint3D" />, хранящий координаты точки и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, точка может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.SphereCenter">
            <summary>Если профиль лежит на сфере, то можно получить центр сферы</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelPoint3D" />, хранящий координаты точки и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, точка может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.Plane">
            <summary>Получить плоскость</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelPlane" />, хранящий координаты плоскости и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или одного прямого ребра, плоскость может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.CurveDirection">
            <summary>Если профиль лежит на окружности или эллипсе, то можно получить направление их осей</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelDirection" />, хранящий координаты вектора и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, направление может быть не определено</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.LineDirection">
            <summary>Если профиль лежит на прямой, то можно получить направление этой прямой</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelDirection" />, хранящий координаты вектора и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, направление может быть не определено</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.PlaneDirection">
            <summary>Если профиль лежит на плоскости, то можно получить направление нормали к этой плоскости</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelDirection" />, хранящий координаты вектора и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, направление может быть не определено</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.ToreDirection">
            <summary>Если профиль лежит на торе, то можно получить направление его оси</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelDirection" />, хранящий координаты вектора и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, направление может быть не определено</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.CylinderDirection">
            <summary>Если профиль лежит на цилиндре, то можно получить направление его оси</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelDirection" />, хранящий координаты вектора и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, направление может быть не определено</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.CurveAxis">
            <summary>Если профиль лежит на окружности или эллипсе, то можно получить их ось</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelAxis" />, хранящий координаты оси и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, ось может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.LineAxis">
            <summary>Если профиль лежит на прямой, то можно получить эту прямую</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelAxis" />, хранящий координаты оси и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, ось может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.ToreAxis">
            <summary>Если профиль лежит на торе, то можно получить его ось</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelAxis" />, хранящий координаты оси и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, ось может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Profile.GeometryData.CylinderAxis">
            <summary>Если профиль лежит на цилиндре, то можно получить его ось</summary>
            <returns>Объект класса <see cref="T:TFlex.Model.Model3D.Geometry.ModelAxis" />, хранящий координаты оси и ссылку на эти геометрические данные профиля</returns>
            <remarks>Для профилей, состоящих из нескольких граней или рёбер, ось может быть не определена</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Profile.GeometryData">
            <summary>Множество геометрических данных профиля</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Profile">
            <summary>Базовый класс для всех типов профилей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TwoPathesIntersectionPoint.Create(TFlex.Model.Model3D.Node3D)">
            <summary>Создать или найти модельный узел на пересечении, если установлен sourceNode использовать этот узел, а не создавать новый</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoPathesIntersectionPoint.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoPathesIntersectionPoint.HandleForSelection">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoPathesIntersectionPoint.CanSelect">
            <summary>Управление выбором точек на пересечении путей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoPathesIntersectionPoint.Coords">
            <summary>Получить координаты точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoPathesIntersectionPoint.PathSecond">
            <summary>Второй путь</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TwoPathesIntersectionPoint.PathFirst">
            <summary>Первый путь</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.TwoPathesIntersectionPoint">
            <summary>Узел на пересечении двух путей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshPoint.Coords">
            <summary>Получить координаты точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshPoint.Plane3">
            <summary>Третья плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshPoint.Plane2">
            <summary>Вторая плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshPoint.Plane1">
            <summary>Первая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshPoint.Create(System.Collections.Generic.Dictionary`2{TFlex.Model.Model3D.Workplane,TFlex.Model.Model3D.Workplane})">
            <summary>Создать или найти модельный узел на пересечении с заменой рабочей плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MeshPoint.Create">
            <summary>Создать или найти модельный узел на пересечении</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshPoint.GroupType">
            <summary>Тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MeshPoint.HandleForSelection">
            <summary>Для внутреннего использования</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MeshPoint">
            <summary>Узел на пересечении трёх плоскостей</summary>
            <remarks>Это временный объект. Узел нельзя явно создать и использовать как родителя для других объектов.
Он возвращается при селекции на сетке точек пересечения рабочих плоскостей</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreePlanesPoint.Plane3">
            <summary>Третья плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreePlanesPoint.Plane2">
            <summary>Вторая плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.ThreePlanesPoint.Plane1">
            <summary>Первая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ThreePlanesPoint.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла на пересечении трёх плоскостей</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.ThreePlanesPoint">
            <summary>Узел на пересечении трёх плоскостей</summary>
            <example>
                <code name="Узел на пересечении трёх плоскостей">
public static void ThreePlanesPoint(ModelPlane p1, ModelPlane p2, ModelPlane p3)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Узел на пересечении трёх плоскостей");//Открытие блока изменений документа

   ThreePlanesPoint threePlanesPoint = new ThreePlanesPoint(document);
   threePlanesPoint.Plane1 = p1.Geometry.Plane;//Первая плоскость
   threePlanesPoint.Plane2 = p2.Geometry.Plane;//Вторая плоскость
   threePlanesPoint.Plane3 = p3.Geometry.Plane;//Третья плоскость

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.RelationPoint.SecondElement">
            <summary>Второй элемент, относительно которого ищется ближайшая точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RelationPoint.FirstElement">
            <summary>Первый элемент, на котором ищется ближайшая точка</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.RelationPoint.Element.Point">
            <summary>Второй элемент как точка, относительно которой ищется ближайшая точка на первом элементе</summary>
            <remarks>Второй элемент задаётся несколькими взаимоисключающими способами: гранью, ребром, циклом, путём, операцией, точкой.
Для первого элемента, на котором ищется точка, это свойство игнорируется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.RelationPoint.Element.Path">
            <summary>Получить путь, относительно которого или на котором ищется ближайшая точка</summary>
            <remarks>Элемент задаётся несколькими взаимоисключающими способами: гранью, ребром, циклом, путём, операцией.
Второй элемент, относительно которого ищется ближайшая точка на первом элементе, может задаваться также точкой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.RelationPoint.Element.Operation">
            <summary>Операция, относительно которой или на которой ищется ближайшая точка</summary>
            <remarks>Элемент задаётся несколькими взаимоисключающими способами: гранью, ребром, циклом, путём, операцией.
Второй элемент, относительно которого ищется ближайшая точка на первом элементе, может задаваться также точкой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.RelationPoint.Element.Loop">
            <summary>Цикл, относительно которого или на котором ищется ближайшая точка</summary>
            <remarks>Элемент задаётся несколькими взаимоисключающими способами: гранью, ребром, циклом, путём, операцией.
Второй элемент, относительно которого ищется ближайшая точка на первом элементе, может задаваться также точкой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.RelationPoint.Element.Edge">
            <summary>Ребро, относительно которого или на котором ищется ближайшая точка</summary>
            <remarks>Элемент задаётся несколькими взаимоисключающими способами: гранью, ребром, циклом, путём, операцией.
Второй элемент, относительно которого ищется ближайшая точка на первом элементе, может задаваться также точкой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.RelationPoint.Element.Face">
            <summary>Получить грань, относительно которой или на которой ищется ближайшая точка</summary>
            <remarks>Элемент задаётся несколькими взаимоисключающими способами: гранью, ребром, циклом, путём, операцией.
Второй элемент, относительно которого ищется ближайшая точка на первом элементе, может задаваться также точкой</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.RelationPoint.Element">
            <summary>Элемент, относительно которого или на котором ищется ближайшая точка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.RelationPoint.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла по наименьшему расстоянию между элементами</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.RelationPoint">
            <summary>Узел по наименьшему расстоянию между элементами</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnFaceOffsetPoint.SecondAdjacent">
            <summary>Получить вторую границу, от которой строится смещение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnFaceOffsetPoint.FirstAdjacent">
            <summary>Получить первую границу, от которого строится смещение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnFaceOffsetPoint.Adjacent.Offset">
            <summary>Получить смещение узла от границы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnFaceOffsetPoint.Adjacent.Edge">
            <summary>Смежное ребро, от которого строится смещение</summary>
            <remarks>Смещение задаётся двумя взаимоисключающими способами: смежной гранью или смежным ребром</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnFaceOffsetPoint.Adjacent.Face">
            <summary>Смежная грань, от которой строится смещение</summary>
            <remarks>Смещение задаётся двумя взаимоисключающими способами: смежной гранью или смежным ребром</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.OnFaceOffsetPoint.Adjacent">
            <summary>Граница</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnFaceOffsetPoint.Face">
            <summary>Получить грань, на которой строится точка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.OnFaceOffsetPoint.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла на грани со смещением от границ</summary>
            <param name="Doc">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.OnFaceOffsetPoint">
            <summary>Узел на грани со смещением от границ</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnSurfacePoint.V">
            <summary>V - параметр узла на поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnSurfacePoint.U">
            <summary>U - параметр узла на поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnSurfacePoint.Surface">
            <summary>Поверхность, на которой строится точка</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.OnSurfacePoint.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла на поверхности</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.OnSurfacePoint">
            <summary>Узел на поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.TotalNumber">
            <summary>Количество найденных пересечений во время последней регенерации</summary>
            <remarks>Информация доступна только у пересчитанного узла</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.Number">
            <summary>Получить номер пересечения</summary>
            <remarks>В некоторых случаях может быть несколько пересечений и возможно явно задать номер пересечения</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.SecondPlane">
            <summary>Второй элемент как листовое тело</summary>
            <remarks>В качестве второго элемента можно задавать или проволочную модель, или ось, или солид, или листовое тело</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.SecondSheet">
            <summary>Второй элемент как листовое тело</summary>
            <remarks>В качестве второго элемента можно задавать или проволочную модель, или ось, или солид, или листовое тело</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.SecondSolid">
            <summary>Второй элемент как твёрдое тело</summary>
            <remarks>В качестве второго элемента можно задавать или проволочную модель, или ось, или солид, или листовое тело</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.SecondAxis">
            <summary>Второй элемент как ось</summary>
            <remarks>В качестве второго элемента можно задавать или проволочную модель, или ось, или солид, или листовое тело</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.SecondWire">
            <summary>Второй элемент как проволочная модель</summary>
            <remarks>В качестве второго элемента можно задавать или проволочную модель, или ось, или солид, или листовое тело</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.FirstAxis">
            <summary>Первый элемент как ось</summary>
            <remarks>В качестве первого элемента можно задавать или проволочную модель или ось</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.IntersectionNode3D.FirstWire">
            <summary>Первый элемент как проволочная модель</summary>
            <remarks>В качестве первого элемента можно задавать или проволочную модель или ось</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.IntersectionNode3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла на пересечении элементов</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.IntersectionNode3D">
            <summary>Узел на пересечении элементов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnWirePoint.Reference">
            <summary>Тип точки отсчёта</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OnWirePoint.ReferenceType.FromPoint">
            <summary>От точки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OnWirePoint.ReferenceType.FromEnd">
            <summary>От конца пути</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OnWirePoint.ReferenceType.FromMid">
            <summary>От середины пути</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OnWirePoint.ReferenceType.FromStart">
            <summary>От начала пути</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OnWirePoint.ReferenceType">
            <summary>Точка отсчёта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnWirePoint.Offset">
            <summary>Смещение на пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnWirePoint.Param">
            <summary>Получить параметр на пути</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnWirePoint.Parameterization">
            <summary>Тип параметризации</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OnWirePoint.ParameterizationType.ByOffset">
            <summary>Смещение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.OnWirePoint.ParameterizationType.ByParameter">
            <summary>Нормализованный по длине параметр</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.OnWirePoint.ParameterizationType">
            <summary>Типы параметризации</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnWirePoint.ReferencePoint">
            <summary>Точка отсчёта смещения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.OnWirePoint.Path">
            <summary>Путь, на котором строится 3D узел</summary>
            <remarks>В качестве пути можно задавать только профиль, путь, ребро. В остальных случаях узел строится не будет</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.OnWirePoint.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла на проволочной модели (на пути)</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.OnWirePoint">
            <summary>Узел, построенный на проволочной модели (на пути)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MassCenterNode3D.Operations">
            <summary>Множество операций</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.DeleteAll">
            <summary>Удалить все операции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.Delete(System.Int32)">
            <summary>Удалить операцию по номеру</summary>
            <param name="index">Номер операции</param>
            <remarks>Операции нумеруются от нуля. Если индекс отрицательный или превышает количество операций, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.Add(TFlex.Model.Model3D.Operation)">
            <summary>Добавить операцию в конец списка</summary>
            <param name="operation">Операция</param>
        </member>
        <member name="M:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.Insert(System.Int32,TFlex.Model.Model3D.Operation)">
            <summary>Вставить операцию перед номером</summary>
            <param name="index">Номер операции</param>
            <param name="operation">Вставляемая операция</param>
            <remarks>Операции нумеруются от нуля. Если индекс отрицательный или превышает количество операций, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray.Length">
            <summary>Количество элементов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.MassCenterNode3D.OperationsArray">
            <summary>Множество операций</summary>
            <remarks>Возможно перечисление операций с использованием конструкции foreach</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.MassCenterNode3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла в центре масс</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.MassCenterNode3D">
            <summary>Узел, построенный в центре масс</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCSPoint.Z">
            <summary>Z - координата узла относительно ЛСК</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCSPoint.Y">
            <summary>Y - координата узла относительно ЛСК</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCSPoint.X">
            <summary>X - координата узла относительно ЛСК</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCSPoint.LCS">
            <summary>Система координат, относительно которой строится 3D узел</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LCSPoint.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания точки по координатам относительно системы координат</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.LCSPoint">
            <summary>Узел, построенный по координатам относительно системы координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.GeometryNode3D.Z">
            <summary>Z - координата узла относительно другого узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.GeometryNode3D.Y">
            <summary>Y - координата узла относительно другого узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.GeometryNode3D.X">
            <summary>X - координата узла относительно другого узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.GeometryNode3D.BasePoint">
            <summary>Узел, относительно которой строится 3D узел</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.GeometryNode3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла по координатам относительно другого узла</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.GeometryNode3D">
            <summary>Узел, построенный по координатам относительно другого узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.WorkplaneNode3D.SecondProjection">
            <summary>Вторая проекция</summary>
            <remarks>Если задаётся поверхность, то 3D точка определяется только одной проекцией
В любом случае, задание второй проекции необязательно</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.WorkplaneNode3D.FirstProjection">
            <summary>Первая проекция</summary>
            <remarks>Если задаётся поверхность, то 3D точка определяется только одной проекцией.
В любом случае, задание второй проекции необязательно</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.WorkplaneNode3D.Projection.Node">
            <summary>Проекция узла - 2D узел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.WorkplaneNode3D.Projection.WorkSurface">
            <summary>Рабочая плоскость, задающая направление проецирования или поверхность, на которой лежит точка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.WorkplaneNode3D.Projection">
            <summary>Проекция</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.WorkplaneNode3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла по проекциям</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.WorkplaneNode3D">
            <summary>Узел, построенный по проекциям</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CoordinateNode3D.Z">
            <summary>Z - координата узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CoordinateNode3D.Y">
            <summary>Y - координата узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CoordinateNode3D.X">
            <summary>X - координата узла</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CoordinateNode3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания узла по координатам</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.CoordinateNode3D">
            <summary>Узел, построенный по координатам</summary>
            <example>
                <code name="Узел, построенный по координатам">
public static void CoordinateNode3D()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Построение 3D-узла");//Открытие блока изменений документа

   //Создаем 3D-узлы
   CoordinateNode3D node1 = new CoordinateNode3D(document); 
   node1.X = 12; node1.Y = 10; node1.Z = 9; 

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model3D.Node3D.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания нового 3D узла</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.Geometry">
            <summary>Получить геометрические данные точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.Point">
            <summary>Получить геометрию 3D узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.TangentPlaneSecondPrincipalDirection">
            <summary>Получить плоскость по нормали к поверхности с ориентацией по второму главному направлению для точки, построенной на грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.TangentPlaneFirstPrincipalDirection">
            <summary>Получить плоскость по нормали к поверхности с ориентацией по первому главному направлению для точки, построенной на грани</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveNormalBinormalPlane">
            <summary>Получить плоскость по нормали и бинормали в точке, построенной на ребре, пути или профиле</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveTangentBinormalPlane">
            <summary>Получить плоскость по касательной и бинормали в точке, построенной на ребре, пути или профиле</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveTangentNormalPlane">
            <summary>Получить плоскость по касательной и нормали в точке, построенной на ребре, пути или профиле</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.SurfaceNormalDirection">
            <summary>Получить нормаль к поверхности в точке, построенной на грани, в виде вектора с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveBinormalDirection">
            <summary>Получить бинормаль к кривой в точке, построенной на ребре, пути или профиле, в виде вектора с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveNormalDirection">
            <summary>Получить нормаль к кривой в точке, построенной на ребре, пути или профиле, в виде вектора с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveInverseTangentDirectionOnPathSecond">
            <summary>Получить вектор обратный к касательной в точке, построенной на втором пути, в виде вектора с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveTangentDirectionOnPathSecond">
            <summary>Получить касательную к кривой в точке, построенной на пути, в виде вектора с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveInverseTangentDirection">
            <summary>Получить вектор обратный к касательной в точке, построенной на ребре, пути или профиле, в виде вектора с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveTangentDirection">
            <summary>Получить касательную к кривой в точке, построенной на ребре, пути или профиле, в виде вектора с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.SurfaceNormalAxis">
            <summary>Получить нормаль к поверхности в точке, построенной на грани, в виде модельной оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveBinormalAxis">
            <summary>Получить бинормаль к кривой в точке, построенной на ребре, пути или профиле, в виде модельной оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveNormalAxis">
            <summary>Получить нормаль к кривой в точке, построенной на ребре, пути или профиле, в виде модельной оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Node3D.GeometryData.CurveTangentAxis">
            <summary>Получить касательную к кривой в точке, построенной на ребре, пути или профиле, в виде модельной оси</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Node3D.GeometryData">
            <summary>Множество геометрических данных точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Node3D">
            <summary>Базовый класс для всех типов 3D узлов</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.ImportedLCS">
            <summary>Класс для представления внешней системы координат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PointsLCS.ClearSwitch">
            <summary>Сбросить все довороты и сдвиги осей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PointsLCS.SwitchXYZ">
            <summary>Повернуть оси X, Y, Z</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PointsLCS.SwitchAroundZ">
            <summary>Повернуть ЛСК на 90 градусов вокруг оси Z</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PointsLCS.SwitchAroundY">
            <summary>Повернуть ЛСК на 90 градусов вокруг оси Y</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PointsLCS.SwitchAroundX">
            <summary>Повернуть ЛСК на 90 градусов вокруг оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.RotateZ">
            <summary>Вращение по оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.RotateY">
            <summary>Вращение по оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.RotateX">
            <summary>Вращение по оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.MoveZ">
            <summary>Перемещение вдоль оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.MoveY">
            <summary>Перемещение вдоль оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.MoveX">
            <summary>Перемещение вдоль оси X</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.OneColor">
            <summary>Одним цветом</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.External">
            <summary>Внешняя ЛСК</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.UseForFragment">
            <summary>Использовать для привязки фрагмента</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.MoveToSurface">
            <summary>Переместить до поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.RotateToSurface">
            <summary>Повернуть до ближайшей точки поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.DirectionToAxisY">
            <summary>Направление задающее ось Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.PointToAxisY">
            <summary>Точка задающая направление оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.DirectionToAxisX">
            <summary>Направление задающее ось Х</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.PointToAxisX">
            <summary>Точка задающая направление оси Х</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PointsLCS.PointToOrigin">
            <summary>Точка, задающая начало системы координат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PointsLCS.#ctor(TFlex.Model.Document)">
            <summary>Конструктор систем координат построенных по точкам</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
        </member>
        <member name="T:TFlex.Model.Model3D.PointsLCS">
            <summary>Класс систем координат построенных по точкам</summary>
            <example>
                <code name="Система координат, построенная по точкам">
public static void PointsLCS()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("система координат построенная по точкам");

   PointsLCS lcs = new PointsLCS(document);

   //начало координат
   CoordinateNode3D node1 = new CoordinateNode3D(document); 
   node1.X = 100; node1.Y = 100; node1.Z = 100; 
   lcs.PointToOrigin = node1.Geometry.Point;

   //Точка задающая направление оси Х
   CoordinateNode3D node2 = new CoordinateNode3D(document); 
   node2.X = 120; node2.Y = 150; node2.Z = 100; 
   lcs.PointToAxisX = node2.Geometry.Point;

   //Точка задающая направление оси Y
   CoordinateNode3D node3 = new CoordinateNode3D(document); 
   node3.X = 120; node3.Y = 150; node3.Z = 200; 
   lcs.PointToAxisY = node3.Geometry.Point;

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.UseForFragmentFixing">
            <summary>Значение свойства "Использовать для привязки фрагмента"</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.Geometry">
            <summary>Геометрические данные системы координат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LCS.TestCompatibility(TFlex.Model.Model3D.LCS,TFlex.Model.Model3D.LCS)">
            <summary>Проверить совместимость типов, объект и объект</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LCS.TestCompatibility(TFlex.Model.Model3D.LCS,TFlex.Model.Model3D.Path3D)">
            <summary>Проверить совместимость типов, объект и трасса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.PlaneXZ">
            <summary>Плоскость XZ</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.PlaneYZ">
            <summary>Плоскость YZ</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.PlaneXY">
            <summary>Плоскость XY</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.Origin">
            <summary>Начало систeмы координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.AxisZ">
            <summary>Ось Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.AxisY">
            <summary>Ось Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.AxisX">
            <summary>Ось Х</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.DirectionZ">
            <summary>Направление оси Z</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.DirectionY">
            <summary>Направление оси Y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCS.GeometryData.DirectionX">
            <summary>Направление оси Х</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.LCS.GeometryData">
            <summary>Множество геометрических данных системы координат</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.LCS">
            <summary>Базовый класс для всех локальных систем координат (ЛСК)</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ParametricCurve.ParamCurve">
            <summary>Получить плоскую кривую, задающую форму кривой в параметрической области поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ParametricCurve.Surface">
            <summary>Получить поверхность, на которой строится кривая</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ParametricCurve.#ctor(TFlex.Model.Model3D.Geometry.BaseSurface,TFlex.Model.Model3D.Geometry.BaseSplineCurve)">
            <summary>Создание прямой</summary>
            <param name="surface">Поверхность, на которой строится кривая</param>
            <param name="curve">Плоская кривая, задающая форму кривой в параметрической области поверхности</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ParametricCurve">
            <summary>Геометрическая кривая на поверхности с модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelParametricCurve.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной кривой. Модельные кривые не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelParametricCurve.ParamCurve">
            <summary>Получить плоскую кривую, задающую форму кривой в параметрической области поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelParametricCurve.Surface">
            <summary>Получить поверхность, на которой строится кривая</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelParametricCurve">
            <summary>Кривая на поверхности с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseParametricCurve.ParamCurve">
            <summary>Получить плоскую кривую, задающую форму кривой в параметрической области поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseParametricCurve.Surface">
            <summary>Получить поверхность, на которой строится кривая</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseParametricCurve">
            <summary>Интерфейс для свойств кривой на поверхности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineCurve.#ctor(TFlex.Model.Model3D.Geometry.PiecewiseData)">
            <summary>Создание сплайна по набору сегментов</summary>
            <param name="data">Описание сплайна</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineCurve.#ctor(TFlex.Model.Model3D.Geometry.SplinewiseData)">
            <summary>Создание интерполяционного сплайна по набору точек, через которые проходит сплайн, по параметрам кривой в этих точках и условиям на концах</summary>
            <param name="data">Описание сплайна</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineCurve.#ctor(TFlex.Model.Model3D.Geometry.SplineData)">
            <summary>Создание сплайна по набору контрольных точек, весов и последовательности узлов параметризации</summary>
            <param name="data">Описание сплайна</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineCurve.SetPiecewise(TFlex.Model.Model3D.Geometry.PiecewiseData)">
            <summary>Установить описание сплайна по набору сегментов</summary>
            <param name="data">Описание сплайна</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineCurve.Piecewise(TFlex.Model.Model3D.Geometry.PiecewiseRepresentation)">
            <summary>Описание сплайна по набору сегментов</summary>
            <param name="representation">Требуемое представление сплайна</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineCurve.Splinewise">
            <summary>Описание интерполяционного сплайна по набору точек, через которые проходит сплайн, по параметрам кривой в этих точках и условиям на концах</summary>
            <remarks>Не все сплайны могут вернуть это представление</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineCurve.Data">
            <summary>Описание сплайна</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplineCurve">
            <summary>Геометрический сплайн</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSplineCurve.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной кривой. Модельные кривые не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSplineCurve.Piecewise(TFlex.Model.Model3D.Geometry.PiecewiseRepresentation)">
            <summary>Получить описание сплайна по набору сегментов</summary>
            <param name="representation">Требуемое представление сплайна</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSplineCurve.Splinewise">
            <summary>Получить описание интерполяционного сплайна по набору точек, через которые проходит сплайн, по параметрам кривой в этих точках и условиям на концах</summary>
            <remarks>Не все сплайны могут вернуть это представление</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSplineCurve.Data">
            <summary>Получить описание сплайна</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelSplineCurve">
            <summary>Сплайн с модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.Representation">
            <summary>Представление сплайна</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.Segments">
            <summary>Получить сегменты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.default(System.UInt32)">
            <summary>Сегмент по номеру</summary>
            <param name="index">Номер сегмента</param>
            <remarks>Сегменты нумеруются от нуля. Если индекс отрицательный или превышает количество сегментов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.DeleteAll">
            <summary>Удалить все сегменты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Delete(System.UInt32)">
            <summary>Удалить сегмент по номеру</summary>
            <param name="index">Номер сегмента</param>
            <remarks>Сегменты нумеруются от нуля. Если индекс отрицательный или превышает количество сегментов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Add(TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment)">
            <summary>Добавить сегмент в конец списка</summary>
            <param name="segment">Добавляемый сегмент</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Insert(System.UInt32,TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment)">
            <summary>Вставить сегмент перед номером</summary>
            <param name="Index">Номер сегмента</param>
            <param name="segment">Сегмент</param>
            <remarks>Сегменты нумеруются от нуля. Если индекс отрицательный или превышает количество сегментов, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Length">
            <summary>Количество сегментов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.Clone">
            <summary>Метод создает неполную копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.#ctor(System.UInt32,System.Boolean)">
            <summary>Конструктор для сегмента с указанием степени сплайна, его рациональности</summary>
            <param name="degree">Степень сплайна</param>
            <param name="rational">Рациональность сплайна</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.default(System.UInt32)">
            <summary>Контрольная точка по номеру</summary>
            <param name="index">Номер контрольной точки</param>
            <remarks>Контрольные точки нумеруются от нуля. Если индекс отрицательный или превышает количество контрольных точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.Length">
            <summary>Количество контрольных точек (на единицу больше степени сплайна)</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.ControlPoint.Clone">
            <summary>Метод создает неполную копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.ControlPoint.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,System.Double)">
            <summary>Конструктор контрольной точки</summary>
            <param name="point">Координаты точки</param>
            <param name="weight">Вес точки</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.ControlPoint.Weight">
            <summary>Вес точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.ControlPoint.Coord">
            <summary>Координаты точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment.ControlPoint">
            <summary>Контрольная точка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet.Segment">
            <summary>Упорядоченное множество контрольных точек в сегменте - координаты точки и вес, если используется</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.PiecewiseData.SegmentsSet">
            <summary>Упорядоченное множество сегментов - координаты точки и вес, если используется</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.Rational">
            <summary>Признак рациональности сплайна</summary>
            <remarks>При изменении типа на нерациональный информация о весах теряется.
При изменении типа на рациональный все веса равны 1.0.
Если тип не меняется, то информация о весах также не меняется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PiecewiseData.Degree">
            <summary>Степень сплайна</summary>
            <remarks>При уменьшении степени информация о лишних точках теряется.
При увеличении степени координаты добавленных точек нулевые.
Если степень не меняется, то информация о точках также не меняется</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PiecewiseData.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.PiecewiseData">
            <summary>Класс для задания и определения свойств сплайна по набору сегментов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSplineCurve.Piecewise(TFlex.Model.Model3D.Geometry.PiecewiseRepresentation)">
            <summary>Получить описание сплайна по набору сегментов</summary>
            <param name="representation">Требуемое представление сплайна</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSplineCurve.Splinewise">
            <summary>Получить описание интерполяционного сплайна по набору точек, через которые проходит сплайн, по параметрам кривой в этих точках и условиям на концах</summary>
            <remarks>Не все сплайны могут вернуть это представление</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSplineCurve.Data">
            <summary>Получить описание сплайна</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseSplineCurve">
            <summary>Интерфейс для свойств сплайна</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Knots">
            <summary>Параметры для каждой точки задаются в явном виде</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.EndDerivative">
            <summary>Производная в конце, если условие в конце задаётся производной</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.BeginDerivative">
            <summary>Производная в начале, если условие в начале задаётся производной</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.End">
            <summary>Условие в конце</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Begin">
            <summary>Условие в начале</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplinewiseData.EndType.ClampedVector">
            <summary>Производная на конце задаётся вектором</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplinewiseData.EndType.Natural">
            <summary>Нулевая кривизна на конце</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplinewiseData.EndType.Periodic">
            <summary>Периодический сплайн</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplinewiseData.EndType">
            <summary>Условия на концах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Points">
            <summary>Получить интерполяционные точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.default(System.UInt32)">
            <summary>Интерполяционная точка по номеру</summary>
            <param name="index">Номер интерполяционной точки</param>
            <remarks>Интерполяционные точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.DeleteAll">
            <summary>Удалить все интерполяционные точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Delete(System.UInt32)">
            <summary>Удалить интерполяционную по номеру</summary>
            <param name="index">Номер интерполяционной точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Add(TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Position)">
            <summary>Добавить интерполяционную точку в конец списка</summary>
            <param name="point">Интерполяционная точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Insert(System.UInt32,TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Position)">
            <summary>Вставить интерполяционную точку перед номером</summary>
            <param name="Index">Номер интерполяционной точки</param>
            <param name="point">Координаты точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Length">
            <summary>Количество интерполяционных точек</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Position.Clone">
            <summary>Метод создает неполную копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Position.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,System.Double)">
            <summary>Конструктор</summary>
            <param name="point">Координаты точки</param>
            <param name="knot">Параметр кривой в данной точке</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Position.Knot">
            <summary>Параметр кривой в данной точке</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Position.Coord">
            <summary>Координаты точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions.Position">
            <summary>Интерполяционная точка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplinewiseData.Positions">
            <summary>Упорядоченное множество интерполяционных точек - координаты точки и параметр, если используется</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplinewiseData.Degree">
            <summary>Получить степень сплайна</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplinewiseData.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplinewiseData">
            <summary>Класс для задания и определения свойств интерполяционного сплайна по набору точек, через которые проходит сплайн, по параметрам кривой в этих точках и условиям на концах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.SelfIntersecting">
            <summary>Признак наличия самопересечения</summary>
            <remarks>Если этот признак не определён, то сплайн считается не самопересекающимся</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.Closed">
            <summary>Признак замкнутости сплайна</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.Periodic">
            <summary>Признак периодичности сплайна</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.KnotSequenceType">
            <summary>Тип последовательности узлов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.Knots">
            <summary>Получить последовательность узлов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.default(System.UInt32)">
            <summary>Узел по номеру</summary>
            <param name="index">Номер узла</param>
            <remarks>Узлы нумеруются от нуля. Если индекс отрицательный или превышает количество узлов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.DeleteAll">
            <summary>Удалить все узлы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Delete(System.UInt32)">
            <summary>Удалить узел по номеру</summary>
            <param name="index">Номер узла</param>
            <remarks>Узлы нумеруются от нуля. Если индекс отрицательный или превышает количество узлов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Add(TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Knot)">
            <summary>Добавить узел в конец списка</summary>
            <param name="knot">Узел</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Insert(System.UInt32,TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Knot)">
            <summary>Вставить узел перед номером</summary>
            <param name="Index">Номер узла, перед которым будет вставлен данный узел</param>
            <param name="knot">Узел</param>
            <remarks>Узлы нумеруются от нуля. Если индекс отрицательный или превышает количество узлов, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Length">
            <summary>Количество узлов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Knot.Clone">
            <summary>Метод создает неполную копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Knot.#ctor(System.Double,System.UInt32)">
            <summary>Конструктор узла</summary>
            <param name="value">Значение параметра в узле</param>
            <param name="multiplicity">Кратность узла</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Knot.Multiplicity">
            <summary>Кратность узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Knot.Value">
            <summary>Значение параметра в узле</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence.Knot">
            <summary>Узел</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplineData.KnotSequence">
            <summary>Последовательность узлов - значение параметра и кратность</summary>
            <remarks>Возможно перечисление узлов с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.Shape">
            <summary>Форма кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplineData.CurveShape.Hyperbolic">
            <summary>Форма кривой дуга гиперболы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplineData.CurveShape.Parabolic">
            <summary>Форма кривой дуга параболы</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplineData.CurveShape.Elliptic">
            <summary>Форма кривой дуга эллипса</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplineData.CurveShape.Circular">
            <summary>Форма кривой дуга окружости</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplineData.CurveShape.Polyline">
            <summary>Форма кривой кусочно-линейная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplineData.CurveShape.Arbitrary">
            <summary>Произвольная форма кривой</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SplineData.CurveShape.Unset">
            <summary>Форма кривой не определена</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplineData.CurveShape">
            <summary>Формы кривой</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.Points">
            <summary>Получить контрольные точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.default(System.UInt32)">
            <summary>Контрольная точка по номеру</summary>
            <param name="index">Номер контрольной точки</param>
            <remarks>Контрольные точки нумеруются от нуля. Если индекс отрицательный или превышает количество контрольных точек, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.DeleteAll">
            <summary>Удалить все контрольные точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.Delete(System.UInt32)">
            <summary>Удалить контрольную точку по номеру</summary>
            <param name="index">Номер контрольной точки</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.Add(TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.ControlPoint)">
            <summary>Добавить контрольную точку в конец списка</summary>
            <param name="point">Контрольная точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.Insert(System.UInt32,TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.ControlPoint)">
            <summary>Вставить контрольную точку перед номером</summary>
            <param name="Index">Номер контрольной точки</param>
            <param name="point">Контрольная точка</param>
            <remarks>Точки нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.Length">
            <summary>Количество контрольных точек</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.ControlPoint.Clone">
            <summary>Метод создает неполную копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.ControlPoint.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,System.Double)">
            <summary>Конструктор контрольной точки</summary>
            <param name="point">Координаты точки</param>
            <param name="weight">Вес точки</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.ControlPoint.Weight">
            <summary>Вес точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.ControlPoint.Coord">
            <summary>Координаты точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints.ControlPoint">
            <summary>Контрольная точка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplineData.ControlPoints">
            <summary>Класс представляет упорядоченное множество контрольных точек - координат точки и вес, если используется</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.Rational">
            <summary>Установить признак рациональности сплайна</summary>
            <remarks>При изменении типа на нерациональный информация о весах теряется.
При изменении типа на рациональный все веса равны 1.0.
Если тип не меняется, то информация о весах также не меняется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineData.Degree">
            <summary>Степень сплайна</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineData.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplineData">
            <summary>Класс для задания и определения свойств сплайна по набору контрольных точек, весов и последовательности узлов параметризации</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.EllipseCurve.SemiAxis">
            <summary>Полуось, от которой откладывается угол эллипса</summary>
            <remarks>Очевидно, что эта полуось лежит в плоскости эллипса</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.EllipseCurve.Normal">
            <summary>Нормаль к плоскости эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.EllipseCurve.Center">
            <summary>Центр эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.EllipseCurve.MajorRadius">
            <summary>Большой радиус эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.EllipseCurve.MinorRadius">
            <summary>Малый радиус эллипса</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.EllipseCurve.#ctor(System.Double,System.Double,TFlex.Model.Model3D.Geometry.Point3D,TFlex.Model.Model3D.Geometry.Direction,TFlex.Model.Model3D.Geometry.Direction)">
            <summary>Создание эллипса</summary>
            <param name="minorradius">Малый радиус эллипса</param>
            <param name="majorradius">Большой радиус эллипса</param>
            <param name="center">Центр эллипса</param>
            <param name="normal">Нормаль к плоскости эллипса</param>
            <param name="semiaxis">Полуось, от которой откладывается угол эллипса</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.EllipseCurve">
            <summary>Класс геометрического эллипса</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelEllipseCurve.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной кривой. Модельные кривые не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEllipseCurve.SemiAxis">
            <summary>Получить полуось, от которой откладывается угол эллипса</summary>
            <remarks>Очевидно, что эта полуось лежит в плоскости эллипса</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEllipseCurve.Normal">
            <summary>Получить нормаль к плоскости эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEllipseCurve.Center">
            <summary>Получить центр эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEllipseCurve.MajorRadius">
            <summary>Получить большой радиус эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelEllipseCurve.MinorRadius">
            <summary>Получить малый радиус эллипса</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelEllipseCurve">
            <summary>Класс эллипса с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEllipseCurve.SemiAxis">
            <summary>Получить полуось, от которой откладывается угол эллипса</summary>
            <remarks>Очевидно, что эта полуось лежит в плоскости эллипса</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEllipseCurve.Normal">
            <summary>Получить нормаль к плоскости эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEllipseCurve.Center">
            <summary>Получить центр эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEllipseCurve.MajorRadius">
            <summary>Получить большой радиус эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseEllipseCurve.MinorRadius">
            <summary>Получить малый радиус эллипса</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseEllipseCurve">
            <summary>Интерфейс для свойств эллипса</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.CircleCurve.SemiAxis">
            <summary>Полуось, от которой откладывается угол окружности</summary>
            <remarks>Очевидно, что эта полуось лежит в плоскости окружности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.CircleCurve.Normal">
            <summary>Нормаль к плоскости окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.CircleCurve.Center">
            <summary>Центр окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.CircleCurve.Radius">
            <summary>Радиус окружности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.CircleCurve.#ctor(System.Double,TFlex.Model.Model3D.Geometry.Point3D,TFlex.Model.Model3D.Geometry.Direction,TFlex.Model.Model3D.Geometry.Direction)">
            <summary>Создание окружности</summary>
            <param name="radius">Радиус окружности</param>
            <param name="center">Центр окружность</param>
            <param name="normal">Нормаль к плоскости окружности</param>
            <param name="semiaxis">Полуось, от которой откладывается угол окружности</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.CircleCurve">
            <summary>Класс геометрической окружности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelCircleCurve.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной кривой. Модельные кривые не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelCircleCurve.SemiAxis">
            <summary>Получить полуось, от которой откладывается угол окружности</summary>
            <remarks>Очевидно, что эта полуось лежит в плоскости окружности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelCircleCurve.Normal">
            <summary>Получить нормаль к плоскости окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelCircleCurve.Center">
            <summary>Получить центр окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelCircleCurve.Radius">
            <summary>Получить радиус окружности</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelCircleCurve">
            <summary>Класс окружности с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCircleCurve.SemiAxis">
            <summary>Получить полуось, от которой откладывается угол окружности</summary>
            <remarks>Очевидно, что эта полуось лежит в плоскости окружности</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCircleCurve.Normal">
            <summary>Получить нормаль к плоскости окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCircleCurve.Center">
            <summary>Получить центр окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCircleCurve.Radius">
            <summary>Получить радиус окружности</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseCircleCurve">
            <summary>Интерфейс для свойств окружности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.LineCurve.Line">
            <summary>Получить описание прямой</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.LineCurve.#ctor(TFlex.Model.Model3D.Geometry.BaseAxis)">
            <summary>Создание прямой</summary>
            <param name="line">Описание прямой</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.LineCurve">
            <summary>Геометрическая прямая</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelLineCurve.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной кривой. Модельные кривые не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelLineCurve.Line">
            <summary>Получить описание прямой</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelLineCurve">
            <summary>Класс прямой с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseLineCurve.Line">
            <summary>Получить описание прямой</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseLineCurve">
            <summary>Интерфейс для свойств прямой</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Curve.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Curve">
            <summary>Геометрическая кривая</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelCurve.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>онструкторы для модельной кривой. Модельные кривые не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelCurve">
            <summary>Класс кривой с модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.#ctor">
            <summary>Конструкторы для геометрической кривой</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной кривой</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Update">
            <summary>Обновить геометрию для каждого конкретного порождённого типа</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCurve.ParasolidCurve">
            <summary>Кривая в формате Parasolid</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.IntersectCurve(TFlex.Model.Model3D.Geometry.BaseInterval,TFlex.Model.Model3D.Geometry.BaseCurve,TFlex.Model.Model3D.Geometry.BaseInterval,System.Boolean,TFlex.Model.Model3D.Geometry.BaseBox,System.Boolean,TFlex.Model.Model3D.Geometry.BaseSurface)">
            <summary>Найти пересечение кривой с другой кривой</summary>
            <param name="owninterval">Собственный параметрический интервал, на котором ищется пересечение</param>
            <param name="curve">Кривая, с которой ищется пересечение</param>
            <param name="interval">Параметрический интервал кривой, на котором ищется пересечение</param>
            <param name="havebox">Использовать область поиска пересечений</param>
            <param name="box">Область поиска пересечений</param>
            <param name="havesurface">Кривые лежат на одной поверхности</param>
            <param name="havesurface">Поверхность, на которой лежат кривые</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.EvalPolyline(System.Double,System.Double,System.Collections.Generic.List`1{TFlex.Model.Model3D.Geometry.Point3D}@)">
            <summary>Получение точек полилинии аппроксимации кривой</summary>
            <param name="tolerance">Допустимое отклонение</param>
            <param name="segmentLengthFactor">Коэффициент максимальной допустимой длины сегмента (1e-6..1)</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.MakeReverseCurve">
            <summary>Трансформация кривой</summary>
            <remarks>Меняется направление кривой</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.ApplyTransform(TFlex.Model.Model3D.Geometry.TransformationMatrix)">
            <summary>Трансформация кривой</summary>
            <param name="transformation">Матрица преобразования</param>
            <remarks>Создаётся новая кривая</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.ConvertParamByLengthRatio(System.Double)">
            <summary>Конвертировать параметр отношения к длине в параметр кривой</summary>
            <param name="paramByLengthRatio">Параметр отношения к длине в диапазоне {0.0; 1.0}</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.ConvertParamByLength(System.Double)">
            <summary>Конвертировать параметр по длине в параметр кривой</summary>
            <param name="paramByLength">Параметр по длине в диапазоне {0; Длина кривой}</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Parameterize(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Вычислить параметр на кривой, для точки, лежащей на кривой</summary>
            <param name="point">Точка на кривой</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Interval(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Вычислить параметрический интервал на кривой, ограниченный двумя точками, лежащими на кривой</summary>
            <param name="point1">Первая точка на кривой</param>
            <param name="point2">Вторая точка на кривой</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Length(TFlex.Model.Model3D.Geometry.BaseInterval)">
            <summary>Вычислить длину кривой по параметру</summary>
            <param name="interval">Интервал на кривой</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Binormal(System.Double)">
            <summary>Вычислить бинормаль в точке на кривой по параметру</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.PrincipalNormal(System.Double)">
            <summary>Вычислить главную нормаль в точке на кривой по параметру</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Tangent(System.Double)">
            <summary>Вычислить касательную в точке на кривой по параметру</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Curvature(System.Double)">
            <summary>Вычислить кривизну в точке на кривой по параметру</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Derivative(System.Double,System.UInt32)">
            <summary>Вычислить производные в точке на кривой по параметру</summary>
            <param name="t">Параметр</param>
            <param name="derivative">Максимальный порядок производной</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseCurve.Eval(System.Double)">
            <summary>Вычислить координаты точки на кривой по параметру</summary>
            <param name="t">Параметр</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCurve.Param">
            <summary>Получить информацию о параметризации</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseCurve">
            <summary>Базовый класс для кривых</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectCurveData.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectCurveData.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveData.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectCurveData.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveData.default(System.UInt32)">
            <summary>Пересечение по номеру</summary>
            <param name="index">Номер пересечения</param>
            <remarks>Пересечения нумеруются от нуля. Если индекс отрицательный или превышает количество пересечений, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveData.Length">
            <summary>Количество пересечений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.Type">
            <summary>Тип совпадения кривых</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.IntersectionType.Tangent">
            <summary>Точка касания</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.IntersectionType.End">
            <summary>Конец участка совпадения кривых</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.IntersectionType.Start">
            <summary>Начало участка совпадения кривых</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.IntersectionType.Simple">
            <summary>Просто пересечение</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.IntersectionType">
            <summary>Типы совпадения кривых</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.Param2">
            <summary>Параметр на второй кривой</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.Param1">
            <summary>Параметр на первой кривой</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection.Coord">
            <summary>Координаты точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectCurveData.Intersection">
            <summary>Точка пересечения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectCurveData">
            <summary>Класс для хранения результатов пересечения двух кривых</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweptSurface.Data">
            <summary>Свойства поверхности выталкивания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweptSurface.#ctor(TFlex.Model.Model3D.Geometry.SweptData)">
            <summary>Конструктор</summary>
            <param name="data">Описание поверхности выталкивания</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweptSurface">
            <summary>Геометрическая поверхность выталкивания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSweptSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSweptSurface.Data">
            <summary>Свойства поверхности выталкивания</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelSweptSurface">
            <summary>Поверхность выталкивания с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSweptSurface.Data">
            <summary>Свойства поверхности выталкивания</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseSweptSurface">
            <summary>Интерфейс для свойств поверхности выталкивания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweptData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweptData.Direction">
            <summary>Направление выталкивания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SweptData.Curve">
            <summary>Кривая, выталкиванием которой образуется поверхность выталкивания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweptData.#ctor(TFlex.Model.Model3D.Geometry.BaseCurve,TFlex.Model.Model3D.Geometry.Direction)">
            <summary>Конструктор</summary>
            <param name="curve">Кривая, выталкиванием которой образуется поверхность выталкивания</param>
            <param name="direction">Направление выталкивания</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SweptData.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SweptData">
            <summary>Класс для задания и определения свойств поверхности выталкивания</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SpunSurface.Data">
            <summary>Свойства поверхности вращения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SpunSurface.#ctor(TFlex.Model.Model3D.Geometry.SpunData)">
            <summary>Конструктор</summary>
            <param name="data">Описание поверхности вращения</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SpunSurface">
            <summary>Геометрическая поверхность вращения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSpunSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSpunSurface.Data">
            <summary>Свойства поверхности вращения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelSpunSurface">
            <summary>Поверхность вращения с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSpunSurface.Data">
            <summary>Свойства поверхности вращения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseSpunSurface">
            <summary>Интерфейс для свойств поверхности вращения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SpunData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SpunData.Axis">
            <summary>Ось вращения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SpunData.Curve">
            <summary>Кривая, вращением которой образуется поверхность вращения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SpunData.#ctor(TFlex.Model.Model3D.Geometry.BaseCurve,TFlex.Model.Model3D.Geometry.BaseAxis)">
            <summary>Конструктор</summary>
            <param name="curve">Кривая, вращением которой образуется поверхность вращения</param>
            <param name="axis">Ось вращения</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SpunData.#ctor">
            <summary>Конструктор по умолчанию</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SpunData">
            <summary>Класс для задания и определения свойств поверхности вращения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineSurface.#ctor(TFlex.Model.Model3D.Geometry.SurfacePiecewiseData)">
            <summary>Создание сплайновой поверхности по набору сегментов</summary>
            <param name="data">Описание сплайновой поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineSurface.#ctor(TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData)">
            <summary>Создание интерполяционной сплайновой поверхности по набору точек, через которые проходит сплайновая поверхность, по параметрам поверхности в этих точках и условиям на концах</summary>
            <param name="data">Описание сплайновой поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineSurface.#ctor(TFlex.Model.Model3D.Geometry.SurfaceSplineData)">
            <summary>Создание сплайновой поверхности по набору контрольных точек, весов и последовательности узлов параметризации</summary>
            <param name="data">Описание сплайновой поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineSurface.SetPiecewise(TFlex.Model.Model3D.Geometry.SurfacePiecewiseData)">
            <summary>Установить описание сплайновой поверхности по набору сегментов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SplineSurface.Piecewise(TFlex.Model.Model3D.Geometry.PiecewiseRepresentation)">
            <summary>Получить описание интерполяционной сплайновой поверхности по набору точек, через которые проходит сплайновая поверхность, по параметрам поверхности в этих точках и условиям на концах</summary>
            <remarks>Не все сплайновые поверхности могут вернуть это представление</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineSurface.Splinewise">
            <summary>Получить описание интерполяционной сплайновой поверхности по набору точек, через которые проходит сплайновая поверхность, по параметрам поверхности в этих точках и условиям на концах</summary>
            <remarks>Не все сплайновые поверхности могут вернуть это представление</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SplineSurface.Data">
            <summary>Описание сплайновой поверхности</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SplineSurface">
            <summary>Геометрическая сплайновая поверхность</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSplineSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSplineSurface.Piecewise(TFlex.Model.Model3D.Geometry.PiecewiseRepresentation)">
            <summary>Получить описание сплайновой поверхности по набору сегментов</summary>
            <param name="representation">Требуемое представление сплайновой поверхности</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSplineSurface.Splinewise">
            <summary>Получить описание интерполяционной сплайновой поверхности по набору точек, через которые проходит сплайновая поверхность, по параметрам поверхности в этих точках и условиям на концах</summary>
            <remarks>Не все сплайновые поверхности могут вернуть это представление</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSplineSurface.Data">
            <summary>Получить описание сплайновой поверхности</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelSplineSurface">
            <summary>Сплайновая поверхность с модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSplineSurface.Piecewise(TFlex.Model.Model3D.Geometry.PiecewiseRepresentation)">
            <summary>Получить описание сплайновой поверхности по набору сегментов</summary>
            <param name="representation">Требуемое представление сплайновой поверхности</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSplineSurface.Splinewise">
            <summary>Получить описание интерполяционной сплайновой поверхности по набору точек, через которые проходит сплайновая поверхность, по параметрам поверхности в этих точках и условиям на концах</summary>
            <remarks>Не все сплайновые поверхности могут вернуть это представление</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSplineSurface.Data">
            <summary>Получить описание сплайновой поверхности</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseSplineSurface">
            <summary>Интерфейс для свойств сплайновой поверхности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.Segments">
            <summary>Получить сегменты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.default(System.UInt32)">
            <summary>Получить строку по номеру. Получить сегменты по U</summary>
            <param name="index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.DeleteAll">
            <summary>Удалить все сегменты</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.VDelete(System.UInt32)">
            <summary>Удалить столбец. Удалить сегменты по V</summary>
            <param name="index">Номер столбца</param>
            <remarks>Столбцы нумеруются от нуля. Если индекс отрицательный или превышает количество столбцов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.UDelete(System.UInt32)">
            <summary>Удалить строку. Удалить сегменты по U</summary>
            <param name="index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.VAdd">
            <summary>Добавить столбец в конец сетки</summary>
            <remarks>Добавить новые сегменты по V с большим значением V</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.UAdd">
            <summary>Добавить строку в конец сетки</summary>
            <remarks>Добавить новые сегменты по U с большим значением U</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.VInsert(System.UInt32)">
            <summary>Вставить столбец. Вставить сегменты по V</summary>
            <param name="Index">Номер столбца</param>
            <remarks>Столбцы нумеруются от нуля. Если индекс отрицательный или превышает количество столбцов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.UInsert(System.UInt32)">
            <summary>Вставить строку. Вставить сегменты по U</summary>
            <param name="Index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SetSize(System.UInt32,System.UInt32)">
            <summary>Задать размер решётки</summary>
            <param name="row">Количество строк. Количество сегментов по U</param>
            <param name="columns">Количество столбцов. Количество сегментов по V</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.VLength">
            <summary>Количество столбцов. Количество сегментов по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.ULength">
            <summary>Количество строк. Количество сегментов по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.default(System.UInt32)">
            <summary>Получить сегмент по номеру</summary>
            <param name="index">Номер сегмента</param>
            <remarks>Сегменты нумеруются от нуля. Если индекс отрицательный или превышает количество сегментов, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Length">
            <summary>Количество сегментов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.default(System.UInt32)">
            <summary>Получить строку по номеру</summary>
            <param name="index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.Length">
            <summary>Количество строк</summary>
            <remarks>Значение на единицу больше степени по V</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.default(System.UInt32)">
            <summary>Контрольная точку по номеру</summary>
            <param name="index">Номер контрольной точки</param>
            <remarks>Контрольные точки нумеруются от нуля. Если индекс отрицательный или превышает количество контрольных точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.Length">
            <summary>Количество контрольных точек</summary>
            <remarks>Значение на единицу больше степени по U</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.ControlPoint.Clone">
            <summary>Создает копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.ControlPoint.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,System.Double)">
            <summary>Конструктор контрольной точки</summary>
            <param name="point">Точка</param>
            <param name="weight">Вес точки</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.ControlPoint.Weight">
            <summary>Вес точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.ControlPoint.Coord">
            <summary>Координаты точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow.ControlPoint">
            <summary>Контрольная точка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment.SegmentRow">
            <summary>Упорядоченное по V множество точек в строке - координаты точки и вес, если используется</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow.Segment">
            <summary>Сетка контрольных точек в сегменте. Упорядоченное по U множество строк точек</summary>
            <remarks>Возможно перечисление строк с использованием конструкции foreach</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet.SegmentsRow">
            <summary>Упорядоченное по V множество сегментов в строке</summary>
            <remarks>Возможно перечисление сегментов с использованием конструкции foreach</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.SegmentsSet">
            <summary>Сетка сегментов. Упорядоченное по U множество строк сегментов</summary>
            <remarks>Возможно перечисление строк с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.Representation">
            <summary>Представление сплайна</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.Rational">
            <summary>Признак рациональности сплайна</summary>
            <remarks>При изменении типа на нерациональный информация о весах теряется.
При изменении типа на рациональный все веса равны 1.0.
Если тип не меняется, то информация о весах также не меняется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.VDegree">
            <summary>Степень сплайна по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.UDegree">
            <summary>Степень сплайна по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfacePiecewiseData">
            <summary>Класс для задания и определения свойств сплайновой поверхности по набору сегментов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.UpperUUpperV">
            <summary>Получить закона кручения в вершине, заданной верхним значением U и верхним значением V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.UpperULowerV">
            <summary>Получить закон кручения в вершине, заданной верхним значением U и нижним значением V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.LowerUUpperV">
            <summary>Получить закон кручения в вершине, заданной нижним значением U и верхним значением V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.LowerULowerV">
            <summary>Получить закон кручения в вершине, заданной нижним значением U и нижним значением V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Twist.Coord">
            <summary>Параметр задания условия кручения на конце</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Twist.Defined">
            <summary>Параметр задания условия кручения на конце</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Twist">
            <summary>Класс для задания закона кручения на концах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.UpperVBoundary">
            <summary>Получить условия по границе, соответствующей изопараметрической кривой по верхнему значению V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.UpperUBoundary">
            <summary>Получить условия по границе, соответствующей изопараметрической кривой по верхнему значению U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.LowerVBoundary">
            <summary>Получить условия по границе, соответствующей изопараметрической кривой по нижнему значению V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.LowerUBoundary">
            <summary>Получить условия по границе, соответствующей изопараметрической кривой по нижнему значению U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.Bound">
            <summary>Условие по границе, соответствующей изопараметрической кривой по нижнему значению U</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.EndType.ClampedSpline">
            <summary>Производные на границе задаются сплайном (в текущей версии не поддерживается)</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.EndType.ClampedVector">
            <summary>Производные на границе задаются векторами</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.EndType.Natural">
            <summary>Нулевая кривизна на границе</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.EndType.Periodic">
            <summary>Периодический сплайн по данному направлению</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.EndType">
            <summary>Типы условий на границах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.default(System.UInt32)">
            <summary>Касательная по номеру</summary>
            <param name="index">Номер касательной</param>
            <remarks>Касательные нумеруются от нуля. Если индекс отрицательный или превышает количество касательных, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition.Length">
            <summary>Количество касательных</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.BoundaryCondition">
            <summary>Условие на границе</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.VKnots">
            <summary>Получить параметры узлов по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.UKnots">
            <summary>Получить параметры узлов по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Knots.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Knots.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Knots.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Knots.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Knots.Defined">
            <summary>Параметры задаются в явном виде</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Knots.default(System.UInt32)">
            <summary>Параметр по номеру</summary>
            <param name="index">Номер точки</param>
            <remarks>Параметры нумеруются от нуля. Если индекс отрицательный или превышает количество точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Knots.Length">
            <summary>Количество параметров</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Knots">
            <summary>Параметризация по одному из параметров</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Points">
            <summary>Получить интерполяционные точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.default(System.UInt32)">
            <summary>Получить строку по номеру. Получить изопараметрическую кривую по U</summary>
            <param name="index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.DeleteAll">
            <summary>Удалить все интерполяционные точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.VDelete(System.UInt32)">
            <summary>Удалить столбец. Удалить изопараметрическую кривую по V</summary>
            <param name="index">Номер столбца</param>
            <remarks>Столбцы нумеруются от нуля. Если индекс отрицательный или превышает количество столбцов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.UDelete(System.UInt32)">
            <summary>Удалить строку. Удалить изопараметрическую кривую по U</summary>
            <param name="index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.VAdd">
            <summary>Добавить столбец в конец сетки</summary>
            <remarks>Добавить новую изопараметрическую кривую по V с большим значением V</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.UAdd">
            <summary>Добавить строку в конец сетки</summary>
            <remarks>Добавить новую изопараметрическую кривую по U с большим значением U</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.VInsert(System.UInt32)">
            <summary>Вставить столбец. Вставить изопараметрическую кривую по V</summary>
            <param name="Index">Номер столбца</param>
            <remarks>Столбцы нумеруются от нуля. Если индекс отрицательный или превышает количество столбцов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.UInsert(System.UInt32)">
            <summary>Вставить строку. Вставить изопараметрическую кривую по U</summary>
            <param name="Index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.SetSize(System.UInt32,System.UInt32)">
            <summary>Задать размер решётки</summary>
            <param name="row">Количество строк</param>
            <param name="columns">Количество столбцов</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.VLength">
            <summary>Количество столбцов. Количество изопараметрических кривых по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.ULength">
            <summary>Количество строк. Количество изопараметрических кривых по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.PositionsRow.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.PositionsRow.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.PositionsRow.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.PositionsRow.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.PositionsRow.default(System.UInt32)">
            <summary>Интерполяционная точку по номеру</summary>
            <param name="index">Номер интерполяционную точки</param>
            <remarks>Интерполяционные точки нумеруются от нуля. Если индекс отрицательный или превышает количество интерполяционных точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.PositionsRow.Length">
            <summary>Количество интерполяционных точек</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions.PositionsRow">
            <summary>Упорядоченное множество интерполяционных точек по V для изопараметрической кривой по U : координаты точки и параметр по V, если используется</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.Positions">
            <summary>Сетка интерполяционных точек. Каждая строка соответствует изопараметрической кривой по U</summary>
            <remarks>Возможно перечисление строк с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.VDegree">
            <summary>Степень сплайна по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.UDegree">
            <summary>Степень сплайна по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplinewiseData">
            <summary>Класс для задания и определения свойств интерполяционной сплайновой поверхности по набору точек, через которые проходит сплайновая поверхность, по параметрам поверхности в этих точках и условиям на концах</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.Convexity">
            <summary>Выпуклость поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ConvexityType.Concave">
            <summary>Вогнутая поверхность</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ConvexityType.Convex">
            <summary>Выпуклая поверхность</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ConvexityType.Arbitrary">
            <summary>Произвольная поверхность. Есть выпуклости и вогнутости</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ConvexityType.Unset">
            <summary>Форма поверхности не определена</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ConvexityType">
            <summary>Типы выпуклостей поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SelfIntersecting">
            <summary>Признак самопересечения сплайна</summary>
            <remarks>Если этот признак не определён, то сплайновая поверхность считается не самопересекающейся</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.VClosed">
            <summary>Признак замкнутости сплайна по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.UClosed">
            <summary>Признак замкнутости сплайна по U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.VPeriodic">
            <summary>Признак периодичности сплайна по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.UPeriodic">
            <summary>Признак периодичности сплайна по U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.VKnotSequenceType">
            <summary>Тип последовательности узлов по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.UKnotSequenceType">
            <summary>Тип последовательности узлов по U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.VKnots">
            <summary>Получить последовательность узлов по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.UKnots">
            <summary>Получить последовательность узлов по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.default(System.UInt32)">
            <summary>Узел по номеру</summary>
            <param name="index">Номер узла</param>
            <remarks>Узлы нумеруются от нуля. Если индекс отрицательный или превышает количество узлов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.DeleteAll">
            <summary>Удалить все узлы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Delete(System.UInt32)">
            <summary>Удалить узел по номеру</summary>
            <param name="index">Номер узла</param>
            <remarks>Узлы нумеруются от нуля. Если индекс отрицательный или превышает количество узлов, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Add(TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Knot)">
            <summary>Добавить узел в конец списка</summary>
            <param name="knot">Добавляемый узел</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Insert(System.UInt32,TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Knot)">
            <summary>Вставить узел перед номером</summary>
            <param name="Index">Номер узла</param>
            <param name="knot">Вставляемый узел</param>
            <remarks>Узлы нумеруются от нуля. Если индекс отрицательный или превышает количество узлов, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Length">
            <summary>Количество узлов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Knot.Clone">
            <summary>Создает копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Knot.#ctor(System.Double,System.UInt32)">
            <summary>Конструктор узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Knot.Multiplicity">
            <summary>Кратность узла</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Knot.Value">
            <summary>Значение параметра в узле</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence.Knot">
            <summary>Узел</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplineData.KnotSequence">
            <summary>Последовательность узлов - значение параметра и кратность</summary>
            <remarks>Возможно перечисление узлов с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.Shape">
            <summary>Форма поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Swept">
            <summary>Форма поверхности кинематическая поверхность</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Quadric">
            <summary>Форма поверхности квадратичная поверхность</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.GeneralisedCone">
            <summary>Форма поверхности обобщенный конус</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Ruled">
            <summary>Форма поверхности линейчатая поверхность</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Revolved">
            <summary>Форма поверхности вращение</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Toroidal">
            <summary>Форма поверхности тор</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Spherical">
            <summary>Форма поверхности сфера</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Conical">
            <summary>Форма поверхности конус</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Cylindrical">
            <summary>Форма поверхности цилиндр</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Planar">
            <summary>Форма поверхности плоскость</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Arbitrary">
            <summary>Произвольная форма поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape.Unset">
            <summary>Форма поверхности не определена</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplineData.SurfaceShape">
            <summary>Типы форм поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.Points">
            <summary>Получить контрольные точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.default(System.UInt32)">
            <summary>Получить строку по номеру. Получить изопараметрическую кривую по U</summary>
            <param name="index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.DeleteAll">
            <summary>Удалить все контрольные точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.VDelete(System.UInt32)">
            <summary>Удалить столбец. Удалить изопараметрическую кривую по V</summary>
            <param name="index">Номер столбца</param>
            <remarks>Столбцы нумеруются от нуля. Если индекс отрицательный или превышает количество столбцов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.UDelete(System.UInt32)">
            <summary>Удалить строку. Удалить изопараметрическую кривую по U</summary>
            <param name="index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат не определён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.VAdd">
            <summary>Добавить столбец в конец сетки. Добавить новую изопараметрическую кривую по V с большим значением V</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.UAdd">
            <summary>Добавить строку в конец сетки. Добавить новую изопараметрическую кривую по U с большим значением U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.VInsert(System.UInt32)">
            <summary>Вставить столбец. Вставить изопараметрическую кривую по V</summary>
            <param name="Index">Номер столбца</param>
            <remarks>Столбцы нумеруются от нуля. Если индекс отрицательный или превышает количество столбцов, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.UInsert(System.UInt32)">
            <summary>Вставить строку. Вставить изопараметрическую кривую по U</summary>
            <param name="Index">Номер строки</param>
            <remarks>Строки нумеруются от нуля. Если индекс отрицательный или превышает количество строк, то результат неопределён</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.SetSize(System.UInt32,System.UInt32)">
            <summary>Задать размер решётки</summary>
            <param name="row">Количество строк</param>
            <param name="columns">Количество столбцов</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.VLength">
            <summary>Количество столбцов. Количество изопараметрических кривых по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ULength">
            <summary>Количество строк. Количество изопараметрических кривых по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.default(System.UInt32)">
            <summary>Контрольная точку по номеру</summary>
            <param name="index">Номер контрольной точки</param>
            <remarks>Контрольные точки нумеруются от нуля. Если индекс отрицательный или превышает количество контрольных точек, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.Length">
            <summary>Количество контрольных точек</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.ControlPoint.Clone">
            <summary>Создает копию объекта</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.ControlPoint.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,System.Double)">
            <summary>Конструктор контрольной точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.ControlPoint.Weight">
            <summary>Вес точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.ControlPoint.Coord">
            <summary>Координаты точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints.ControlPoint">
            <summary>Контрольная точка</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet.ControlPoints">
            <summary>Упорядоченное множество контрольных точек по V для изопараметрической кривой по U - координаты точки и вес, если используется</summary>
            <remarks>Возможно перечисление точек с использованием конструкции foreach</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplineData.ControlNet">
            <summary>Сетка контрольных точек</summary>
            <remarks>Каждая строка соответствует изопараметрической кривой по U. Возможно перечисление строк с использованием конструкции foreach</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.Rational">
            <summary>Признак рациональности сплайна</summary>
            <remarks>При изменении типа на нерациональный информация о весах теряется.
При изменении типа на рациональный все веса равны 1.0.
Если тип не меняется, то информация о весах также не меняется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.VDegree">
            <summary>Степень сплайна по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SurfaceSplineData.UDegree">
            <summary>Степень сплайна по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SurfaceSplineData.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SurfaceSplineData">
            <summary>Класс для задания и определения свойств сплайновой поверхности по набору контрольных точек, весов и последовательности узлов параметризации</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ConeSurface.ReferenceDirection">
            <summary>Полуось основания, от которой откладывается угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ConeSurface.Axis">
            <summary>Ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ConeSurface.SemiAngle">
            <summary>Половина угла конуса в градусах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ConeSurface.Radius">
            <summary>Радиус</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ConeSurface.#ctor(System.Double,System.Double,TFlex.Model.Model3D.Geometry.BaseAxis,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Создание цилиндра</summary>
            <param name="radius">Радиус основания</param>
            <param name="semiangle">Половина угла конуса в градусах</param>
            <param name="axis">Ось симметрии</param>
            <param name="referencedirection">Полуось основания, от которой откладывается угол</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ConeSurface">
            <summary>Геометрический конус</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelConeSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelConeSurface.ReferenceDirection">
            <summary>Получить полуось основания, от которой откладывается угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelConeSurface.Axis">
            <summary>Получить ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelConeSurface.SemiAngle">
            <summary>Получить половину угла конуса в градусах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelConeSurface.Radius">
            <summary>Получить радиус</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelConeSurface">
            <summary>Коническая поверхность с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseConeSurface.ReferenceDirection">
            <summary>Получить полуось основания, от которой откладывается угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseConeSurface.Axis">
            <summary>Получить ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseConeSurface.SemiAngle">
            <summary>Получить половину угла конуса в градусах</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseConeSurface.Radius">
            <summary>Получить радиус</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseConeSurface">
            <summary>Интерфейс для свойств конической поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.TorusSurface.ReferenceDirection">
            <summary>Полуось основания, от которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.TorusSurface.Axis">
            <summary>Ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.TorusSurface.MajorRadius">
            <summary>Большой радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.TorusSurface.MinorRadius">
            <summary>Малый радиус</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.TorusSurface.#ctor(System.Double,System.Double,TFlex.Model.Model3D.Geometry.BaseAxis,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конструктор</summary>
            <param name="minorradius">Малый радиус основания</param>
            <param name="majorradius">Большой радиус основания</param>
            <param name="axis">Ось симметрии</param>
            <param name="referencedirection">Полуось основания, от которой откладывается угол</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TorusSurface">
            <summary>Геометрический тор</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelTorusSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTorusSurface.ReferenceDirection">
            <summary>Получить полуось основания, от которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTorusSurface.Axis">
            <summary>Получить ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTorusSurface.MajorRadius">
            <summary>Получить большой радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelTorusSurface.MinorRadius">
            <summary>Получить малый радиус</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelTorusSurface">
            <summary>Тороидальная поверхность с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseTorusSurface.ReferenceDirection">
            <summary>Получить полуось основания, от которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseTorusSurface.Axis">
            <summary>Получить ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseTorusSurface.MajorRadius">
            <summary>Получить большой радиус</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseTorusSurface.MinorRadius">
            <summary>Получить малый радиус</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseTorusSurface">
            <summary>Интерфейс для свойств тороидальной поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SphereSurface.ReferenceDirection">
            <summary>Полуось основания, от которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SphereSurface.Normal">
            <summary>Нормаль к плоскости в которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SphereSurface.Center">
            <summary>Центр сферы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.SphereSurface.Radius">
            <summary>Радиус сферы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.SphereSurface.#ctor(System.Double,TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конструктор</summary>
            <param name="center">Радиус сферы</param>
            <param name="normal">Ось симметрии</param>
            <param name="referencedirection">Полуось основания, от которой откладывается угол</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.SphereSurface">
            <summary>Геометрическая сфера</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSphereSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSphereSurface.ReferenceDirection">
            <summary>Получить полуось основания, от которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSphereSurface.Normal">
            <summary>Получить нормаль к плоскости в которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSphereSurface.Center">
            <summary>Получить центр сферы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelSphereSurface.Radius">
            <summary>Получить радиус сферы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelSphereSurface">
            <summary>Сферическая поверхность с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSphereSurface.ReferenceDirection">
            <summary>Получить полуось основания, от которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSphereSurface.Normal">
            <summary>Получить нормаль к плоскости в которой откладываются углы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSphereSurface.Center">
            <summary>Получить центр сферы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSphereSurface.Radius">
            <summary>Получить радиус сферы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseSphereSurface">
            <summary>Интерфейс для свойств сферической поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.CylinderSurface.ReferenceDirection">
            <summary>Полуось основания, от которой откладывается угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.CylinderSurface.Axis">
            <summary>Получить ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.CylinderSurface.Radius">
            <summary>Радиус основания</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.CylinderSurface.#ctor(System.Double,TFlex.Model.Model3D.Geometry.BaseAxis,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конструктор</summary>
            <param name="radius">Радиус основания</param>
            <param name="axis">Ось симметрии</param>
            <param name="referencedirection">Полуось основания, от которой откладывается угол</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.CylinderSurface">
            <summary>Геометрический цилиндр</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelCylinderSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelCylinderSurface.ReferenceDirection">
            <summary>Получить полуось основания, от которой откладывается угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelCylinderSurface.Axis">
            <summary>Получить ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelCylinderSurface.Radius">
            <summary>Получить радиус основания</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelCylinderSurface">
            <summary>Цилиндрическая поверхность с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCylinderSurface.ReferenceDirection">
            <summary>Получить полуось основания, от которой откладывается угол</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCylinderSurface.Axis">
            <summary>Получить ось симметрии</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseCylinderSurface.Radius">
            <summary>Получить радиус основания</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseCylinderSurface">
            <summary>Интерфейс для свойств цилиндрической поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.PlaneSurface.Plane">
            <summary>Описание плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.PlaneSurface.#ctor(TFlex.Model.Model3D.Geometry.BasePlane)">
            <summary>Конструктор</summary>
            <param name="plane">Описание плоскости</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.PlaneSurface">
            <summary>Геометрическая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelPlaneSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelPlaneSurface.Plane">
            <summary>Получить описание плоскости</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelPlaneSurface">
            <summary>Плоскость с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BasePlaneSurface.Plane">
            <summary>Получить описание плоскости</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BasePlaneSurface">
            <summary>Интерфейс для свойств плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Surface.CreateSweep(TFlex.Model.Model3D.Geometry.BaseCurve,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Создать поверхность выталкивания</summary>
            <param name="curve">Выталкиваемая кривая</param>
            <param name="direction">Направление выталкивания</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Surface.CreateSpin(TFlex.Model.Model3D.Geometry.BaseCurve,TFlex.Model.Model3D.Geometry.BaseAxis,System.Boolean,System.Boolean,TFlex.Model.Model3D.Geometry.BaseInterval)">
            <summary>Создать поверхность вращения</summary>
            <param name="curve">Вращаемая кривая</param>
            <param name="axis">Ось вращения</param>
            <param name="simplify">Для результирующей поверхности подбирать аналитическое решение</param>
            <param name="confine">Поверхность вращения создаётся только для части кривой, границы которой задаются интервалом</param>
            <param name="interval">Параметрический интервал на кривой, если поверхность вращения создаётся только для части кривой</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Surface.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Surface">
            <summary>Геометрическая поверхность</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSurface.#ctor(TFlex.Model.Model3D.Geometry.ModelTopol,System.IntPtr)">
            <summary>Конструктор для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструктор для модельной поверхности. Модельные поверхности не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelSurface">
            <summary>Поверхность с модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.#ctor">
            <summary>Конструкторы для геометрической поверхности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной поверхности</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.IntersectCurve(TFlex.Model.Model3D.Geometry.BaseCurve,TFlex.Model.Model3D.Geometry.BaseInterval,System.Boolean,TFlex.Model.Model3D.Geometry.BaseBox)">
            <summary>Найти пересечение поверхности с кривой</summary>
            <param name="curve">Кривая, с которой ищется пересечение</param>
            <param name="interval">Параметрический интервал кривой, на котором ищется пересечение</param>
            <param name="havebox">Использовать область поиска пересечений</param>
            <param name="box">Область поиска пересечений</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.IntersectSurface(TFlex.Model.Model3D.Geometry.BaseSurface,System.Boolean,TFlex.Model.Model3D.Geometry.BaseBox,System.Boolean,TFlex.Model.Model3D.Geometry.UVBox,System.Boolean,TFlex.Model.Model3D.Geometry.UVBox,System.Boolean,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Найти пересечение поверхности с другой поверхностью</summary>
            <param name="surface">Поверхность, с которой ищется пересечение</param>
            <param name="havebox">Использовать область поиска пересечений</param>
            <param name="box">Область поиска пересечений</param>
            <param name="haveuvbox1">Использовать параметрическую область поиска пересечений для первой поверхности</param>
            <param name="uvbox1">Параметрическая область поиска пересечений для первой поверхности</param>
            <param name="haveuvbox2">Использовать параметрическую область поиска пересечений для второй поверхности</param>
            <param name="uvbox2">Параметрическая область поиска пересечений для второй поверхности</param>
            <param name="havepoint">Использовать точку для отбора одной из нескольких веток пересечения, на которой лежит точка</param>
            <param name="point">Точка для отбора одной из нескольких веток пересечения, на которой лежит точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.ApplyTransform(TFlex.Model.Model3D.Geometry.TransformationMatrix)">
            <summary>Трансформация поверхности</summary>
            <param name="transformation">Матрица трансфорации</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.Parameterize2(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Вычислить параметры на поверхности, для точки, лежащей около нее</summary>
            <param name="point">Точка на кривой</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.Parameterize(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Вычислить параметр на поверхности, для точки, лежащей на поверхности</summary>
            <param name="point">Точка на поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.PrincipalDirection2(TFlex.Model.Model3D.Geometry.UV)">
            <summary>Вычислить второе главное направление в точке по параметрам</summary>
            <param name="uv">параметры на поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.PrincipalDirection1(TFlex.Model.Model3D.Geometry.UV)">
            <summary>Вычислить первое главное направление в точке по параметрам</summary>
            <param name="uv">Параметры на поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.Normal(TFlex.Model.Model3D.Geometry.UV)">
            <summary>Вычислить нормаль к поверхности в точке по параметрам</summary>
            <param name="uv">Параметры на поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.PrincipalCurvature2(TFlex.Model.Model3D.Geometry.UV)">
            <summary>Вычислить вторую главную кривизну в точках на поверхности по параметрам</summary>
            <param name="uv">Параметры на поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.PrincipalCurvature1(TFlex.Model.Model3D.Geometry.UV)">
            <summary>Вычислить первую главную кривизну в точек на поверхности по параметрам</summary>
            <param name="uv">Параметры на поверхности</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.Derivative(TFlex.Model.Model3D.Geometry.UV,System.UInt32,System.UInt32)">
            <summary>Вычислить производные в точке на поверхности по параметрам</summary>
            <param name="uv">Параметры на поверхности</param>
            <param name="uderivs">Максимальный порядок производной по U</param>
            <param name="vderivs">Максимальный порядок производной по V</param>
            <remarks>
Производные возвращаются в следующем порядке:
<![CDATA[i-ая производная ( i <= 'uderivs' ) по u и j-ая производная ( j <= 'vderivs' ) по v хранится по индексу = i + ( 'uderivs' + 1 ) ^ j ).]]>
Например, если 'uderivs' == 2 и 'vderivs' == 3, тогда массив из 12 векторов выглядит следующим образом :
	p(u,v)     p(u,v)     p(u,v)
					 u          uu
Затем:
	p(u,v)     p(u,v)     p(u,v)
		  v          uv         uuv
Затем:
	p(u,v)     p(u,v)     p(u,v)
		  vv         uvv        uuvv
Затем:
	p(u,v)     p(u,v)     p(u,v)
		  vvv        uvvv       uuvvv
Здесь запись :
	p(u,v)       
		  uvv
- означает первую производную по u и вторую производную по V
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseSurface.Eval(TFlex.Model.Model3D.Geometry.UV)">
            <summary>Вычислить координаты точки на поверхности по параметрам</summary>
            <param name="uv">Параметры на поверхности</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSurface.VParam">
            <summary>Получить информацию о параметризации по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseSurface.UParam">
            <summary>Получить информацию о параметризации по U</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseSurface">
            <summary>Базовый класс для поверхностей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.Curves">
            <summary>Кривые пересечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.Points">
            <summary>Точки пересечения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.default(System.Int32)">
            <summary>Пересечение по номеру</summary>
            <param name="index">Номер пересечения</param>
            <remarks>Пересечения нумеруются от нуля. Если индекс отрицательный или превышает количество пересечений, то результат неопределён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Length">
            <summary>Количество пересечений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Intersection.Type">
            <summary>Тип совпадения кривых</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Intersection.IntersectionType.Tangent">
            <summary>Кривая касания</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Intersection.IntersectionType.Simple">
            <summary>Просто пересечение</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Intersection.IntersectionType">
            <summary>Тип пересечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Intersection.Interval">
            <summary>Параметрический интервал на кривой пересечения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Intersection.Curve">
            <summary>Кривая пересечения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData.Intersection">
            <summary>Кривая пересечения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.CurveData">
            <summary>Класс для хранения кривых пересечения</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.PointData.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.PointData.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.PointData.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.PointData.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.PointData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.PointData.default(System.UInt32)">
            <summary>Пересечение по номеру</summary>
            <param name="index">Номер пересечения</param>
            <remarks>Пересечения нумеруются от нуля. Если индекс отрицательный или превышает количество пересечений, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.PointData.Length">
            <summary>Количество пересечений</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectSurfaceData.PointData">
            <summary>Класс для хранения точек пересечения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectSurfaceData">
            <summary>Класс для хранения результатов пересечения двух поверхностей</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.default(System.UInt32)">
            <summary>Пересечение по номеру</summary>
            <param name="index">Номер пересечения</param>
            <remarks>Пересечения нумеруются от нуля. Если индекс отрицательный или превышает количество пересечений, то результат не определён</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Length">
            <summary>Количество пересечений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.Type">
            <summary>Тип совпадения кривых</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.IntersectionType.Tangent">
            <summary>Точка касания</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.IntersectionType.End">
            <summary>Конец участка совпадения кривой и поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.IntersectionType.Start">
            <summary>Начало участка совпадения кривой и поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.IntersectionType.Simple">
            <summary>Просто пересечение</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.IntersectionType">
            <summary>Тип совпадения кривой и поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.UV">
            <summary>Параметр на поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.Param">
            <summary>Параметр на кривой</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection.Coord">
            <summary>Координаты точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData.Intersection">
            <summary>Точка пересечения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.IntersectCurveSurfaceData">
            <summary>Класс для хранения результатов пересечения кривой и поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.UVBox.HighV">
            <summary>Установить верхнюю границу параметрической области по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.UVBox.HighU">
            <summary>Установить верхнюю границу параметрической области по U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.UVBox.LowV">
            <summary>Установить нижнюю границу параметрической области по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.UVBox.LowU">
            <summary>Установить нижнюю границу параметрической области по U</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UVBox.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="lowu">Нижняя граница параметрической области по U</param>
            <param name="lowv">Нижняя граница параметрической области по V</param>
            <param name="highu">Верхняя граница параметрической области по U</param>
            <param name="highv">Верхняя граница параметрической области по V</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.UVBox">
            <summary>Информация о параметрической области на поверхности</summary>
            <remarks>Можно изменять границы параметрической области</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseUVBox.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="lowu">Нижняя граница параметрической области по U</param>
            <param name="lowv">Нижняя граница параметрической области по V</param>
            <param name="highu">Верхняя граница параметрической области по U</param>
            <param name="highv">Верхняя граница параметрической области по V</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseUVBox.HighV">
            <summary>Получить верхнюю границу параметрической области по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseUVBox.HighU">
            <summary>Получить верхнюю границу параметрической области по U</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseUVBox.LowV">
            <summary>Получить нижнюю границу параметрической области по V</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseUVBox.LowU">
            <summary>Получить нижнюю границу параметрической области по U</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseUVBox">
            <summary>Информация о параметрической области на поверхности</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.UV.V">
            <summary>Параметр V</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.UV.U">
            <summary>Параметр U</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.UV">
            <summary>Параметры для поверхностей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Param.Continuous">
            <summary>Получить признак непрерывности всех производных</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Param.Form">
            <summary>Получить отношение между параметризацией и пространственной величиной</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.FormType.Any">
            <summary>Все остальные случаи</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.FormType.Circular">
            <summary>Параметр является углом окружности. Для поверхности окружность соответствует изолиния по другому параметру</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.FormType.Linear">
            <summary>Параметр пропорционален расстоянию вдоль прямой. Для поверхности прямой линии соответствует изолиния по другому параметру</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Param.FormType">
            <summary>Отношение между параметризацией и пространственной величиной</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Param.Periodic">
            <summary>Получить периодичность параметра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.PeriodicType.PeriodicSeamed">
            <summary>Периодический, но не непрерывно дифференцируемый через границу</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.PeriodicType.PeriodicYes">
            <summary>Периодический непрерывно дифференцируемый через границу</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.PeriodicType.PeriodicNo">
            <summary>Не периодический</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Param.PeriodicType">
            <summary>Периодичность параметра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Param.EndBound">
            <summary>Получить тип ограничений значений конечного параметра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Param.StartBound">
            <summary>Получить тип ограничений значений начального параметра</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.BoundType.Degenerate">
            <summary>Этот параметр имеет смысл только для поверхностей. 3D геометрия для данного интервала вырожденная</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.BoundType.Closed">
            <summary>Концевые точки параметрического интервала совпадают</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.BoundType.Bound">
            <summary>Значение параметра не может быть расширено в данном направлении</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.BoundType.Extendable">
            <summary>Значение параметра может быть расширено в данном направлении</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.Param.BoundType.Infinite">
            <summary>Значение параметра неограничено в данном направлении</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Param.BoundType">
            <summary>Тип ограничений значений параметра</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Param.Interval">
            <summary>Разрешенный интервал значений параметра</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Param">
            <summary>Информация о параметризации</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Interval.End">
            <summary>Установить конец интервала</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Interval.Start">
            <summary>Установить начало интервала</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Interval.#ctor(System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="start">Начало интервала</param>
            <param name="end">Конец интервала</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Interval">
            <summary>Информация об интервале</summary>
            <remarks>Можно изменять границы интервала</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseInterval.#ctor(System.Double,System.Double)">
            <summary>Конструктор</summary>
            <param name="start">Начало интервала</param>
            <param name="end">Конец интервала</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseInterval.End">
            <summary>Получить конец интервала</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseInterval.Start">
            <summary>Получить начало интервала</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseInterval">
            <summary>Информация об интервале</summary>
            <remarks>Границы интервала изменять нельзя</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Direction.default(System.Int32)">
            <summary>Коодината по номеру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Direction.Z">
            <summary>Z - координата вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Direction.Y">
            <summary>Y - координата вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Direction.X">
            <summary>X - координата вектора</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Direction.#ctor(TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Копирование координат другого вектора</summary>
            <param name="direction">Вектор, из которого берутся координаты</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Direction.#ctor(System.Double,System.Double,System.Double)">
            <summary>Создание геометрического вектора</summary>
            <param name="x">X - координата вектора</param>
            <param name="y">Y - координата вектора</param>
            <param name="z">Z - координата вектора</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Direction">
            <summary>Геометрический вектор</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelDirection.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельного вектора. Модельные векторы не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelDirection">
            <summary>Вектор с модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseDirection.#ctor(System.Double,System.Double,System.Double)">
            <summary>Конструктор для геометрического вектора</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseDirection.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельного вектора</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseDirection.Update">
            <summary>Обновить геометрию для каждого конкретного порождённого типа</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseDirection.Colinear(TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Проверить данный вектор на коллинеарность с другим</summary>
            <param name="other">Вектор</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseDirection.MakeOrtho">
            <summary>Сделать вектор, перпендикулярный данному</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseDirection.NormalizedVector">
            <summary>Нормализованный вектор</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseDirection.Magnitude">
            <summary>Длина вектора</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseDirection.CrossProduct(TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Векторное произведение векторов</summary>
            <param name="direction">Вектор-сомножитель</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseDirection.default(System.Int32)">
            <summary>Получить коодинату по номеру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseDirection.Z">
            <summary>Получить Z - координату вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseDirection.Y">
            <summary>Получить Y - координату вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseDirection.X">
            <summary>Получить X - координату вектора</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseDirection">
            <summary>Базовый класс для вектора</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Axis.Direction">
            <summary>Вектор направления оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Axis.Origin">
            <summary>Точка, через которую проходит ось</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Axis.#ctor(TFlex.Model.Model3D.Geometry.BaseAxis)">
            <summary>Конструктор для создания геометрической оси, полученной копированием свойств с другой оси</summary>
            <param name="axis">Геометрическая ось, с которой копируются свойства</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Axis.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конструктор для создания геометрической оси по точке и направлению</summary>
            <param name="origin">Точка, через которую проходит ось</param>
            <param name="direction">Вектор направления оси</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Axis">
            <summary>Класс геометрической оси</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelAxis">
            <summary>Класс оси с модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseAxis.LineNearPoints(TFlex.Model.Model3D.Geometry.Axis)">
            <summary>Получить точку на прямой, ближайшую к другой прямой</summary>
            <param name="line">Ближайшая к данной прямой прямая</param>
            <remarks>Если прямые параллельны, то результат нулевой</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseAxis.PointProjection(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Получить ортогональную проекцию точки на прямую</summary>
            <param name="point">Точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseAxis.LineIntersection(TFlex.Model.Model3D.Geometry.Axis)">
            <summary>Получить пересечение двух прямых</summary>
            <param name="line">Геометрическая ось, с которой пересекается данная ось</param>
            <remarks>Если оси не пересекаются, то результат нулевой</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseAxis.Direction">
            <summary>Вектор направления оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseAxis.Origin">
            <summary>Точка, через которую проходит ось</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseAxis.Update">
            <summary>Обновить геометрию для каждого конкретного порождённого типа</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseAxis.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конструктор для геометрической оси</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseAxis.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной оси</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseAxis">
            <summary>Базовый класс для оси</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Plane.XAxis">
            <summary>Направление оси X к плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Plane.Normal">
            <summary>Нормаль к плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Plane.Origin">
            <summary>Нулевая точка плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Plane.#ctor(TFlex.Model.Model3D.Geometry.BasePlane)">
            <summary>Конструктор, копирующий свойства другой плоскости</summary>
            <param name="plane">Плоскость, из которой берутся свойства</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Plane.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конструктор для создания геометрической плоскости по точке и двум осям</summary>
            <param name="origin">Нулевая точка плоскости</param>
            <param name="normal">Нормаль к плоскости</param>
            <param name="xaxis">Направление оси X на плоскости</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Plane">
            <summary>Геометрическая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelPlane.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной плоскости. Модельные плоскости не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelPlane">
            <summary>Плоскость модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePlane.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конструктор для геометрической плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePlane.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePlane.Equal(TFlex.Model.Model3D.Geometry.BasePlane)">
            <summary>Проверка совпадения плоскостей</summary>
            <param name="other">Плоскость, с которой ищется пересечение данной плоскости</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePlane.LineIntersection(TFlex.Model.Model3D.Geometry.Axis)">
            <summary>Получить пересечение плоскости с прямой</summary>
            <param name="line">Прямая, с которой ищется пересечение</param>
            <remarks>Если прямая не пересекает плоскость, то результат нулевой</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePlane.PlaneIntersection(TFlex.Model.Model3D.Geometry.BasePlane)">
            <summary>Получить пересечение двух плоскостей</summary>
            <param name="plane">Плоскость, с которой ищется пересечение</param>
            <remarks>Если плоскости параллельны, то результат нулевой</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePlane.PointProjection(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Получить ортогональную проекцию точки на плоскость</summary>
            <param name="point">Точка, проецируемая на плоскость</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BasePlane.XAxis">
            <summary>Получить направление оси X к плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BasePlane.Normal">
            <summary>Получить нормаль к плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BasePlane.Origin">
            <summary>Получить нулевую точку плоскости</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BasePlane">
            <summary>Базовый класс для плоскостей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Point3D.default(System.Int32)">
            <summary>Координата по номеру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Point3D.Z">
            <summary>Z - координата точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Point3D.Y">
            <summary>Y - координата точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Point3D.X">
            <summary>X - координата точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Point3D.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конструктор, копирующий координаты другой точки</summary>
            <param name="point">Точка, из которой берутся координаты</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Point3D.#ctor(System.Double,System.Double,System.Double)">
            <summary>Конструктор для создания геометрической точки по координатам</summary>
            <param name="x">X - координата точки</param>
            <param name="y">Y - координата точки</param>
            <param name="z">Z - координата точки</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Point3D">
            <summary>Геометрическая точка</summary>
            <remarks>Задаётся своими координатами</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelPoint3D.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной точки. Модельные точки не могут создаваться пользователем, так как возвращаются как свойства объектов модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelPoint3D">
            <summary>Точка модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePoint3D.#ctor(System.Double,System.Double,System.Double)">
            <summary>Конструктор для геометрической точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePoint3D.#ctor(TFlex.Model.Model3D.Object3D,System.IntPtr)">
            <summary>Конструкторы для модельной точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BasePoint3D.Distance(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Получить расстояние до заданной точки</summary>
            <param name="other">Заданная точка</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BasePoint3D.default(System.Int32)">
            <summary>Получить координату по номеру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BasePoint3D.Z">
            <summary>Получить Z - координату точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BasePoint3D.Y">
            <summary>Получить Y - координату точки</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BasePoint3D.X">
            <summary>Получить X - координату точки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BasePoint3D">
            <summary>Базовый класс для точек</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ParameterizationType">
            <summary>Тип последовательности узлов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.ParameterizationType.SmoothSeam">
            <summary>Параметризация для замкнутых периодических сплайнов</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.ParameterizationType.BezierEnds">
            <summary>Первый и последний узлы кратности = Степень сплайна + 1. Остальные узлы расположены неравномерно</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.ParameterizationType.PiecewiseBezier">
            <summary>Первый и последний узлы кратности = Степень сплайна + 1, остальные узлы имеют кратность = Степень сплайна, с разбиением на равные промежутки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.ParameterizationType.QuasiUniform">
            <summary>Первый и последний узлы кратности = Степень сплайна + 1, остальные узлы имеют кратность = 1, с разбиением на равные промежутки</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.ParameterizationType.Uniform">
            <summary>Равномерная параметризация</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.ParameterizationType.NonUniform">
            <summary>Неравномерная параметризация</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.ParameterizationType.Unset">
            <summary>Тип последовательности не определён</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.PiecewiseRepresentation">
            <summary>Типы представлений сплайна</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.PiecewiseRepresentation.Taylor">
            <summary>Тейлоровы сплайны</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.PiecewiseRepresentation.Hermite">
            <summary>Эрмитовы сплайны</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.PiecewiseRepresentation.Polynomial">
            <summary>Полиномиальные сплайны</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.PiecewiseRepresentation.Bezier">
            <summary>Безье сплайны</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.UnitConverter.Scale">
            <summary>Коэффициент преобразования из единиц модели в метры</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.FromMeter(TFlex.Model.Model3D.Geometry.BasePlane)">
            <summary>Конвертировать координаты плоскости из метров в единицы модели</summary>
            <param name="plane">Плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.ToMeter(TFlex.Model.Model3D.Geometry.BasePlane)">
            <summary>Конвертировать координаты плоскости из единиц модели в метры</summary>
            <param name="plane">Плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.FromMeter(TFlex.Model.Model3D.Geometry.BaseAxis)">
            <summary>Конвертировать координаты оси из метров в единицы модели</summary>
            <param name="axis">Ось</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.ToMeter(TFlex.Model.Model3D.Geometry.BaseAxis)">
            <summary>Конвертировать координаты оси из единиц модели в метры</summary>
            <param name="axis">Ось</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.FromMeter(TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конвертировать координаты вектора направления из метров в единицы модели</summary>
            <param name="vector">Вектор направления</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.ToMeter(TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конвертировать координаты вектора направления из единиц модели в метры</summary>
            <param name="vector">Вектор направления</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.FromMeter(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конвертировать координаты точки из метров в единицы модели</summary>
            <param name="point">Точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.ToMeter(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конвертировать координаты точки из единиц модели в метры</summary>
            <param name="point">Точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.FromMeter(System.Double)">
            <summary>Конвертация из метров в единицы модели</summary>
            <param name="scale">Величина геометрического объекта в метрах</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.ToMeter(System.Double)">
            <summary>Конвертация из единиц модели в метры</summary>
            <param name="scale">Величина геометрического объекта в единицах модели</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.UnitConverter.#ctor(TFlex.Model.Document)">
            <summary>Конструктор</summary>
            <param name="document">Документ, единицы которого учитываются</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.UnitConverter">
            <summary>Конвертер единиц измерения модели</summary>
            <remarks>В модели результирующая геометрия объектов хранится в метрах. Данный класс позволяет конвертировать геометрию в единицы модели и обратно</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TopolSolid">
            <summary>Твёрдотельная модель с топологии</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelSolid">
            <summary>Твёрдотельная модель с объекта модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Solid">
            <summary>Базовый класс для твёрдотельных моделей</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TopolSheet">
            <summary>Листовая модель с топологии</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelSheet">
            <summary>Листовая модель с объекта модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Sheet">
            <summary>Базовый класс для листовых моделей</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TopolWire">
            <summary>Проволочная модель с топологии</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelWire">
            <summary>Проволочная модель с объекта модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Wire">
            <summary>Базовый класс для проволочных моделей</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TopolContour">
            <summary>Контур с топологии</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelContour">
            <summary>Контур с объекта модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Contour">
            <summary>Базовый класс для контуров</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.TopolBodies">
            <summary>Множество тел с топологии</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelBodies.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelBodies.Reset">
            <summary>Сбросить перечислитель</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelBodies.MoveNext">
            <summary>Перейти к следующему элементу</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelBodies.Current">
            <summary>Получить текущий элемент</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.ModelBodies.GetEnumerator">
            <summary>Получить перечислитель</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelBodies.default(System.Int32)">
            <summary>Возвращает тело по номеру</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelBodies.Length">
            <summary>Количество тел</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelBodies">
            <summary>Множество тел с объекта модели</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Bodies">
            <summary>Базовый класс для множества тел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Geometry.Owner">
            <summary>Получить модельный объект, которому принадлежит геометрический объект</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Geometry.Reference">
            <summary>Создать объект типа ссылка на геометрический объект</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Geometry.Dispose">
            <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Geometry.Valid">
            <summary>Проверка достоверности ссылки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Geometry.Equals(TFlex.Model.Model3D.Geometry.Geometry)">
            <summary>Проверка эквивалетности ссылки</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Geometry">
            <summary>Базовый класс для геометрических данных объектов 3D модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Body.ReverseIfWire">
            <summary>Если тело является контуром, то можно изменить ориентацию контура</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Body.NormalizeIfPlanarClosedWire(TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Если тело является плоским замкнутым контуром, то обход по нему можно ориентировать против часовой стрелки согласно нормали к этой плоскости</summary>
            <param name="direction">Нормаль к плоскости заданного контура</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Body.Existence">
            <summary>Признак существования тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Body.Vertices">
            <summary>Множество вершин</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Body.Edges">
            <summary>Множество рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Body.Loops">
            <summary>Множество циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.Body.Faces">
            <summary>Множество граней</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Body.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конструктор для создания параллелепипеда</summary>
            <param name="p0">Первая точка - база</param>
            <param name="p1">Вторая точка - размер по 'X'</param>
            <param name="p2">Третья точка - размер по 'Y'</param>
            <param name="p3">Четвёртая точка - размер по 'Z'</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Body.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конструктор для создания листового прямоугольника(параллелограмма)</summary>
            <param name="p0">Первая точка контура</param>
            <param name="p1">Вторая точка контура</param>
            <param name="p2">Третья точка контура</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Body.#ctor(TFlex.Model.Model3D.Geometry.BaseFace)">
            <summary>Конструктор для создания листового тела на основе грани</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.Body.#ctor(TFlex.Model.Model3D.Geometry.BaseBody)">
            <summary>Конструктор для создания тела как копии другого тела</summary>
            <param name="body">Тело с которого копируется данное тело</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.Body">
            <summary>Класс хранения геометрических тел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelBody.Vertices">
            <summary>Множество вершин</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelBody.Edges">
            <summary>Множество рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelBody.Loops">
            <summary>Множество циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ModelBody.Faces">
            <summary>Множество граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ModelBody">
            <summary>Класс хранения тел с модели</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ClashBodyResultItem.Tool">
            <summary>Второй объект</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ClashBodyResultItem.Target">
            <summary>Первый объект</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ClashBodyResultItem">
            <summary>Информация о столкновении двух тел</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ClashTopolResultItem.Tool">
            <summary>Второй объект</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.ClashTopolResultItem.Target">
            <summary>Первый объект</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.ClashTopolResultItem">
            <summary>Информация о столкновении двух топологий</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseClashResultItem.Type">
            <summary>Тип столкновения</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseClashResultItem">
            <summary>Информация о столкновении</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.UnsetApprox">
            <summary>Если ранее была вызвана функция <see cref="M:TFlex.Model.Model3D.Geometry.BaseBody.SetApprox" />, то по завершении работы нужно вызвать функцию удаления вспомогательных данных</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.SetApprox">
            <summary>Функция формирует набор вспомогательных данных, ускоряющих выполнение функции <see cref="M:TFlex.Model.Model3D.Geometry.BaseBody.ContainsPoint(TFlex.Model.Model3D.Geometry.BasePoint3D)" />, если выполняется несколько вызовов этой функции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBody.NormalIfPlanarSheet">
            <summary>Для плоского листового тела возвращается нормаль к лицевой стороне тела</summary>
            <returns>Нормаль к лицевой стороне тела</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.Facet(System.Double,System.Boolean,System.Boolean)">
            <summary>Функция создаёт плоскогранную сетку</summary>
            <returns>Сетка</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.Clash(TFlex.Model.Model3D.Geometry.BaseBody,System.Boolean,System.Boolean)">
            <summary>Функция определяет столкновение тел</summary>
            <param name="body">Тело для проверки</param>
            <param name="isFindAllClashes">Найти все столкновения</param>
            <param name="isFindIntersect">Исследовать столкновения</param>
            <returns>Информация о столкновении тел</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.ClashBody(TFlex.Model.Model3D.Geometry.BaseBody)">
            <summary>Функция определяет перекрытие тел</summary>
            <param name="body">Тело для проверки</param>
            <returns>Тип пересечения</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.ContainsPoint(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Функция определяет положение точки относительно тела</summary>
            <param name="point">Точка</param>
            <returns>Положение точки относительно тела</returns>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseBody.TypeOfClash">
            <summary>Тип столкновения</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.TypeOfClashing.NoneIntersect">
            <summary>Пересечение отсутсвует</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.TypeOfClashing.Abutment">
            <summary>Неклассифицированное касание тел</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.TypeOfClashing.TrueAbutment">
            <summary>Касание тел</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.TypeOfClashing.TrueIntersect">
            <summary>Настоящее пересечение тел</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.Enclosure.Undefined">
            <summary>Положение точки относительно тела неопределено</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.Enclosure.On">
            <summary>Точка на поверхности тела</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.Enclosure.Outside">
            <summary>Точка снаружи тела</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.Enclosure.Inside">
            <summary>Точка внутри тела</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseBody.Enclosure">
            <summary>Положение точки относительно тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBody.LengthIfWire">
            <summary>Если тело является контуром, то можно получить его длину</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBody.PlaneIfWire">
            <summary>Если тело является контуром, то можно проверить его планарность и получить плоскость, в которой он лежит</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBody.IsClosedIfWire">
            <summary>Если тело является контуром, то можно проверить его замкнутость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.ApplyTransform(TFlex.Model.Model3D.Geometry.TransformationMatrix)">
            <summary>Трансформация геометрии тела</summary>
            <param name="transformation">Матрица преобразования</param>
            <remarks>Создаётся новое тело</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.BodyType.General">
            <summary>Смешанный набор</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.BodyType.Solid">
            <summary>Твёрдотельная модель</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.BodyType.Sheet">
            <summary>Составная поверхность</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.BodyType.Wire">
            <summary>Составная кривая</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.BodyType.Acorn">
            <summary>Множество изолированных вершин</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.Geometry.BaseBody.BodyType.Minimum">
            <summary>Одна вершина</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseBody.BodyType">
            <summary>Тип тела</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.FindExtreme(TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection,TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Найти экстремальную точку на теле в заданном направлении</summary>
            <param name="direction1">Первое направление поиска</param>
            <param name="direction2">Второе направление поиска</param>
            <param name="direction3">Третье направление поиска</param>
            <remarks>Экстремальная точка ищется в направлении 1. Если решение неоднозначное, то количество экстремальных точек последовательно редуцируется по направлениям 2 и 3. Все три направления взаимно ортогональны</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.RangeTopol(TFlex.Model.Model3D.Geometry.BaseTopol)">
            <summary>Найти ближайшее расстояние между телом и топологическим элементом</summary>
            <param name="rhs">Топологический элемент</param>
            <returns>Расстояние</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.RangeTopol(TFlex.Model.Model3D.Geometry.BaseBody)">
            <summary>Найти ближайшие расстояние между двумя телами</summary>
            <param name="rhs">Тело до которого ищется расстояние</param>
            <returns>Расстояние</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.RangePoint(TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.Point3D@,TFlex.Model.Model3D.Geometry.UV@)">
            <summary>Найти точку на теле ближайшую к данной точке</summary>
            <param name="point">Точка</param>
            <returns>Точка на теле ближайшая к данной точке</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.WireEval(TFlex.Model.Model3D.Geometry.BasePoint3D,System.Int32,System.Collections.Generic.List`1{TFlex.Model.Model3D.Geometry.Point3D}@)">
            <summary>Получения производных в заданной точке на проволочном теле</summary>
            <param name="point">точка на проволочном теле</param>
            <returns>p[0] - точка, p[1] - первая производная, p[2] - вторая производная, p[n] - n-ая производная</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.IntersectWire(TFlex.Model.Model3D.Geometry.BaseBody,System.Collections.Generic.List`1{TFlex.Model.Model3D.Geometry.Point3D}@)">
            <summary>Найти точки пересечения проволочных тел</summary>
            <param name="sourceWire">проволочное тело</param>
            <returns>true, если найдены точки пересечения</returns>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseBody.RangePointGeometryParameters">
            <summary>Тип параметризации</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.RangePoint(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Найти точку на теле ближайшую к данной точке</summary>
            <param name="point">Точка</param>
            <returns>Точка на теле ближайшая к данной точке</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Geometry.BaseBody.FindBoundBox">
            <summary>Получить границы тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBody.Vertices">
            <summary>Множество вершин</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBody.Edges">
            <summary>Множество рёбер</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBody.Loops">
            <summary>Множество циклов</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Geometry.BaseBody.Faces">
            <summary>Множество граней</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Geometry.BaseBody">
            <summary>Базовый класс хранения тел</summary>
        </member>
        <member name="M:EuclideanWorkplane.DoActionLikeRemoveLink(DeleteElementsContext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Пытаемся разорвать связь с родителем
</member>
        <member name="T:Workplane.EmbedWireBodyOn2DData">
Конвертация 3D-кривой на рабочей поверхности в 2D кривую на странице
</member>
        <member name="M:LCSystem.ProjectOnZAxis(TFM.SSE.Vector3d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проецировать точку на ось Z
</member>
        <member name="M:LCSystem.ProjectOnYAxis(TFM.SSE.Vector3d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проецировать точку на ось Y
</member>
        <member name="M:LCSystem.ProjectOnXAxis(TFM.SSE.Vector3d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Проецировать точку на ось X
</member>
        <member name="M:LCSystem.#ctor(TFM.SSE.Matrix4d!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Система координат задаётся преобразованием глобальной системы координат
</member>
        <member name="M:IdentifyElemManager.UpdateSearchInfo">
}
}
</member>
        <member name="M:IdentifyElemManager.ReadIdentify(CFile*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,MapPtr2Ptr*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt16)">
В ЧПУ вместо хранения ссылки на идентификатор записывался и читался целиком идентификатор
</member>
        <member name="M:IdentifyElemManager.CreateUserFieldIdentify(TFDocRegenContext*,TF_PK_USER_FIELD_t*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TypeofEntity,SelScnObj*,TFM.SSE.Vector3d*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFM.SSE.Vector3d*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,TFM.SSE.Vector3d*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Создание идентификатора на основе идентификатора в старом формате. Используется при конвертации файлов старых форматов, где вместо ссылки через IdentifyElem
использовалась прямая ссылка по идентификатору в старом формате. Например, вершина на профиле или пути в версиях до 8.0.
</member>
        <member name="M:IdentifyElemManager.CreateIdentifyFix(TFDocRegenContext*,System.Int32,GeometricBody*,SelScnObj*,TFObjectID)">
Следующие функции устаревшие, и будут удалены в следующей версии. Не использовать в новой функциональности!
{
Функция используется для установки одноразовой ссылки
</member>
        <member name="T:TF_PK_USER_FIELD_t">
Создать ссылку на отдельный топологический элементы в модели сборки.
Предполагается работа с идентификаторами в старом формате.
Редактироание в контексте сборки
</member>
        <member name="M:IdentifyElemManager.CreateProjectionIdentify(TFDocRegenContext*,System.Int32,GeometricBody*,CViewData*,System.Boolean,System.Boolean)">
Ссылка создаётся только для картиночных проекций
</member>
        <member name="M:IdentifyElemManager.CreateIdentify(TFDocRegenContext*,SelScnObj*,System.Int32,GeometricBody*,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
Создать или найти ранее созданную ссылку на геометрический элемент
{
</member>
        <member name="M:IdentifyElem.FindEntityOnlyByIdentifier(System.Boolean)">
Поиск топологических элементов выполняется только по идентификаторам элементов на момент создания ссылки. Никакие "умные" алгоритмы не применяются.
</member>
        <member name="M:IdentifyElem.BodyOwner">
Сссылка на топологический элемент тела
</member>
        <member name="M:IdentifyElem.Owner">
Ссылка на топологический элемент операции или кострукционного элемента
</member>
        <member name="M:IdentifyElem.LastBodyOperationIdentifier">
Идентификатор последней верхней операции в случае ссылки на элемент тела. Используется для проверки изменения верхней операции в пересчете
</member>
        <member name="T:TFReference.CTFBoolPropertyAuto">
Класс для автоматической переменной для установки нового значения флага и восстановления старого значения флага при завершении
</member>
        <member name="M:TFlex.Model.Model3D.EuclideanWorkplaneManager.MovePlane(TFlex.Model.Model3D.Workplane,System.Double)">
            <summary>Переместить рабочую плоскость по нормали к плоскости на заданное значение</summary>
            <param name="plane">Перемещаемая плоскость</param>
            <param name="offset">Величина, на которую выполняется перемещение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EuclideanWorkplaneManager.SetDistance(TFlex.Model.Model3D.Workplane,TFlex.Model.Model3D.Workplane,System.Double)">
            <summary>Задать расстояние между рабочими плоскостями</summary>
            <param name="basePlane">Базовая плоскость</param>
            <param name="moveablePlane">Перемещаемая плоскость</param>
            <param name="dDistance">Расстояние</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EuclideanWorkplaneManager.MakeArray(TFlex.Model.Model3D.Workplane,TFlex.Model.Model3D.Workplane,System.Int32,System.Boolean,System.Double,System.Double,System.Double)">
            <summary>Создать группу рабочих плоскостей</summary>
            <param name="plane1">Первая плоскость</param>
            <param name="plane2">Вторая плоскость</param>
            <param name="nCount" />
            <param name="fUseStep">true - использовать значение шага step,
иначе - определять шаг по расстоянию между данными плоскостями и количеству nCount</param>
            <param name="step" />
            <param name="beginOffset">Начальное смещение</param>
            <param name="endOffset">Конечное смещение</param>
        </member>
        <member name="M:TFlex.Model.Model3D.EuclideanWorkplaneManager.MakeUniform(TFlex.Model.Model3D.Workplane[],System.Double,System.Double)">
            <summary>Установить рабочие плоскости равномерно</summary>
            <param name="planes">Набор плоскостей</param>
            <param name="beginOffset">Начальное смещение</param>
            <param name="endOffset">Конечное смещение</param>
        </member>
        <member name="T:TFlex.Model.Model3D.EuclideanWorkplaneManager">
            <summary>Функции управления несколькими рабочими плоскостями</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SymmetryPlaneWorkplane.Ratio">
            <summary>Отношение</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SymmetryPlaneWorkplane.SecondPlane">
            <summary>Вторая плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.SymmetryPlaneWorkplane.FirstPlane">
            <summary>Первая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.SymmetryPlaneWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.SymmetryPlaneWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.SymmetryPlaneWorkplane">
            <summary>Рабочая плоскость относительно плоскости симметрии</summary>
            <example>
                <code name="Рабочая плоскость относительно плоскости симметрии">
public static void SymmetryPlaneWorkplane()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   OnPointsWorkplane onPointsWorkplane = new OnPointsWorkplane(document);//создаем объект
   onPointsWorkplane.Name = "A";
	    
   //построение узлов		    
   CoordinateNode3D node1 = new CoordinateNode3D(document); 
   node1.X = 10; node1.Y = 20; node1.Z = 70;
	    
   CoordinateNode3D node2 = new CoordinateNode3D(document); 
   node2.X = 10; node2.Y = 10; node2.Z = 70;

   CoordinateNode3D node3 = new CoordinateNode3D(document); 
   node3.X = 20; node3.Y = 10; node3.Z = 70;
	    
   //построение плоскости A по 3 точкам
   onPointsWorkplane.FirstPointOnWorkplane = node1.Geometry.Point;
   onPointsWorkplane.SecondPointOnWorkplane = node2.Geometry.Point;
   onPointsWorkplane.ThirdPointOnWorkplane = node3.Geometry.Point;
	    
   //построение параллельной плоскости
   ParallelPlaneWorkplane parallelPlaneWorkplane = new ParallelPlaneWorkplane(document);
   parallelPlaneWorkplane.Name = "B || A";
   parallelPlaneWorkplane.Color = 100;
   parallelPlaneWorkplane.Offset = 100;
   parallelPlaneWorkplane.BasePlane =onPointsWorkplane.Geometry.Plane;
	    
   //Рабочая плоскость относительно плоскости симметрии
   SymmetryPlaneWorkplane s = new SymmetryPlaneWorkplane(document);
   s.FirstPlane = onPointsWorkplane.Geometry.Plane;//первая плоскость
   s.SecondPlane = parallelPlaneWorkplane.Geometry.Plane;//вторая плоскость

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.TangentToSurfaceWorkplane.PointNearToSurface">
            <summary>Точка, задающая положение рабочей плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.TangentToSurfaceWorkplane.TangentSurface">
            <summary>Поверхность, которой касается рабочая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.TangentToSurfaceWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.TangentToSurfaceWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.TangentToSurfaceWorkplane">
            <summary>Рабочая плоскость, касательная поверхности</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PerpendicularToPathWorkplane.Location">
            <summary>Точка, задающая начало координат рабочей плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PerpendicularToPathWorkplane.PointOnWorkplane">
            <summary>Точка, задающая положение рабочей плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.PerpendicularToPathWorkplane.Path">
            <summary>Путь, перпендикулярно которому проходит рабочая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.PerpendicularToPathWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.PerpendicularToPathWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.PerpendicularToPathWorkplane">
            <summary>Рабочая плоскость, перпендикулярная кривой</summary>
            <example>
                <code name="Перпендикулярная плоскость">
public static void PerpendicularToPathWorkplane(PolylineSplinePath3D polylineSplinePath3D, ModelEdge modelEdge)
{
   Document document = TFlex.Application.ActiveDocument;//получение активного документа
   document.BeginChanges("построение перпендикулярной плоскости");//открытие блока изменений документа

   OnPointsWorkplane onPointsWorkplane = new OnPointsWorkplane(document);//создаем объект
   onPointsWorkplane.Name = "a";

   //построение узлов
   CoordinateNode3D node1 = new CoordinateNode3D(document);
   node1.X = 10; node1.Y = 20; node1.Z = 70;

   CoordinateNode3D node2 = new CoordinateNode3D(document);
   node2.X = 10; node2.Y = 10; node2.Z = 70;

   CoordinateNode3D node3 = new CoordinateNode3D(document);
   node3.X = 20; node3.Y = 10; node3.Z = 70;

   //построение плоскости a по 3 точкам
   onPointsWorkplane.FirstPointOnWorkplane = node1.Geometry.Point;
   onPointsWorkplane.SecondPointOnWorkplane = node2.Geometry.Point;
   onPointsWorkplane.ThirdPointOnWorkplane = node3.Geometry.Point;

   PerpendicularToPathWorkplane p = new PerpendicularToPathWorkplane(document);
   p.Name = "p";
   p.PointOnWorkplane = node1.Geometry.Point;
   p.Location = node1.Geometry.Point;

   /*1. Плоскость перпендикулярная полилинии
   p.Path = polylineSplinePath3D.Geometry.Wire;//путь, перпендикулярно которому проходит рабочая плоскость*/

   //2. Плоскость перпендикулярная ребру 
   p.Path = modelEdge.Geometry.Wire;

   document.EndChanges();//закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.OnAxisWorkplane.Angle">
            <summary>Угол поворота</summary>
            <remarks>Доворот рабочей плоскости задаётся тремя взаимоисключающими способами :
- точкой, через которую проходит рабочая плоскость;
- параметром угла поворота;
- поверхностью, которой касается рабочая плоскость.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnAxisWorkplane.FaceTangentToWorkplane">
            <summary>Поверхность, которой касается рабочая плоскость</summary>
            <remarks>Доворот рабочей плоскости задаётся тремя взаимоисключающими способами :
- точкой, через которую проходит рабочая плоскость;
- параметром угла поворота;
- поверхностью, которой касается рабочая плоскость.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnAxisWorkplane.PointOnWorkplane">
            <summary>Точка, задающая доворот рабочей плоскости</summary>
            <remarks>Доворот рабочей плоскости задаётся тремя взаимоисключающими способами :
- точкой, через которую проходит рабочая плоскость;
- параметром угла поворота;
- поверхностью, которой касается рабочая плоскость.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnAxisWorkplane.BasePlane">
            <summary>Плоскость, относительно которой задаётся доворот рабочей плоскости</summary>
            <remarks>В случае выбора плоскости доворот задаётся параметром угла поворота</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnAxisWorkplane.AxisOnWorkplane">
            <summary>Ось, которая лежит на рабочей плоскости</summary>
            <remarks>Положение рабочей плоскости задаётся двумя взаимоисключающими способами : плоским ребром или осью</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnAxisWorkplane.EdgeOnWorkplane">
            <summary>Плоское ребро, которое лежит на рабочей плоскости</summary>
            <remarks>Положение рабочей плоскости задаётся двумя взаимоисключающими способами : плоским ребром или осью.
Если ребро прямое, то также как и в случае выбора оси можно дополнительно задавать доворот рабочей плоскости относительно оси или ребра</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.OnAxisWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.OnAxisWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.OnAxisWorkplane">
            <summary>Рабочая плоскость по оси или плоскому ребру</summary>
            <example>
                <code name="Рабочая плоскость по оси">
public static void OnAxisWorkplane(ModelFace modelFace)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Рабочая плоскость по оси или плоскому ребру");//Открытие блока изменений документа

   //Рабочая плоскость по оси 
   OnAxisWorkplane onAxisWorkplane = new OnAxisWorkplane(document);
   onAxisWorkplane.Name = "плоскость по оси";
   onAxisWorkplane.AxisOnWorkplane = modelFace.Geometry.Axis;
   onAxisWorkplane.Angle = 120;

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.OnPointsWorkplane.Angle">
            <summary>Угол поворота</summary>
            <remarks>Положение рабочей плоскости задаётся следующими способами :
- точкой и осью;
- двумя точками (возможно задание угла доворота);
- тремя точками;
- точкой и конусом или цилиндром;
- двумя точками и плоскостью (возможно задание угла доворота);
- двумя точками и направлением (возможно задание угла доворота);
- двумя точками и цилиндром, конусом или сферой;</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnPointsWorkplane.FaceTangentToWorkplane">
            <summary>Поверхность, которой касается рабочая плоскость</summary>
            <remarks>Положение рабочей плоскости задаётся следующими способами :
- точкой и осью;
- двумя точками (возможно задание угла доворота);
- тремя точками;
- точкой и конусом или цилиндром;
- двумя точками и плоскостью (возможно задание угла доворота);
- двумя точками и направлением (возможно задание угла доворота);
- двумя точками и цилиндром, конусом или сферой;</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnPointsWorkplane.BaseDirection">
            <summary>Направление, относительно которого задаётся доворот рабочей плоскости</summary>
            <remarks>Положение рабочей плоскости задаётся следующими способами :
- точкой и осью;
- двумя точками (возможно задание угла доворота);
- тремя точками;
- точкой и конусом или цилиндром;
- двумя точками и плоскостью (возможно задание угла доворота);
- двумя точками и направлением (возможно задание угла доворота);
- двумя точками и цилиндром, конусом или сферой;</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnPointsWorkplane.BasePlane">
            <summary>Плоскость, относительно которой задаётся доворот рабочей плоскости</summary>
            <remarks>Положение рабочей плоскости задаётся следующими способами :
- точкой и осью;
- двумя точками (возможно задание угла доворота);
- тремя точками;
- точкой и конусом или цилиндром;
- двумя точками и плоскостью (возможно задание угла доворота);
- двумя точками и направлением (возможно задание угла доворота);
- двумя точками и цилиндром, конусом или сферой;</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnPointsWorkplane.ThirdPointOnWorkplane">
            <summary>Третья точка, задающая положение рабочей плоскости</summary>
            <remarks>Положение рабочей плоскости задаётся следующими способами :
- точкой и осью;
- двумя точками (возможно задание угла доворота);
- тремя точками;
- точкой и конусом или цилиндром;
- двумя точками и плоскостью (возможно задание угла доворота);
- двумя точками и направлением (возможно задание угла доворота);
- двумя точками и цилиндром, конусом или сферой;</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnPointsWorkplane.SecondPointOnWorkplane">
            <summary>Вторая точку, задающая положение рабочей плоскости</summary>
            <remarks>Положение рабочей плоскости задаётся следующими способами :
- точкой и осью;
- двумя точками (возможно задание угла доворота);
- тремя точками;
- точкой и конусом или цилиндром;
- двумя точками и плоскостью (возможно задание угла доворота);
- двумя точками и направлением (возможно задание угла доворота);
- двумя точками и цилиндром, конусом или сферой;</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnPointsWorkplane.AxisOnWorkplane">
            <summary>Ось, через которую проходит рабочая плоскость</summary>
            <remarks>Положение рабочей плоскости задаётся следующими способами :
- точкой и осью;
- двумя точками (возможно задание угла доворота);
- тремя точками;
- точкой и конусом или цилиндром;
- двумя точками и плоскостью (возможно задание угла доворота);
- двумя точками и направлением (возможно задание угла доворота);
- двумя точками и цилиндром, конусом или сферой;</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.OnPointsWorkplane.FirstPointOnWorkplane">
            <summary>Первая точка, задающая положение рабочей плоскости</summary>
            <remarks>Положение рабочей плоскости задаётся следующими способами :
- точкой и осью;
- двумя точками (возможно задание угла доворота);
- тремя точками;
- точкой и конусом или цилиндром;
- двумя точками и плоскостью (возможно задание угла доворота);
- двумя точками и направлением (возможно задание угла доворота);
- двумя точками и цилиндром, конусом или сферой;</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.OnPointsWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.OnPointsWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.OnPointsWorkplane">
            <summary>Рабочая плоскость по трём точкам или точке и прямой</summary>
            <example>
                <code name="Построение плоскости по 3 точкам">
public static void OnPointsWorkplane()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Рабочая плоскость по трем точкам");//Открытие блока изменений документа

   OnPointsWorkplane onPointsWorkplane = new OnPointsWorkplane(document);//создаем объект
   onPointsWorkplane.Name = "A";
	
   //построение узлов
   CoordinateNode3D node1 = new CoordinateNode3D(document); 
   node1.X = 10; node1.Y = 20; node1.Z = 70; 
   CoordinateNode3D node2 = new CoordinateNode3D(document); 
   node2.X = 10; node2.Y = 10; node2.Z = 70;
   CoordinateNode3D node3 = new CoordinateNode3D(document); 
   node3.X = 20; node3.Y = 10; node3.Z = 70;

   //построение плоскости A по 3 точкам
   onPointsWorkplane.FirstPointOnWorkplane = node1.Geometry.Point;
   onPointsWorkplane.SecondPointOnWorkplane = node2.Geometry.Point;
   onPointsWorkplane.ThirdPointOnWorkplane = node3.Geometry.Point;

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.ParallelPlaneWorkplane.Offset">
            <summary>Смещение</summary>
            <remarks>Положение рабочей плоскости задаётся четырьмя взаимоисключающими способами: смещением, точкой, гранью, ребром</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ParallelPlaneWorkplane.EdgeTangentToWorkplane">
            <summary>Ребро, которого касается рабочая плоскость</summary>
            <remarks>Положение рабочей плоскости задаётся четырьмя взаимоисключающими способами: смещением, точкой, гранью, ребром</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ParallelPlaneWorkplane.FaceTangentToWorkplane">
            <summary>Поверхность, которой касается рабочая плоскость</summary>
            <remarks>Положение рабочей плоскости задаётся четырьмя взаимоисключающими способами: смещением, точкой, гранью, ребром</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ParallelPlaneWorkplane.PointOnWorkplane">
            <summary>Точка, задающую положение рабочей плоскости</summary>
            <remarks>Положение рабочей плоскости задаётся четырьмя взаимоисключающими способами: смещением, точкой, гранью, ребром</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.ParallelPlaneWorkplane.BasePlane">
            <summary>Плоскость, задающая положение рабочей плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.ParallelPlaneWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ParallelPlaneWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.ParallelPlaneWorkplane">
            <summary>Рабочая плоскость, параллельная плоскости</summary>
            <example>
                <code name="Параллельная плоскость">
public static void ParallelPlaneWorkplane()
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Построение параллельной плоскости");//Открытие блока изменений документа

   OnPointsWorkplane onPointsWorkplane = new OnPointsWorkplane(document);//создаем объект
   onPointsWorkplane.Name = "A";
	
   //построение узлов
   CoordinateNode3D node1 = new CoordinateNode3D(document); 
   node1.X = 10; node1.Y = 20; node1.Z = 70;
	
   CoordinateNode3D node2 = new CoordinateNode3D(document); 
   node2.X = 10; node2.Y = 10; node2.Z = 70;
	
   CoordinateNode3D node3 = new CoordinateNode3D(document); 
   node3.X = 20; node3.Y = 10; node3.Z = 70;
	
   //построение плоскости A по 3 точкам
   onPointsWorkplane.FirstPointOnWorkplane = node1.Geometry.Point;
   onPointsWorkplane.SecondPointOnWorkplane = node2.Geometry.Point;
   onPointsWorkplane.ThirdPointOnWorkplane = node3.Geometry.Point;
	
   //рабочая плоскость параллельная плоскости
   ParallelPlaneWorkplane parallelPlaneWorkplane = new ParallelPlaneWorkplane(document);
   parallelPlaneWorkplane.Name = "B || A";
   parallelPlaneWorkplane.Color = 100;
   parallelPlaneWorkplane.Offset = 100;
   parallelPlaneWorkplane.BasePlane =onPointsWorkplane.Geometry.Plane;

   document.EndChanges();//Закрытие блока изменений документа
} 
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.Model3DWorkplane.ReferenceDirection">
            <summary>Точка, задающая направление оси X рабочей плоскости</summary>
            <remarks>Если не задано начало координат рабочей плоскости, то точка, задающая направление оси X рабочей плоскости, не используется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Model3DWorkplane.Location">
            <summary>Точка, задающая начало координат рабочей плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Model3DWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Model3DWorkplane">
            <summary>Рабочая плоскость, построенная по 3D</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.CopyWorkplane.BaseWorkplane">
            <summary>Рабочая плоскость</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.CopyWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.CopyWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.CopyWorkplane">
            <summary>Рабочая плоскость как копия другой рабочей плоскости</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.LCSWorkplane.LCS">
            <summary>Локальная система координат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.LCSWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.LCSWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.LCSWorkplane.Orientation">
            <summary>Пара осей локальной системы координат, которыми задаётся рабочая плоскость</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.LCSWorkplane.OrientationType.YZ">
            <summary>По осям Y и Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.LCSWorkplane.OrientationType.XZ">
            <summary>По осям X и Z</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.LCSWorkplane.OrientationType.XY">
            <summary>По осям X и Y</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.LCSWorkplane.OrientationType">
            <summary>Какой парой осей локальной системы координат задаётся рабочая плоскость</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.LCSWorkplane">
            <summary>Рабочая плоскость по локальной системе координат</summary>
            <example>
                <code name="Рабочая плоскость по локальной системе координат">
public static void LCSWorkplane()
{
    Document doc = TFlex.Application.ActiveDocument;
    
    doc.BeginChanges("Создание РП ЛСК");
    
    Page pg = new Page(doc);
    
    pg.Name = "LW-PL_";
    pg.PageType = PageType.Workplane;
    
    CoordinateNode3D nd0 = new CoordinateNode3D(doc);
    nd0.X = 0;
    nd0.Y = 0;
    nd0.Z = 0;
    
    CoordinateNode3D ndx = new CoordinateNode3D(doc);
    ndx.X = 1;
    ndx.Y = 0;
    ndx.Z = 0;

    CoordinateNode3D ndy = new CoordinateNode3D(doc);
    ndy.X = 0;
    ndy.Y = 1;
    ndy.Z = 0;
    
    PointsLCS LCS = new PointsLCS(doc);
    LCS.PointToOrigin = nd0.Geometry.Point;
    LCS.PointToAxisX = ndx.Geometry.Point;
    LCS.PointToAxisY = ndy.Geometry.Point;
    
    LCSWorkplane wp_LCS = new LCSWorkplane(doc);
    wp_LCS.Name = "LW-PL_";
    wp_LCS.LCS = LCS;
    wp_LCS.Orientation = LCSWorkplane.OrientationType.XY;
    wp_LCS.ShowOn3D = true;
    wp_LCS.Page = pg;
    doc.EndChanges();
    
    return;
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectingWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.ProjectingWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.ProjectingWorkplane">
            <summary>Рабочая плоскость по проекции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AuxiliaryWorkplane.BaseWorkplane">
            <summary>Базовая рабочую плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AuxiliaryWorkplane.SecondRotationNode">
            <summary>Второй узел направления вращения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AuxiliaryWorkplane.FirstRotationNode">
            <summary>Первый узел направления вращения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AuxiliaryWorkplane.SecondDirectionNode">
            <summary>Второй узел направления взгляда</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.AuxiliaryWorkplane.FirstDirectionNode">
            <summary>Первый узел направления взгляда</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.AuxiliaryWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.AuxiliaryWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.AuxiliaryWorkplane">
            <summary>Рабочая плоскость на основе вспомогательного 2D-вида</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.StandardWorkplane.SetPosition(TFlex.Model.Model3D.Geometry.Point3D)">
            <summary>Переместить рабочую плоскость до совпадения с точкой</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.StandardWorkplane.Standard">
            <summary>Стандартный вид рабочей плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.StandardWorkplane.#ctor(TFlex.Model.Model3D.Workplane,System.Double)">
            <summary>Конструктор для создания стандартной рабочей плоскости, смещённой относительно другой рабочей плоскости</summary>
            <param name="plane">Родительская плоскость</param>
            <param name="offset">Смещение</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.StandardWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.StandardWorkplane.StandardType,TFlex.Model.Page)">
            <summary>Конструктор для создания стандартной рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="type">Стандартный вид</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.StandardWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Model3D.StandardWorkplane.StandardType)">
            <summary>Конструктор для создания стандартной рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="type">Стандартный вид</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardWorkplane.StandardType.Right">
            <summary>Вид справа</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardWorkplane.StandardType.Left">
            <summary>Вид слева</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardWorkplane.StandardType.Bottom">
            <summary>Вид снизу</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardWorkplane.StandardType.Top">
            <summary>Вид сверху</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardWorkplane.StandardType.Back">
            <summary>Вид сзади</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardWorkplane.StandardType.Front">
            <summary>Вид спереди</summary>
        </member>
        <member name="F:TFlex.Model.Model3D.StandardWorkplane.StandardType.Undefined">
            <summary>Вид не задан</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.StandardWorkplane.StandardType">
            <summary>Стандартные виды</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.StandardWorkplane">
            <summary>Стандартная рабочая плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Model2DWorkplane.BoundQuadrant">
            <summary>Квадрант границы рабочей плоскости, если границы задаются одним узлом и границами листа</summary>
            <remarks>Квадранты нумеруются от 1 до 4.
По умолчанию первый угол задаётся точкой привязки.</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Model2DWorkplane.SecondBoundCorner">
            <summary>Второй угол границы</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Model2DWorkplane.FirstBoundCorner">
            <summary>Первый угол границы</summary>
            <remarks>По умолчанию первый угол задаётся точкой привязки</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Model2DWorkplane.TargetNode">
            <summary>Связь с 3D-узлом</summary>
            <remarks>Для рабочей плоскости по проекции и рабочей плоскости по системе координат связь с 3D-узлом не используется</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Model2DWorkplane.BaseNode">
            <summary>Точка привязки</summary>
            <remarks>Для рабочей плоскости по проекции точка привязки не используется</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Model2DWorkplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Model2DWorkplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Model2DWorkplane">
            <summary>Рабочая плоскость, построенная по 2D</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Workplane.Project(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Проекция точки на рабочую плоскость</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Workplane.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Workplane.AddOffset">
            <summary>Смещение рабочей плоскости вдоль нормали</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Workplane.Geometry">
            <summary>Получить геометрические данные рабочей плоскости</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Workplane.#ctor(TFlex.Model.Document,TFlex.Model.Page)">
            <summary>Конструктор для создания новой рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <param name="page">Страница, на которой создаётся рабочая плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Workplane.#ctor(TFlex.Model.Document)">
            <summary>Конструктор для создания новой рабочей плоскости</summary>
            <param name="document">Документ, в котором создаётся новый объект</param>
            <remarks>Рабочая плоскость создаётся на активной странице</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Workplane.GeometryData.Surface">
            <summary>Получить поверхность</summary>
            <returns>Объект класса TFlex::Model :: Model3D::Geometry::ModelSurface, хранящий плоскость в общем для всех поверхностей представлении и ссылку на эти геометрические данные рабочей плоскости</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Workplane.GeometryData.Point">
            <summary>Получить нулевую точку рабочей плоскости</summary>
            <returns>Объект класса TFlex::Model :: Model3D::Geometry::ModelPoint3D, хранящий координаты точки и ссылку на эти геометрические данные рабочей плоскости</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Workplane.GeometryData.Plane">
            <summary>Получить плоскость</summary>
            <returns>Объект класса TFlex::Model :: Model3D::Geometry::ModelPlane, хранящий координаты плоскости и ссылку на эти геометрические данные рабочей плоскости</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Workplane.GeometryData.Axis">
            <summary>Получить ось</summary>
            <remarks>Направление оси задаётся нормалью к плоскости. Ось проходит через нулевую точку плоскости</remarks>
            <returns>Объект класса TFlex::Model :: Model3D::Geometry::ModelAxis, хранящий координаты оси и ссылку на эти геометрические данные рабочей плоскости</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Workplane.GeometryData.Direction">
            <summary>Получить нормаль к рабочей плоскости</summary>
            <returns>Объект класса TFlex::Model :: Model3D::Geometry::ModelDirection, хранящий координаты вектора и ссылку на эти геометрические данные рабочей плоскости</returns>
        </member>
        <member name="T:TFlex.Model.Model3D.Workplane.GeometryData">
            <summary>Множество геометрических данных рабочей плоскости</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Workplane">
            <summary>Базовый класс для всех типов рабочих плоскостей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.WorkSurface.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.WorkSurface.ShowOn3D">
            <summary>Признак рисования рабочей плоскости в 3D сцене</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.WorkSurface.Page">
            <summary>Страница</summary>
            <example>
                <code name="Cоздание страницы">
public static void SetPage(ModelObject ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Page p = new Page(document);//создание страницы
   p.Name = "страница1"
   ob.Page = p;//cтраница, на которой размещается элемент
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="T:TFlex.Model.Model3D.WorkSurface">
            <summary>Базовый класс для всех типов рабочих поверхностей</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Construction3D.Exported">
            <summary>Свойство экспортирования объекта при вставке в сборку</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Construction3D">
            <summary>Базовый класс для элементов построения 3D модели</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Operation.RangePoint(TFlex.Model.Model3D.Operation,TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Найти точку на операции ближайшую к данной точке</summary>
            <param name="operation">Операция</param>
            <param name="point">Точка</param>
            <returns>Точка на теле ближайшая к данной точке</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Operation.RadialRayTest(TFlex.Model.Model3D.Operation,TFlex.Model.Model3D.Geometry.BasePoint3D,TFlex.Model.Model3D.Geometry.BaseDirection,System.Collections.Generic.List`1{System.Double},System.Collections.Generic.List`1{TFlex.Model.Model3D.Geometry.BasePoint3D})">
            <summary>Определение точек касания луча с операцией по расстоянию до перпендикуляра к лучу</summary>
            <param name="operation">Операция</param>
            <param name="rayOrigin">Исходная точка луча</param>
            <param name="rayDir">Направление луча</param>
            <param name="distances">Растояние до перпендикуляра к лучу</param>
            <param name="points">Точки касания</param>
            <returns>Результат поиска</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Operation.FindBodyOwner(System.Boolean)">
            <summary>Получить базовую операцию, в которой хранятся свойства тела</summary>
            <param name="any">Если базовой операции нет, то возвращать саму передаваемую операцию</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.TopOperation">
            <summary>Верхняя операция в теле</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.Body">
            <summary>Тело, в которое входит операция</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Operation.FindAssociatedTopols(TFlex.Model.Model3D.Hole)">
            <summary>Поиск топологических элементов, ассоциированных с отверстием</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Operation.FindAssociatedTopols(TFlex.Model.Model3D.LCS)">
            <summary>Поиск топологических элементов, ассоциированных с системой координат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Operation.ExportGeometry(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Сохранение тел в файл в формате Parasolid</summary>
            <param name="file">Имя выходного файла</param>
            <param name="redundant">Удалять избыточную геометрию</param>
            <param name="materials">Выгружать с материалами</param>
            <param name="assembly">Сохранять структуру сборки</param>
            <param name="binary">Использовать бинарный формат</param>
            <returns>Результат экспорта</returns>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.MeshDensity">
            <summary>Плотность сетки в диапазоне 0.0-1.0</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.Transparency">
            <summary>Прозрачность</summary>
            <remarks>Значение от 0 до 1</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.Suppression">
            <summary>Свойство подавленности операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.Fixed">
            <summary>Свойство фиксации операции относительно сопряжений</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.TopLevel">
            <summary>Признак верхней операции</summary>
            <remarks>Именно геометрия верхних операций является текущей геометрией модели в целом</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.CoatingMaterial">
            <summary>Материал операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.Material">
            <summary>Материал операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.Wireframe">
            <summary>Признак рёберной отрисовки операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.Geometry">
            <summary>Геометрические данные операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GroupType">
            <summary>Получить тип объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Box">
            <summary>Получить границы операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Curve">
            <summary>Получить кривую, на которой лежит граница листовой операции</summary>
            <remarks>Для операций, состоящих из нескольких рёбер, кривая может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Surface">
            <summary>Получить поверхность, на которой лежит листовая операция</summary>
            <remarks>Для операций, состоящих из нескольких граней, поверхность может быть не определена</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.AABoundBox">
            <summary>Получить параллельный осям ограничивающий прямоугольник</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.BoundBox">
            <summary>Получить bound box</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Solid">
            <summary>Получить тело для твердотельной операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Sheet">
            <summary>Получить тело листовой операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Wire">
            <summary>Получить рёберные границы листовой операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.ContourLaminar">
            <summary>Получить границы листовой операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.ContourSheet">
            <summary>Получить контур листовой операции</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Plane">
            <summary>Получить плоскость плоского листового тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Axis">
            <summary>Получить ось</summary>
            <remarks>Возвращаемая ось зависит от типа операции.
<list type="table"><listheader><term>Операция</term><description>Ось</description></listheader><item><term>Вращение</term><description>Ось вращения</description></item><item><term>Круговой массив</term><description>Ось вращения</description></item><item><term>Спираль</term><description>Ось спирали</description></item><item><term>Пружина</term><description>Ось пружины</description></item></list></remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Operation.GeometryData.Direction">
            <summary>Получить направление</summary>
            <remarks>Возвращаемое направление зависит от типа операции.
<list type="table"><listheader><term>Операция</term><term>Направление</term></listheader><item><term>Выталкивание</term><description>Направление выталкивания</description></item><item><term>Вращение</term><description>Ось вращения</description></item><item><term>Линейный массив</term><description>Направление копирования</description></item><item><term>Круговой массив</term><description>Ось вращения</description></item><item><term>Спираль</term><description>Ось спирали</description></item><item><term>Пружина</term><description>Ось пружины</description></item><item><term>Уклон</term><description>Направление уклона</description></item></list></remarks>
        </member>
        <member name="T:TFlex.Model.Model3D.Operation.GeometryData">
            <summary>Множество геометрических данных операции</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Operation">
            <summary>Базовый класс для всех операций</summary>
            <remarks>В текущей версии поддерживаются только листовые и твёрдотельные операции</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Suppression.Suppress">
            <summary>Константное значение в виде логического значения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Suppression.Variable">
            <summary>Ссылка на переменную</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Suppression.#ctor(System.Boolean)">
            <summary>Конструктор для создания параметра, заданного константой</summary>
            <param name="suppress" />
        </member>
        <member name="M:TFlex.Model.Model3D.Suppression.#ctor(TFlex.Model.Variable)">
            <summary>Конструктор для создания параметра, заданного переменной</summary>
            <param name="var">Переменная</param>
        </member>
        <member name="T:TFlex.Model.Model3D.Suppression">
            <summary>Класс подавления операции</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.RenderSwitch.#ctor">
            <summary>Конструктор.</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.RenderSwitch">
            <summary>Класс позволяет хранить разные деревья для различных стилей изображения.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.ExternalNode.#ctor(System.IntPtr)">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.ExternalNode">
            <summary>Узел неизвестного типа</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Separator.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Separator">
            <summary>Разделитель</summary>
            <remarks>
Объект этого класса изолирует эффекты атрибутов и трансформаций, являющихся его потомками.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.GroupingNode.#ctor">
            <summary>Конструктор</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.GroupingNode">
            <summary>Группа</summary>
            <remarks>
При использовании этого класса эффект атрибутов и трансформаций сохраняется при выходе из группы.
</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Group.InsertChild(System.Int32,TFlex.Model.Model3D.Visual.SceneNode)">
            <summary>Вставляет узел в число потомков.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Group.RemoveChild(TFlex.Model.Model3D.Visual.SceneNode)">
            <summary>Удаляет первого найденного потомка.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Group.RemoveChild(System.Int32)">
            <summary>Удаляет потомка с соответствующим индексом. Потомки с большими индексами сдвигаются влево.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Group.FindChild(TFlex.Model.Model3D.Visual.SceneNode)">
            <summary>В случае, если node является потомком группы, возвращает его индекс, иначе возвращает -1.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Group.GetChild(System.Int32)">
            <summary>Возвращает потомка с заданным индексом, null в случае, если такого не существует.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Group.GetNumChildren">
            <summary>Возвращает число потомков группы.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.Group.AddChild(TFlex.Model.Model3D.Visual.SceneNode)">
            <summary>Узел становится правым потомком группы.</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.Group">
            <summary>Базовый класс для групп</summary>
            <remarks>
Класс служит для группировки узлов в дереве сцены.
При выводе на экран, поиске и прочих действиях дерево обходится слева направо и сверху вниз.
</remarks>
        </member>
        <member name="F:TFlex.Model.Model3D.Visual.SceneNode.m_node">
            <summary>Указатель на объект класса SoNode.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.SceneNode.FromHandle(System.IntPtr)">
            <summary>Распознает тип узла OpenInventor и создает соответствующий объект.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.SceneNode.CompareTo(System.Object)">
            <summary>Сравнивает указатели на узлы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.SceneNode.op_Inequality(TFlex.Model.Model3D.Visual.SceneNode,TFlex.Model.Model3D.Visual.SceneNode)">
            <summary>Сравнивает указатели на узлы</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Visual.SceneNode.op_Equality(TFlex.Model.Model3D.Visual.SceneNode,TFlex.Model.Model3D.Visual.SceneNode)">
            <summary>Сравнивает указатели на узлы</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.SceneNode.InvalidNodeException">
            <summary>Исключения этого класса выбрасываются при ошибке обращения к объектам класса SceneNode.</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Visual.SceneNode">
            <summary>Базовый класс для элементов, входящих в состав изображения модельного объекта.
Из объектов данного класса строится дерево трехмерной сцены.</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FloatVector.op_Inequality(TFlex.Model.Model3D.FloatVector,TFlex.Model.Model3D.FloatVector)">
            <summary>Проверка неравенства</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FloatVector.op_Equality(TFlex.Model.Model3D.FloatVector,TFlex.Model.Model3D.FloatVector)">
            <summary>Проверка равенства</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FloatVector.Equals(System.Object)">
            <summary>Проверка равенства</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FloatVector.op_Implicit(TFlex.Model.Model3D.Geometry.BaseDirection)~TFlex.Model.Model3D.FloatVector">
            <summary>Преобразование вектора</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FloatVector.#ctor(TFlex.Model.Model3D.Geometry.BaseDirection)">
            <summary>Конструктор, берущий координаты с вектора</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FloatVector.op_Implicit(TFlex.Model.Model3D.Geometry.BasePoint3D)~TFlex.Model.Model3D.FloatVector">
            <summary>Преобразование точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FloatVector.#ctor(TFlex.Model.Model3D.Geometry.BasePoint3D)">
            <summary>Конструктор, берущий координаты с точки</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.FloatVector.#ctor(System.Single,System.Single,System.Single)">
            <summary>Конструктор, задающий начальные значения координат</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FloatVector.data(System.Int32)">
            <summary>Координанта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FloatVector.z">
Координата z
</member>
        <member name="P:TFlex.Model.Model3D.FloatVector.y">
            <summary>Координата y</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.FloatVector.x">
Координата x
</member>
        <member name="T:TFlex.Model.Model3D.FloatVector">
            <summary>Трехмерный вектор, элементы которого имеют тип float</summary>
            <remarks>Доступ к элементам вектора возможен любым из способов: vec.x , vec.X , vec.data[0]</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.SetUniqueName(System.String)">
            <summary>Установить новое уникальное имя с заданным префиксом</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.VisibleInScene">
            <summary>Свойство видимости объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.InScene">
            <summary>Объект в сцене</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.Auxiliary">
            <summary>Внутрисистемный объект. Используется для Refer объектов фрагментов.
Такие объекты скрыты от пользователя.
Работа с такими объектами может быть реализована на уровне API.NET или ядром TFlex.
Такие объекты не передаются на следующий уровень сборки.
</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.Layer">
            <summary>Слой, на котором размещается объект</summary>
            <example>
                <code name="Установка слоя">
public static void SetLayer(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа

   Layer l = new Layer(document);
   l.Monochrome = true;//Параметр слоя "одноцветный"
   l.Color = 12;//цвет
			
   ob.Layer = l;//установка слоя 

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.Level">
            <summary>Уровень</summary>
            <example>
                <code name="Установка уровня">
public static void SetLevel(Object ob)
{
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("Установка уровня");//Открытие блока изменений документа
			
   ob.Level = 3;//установка уровня	

   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.Color">
            <summary>Цвет</summary>
            <example>
                <code name="Установка цвета">
public static void SetColor(Object ob)
{			
   Document document = TFlex.Application.ActiveDocument;//Получение активного документа
   document.BeginChanges("");//Открытие блока изменений документа
		
   ob.Color = 40;//установка цвета
		
   document.EndChanges();//Закрытие блока изменений документа
}
</code>
            </example>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.CreateReference(TFlex.Model.Document)">
            <summary>Создаёт ссылочный элемент в указанном документе</summary>
            <param name="targetDocument">Документ, в котором создаётся ссылочный элемент</param>
            <returns>3D объект</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.CreateReference">
            <summary>Создаёт ссылочный элемент в исходном документе(внутренняя ссылка)</summary>
            <returns>3D объект</returns>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GetGeomReference(System.Int32,TFlex.Model.ModelObject.ArrayIndices)">
            <summary>Получить ссылку на родительский объект по ключу и индексу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="indices">Координаты элемента</param>
            <remarks>Используется для организации массивов. Поскольку геометрические данные связаны с родительской операцией, то саму родительскую операцию также можно получить по такому же ключу через функции <see cref="M:TFlex.Model.Model3D.Object3D.GetReference(System.Int32)" /> /&gt;</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GetGeomReference(System.Int32)">
            <summary>Получить ссылку на родительский объект по ключу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <remarks>Поскольку геометрические данные связаны с родительской операцией, то саму родительскую операцию также можно получить по такому же ключу через функции <see cref="M:TFlex.Model.Model3D.Object3D.GetReference(System.Int32)" /> /&gt;</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.SetGeomReference(System.Int32,TFlex.Model.Model3D.Object3D.GeomReference,TFlex.Model.ModelObject.ArrayIndices)">
            <summary>Установить ссылку на родительский объект по ключу и индексу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="reference">Ссылка на родительский объект</param>
            <param name="indices">Координаты элемента</param>
            <remarks>Используется для организации массивов</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.SetGeomReference(System.Int32,TFlex.Model.Model3D.Object3D.GeomReference)">
            <summary>Установить ссылку на родительский объект по ключу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="reference">Ссылка на родительский объект</param>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.GeomReference.IsTopol">
            <summary>Получить признак ссылки на геометрический элемент модельного тела</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.GeomReference.Geometry">
            <summary>Получить родительскую геометрию</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelTopol,System.UInt32)">
            <summary>Конструктор ссылки на геометрический элемент модельного тела с передаваемым набором флажков</summary>
            <param name="topol">Геометрический элемент модельного тела</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelTopol)">
            <summary>Конструктор ссылки на геометрический элемент модельного тела</summary>
            <param name="topol">Геометрический элемент модельного тела</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelBodies,System.UInt32)">
            <summary>Конструктор ссылки на модельный набор тел с передаваемым набором флажков</summary>
            <param name="bodies">Модельный набор тел</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelBodies)">
            <summary>Конструктор ссылки на модельный набор тел</summary>
            <param name="bodies">Модельный набор тел</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelBox,System.UInt32)">
            <summary>Конструктор ссылки на модельную границу с передаваемым набором флажков</summary>
            <param name="box">Модельная граница</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelBox)">
            <summary>Конструктор ссылки на модельную границу</summary>
            <param name="box">Модельная граница</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelCurve,System.UInt32)">
            <summary>Конструктор ссылки на модельную кривую с передаваемым набором флажков</summary>
            <param name="curve">Модельная кривая</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelCurve)">
            <summary>Конструктор ссылки на модельную кривую</summary>
            <param name="curve">Модельная кривая</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelSurface,System.UInt32)">
            <summary>Конструктор ссылки на модельную поверхность с передаваемым набором флажков</summary>
            <param name="surface">Модельная поверхность</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelSurface)">
            <summary>Конструктор ссылки на модельную поверхность</summary>
            <param name="surface">Модельная поверхность</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelPlane,System.UInt32)">
            <summary>Конструктор ссылки на модельную плоскость с передаваемым набором флажков</summary>
            <param name="plane">Модельная плоскость</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelPlane)">
            <summary>Конструктор ссылки на модельную плоскость</summary>
            <param name="plane">Модельная плоскость</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelAxis,System.UInt32)">
            <summary>Конструктор ссылки на модельную ось с передаваемым набором флажков</summary>
            <param name="axis">Модельная ось</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelAxis)">
            <summary>Конструктор ссылки на модельную ось</summary>
            <param name="axis">Модельная ось</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelDirection,System.UInt32)">
            <summary>Конструктор ссылки на модельное направление с передаваемым набором флажков</summary>
            <param name="direction">Модельное направление</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelDirection)">
            <summary>Конструктор ссылки на модельное направление</summary>
            <param name="direction">Модельное направление</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelPoint3D,System.UInt32)">
            <summary>Конструктор ссылки на модельную точку с передаваемым набором флажков</summary>
            <param name="point">Модельная точка</param>
            <param name="states">Набор флажков</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GeomReference.#ctor(TFlex.Model.Model3D.Geometry.ModelPoint3D)">
            <summary>Конструктор ссылки на модельную точку</summary>
            <param name="point">Модельная точка</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.Clone">
            <summary>Класс для передачи ссылки на геометрические свойства родительского объекта или на отдельные геометрические элементы тел модели (грани, циклы, рёбра, вершины)</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GetReference(System.Int32,TFlex.Model.ModelObject.ArrayIndices)">
            <summary>Получить ссылку на родительский объект по ключу и индексу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="indices">Координаты элемента</param>
            <remarks>Используется для организации массивов</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.GetReference(System.Int32)">
            <summary>Получить ссылку на родительский объект по ключу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.SetReference(System.Int32,TFlex.Model.ModelObject.Reference,TFlex.Model.ModelObject.ArrayIndices)">
            <summary>Установить ссылку на родительский объект по ключу и индексу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="reference">Ссылка на родительский объект</param>
            <param name="indices">Координаты элемента</param>
            <remarks>Используется для организации массивов</remarks>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.SetReference(System.Int32,TFlex.Model.ModelObject.Reference)">
            <summary>Установить ссылку на родительcкий объект по ключу</summary>
            <param name="id">Идентификатор ключа, по которому в контейнере ссылок хранится объект</param>
            <param name="reference">Ссылка на родительский объект</param>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.CancelRollback">
            <summary>Завершить откат</summary>
        </member>
        <member name="M:TFlex.Model.Model3D.Object3D.RollbackToParents">
            <summary>Откат модели к состоянию, когда из сцены выгружены потомки объекта и он сам</summary>
            <remarks>В сцене остаются прогруженными родителькие объекты</remarks>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.Transformations">
            <summary>Контейнер групп преобразований 3D объекта</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.VolatileTransformations">
            <summary>Преобразование 3D объекта для изменения</summary>
        </member>
        <member name="P:TFlex.Model.Model3D.Object3D.ConstTransformations">
            <summary>Преобразование 3D объекта для чтения (устаревшая версия трансформации - допускается чтение трансформации в старых документах.)</summary>
        </member>
        <member name="T:TFlex.Model.Model3D.Object3D">
            <summary>Базовый класс для объектов 3D модели</summary>
        </member>
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
        <!-- Discarding badly formed XML document comment for member 'T:TFlex.Model.Model3D.AreaProfile'. -->
    </members>
</doc>